require.config({
    config: {
        'jsbuild':{"Lof_AdvancedReports/vendors/bootstrap/js/bootstrap.min.js":"/*!\n * Bootstrap v3.3.6 (http://getbootstrap.com)\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under the MIT license\n */\nif(\"undefined\"==typeof jQuery)throw new Error(\"Bootstrap's JavaScript requires jQuery\");+function(a){\"use strict\";var b=a.fn.jquery.split(\" \")[0].split(\".\");if(b[0]<2&&b[1]<9||1==b[0]&&9==b[1]&&b[2]<1||b[0]>2)throw new Error(\"Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3\")}(jQuery),+function(a){\"use strict\";function b(){var a=document.createElement(\"bootstrap\"),b={WebkitTransition:\"webkitTransitionEnd\",MozTransition:\"transitionend\",OTransition:\"oTransitionEnd otransitionend\",transition:\"transitionend\"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one(\"bsTransitionEnd\",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var c=a(this),e=c.data(\"bs.alert\");e||c.data(\"bs.alert\",e=new d(this)),\"string\"==typeof b&&e[b].call(c)})}var c='[data-dismiss=\"alert\"]',d=function(b){a(b).on(\"click\",c,this.close)};d.VERSION=\"3.3.6\",d.TRANSITION_DURATION=150,d.prototype.close=function(b){function c(){g.detach().trigger(\"closed.bs.alert\").remove()}var e=a(this),f=e.attr(\"data-target\");f||(f=e.attr(\"href\"),f=f&&f.replace(/.*(?=#[^\\s]*$)/,\"\"));var g=a(f);b&&b.preventDefault(),g.length||(g=e.closest(\".alert\")),g.trigger(b=a.Event(\"close.bs.alert\")),b.isDefaultPrevented()||(g.removeClass(\"in\"),a.support.transition&&g.hasClass(\"fade\")?g.one(\"bsTransitionEnd\",c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on(\"click.bs.alert.data-api\",c,d.prototype.close)}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.button\"),f=\"object\"==typeof b&&b;e||d.data(\"bs.button\",e=new c(this,f)),\"toggle\"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION=\"3.3.6\",c.DEFAULTS={loadingText:\"loading...\"},c.prototype.setState=function(b){var c=\"disabled\",d=this.$element,e=d.is(\"input\")?\"val\":\"html\",f=d.data();b+=\"Text\",null==f.resetText&&d.data(\"resetText\",d[e]()),setTimeout(a.proxy(function(){d[e](null==f[b]?this.options[b]:f[b]),\"loadingText\"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle=\"buttons\"]');if(b.length){var c=this.$element.find(\"input\");\"radio\"==c.prop(\"type\")?(c.prop(\"checked\")&&(a=!1),b.find(\".active\").removeClass(\"active\"),this.$element.addClass(\"active\")):\"checkbox\"==c.prop(\"type\")&&(c.prop(\"checked\")!==this.$element.hasClass(\"active\")&&(a=!1),this.$element.toggleClass(\"active\")),c.prop(\"checked\",this.$element.hasClass(\"active\")),a&&c.trigger(\"change\")}else this.$element.attr(\"aria-pressed\",!this.$element.hasClass(\"active\")),this.$element.toggleClass(\"active\")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on(\"click.bs.button.data-api\",'[data-toggle^=\"button\"]',function(c){var d=a(c.target);d.hasClass(\"btn\")||(d=d.closest(\".btn\")),b.call(d,\"toggle\"),a(c.target).is('input[type=\"radio\"]')||a(c.target).is('input[type=\"checkbox\"]')||c.preventDefault()}).on(\"focus.bs.button.data-api blur.bs.button.data-api\",'[data-toggle^=\"button\"]',function(b){a(b.target).closest(\".btn\").toggleClass(\"focus\",/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.carousel\"),f=a.extend({},c.DEFAULTS,d.data(),\"object\"==typeof b&&b),g=\"string\"==typeof b?b:f.slide;e||d.data(\"bs.carousel\",e=new c(this,f)),\"number\"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(\".carousel-indicators\"),this.options=c,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&&this.$element.on(\"keydown.bs.carousel\",a.proxy(this.keydown,this)),\"hover\"==this.options.pause&&!(\"ontouchstart\"in document.documentElement)&&this.$element.on(\"mouseenter.bs.carousel\",a.proxy(this.pause,this)).on(\"mouseleave.bs.carousel\",a.proxy(this.cycle,this))};c.VERSION=\"3.3.6\",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:\"hover\",wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(\".item\"),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var c=this.getItemIndex(b),d=\"prev\"==a&&0===c||\"next\"==a&&c==this.$items.length-1;if(d&&!this.options.wrap)return b;var e=\"prev\"==a?-1:1,f=(c+e)%this.$items.length;return this.$items.eq(f)},c.prototype.to=function(a){var b=this,c=this.getItemIndex(this.$active=this.$element.find(\".item.active\"));return a>this.$items.length-1||0>a?void 0:this.sliding?this.$element.one(\"slid.bs.carousel\",function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a>c?\"next\":\"prev\",this.$items.eq(a))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(\".next, .prev\").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide(\"next\")},c.prototype.prev=function(){return this.sliding?void 0:this.slide(\"prev\")},c.prototype.slide=function(b,d){var e=this.$element.find(\".item.active\"),f=d||this.getItemForDirection(b,e),g=this.interval,h=\"next\"==b?\"left\":\"right\",i=this;if(f.hasClass(\"active\"))return this.sliding=!1;var j=f[0],k=a.Event(\"slide.bs.carousel\",{relatedTarget:j,direction:h});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,g&&this.pause(),this.$indicators.length){this.$indicators.find(\".active\").removeClass(\"active\");var l=a(this.$indicators.children()[this.getItemIndex(f)]);l&&l.addClass(\"active\")}var m=a.Event(\"slid.bs.carousel\",{relatedTarget:j,direction:h});return a.support.transition&&this.$element.hasClass(\"slide\")?(f.addClass(b),f[0].offsetWidth,e.addClass(h),f.addClass(h),e.one(\"bsTransitionEnd\",function(){f.removeClass([b,h].join(\" \")).addClass(\"active\"),e.removeClass([\"active\",h].join(\" \")),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass(\"active\"),f.addClass(\"active\"),this.sliding=!1,this.$element.trigger(m)),g&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this};var e=function(c){var d,e=a(this),f=a(e.attr(\"data-target\")||(d=e.attr(\"href\"))&&d.replace(/.*(?=#[^\\s]+$)/,\"\"));if(f.hasClass(\"carousel\")){var g=a.extend({},f.data(),e.data()),h=e.attr(\"data-slide-to\");h&&(g.interval=!1),b.call(f,g),h&&f.data(\"bs.carousel\").to(h),c.preventDefault()}};a(document).on(\"click.bs.carousel.data-api\",\"[data-slide]\",e).on(\"click.bs.carousel.data-api\",\"[data-slide-to]\",e),a(window).on(\"load\",function(){a('[data-ride=\"carousel\"]').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){\"use strict\";function b(b){var c,d=b.attr(\"data-target\")||(c=b.attr(\"href\"))&&c.replace(/.*(?=#[^\\s]+$)/,\"\");return a(d)}function c(b){return this.each(function(){var c=a(this),e=c.data(\"bs.collapse\"),f=a.extend({},d.DEFAULTS,c.data(),\"object\"==typeof b&&b);!e&&f.toggle&&/show|hide/.test(b)&&(f.toggle=!1),e||c.data(\"bs.collapse\",e=new d(this,f)),\"string\"==typeof b&&e[b]()})}var d=function(b,c){this.$element=a(b),this.options=a.extend({},d.DEFAULTS,c),this.$trigger=a('[data-toggle=\"collapse\"][href=\"#'+b.id+'\"],[data-toggle=\"collapse\"][data-target=\"#'+b.id+'\"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};d.VERSION=\"3.3.6\",d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0},d.prototype.dimension=function(){var a=this.$element.hasClass(\"width\");return a?\"width\":\"height\"},d.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass(\"in\")){var b,e=this.$parent&&this.$parent.children(\".panel\").children(\".in, .collapsing\");if(!(e&&e.length&&(b=e.data(\"bs.collapse\"),b&&b.transitioning))){var f=a.Event(\"show.bs.collapse\");if(this.$element.trigger(f),!f.isDefaultPrevented()){e&&e.length&&(c.call(e,\"hide\"),b||e.data(\"bs.collapse\",null));var g=this.dimension();this.$element.removeClass(\"collapse\").addClass(\"collapsing\")[g](0).attr(\"aria-expanded\",!0),this.$trigger.removeClass(\"collapsed\").attr(\"aria-expanded\",!0),this.transitioning=1;var h=function(){this.$element.removeClass(\"collapsing\").addClass(\"collapse in\")[g](\"\"),this.transitioning=0,this.$element.trigger(\"shown.bs.collapse\")};if(!a.support.transition)return h.call(this);var i=a.camelCase([\"scroll\",g].join(\"-\"));this.$element.one(\"bsTransitionEnd\",a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])}}}},d.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass(\"in\")){var b=a.Event(\"hide.bs.collapse\");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass(\"collapsing\").removeClass(\"collapse in\").attr(\"aria-expanded\",!1),this.$trigger.addClass(\"collapsed\").attr(\"aria-expanded\",!1),this.transitioning=1;var e=function(){this.transitioning=0,this.$element.removeClass(\"collapsing\").addClass(\"collapse\").trigger(\"hidden.bs.collapse\")};return a.support.transition?void this.$element[c](0).one(\"bsTransitionEnd\",a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){this[this.$element.hasClass(\"in\")?\"hide\":\"show\"]()},d.prototype.getParent=function(){return a(this.options.parent).find('[data-toggle=\"collapse\"][data-parent=\"'+this.options.parent+'\"]').each(a.proxy(function(c,d){var e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var c=a.hasClass(\"in\");a.attr(\"aria-expanded\",c),b.toggleClass(\"collapsed\",!c).attr(\"aria-expanded\",c)};var e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return a.fn.collapse=e,this},a(document).on(\"click.bs.collapse.data-api\",'[data-toggle=\"collapse\"]',function(d){var e=a(this);e.attr(\"data-target\")||d.preventDefault();var f=b(e),g=f.data(\"bs.collapse\"),h=g?\"toggle\":e.data();c.call(f,h)})}(jQuery),+function(a){\"use strict\";function b(b){var c=b.attr(\"data-target\");c||(c=b.attr(\"href\"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\\s]*$)/,\"\"));var d=c&&a(c);return d&&d.length?d:b.parent()}function c(c){c&&3===c.which||(a(e).remove(),a(f).each(function(){var d=a(this),e=b(d),f={relatedTarget:this};e.hasClass(\"open\")&&(c&&\"click\"==c.type&&/input|textarea/i.test(c.target.tagName)&&a.contains(e[0],c.target)||(e.trigger(c=a.Event(\"hide.bs.dropdown\",f)),c.isDefaultPrevented()||(d.attr(\"aria-expanded\",\"false\"),e.removeClass(\"open\").trigger(a.Event(\"hidden.bs.dropdown\",f)))))}))}function d(b){return this.each(function(){var c=a(this),d=c.data(\"bs.dropdown\");d||c.data(\"bs.dropdown\",d=new g(this)),\"string\"==typeof b&&d[b].call(c)})}var e=\".dropdown-backdrop\",f='[data-toggle=\"dropdown\"]',g=function(b){a(b).on(\"click.bs.dropdown\",this.toggle)};g.VERSION=\"3.3.6\",g.prototype.toggle=function(d){var e=a(this);if(!e.is(\".disabled, :disabled\")){var f=b(e),g=f.hasClass(\"open\");if(c(),!g){\"ontouchstart\"in document.documentElement&&!f.closest(\".navbar-nav\").length&&a(document.createElement(\"div\")).addClass(\"dropdown-backdrop\").insertAfter(a(this)).on(\"click\",c);var h={relatedTarget:this};if(f.trigger(d=a.Event(\"show.bs.dropdown\",h)),d.isDefaultPrevented())return;e.trigger(\"focus\").attr(\"aria-expanded\",\"true\"),f.toggleClass(\"open\").trigger(a.Event(\"shown.bs.dropdown\",h))}return!1}},g.prototype.keydown=function(c){if(/(38|40|27|32)/.test(c.which)&&!/input|textarea/i.test(c.target.tagName)){var d=a(this);if(c.preventDefault(),c.stopPropagation(),!d.is(\".disabled, :disabled\")){var e=b(d),g=e.hasClass(\"open\");if(!g&&27!=c.which||g&&27==c.which)return 27==c.which&&e.find(f).trigger(\"focus\"),d.trigger(\"click\");var h=\" li:not(.disabled):visible a\",i=e.find(\".dropdown-menu\"+h);if(i.length){var j=i.index(c.target);38==c.which&&j>0&&j--,40==c.which&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger(\"focus\")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on(\"click.bs.dropdown.data-api\",c).on(\"click.bs.dropdown.data-api\",\".dropdown form\",function(a){a.stopPropagation()}).on(\"click.bs.dropdown.data-api\",f,g.prototype.toggle).on(\"keydown.bs.dropdown.data-api\",f,g.prototype.keydown).on(\"keydown.bs.dropdown.data-api\",\".dropdown-menu\",g.prototype.keydown)}(jQuery),+function(a){\"use strict\";function b(b,d){return this.each(function(){var e=a(this),f=e.data(\"bs.modal\"),g=a.extend({},c.DEFAULTS,e.data(),\"object\"==typeof b&&b);f||e.data(\"bs.modal\",f=new c(this,g)),\"string\"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$dialog=this.$element.find(\".modal-dialog\"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&&this.$element.find(\".modal-content\").load(this.options.remote,a.proxy(function(){this.$element.trigger(\"loaded.bs.modal\")},this))};c.VERSION=\"3.3.6\",c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var d=this,e=a.Event(\"show.bs.modal\",{relatedTarget:b});this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass(\"modal-open\"),this.escape(),this.resize(),this.$element.on(\"click.dismiss.bs.modal\",'[data-dismiss=\"modal\"]',a.proxy(this.hide,this)),this.$dialog.on(\"mousedown.dismiss.bs.modal\",function(){d.$element.one(\"mouseup.dismiss.bs.modal\",function(b){a(b.target).is(d.$element)&&(d.ignoreBackdropClick=!0)})}),this.backdrop(function(){var e=a.support.transition&&d.$element.hasClass(\"fade\");d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.adjustDialog(),e&&d.$element[0].offsetWidth,d.$element.addClass(\"in\"),d.enforceFocus();var f=a.Event(\"shown.bs.modal\",{relatedTarget:b});e?d.$dialog.one(\"bsTransitionEnd\",function(){d.$element.trigger(\"focus\").trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger(\"focus\").trigger(f)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event(\"hide.bs.modal\"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off(\"focusin.bs.modal\"),this.$element.removeClass(\"in\").off(\"click.dismiss.bs.modal\").off(\"mouseup.dismiss.bs.modal\"),this.$dialog.off(\"mousedown.dismiss.bs.modal\"),a.support.transition&&this.$element.hasClass(\"fade\")?this.$element.one(\"bsTransitionEnd\",a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off(\"focusin.bs.modal\").on(\"focusin.bs.modal\",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger(\"focus\")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on(\"keydown.dismiss.bs.modal\",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off(\"keydown.dismiss.bs.modal\")},c.prototype.resize=function(){this.isShown?a(window).on(\"resize.bs.modal\",a.proxy(this.handleUpdate,this)):a(window).off(\"resize.bs.modal\")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass(\"modal-open\"),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger(\"hidden.bs.modal\")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var d=this,e=this.$element.hasClass(\"fade\")?\"fade\":\"\";if(this.isShown&&this.options.backdrop){var f=a.support.transition&&e;if(this.$backdrop=a(document.createElement(\"div\")).addClass(\"modal-backdrop \"+e).appendTo(this.$body),this.$element.on(\"click.dismiss.bs.modal\",a.proxy(function(a){return this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(a.target===a.currentTarget&&(\"static\"==this.options.backdrop?this.$element[0].focus():this.hide()))},this)),f&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass(\"in\"),!b)return;f?this.$backdrop.one(\"bsTransitionEnd\",b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass(\"in\");var g=function(){d.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass(\"fade\")?this.$backdrop.one(\"bsTransitionEnd\",g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else b&&b()},c.prototype.handleUpdate=function(){this.adjustDialog()},c.prototype.adjustDialog=function(){var a=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&a?this.scrollbarWidth:\"\",paddingRight:this.bodyIsOverflowing&&!a?this.scrollbarWidth:\"\"})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:\"\",paddingRight:\"\"})},c.prototype.checkScrollbar=function(){var a=window.innerWidth;if(!a){var b=document.documentElement.getBoundingClientRect();a=b.right-Math.abs(b.left)}this.bodyIsOverflowing=document.body.clientWidth<a,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css(\"padding-right\")||0,10);this.originalBodyPad=document.body.style.paddingRight||\"\",this.bodyIsOverflowing&&this.$body.css(\"padding-right\",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css(\"padding-right\",this.originalBodyPad)},c.prototype.measureScrollbar=function(){var a=document.createElement(\"div\");a.className=\"modal-scrollbar-measure\",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on(\"click.bs.modal.data-api\",'[data-toggle=\"modal\"]',function(c){var d=a(this),e=d.attr(\"href\"),f=a(d.attr(\"data-target\")||e&&e.replace(/.*(?=#[^\\s]+$)/,\"\")),g=f.data(\"bs.modal\")?\"toggle\":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is(\"a\")&&c.preventDefault(),f.one(\"show.bs.modal\",function(a){a.isDefaultPrevented()||f.one(\"hidden.bs.modal\",function(){d.is(\":visible\")&&d.trigger(\"focus\")})}),b.call(f,g,this)})}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.tooltip\"),f=\"object\"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data(\"bs.tooltip\",e=new c(this,f)),\"string\"==typeof b&&e[b]())})}var c=function(a,b){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.inState=null,this.init(\"tooltip\",a,b)};c.VERSION=\"3.3.6\",c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:\"top\",selector:!1,template:'<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',trigger:\"hover focus\",title:\"\",delay:0,html:!1,container:!1,viewport:{selector:\"body\",padding:0}},c.prototype.init=function(b,c,d){if(this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(a.isFunction(this.options.viewport)?this.options.viewport.call(this,this.$element):this.options.viewport.selector||this.options.viewport),this.inState={click:!1,hover:!1,focus:!1},this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error(\"`selector` option must be specified when initializing \"+this.type+\" on the window.document object!\");for(var e=this.options.trigger.split(\" \"),f=e.length;f--;){var g=e[f];if(\"click\"==g)this.$element.on(\"click.\"+this.type,this.options.selector,a.proxy(this.toggle,this));else if(\"manual\"!=g){var h=\"hover\"==g?\"mouseenter\":\"focusin\",i=\"hover\"==g?\"mouseleave\":\"focusout\";this.$element.on(h+\".\"+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+\".\"+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:\"manual\",selector:\"\"}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&\"number\"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data(\"bs.\"+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data(\"bs.\"+this.type,c)),b instanceof a.Event&&(c.inState[\"focusin\"==b.type?\"focus\":\"hover\"]=!0),c.tip().hasClass(\"in\")||\"in\"==c.hoverState?void(c.hoverState=\"in\"):(clearTimeout(c.timeout),c.hoverState=\"in\",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){\"in\"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.isInStateTrue=function(){for(var a in this.inState)if(this.inState[a])return!0;return!1},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data(\"bs.\"+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data(\"bs.\"+this.type,c)),b instanceof a.Event&&(c.inState[\"focusout\"==b.type?\"focus\":\"hover\"]=!1),c.isInStateTrue()?void 0:(clearTimeout(c.timeout),c.hoverState=\"out\",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){\"out\"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide())},c.prototype.show=function(){var b=a.Event(\"show.bs.\"+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr(\"id\",g),this.$element.attr(\"aria-describedby\",g),this.options.animation&&f.addClass(\"fade\");var h=\"function\"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\\s?auto?\\s?/i,j=i.test(h);j&&(h=h.replace(i,\"\")||\"top\"),f.detach().css({top:0,left:0,display:\"block\"}).addClass(h).data(\"bs.\"+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element),this.$element.trigger(\"inserted.bs.\"+this.type);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.getPosition(this.$viewport);h=\"bottom\"==h&&k.bottom+m>o.bottom?\"top\":\"top\"==h&&k.top-m<o.top?\"bottom\":\"right\"==h&&k.right+l>o.width?\"left\":\"left\"==h&&k.left-l<o.left?\"right\":h,f.removeClass(n).addClass(h)}var p=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(p,h);var q=function(){var a=e.hoverState;e.$element.trigger(\"shown.bs.\"+e.type),e.hoverState=null,\"out\"==a&&e.leave(e)};a.support.transition&&this.$tip.hasClass(\"fade\")?f.one(\"bsTransitionEnd\",q).emulateTransitionEnd(c.TRANSITION_DURATION):q()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css(\"margin-top\"),10),h=parseInt(d.css(\"margin-left\"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top+=g,b.left+=h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass(\"in\");var i=d[0].offsetWidth,j=d[0].offsetHeight;\"top\"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=/top|bottom/.test(c),m=l?2*k.left-e+i:2*k.top-f+j,n=l?\"offsetWidth\":\"offsetHeight\";d.offset(b),this.replaceArrow(m,d[0][n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?\"left\":\"top\",50*(1-a/b)+\"%\").css(c?\"top\":\"left\",\"\")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(\".tooltip-inner\")[this.options.html?\"html\":\"text\"](b),a.removeClass(\"fade in top bottom left right\")},c.prototype.hide=function(b){function d(){\"in\"!=e.hoverState&&f.detach(),e.$element.removeAttr(\"aria-describedby\").trigger(\"hidden.bs.\"+e.type),b&&b()}var e=this,f=a(this.$tip),g=a.Event(\"hide.bs.\"+this.type);return this.$element.trigger(g),g.isDefaultPrevented()?void 0:(f.removeClass(\"in\"),a.support.transition&&f.hasClass(\"fade\")?f.one(\"bsTransitionEnd\",d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr(\"title\")||\"string\"!=typeof a.attr(\"data-original-title\"))&&a.attr(\"data-original-title\",a.attr(\"title\")||\"\").attr(\"title\",\"\")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d=\"BODY\"==c.tagName,e=c.getBoundingClientRect();null==e.width&&(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){return\"bottom\"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:\"top\"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:\"left\"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.right&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr(\"data-original-title\")||(\"function\"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){if(!this.$tip&&(this.$tip=a(this.options.template),1!=this.$tip.length))throw new Error(this.type+\" `template` option must consist of exactly 1 top-level element!\");return this.$tip},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(\".tooltip-arrow\")},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data(\"bs.\"+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data(\"bs.\"+this.type,c))),b?(c.inState.click=!c.inState.click,c.isInStateTrue()?c.enter(c):c.leave(c)):c.tip().hasClass(\"in\")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){var a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off(\".\"+a.type).removeData(\"bs.\"+a.type),a.$tip&&a.$tip.detach(),a.$tip=null,a.$arrow=null,a.$viewport=null})};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.popover\"),f=\"object\"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data(\"bs.popover\",e=new c(this,f)),\"string\"==typeof b&&e[b]())})}var c=function(a,b){this.init(\"popover\",a,b)};if(!a.fn.tooltip)throw new Error(\"Popover requires tooltip.js\");c.VERSION=\"3.3.6\",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:\"right\",trigger:\"click\",content:\"\",template:'<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(\".popover-title\")[this.options.html?\"html\":\"text\"](b),a.find(\".popover-content\").children().detach().end()[this.options.html?\"string\"==typeof c?\"html\":\"append\":\"text\"](c),a.removeClass(\"fade top bottom left right in\"),a.find(\".popover-title\").html()||a.find(\".popover-title\").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr(\"data-content\")||(\"function\"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(\".arrow\")};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){\"use strict\";function b(c,d){this.$body=a(document.body),this.$scrollElement=a(a(c).is(document.body)?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||\"\")+\" .nav li > a\",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on(\"scroll.bs.scrollspy\",a.proxy(this.process,this)),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data(\"bs.scrollspy\"),f=\"object\"==typeof c&&c;e||d.data(\"bs.scrollspy\",e=new b(this,f)),\"string\"==typeof c&&e[c]()})}b.VERSION=\"3.3.6\",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b=this,c=\"offset\",d=0;this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight(),a.isWindow(this.$scrollElement[0])||(c=\"position\",d=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var b=a(this),e=b.data(\"target\")||b.attr(\"href\"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(\":visible\")&&[[f[c]().top+d,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){b.offsets.push(this[0]),b.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<e[0])return this.activeTarget=null,this.clear();for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(void 0===e[a+1]||b<e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var c=this.selector+'[data-target=\"'+b+'\"],'+this.selector+'[href=\"'+b+'\"]',d=a(c).parents(\"li\").addClass(\"active\");\nd.parent(\".dropdown-menu\").length&&(d=d.closest(\"li.dropdown\").addClass(\"active\")),d.trigger(\"activate.bs.scrollspy\")},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,\".active\").removeClass(\"active\")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on(\"load.bs.scrollspy.data-api\",function(){a('[data-spy=\"scroll\"]').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.tab\");e||d.data(\"bs.tab\",e=new c(this)),\"string\"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION=\"3.3.6\",c.TRANSITION_DURATION=150,c.prototype.show=function(){var b=this.element,c=b.closest(\"ul:not(.dropdown-menu)\"),d=b.data(\"target\");if(d||(d=b.attr(\"href\"),d=d&&d.replace(/.*(?=#[^\\s]*$)/,\"\")),!b.parent(\"li\").hasClass(\"active\")){var e=c.find(\".active:last a\"),f=a.Event(\"hide.bs.tab\",{relatedTarget:b[0]}),g=a.Event(\"show.bs.tab\",{relatedTarget:e[0]});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&&!f.isDefaultPrevented()){var h=a(d);this.activate(b.closest(\"li\"),c),this.activate(h,h.parent(),function(){e.trigger({type:\"hidden.bs.tab\",relatedTarget:b[0]}),b.trigger({type:\"shown.bs.tab\",relatedTarget:e[0]})})}}},c.prototype.activate=function(b,d,e){function f(){g.removeClass(\"active\").find(\"> .dropdown-menu > .active\").removeClass(\"active\").end().find('[data-toggle=\"tab\"]').attr(\"aria-expanded\",!1),b.addClass(\"active\").find('[data-toggle=\"tab\"]').attr(\"aria-expanded\",!0),h?(b[0].offsetWidth,b.addClass(\"in\")):b.removeClass(\"fade\"),b.parent(\".dropdown-menu\").length&&b.closest(\"li.dropdown\").addClass(\"active\").end().find('[data-toggle=\"tab\"]').attr(\"aria-expanded\",!0),e&&e()}var g=d.find(\"> .active\"),h=e&&a.support.transition&&(g.length&&g.hasClass(\"fade\")||!!d.find(\"> .fade\").length);g.length&&h?g.one(\"bsTransitionEnd\",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass(\"in\")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),\"show\")};a(document).on(\"click.bs.tab.data-api\",'[data-toggle=\"tab\"]',e).on(\"click.bs.tab.data-api\",'[data-toggle=\"pill\"]',e)}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.affix\"),f=\"object\"==typeof b&&b;e||d.data(\"bs.affix\",e=new c(this,f)),\"string\"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on(\"scroll.bs.affix.data-api\",a.proxy(this.checkPosition,this)).on(\"click.bs.affix.data-api\",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};c.VERSION=\"3.3.6\",c.RESET=\"affix affix-top affix-bottom\",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&\"top\"==this.affixed)return c>e?\"top\":!1;if(\"bottom\"==this.affixed)return null!=c?e+this.unpin<=f.top?!1:\"bottom\":a-d>=e+g?!1:\"bottom\";var h=null==this.affixed,i=h?e:f.top,j=h?g:b;return null!=c&&c>=e?\"top\":null!=d&&i+j>=a-d?\"bottom\":!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass(\"affix\");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(\":visible\")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=Math.max(a(document).height(),a(document.body).height());\"object\"!=typeof d&&(f=e=d),\"function\"==typeof e&&(e=d.top(this.$element)),\"function\"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css(\"top\",\"\");var i=\"affix\"+(h?\"-\"+h:\"\"),j=a.Event(i+\".bs.affix\");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin=\"bottom\"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace(\"affix\",\"affixed\")+\".bs.affix\")}\"bottom\"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on(\"load\",function(){a('[data-spy=\"affix\"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);","Milople_Personalizedcool/js/fonts.js":"/**\r\n*\r\n* Do not edit or add to this file if you wish to upgrade the module to newer\r\n* versions in the future. If you wish to customize the module for your\r\n* needs please contact us to https://www.milople.com/contact-us.html\r\n*\r\n* @category    Ecommerce\r\n* @package     Milople_Personlized\r\n* @copyright   Copyright (c) 2016 Milople Technologies Pvt. Ltd. All Rights Reserved.\r\n* @url         https://www.milople.com/magento2-extensions/personalized-products-m2.html\r\n*\r\n**/\r\n;(function(window,document,undefined){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function k(a,b,c){k=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf(\"native code\")?aa:ba;return k.apply(null,arguments)}var n=Date.now||function(){return+new Date};function q(a,b){this.K=a;this.w=b||a;this.G=this.w.document}q.prototype.createElement=function(a,b,c){a=this.G.createElement(a);if(b)for(var d in b)b.hasOwnProperty(d)&&(\"style\"==d?a.style.cssText=b[d]:a.setAttribute(d,b[d]));c&&a.appendChild(this.G.createTextNode(c));return a};function r(a,b,c){a=a.G.getElementsByTagName(b)[0];a||(a=document.documentElement);a&&a.lastChild&&a.insertBefore(c,a.lastChild)}function ca(a,b){function c(){a.G.body?b():setTimeout(c,0)}c()}\r\nfunction s(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(\" \").replace(/\\s+/g,\" \").replace(/^\\s+|\\s+$/,\"\")}function t(a,b){for(var c=a.className.split(/\\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}\r\nfunction u(a){if(\"string\"===typeof a.na)return a.na;var b=a.w.location.protocol;\"about:\"==b&&(b=a.K.location.protocol);return\"https:\"==b?\"https:\":\"http:\"}function v(a,b){var c=a.createElement(\"link\",{rel:\"stylesheet\",href:b,media:\"all\"}),d=!1;c.onload=function(){d||(d=!0)};c.onerror=function(){d||(d=!0)};r(a,\"head\",c)}\r\nfunction w(a,b,c,d){var e=a.G.getElementsByTagName(\"head\")[0];if(e){var f=a.createElement(\"script\",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&\"loaded\"!=this.readyState&&\"complete\"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,\"HEAD\"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);window.setTimeout(function(){g||(g=!0,c&&c(Error(\"Script load timeout\")))},d||5E3);return f}return null};function x(a,b){this.Y=a;this.ga=b};function y(a,b,c,d){this.c=null!=a?a:null;this.g=null!=b?b:null;this.D=null!=c?c:null;this.e=null!=d?d:null}var da=/^([0-9]+)(?:[\\._-]([0-9]+))?(?:[\\._-]([0-9]+))?(?:[\\._+-]?(.*))?$/;y.prototype.compare=function(a){return this.c>a.c||this.c===a.c&&this.g>a.g||this.c===a.c&&this.g===a.g&&this.D>a.D?1:this.c<a.c||this.c===a.c&&this.g<a.g||this.c===a.c&&this.g===a.g&&this.D<a.D?-1:0};y.prototype.toString=function(){return[this.c,this.g||\"\",this.D||\"\",this.e||\"\"].join(\"\")};\r\nfunction z(a){a=da.exec(a);var b=null,c=null,d=null,e=null;a&&(null!==a[1]&&a[1]&&(b=parseInt(a[1],10)),null!==a[2]&&a[2]&&(c=parseInt(a[2],10)),null!==a[3]&&a[3]&&(d=parseInt(a[3],10)),null!==a[4]&&a[4]&&(e=/^[0-9]+$/.test(a[4])?parseInt(a[4],10):a[4]));return new y(b,c,d,e)};function A(a,b,c,d,e,f,g,h){this.N=a;this.k=h}A.prototype.getName=function(){return this.N};function B(a){this.a=a}var ea=new A(\"Unknown\",0,0,0,0,0,0,new x(!1,!1));\r\nB.prototype.parse=function(){var a;if(-1!=this.a.indexOf(\"MSIE\")||-1!=this.a.indexOf(\"Trident/\")){a=C(this);var b=z(D(this)),c=null,d=E(this.a,/Trident\\/([\\d\\w\\.]+)/,1),c=-1!=this.a.indexOf(\"MSIE\")?z(E(this.a,/MSIE ([\\d\\w\\.]+)/,1)):z(E(this.a,/rv:([\\d\\w\\.]+)/,1));\"\"!=d&&z(d);a=new A(\"MSIE\",0,0,0,0,0,0,new x(\"Windows\"==a&&6<=c.c||\"Windows Phone\"==a&&8<=b.c,!1))}else if(-1!=this.a.indexOf(\"Opera\"))a:if(a=z(E(this.a,/Presto\\/([\\d\\w\\.]+)/,1)),z(D(this)),null!==a.c||z(E(this.a,/rv:([^\\)]+)/,1)),-1!=this.a.indexOf(\"Opera Mini/\"))a=\r\nz(E(this.a,/Opera Mini\\/([\\d\\.]+)/,1)),a=new A(\"OperaMini\",0,0,0,C(this),0,0,new x(!1,!1));else{if(-1!=this.a.indexOf(\"Version/\")&&(a=z(E(this.a,/Version\\/([\\d\\.]+)/,1)),null!==a.c)){a=new A(\"Opera\",0,0,0,C(this),0,0,new x(10<=a.c,!1));break a}a=z(E(this.a,/Opera[\\/ ]([\\d\\.]+)/,1));a=null!==a.c?new A(\"Opera\",0,0,0,C(this),0,0,new x(10<=a.c,!1)):new A(\"Opera\",0,0,0,C(this),0,0,new x(!1,!1))}else/OPR\\/[\\d.]+/.test(this.a)?a=F(this):/AppleWeb(K|k)it/.test(this.a)?a=F(this):-1!=this.a.indexOf(\"Gecko\")?\r\n(a=\"Unknown\",b=new y,z(D(this)),b=!1,-1!=this.a.indexOf(\"Firefox\")?(a=\"Firefox\",b=z(E(this.a,/Firefox\\/([\\d\\w\\.]+)/,1)),b=3<=b.c&&5<=b.g):-1!=this.a.indexOf(\"Mozilla\")&&(a=\"Mozilla\"),c=z(E(this.a,/rv:([^\\)]+)/,1)),b||(b=1<c.c||1==c.c&&9<c.g||1==c.c&&9==c.g&&2<=c.D),a=new A(a,0,0,0,C(this),0,0,new x(b,!1))):a=ea;return a};\r\nfunction C(a){var b=E(a.a,/(iPod|iPad|iPhone|Android|Windows Phone|BB\\d{2}|BlackBerry)/,1);if(\"\"!=b)return/BB\\d{2}/.test(b)&&(b=\"BlackBerry\"),b;a=E(a.a,/(Linux|Mac_PowerPC|Macintosh|Windows|CrOS|PlayStation|CrKey)/,1);return\"\"!=a?(\"Mac_PowerPC\"==a?a=\"Macintosh\":\"PlayStation\"==a&&(a=\"Linux\"),a):\"Unknown\"}\r\nfunction D(a){var b=E(a.a,/(OS X|Windows NT|Android) ([^;)]+)/,2);if(b||(b=E(a.a,/Windows Phone( OS)? ([^;)]+)/,2))||(b=E(a.a,/(iPhone )?OS ([\\d_]+)/,2)))return b;if(b=E(a.a,/(?:Linux|CrOS|CrKey) ([^;)]+)/,1))for(var b=b.split(/\\s/),c=0;c<b.length;c+=1)if(/^[\\d\\._]+$/.test(b[c]))return b[c];return(a=E(a.a,/(BB\\d{2}|BlackBerry).*?Version\\/([^\\s]*)/,2))?a:\"Unknown\"}\r\nfunction F(a){var b=C(a),c=z(D(a)),d=z(E(a.a,/AppleWeb(?:K|k)it\\/([\\d\\.\\+]+)/,1)),e=\"Unknown\",f=new y,f=\"Unknown\",g=!1;/OPR\\/[\\d.]+/.test(a.a)?e=\"Opera\":-1!=a.a.indexOf(\"Chrome\")||-1!=a.a.indexOf(\"CrMo\")||-1!=a.a.indexOf(\"CriOS\")?e=\"Chrome\":/Silk\\/\\d/.test(a.a)?e=\"Silk\":\"BlackBerry\"==b||\"Android\"==b?e=\"BuiltinBrowser\":-1!=a.a.indexOf(\"PhantomJS\")?e=\"PhantomJS\":-1!=a.a.indexOf(\"Safari\")?e=\"Safari\":-1!=a.a.indexOf(\"AdobeAIR\")?e=\"AdobeAIR\":-1!=a.a.indexOf(\"PlayStation\")&&(e=\"BuiltinBrowser\");\"BuiltinBrowser\"==\r\ne?f=\"Unknown\":\"Silk\"==e?f=E(a.a,/Silk\\/([\\d\\._]+)/,1):\"Chrome\"==e?f=E(a.a,/(Chrome|CrMo|CriOS)\\/([\\d\\.]+)/,2):-1!=a.a.indexOf(\"Version/\")?f=E(a.a,/Version\\/([\\d\\.\\w]+)/,1):\"AdobeAIR\"==e?f=E(a.a,/AdobeAIR\\/([\\d\\.]+)/,1):\"Opera\"==e?f=E(a.a,/OPR\\/([\\d.]+)/,1):\"PhantomJS\"==e&&(f=E(a.a,/PhantomJS\\/([\\d.]+)/,1));f=z(f);g=\"AdobeAIR\"==e?2<f.c||2==f.c&&5<=f.g:\"BlackBerry\"==b?10<=c.c:\"Android\"==b?2<c.c||2==c.c&&1<c.g:526<=d.c||525<=d.c&&13<=d.g;return new A(e,0,0,0,0,0,0,new x(g,536>d.c||536==d.c&&11>d.g))}\r\nfunction E(a,b,c){return(a=a.match(b))&&a[c]?a[c]:\"\"};function G(a){this.ma=a||\"-\"}G.prototype.e=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\\W_]+/g,\"\").toLowerCase());return b.join(this.ma)};function H(a,b){this.N=a;this.Z=4;this.O=\"n\";var c=(b||\"n4\").match(/^([nio])([1-9])$/i);c&&(this.O=c[1],this.Z=parseInt(c[2],10))}H.prototype.getName=function(){return this.N};function I(a){return a.O+a.Z}function ga(a){var b=4,c=\"n\",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.d=a;this.q=a.w.document.documentElement;this.Q=b;this.j=\"wf\";this.h=new G(\"-\");this.ha=!1!==b.events;this.F=!1!==b.classes}function J(a){if(a.F){var b=t(a.q,a.h.e(a.j,\"active\")),c=[],d=[a.h.e(a.j,\"loading\")];b||c.push(a.h.e(a.j,\"inactive\"));s(a.q,c,d)}K(a,\"inactive\")}function K(a,b,c){if(a.ha&&a.Q[b])if(c)a.Q[b](c.getName(),I(c));else a.Q[b]()};function ia(){this.C={}};function L(a,b){this.d=a;this.I=b;this.o=this.d.createElement(\"span\",{\"aria-hidden\":\"true\"},this.I)}\r\nfunction M(a,b){var c=a.o,d;d=[];for(var e=b.N.split(/,\\s*/),f=0;f<e.length;f++){var g=e[f].replace(/['\"]/g,\"\");-1==g.indexOf(\" \")?d.push(g):d.push(\"'\"+g+\"'\")}d=d.join(\",\");e=\"normal\";\"o\"===b.O?e=\"oblique\":\"i\"===b.O&&(e=\"italic\");c.style.cssText=\"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:\"+d+\";\"+(\"font-style:\"+e+\";font-weight:\"+(b.Z+\"00\")+\";\")}\r\nfunction N(a){r(a.d,\"body\",a.o)}L.prototype.remove=function(){var a=this.o;a.parentNode&&a.parentNode.removeChild(a)};function O(a,b,c,d,e,f,g,h){this.$=a;this.ka=b;this.d=c;this.m=d;this.k=e;this.I=h||\"BESbswy\";this.v={};this.X=f||3E3;this.ca=g||null;this.H=this.u=this.t=null;this.t=new L(this.d,this.I);this.u=new L(this.d,this.I);this.H=new L(this.d,this.I);M(this.t,new H(\"serif\",I(this.m)));M(this.u,new H(\"sans-serif\",I(this.m)));M(this.H,new H(\"monospace\",I(this.m)));N(this.t);N(this.u);N(this.H);this.v.serif=this.t.o.offsetWidth;this.v[\"sans-serif\"]=this.u.o.offsetWidth;this.v.monospace=this.H.o.offsetWidth}\r\nvar P={sa:\"serif\",ra:\"sans-serif\",qa:\"monospace\"};O.prototype.start=function(){this.oa=n();M(this.t,new H(this.m.getName()+\",serif\",I(this.m)));M(this.u,new H(this.m.getName()+\",sans-serif\",I(this.m)));Q(this)};function R(a,b,c){for(var d in P)if(P.hasOwnProperty(d)&&b===a.v[P[d]]&&c===a.v[P[d]])return!0;return!1}\r\nfunction Q(a){var b=a.t.o.offsetWidth,c=a.u.o.offsetWidth;b===a.v.serif&&c===a.v[\"sans-serif\"]||a.k.ga&&R(a,b,c)?n()-a.oa>=a.X?a.k.ga&&R(a,b,c)&&(null===a.ca||a.ca.hasOwnProperty(a.m.getName()))?S(a,a.$):S(a,a.ka):ja(a):S(a,a.$)}function ja(a){setTimeout(k(function(){Q(this)},a),50)}function S(a,b){a.t.remove();a.u.remove();a.H.remove();b(a.m)};function T(a,b,c,d){this.d=b;this.A=c;this.S=0;this.ea=this.ba=!1;this.X=d;this.k=a.k}function ka(a,b,c,d,e){c=c||{};if(0===b.length&&e)J(a.A);else for(a.S+=b.length,e&&(a.ba=e),e=0;e<b.length;e++){var f=b[e],g=c[f.getName()],h=a.A,m=f;h.F&&s(h.q,[h.h.e(h.j,m.getName(),I(m).toString(),\"loading\")]);K(h,\"fontloading\",m);h=null;h=new O(k(a.ia,a),k(a.ja,a),a.d,f,a.k,a.X,d,g);h.start()}}\r\nT.prototype.ia=function(a){var b=this.A;b.F&&s(b.q,[b.h.e(b.j,a.getName(),I(a).toString(),\"active\")],[b.h.e(b.j,a.getName(),I(a).toString(),\"loading\"),b.h.e(b.j,a.getName(),I(a).toString(),\"inactive\")]);K(b,\"fontactive\",a);this.ea=!0;la(this)};\r\nT.prototype.ja=function(a){var b=this.A;if(b.F){var c=t(b.q,b.h.e(b.j,a.getName(),I(a).toString(),\"active\")),d=[],e=[b.h.e(b.j,a.getName(),I(a).toString(),\"loading\")];c||d.push(b.h.e(b.j,a.getName(),I(a).toString(),\"inactive\"));s(b.q,d,e)}K(b,\"fontinactive\",a);la(this)};function la(a){0==--a.S&&a.ba&&(a.ea?(a=a.A,a.F&&s(a.q,[a.h.e(a.j,\"active\")],[a.h.e(a.j,\"loading\"),a.h.e(a.j,\"inactive\")]),K(a,\"active\")):J(a.A))};function U(a){this.K=a;this.B=new ia;this.pa=new B(a.navigator.userAgent);this.a=this.pa.parse();this.U=this.V=0;this.R=this.T=!0}\r\nU.prototype.load=function(a){this.d=new q(this.K,a.context||this.K);this.T=!1!==a.events;this.R=!1!==a.classes;var b=new ha(this.d,a),c=[],d=a.timeout;b.F&&s(b.q,[b.h.e(b.j,\"loading\")]);K(b,\"loading\");var c=this.B,e=this.d,f=[],g;for(g in a)if(a.hasOwnProperty(g)){var h=c.C[g];h&&f.push(h(a[g],e))}c=f;this.U=this.V=c.length;a=new T(this.a,this.d,b,d);d=0;for(g=c.length;d<g;d++)e=c[d],e.L(this.a,k(this.la,this,e,b,a))};\r\nU.prototype.la=function(a,b,c,d){var e=this;d?a.load(function(a,b,d){ma(e,c,a,b,d)}):(a=0==--this.V,this.U--,a&&0==this.U?J(b):(this.R||this.T)&&ka(c,[],{},null,a))};function ma(a,b,c,d,e){var f=0==--a.V;(a.R||a.T)&&setTimeout(function(){ka(b,c,d||null,e||null,f)},0)};function na(a,b,c){this.P=a?a:b+oa;this.s=[];this.W=[];this.fa=c||\"\"}var oa=\"//fonts.googleapis.com/css\";na.prototype.e=function(){if(0==this.s.length)throw Error(\"No fonts to load!\");if(-1!=this.P.indexOf(\"kit=\"))return this.P;for(var a=this.s.length,b=[],c=0;c<a;c++)b.push(this.s[c].replace(/ /g,\"+\"));a=this.P+\"?family=\"+b.join(\"%7C\");0<this.W.length&&(a+=\"&subset=\"+this.W.join(\",\"));0<this.fa.length&&(a+=\"&text=\"+encodeURIComponent(this.fa));return a};function pa(a){this.s=a;this.da=[];this.M={}}\r\nvar qa={latin:\"BESbswy\",cyrillic:\"&#1081;&#1103;&#1046;\",greek:\"&#945;&#946;&#931;\",khmer:\"&#x1780;&#x1781;&#x1782;\",Hanuman:\"&#x1780;&#x1781;&#x1782;\"},ra={thin:\"1\",extralight:\"2\",\"extra-light\":\"2\",ultralight:\"2\",\"ultra-light\":\"2\",light:\"3\",regular:\"4\",book:\"4\",medium:\"5\",\"semi-bold\":\"6\",semibold:\"6\",\"demi-bold\":\"6\",demibold:\"6\",bold:\"7\",\"extra-bold\":\"8\",extrabold:\"8\",\"ultra-bold\":\"8\",ultrabold:\"8\",black:\"9\",heavy:\"9\",l:\"3\",r:\"4\",b:\"7\"},sa={i:\"i\",italic:\"i\",n:\"n\",normal:\"n\"},ta=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;\r\npa.prototype.parse=function(){for(var a=this.s.length,b=0;b<a;b++){var c=this.s[b].split(\":\"),d=c[0].replace(/\\+/g,\" \"),e=[\"n4\"];if(2<=c.length){var f;var g=c[1];f=[];if(g)for(var g=g.split(\",\"),h=g.length,m=0;m<h;m++){var l;l=g[m];if(l.match(/^[\\w-]+$/)){l=ta.exec(l.toLowerCase());var p=void 0;if(null==l)p=\"\";else{p=void 0;p=l[1];if(null==p||\"\"==p)p=\"4\";else var fa=ra[p],p=fa?fa:isNaN(p)?\"4\":p.substr(0,1);l=l[2];p=[null==l||\"\"==l?\"n\":sa[l],p].join(\"\")}l=p}else l=\"\";l&&f.push(l)}0<f.length&&(e=f);\r\n3==c.length&&(c=c[2],f=[],c=c?c.split(\",\"):f,0<c.length&&(c=qa[c[0]])&&(this.M[d]=c))}this.M[d]||(c=qa[d])&&(this.M[d]=c);for(c=0;c<e.length;c+=1)this.da.push(new H(d,e[c]))}};function V(a,b){this.a=(new B(navigator.userAgent)).parse();this.d=a;this.f=b}var ua={Arimo:!0,Cousine:!0,Tinos:!0};V.prototype.L=function(a,b){b(a.k.Y)};V.prototype.load=function(a){var b=this.d;\"MSIE\"==this.a.getName()&&1!=this.f.blocking?ca(b,k(this.aa,this,a)):this.aa(a)};\r\nV.prototype.aa=function(a){for(var b=this.d,c=new na(this.f.api,u(b),this.f.text),d=this.f.families,e=d.length,f=0;f<e;f++){var g=d[f].split(\":\");3==g.length&&c.W.push(g.pop());var h=\"\";2==g.length&&\"\"!=g[1]&&(h=\":\");c.s.push(g.join(h))}d=new pa(d);d.parse();v(b,c.e());a(d.da,d.M,ua)};function W(a,b){this.d=a;this.f=b;this.p=[]}W.prototype.J=function(a){var b=this.d;return u(this.d)+(this.f.api||\"//f.fontdeck.com/s/css/js/\")+(b.w.location.hostname||b.K.location.hostname)+\"/\"+a+\".js\"};\r\nW.prototype.L=function(a,b){var c=this.f.id,d=this.d.w,e=this;c?(d.__webfontfontdeckmodule__||(d.__webfontfontdeckmodule__={}),d.__webfontfontdeckmodule__[c]=function(a,c){for(var d=0,m=c.fonts.length;d<m;++d){var l=c.fonts[d];e.p.push(new H(l.name,ga(\"font-weight:\"+l.weight+\";font-style:\"+l.style)))}b(a)},w(this.d,this.J(c),function(a){a&&b(!1)})):b(!1)};W.prototype.load=function(a){a(this.p)};function X(a,b){this.d=a;this.f=b;this.p=[]}X.prototype.J=function(a){var b=u(this.d);return(this.f.api||b+\"//use.typekit.net\")+\"/\"+a+\".js\"};X.prototype.L=function(a,b){var c=this.f.id,d=this.d.w,e=this;c?w(this.d,this.J(c),function(a){if(a)b(!1);else{if(d.Typekit&&d.Typekit.config&&d.Typekit.config.fn){a=d.Typekit.config.fn;for(var c=0;c<a.length;c+=2)for(var h=a[c],m=a[c+1],l=0;l<m.length;l++)e.p.push(new H(h,m[l]));try{d.Typekit.load({events:!1,classes:!1})}catch(p){}}b(!0)}},2E3):b(!1)};\r\nX.prototype.load=function(a){a(this.p)};function Y(a,b){this.d=a;this.f=b;this.p=[]}Y.prototype.L=function(a,b){var c=this,d=c.f.projectId,e=c.f.version;if(d){var f=c.d.w;w(this.d,c.J(d,e),function(e){if(e)b(!1);else{if(f[\"__mti_fntLst\"+d]&&(e=f[\"__mti_fntLst\"+d]()))for(var h=0;h<e.length;h++)c.p.push(new H(e[h].fontfamily));b(a.k.Y)}}).id=\"__MonotypeAPIScript__\"+d}else b(!1)};Y.prototype.J=function(a,b){var c=u(this.d),d=(this.f.api||\"fast.fonts.net/jsapi\").replace(/^.*http(s?):(\\/\\/)?/,\"\");return c+\"//\"+d+\"/\"+a+\".js\"+(b?\"?v=\"+b:\"\")};\r\nY.prototype.load=function(a){a(this.p)};function Z(a,b){this.d=a;this.f=b}Z.prototype.load=function(a){var b,c,d=this.f.urls||[],e=this.f.families||[],f=this.f.testStrings||{};b=0;for(c=d.length;b<c;b++)v(this.d,d[b]);d=[];b=0;for(c=e.length;b<c;b++){var g=e[b].split(\":\");if(g[1])for(var h=g[1].split(\",\"),m=0;m<h.length;m+=1)d.push(new H(g[0],h[m]));else d.push(new H(g[0]))}a(d,f)};Z.prototype.L=function(a,b){return b(a.k.Y)};var $=new U(this);$.B.C.custom=function(a,b){return new Z(b,a)};$.B.C.fontdeck=function(a,b){return new W(b,a)};$.B.C.monotype=function(a,b){return new Y(b,a)};$.B.C.typekit=function(a,b){return new X(b,a)};$.B.C.google=function(a,b){return new V(b,a)};this.WebFont||(this.WebFont={},this.WebFont.load=k($.load,$),this.WebFontConfig&&$.load(this.WebFontConfig));})(this,document);\r\n WebFont.load({\r\n    google: { \r\n        families: [\r\n        'Droid+Serif', \r\n        'Lobster', \r\n        'Open+Sans',\r\n        'PT+Serif',\r\n        'Lato',\r\n        'Ubuntu',\r\n        'Tangerine',\r\n        'Source+Sans+Pro',\r\n        'Roboto',\r\n        'Raleway',\r\n        'Rancho',\r\n        'Inconsolata',\r\n        'Droid+Sans',\r\n        'Philosopher',\r\n        'Plaster',\r\n        'Rokkitt',\r\n        'Sofia',\r\n        'Playball',\r\n        'Nosifer',\r\n        'Pacifico',\r\n        'Gravitas+One',\r\n        'Volkorn',\r\n        'Merriweather',\r\n        'Old+Standard+TT',\r\n        'Arvo',\r\n        'Josefin+Slab',\r\n        'Libre+Baskerville',\r\n        'Lora',\r\n        'Oswald'\r\n        ] \r\n                     \r\n     } \r\n}); \r\n\r\n\r\n","Milople_Personalizedcool/js/jcrop.min.js":"/**\r\n * jquery.Jcrop.min.js v0.9.12 (build:20130202)\r\n * jQuery Image Cropping Plugin - released under MIT License\r\n * Copyright (c) 2008-2013 Tapmodo Interactive LLC\r\n * https://github.com/tapmodo/Jcrop\r\n */\r\nrequire([\"jquery\"], function (jQuery) {\r\n(function(a){a.Jcrop=function(b,c){function i(a){return Math.round(a)+\"px\"}function j(a){return d.baseClass+\"-\"+a}function k(){return a.fx.step.hasOwnProperty(\"backgroundColor\")}function l(b){var c=a(b).offset();return[c.left,c.top]}function m(a){return[a.pageX-e[0],a.pageY-e[1]]}function n(b){typeof b!=\"object\"&&(b={}),d=a.extend(d,b),a.each([\"onChange\",\"onSelect\",\"onRelease\",\"onDblClick\"],function(a,b){typeof d[b]!=\"function\"&&(d[b]=function(){})})}function o(a,b,c){e=l(D),bc.setCursor(a===\"move\"?a:a+\"-resize\");if(a===\"move\")return bc.activateHandlers(q(b),v,c);var d=_.getFixed(),f=r(a),g=_.getCorner(r(f));_.setPressed(_.getCorner(f)),_.setCurrent(g),bc.activateHandlers(p(a,d),v,c)}function p(a,b){return function(c){if(!d.aspectRatio)switch(a){case\"e\":c[1]=b.y2;break;case\"w\":c[1]=b.y2;break;case\"n\":c[0]=b.x2;break;case\"s\":c[0]=b.x2}else switch(a){case\"e\":c[1]=b.y+1;break;case\"w\":c[1]=b.y+1;break;case\"n\":c[0]=b.x+1;break;case\"s\":c[0]=b.x+1}_.setCurrent(c),bb.update()}}function q(a){var b=a;return bd.watchKeys\r\n(),function(a){_.moveOffset([a[0]-b[0],a[1]-b[1]]),b=a,bb.update()}}function r(a){switch(a){case\"n\":return\"sw\";case\"s\":return\"nw\";case\"e\":return\"nw\";case\"w\":return\"ne\";case\"ne\":return\"sw\";case\"nw\":return\"se\";case\"se\":return\"nw\";case\"sw\":return\"ne\"}}function s(a){return function(b){return d.disabled?!1:a===\"move\"&&!d.allowMove?!1:(e=l(D),W=!0,o(a,m(b)),b.stopPropagation(),b.preventDefault(),!1)}}function t(a,b,c){var d=a.width(),e=a.height();d>b&&b>0&&(d=b,e=b/a.width()*a.height()),e>c&&c>0&&(e=c,d=c/a.height()*a.width()),T=a.width()/d,U=a.height()/e,a.width(d).height(e)}function u(a){return{x:a.x*T,y:a.y*U,x2:a.x2*T,y2:a.y2*U,w:a.w*T,h:a.h*U}}function v(a){var b=_.getFixed();b.w>d.minSelect[0]&&b.h>d.minSelect[1]?(bb.enableHandles(),bb.done()):bb.release(),bc.setCursor(d.allowSelect?\"crosshair\":\"default\")}function w(a){if(d.disabled)return!1;if(!d.allowSelect)return!1;W=!0,e=l(D),bb.disableHandles(),bc.setCursor(\"crosshair\");var b=m(a);return _.setPressed(b),bb.update(),bc.activateHandlers(x,v,a.type.substring\r\n(0,5)===\"touch\"),bd.watchKeys(),a.stopPropagation(),a.preventDefault(),!1}function x(a){_.setCurrent(a),bb.update()}function y(){var b=a(\"<div></div>\").addClass(j(\"tracker\"));return g&&b.css({opacity:0,backgroundColor:\"white\"}),b}function be(a){G.removeClass().addClass(j(\"holder\")).addClass(a)}function bf(a,b){function t(){window.setTimeout(u,l)}var c=a[0]/T,e=a[1]/U,f=a[2]/T,g=a[3]/U;if(X)return;var h=_.flipCoords(c,e,f,g),i=_.getFixed(),j=[i.x,i.y,i.x2,i.y2],k=j,l=d.animationDelay,m=h[0]-j[0],n=h[1]-j[1],o=h[2]-j[2],p=h[3]-j[3],q=0,r=d.swingSpeed;c=k[0],e=k[1],f=k[2],g=k[3],bb.animMode(!0);var s,u=function(){return function(){q+=(100-q)/r,k[0]=Math.round(c+q/100*m),k[1]=Math.round(e+q/100*n),k[2]=Math.round(f+q/100*o),k[3]=Math.round(g+q/100*p),q>=99.8&&(q=100),q<100?(bh(k),t()):(bb.done(),bb.animMode(!1),typeof b==\"function\"&&b.call(bs))}}();t()}function bg(a){bh([a[0]/T,a[1]/U,a[2]/T,a[3]/U]),d.onSelect.call(bs,u(_.getFixed())),bb.enableHandles()}function bh(a){_.setPressed([a[0],a[1]]),_.setCurrent([a[2],\r\na[3]]),bb.update()}function bi(){return u(_.getFixed())}function bj(){return _.getFixed()}function bk(a){n(a),br()}function bl(){d.disabled=!0,bb.disableHandles(),bb.setCursor(\"default\"),bc.setCursor(\"default\")}function bm(){d.disabled=!1,br()}function bn(){bb.done(),bc.activateHandlers(null,null)}function bo(){G.remove(),A.show(),A.css(\"visibility\",\"visible\"),a(b).removeData(\"Jcrop\")}function bp(a,b){bb.release(),bl();var c=new Image;c.onload=function(){var e=c.width,f=c.height,g=d.boxWidth,h=d.boxHeight;D.width(e).height(f),D.attr(\"src\",a),H.attr(\"src\",a),t(D,g,h),E=D.width(),F=D.height(),H.width(E).height(F),M.width(E+L*2).height(F+L*2),G.width(E).height(F),ba.resize(E,F),bm(),typeof b==\"function\"&&b.call(bs)},c.src=a}function bq(a,b,c){var e=b||d.bgColor;d.bgFade&&k()&&d.fadeTime&&!c?a.animate({backgroundColor:e},{queue:!1,duration:d.fadeTime}):a.css(\"backgroundColor\",e)}function br(a){d.allowResize?a?bb.enableOnly():bb.enableHandles():bb.disableHandles(),bc.setCursor(d.allowSelect?\"crosshair\":\"default\"),bb\r\n.setCursor(d.allowMove?\"move\":\"default\"),d.hasOwnProperty(\"trueSize\")&&(T=d.trueSize[0]/E,U=d.trueSize[1]/F),d.hasOwnProperty(\"setSelect\")&&(bg(d.setSelect),bb.done(),delete d.setSelect),ba.refresh(),d.bgColor!=N&&(bq(d.shade?ba.getShades():G,d.shade?d.shadeColor||d.bgColor:d.bgColor),N=d.bgColor),O!=d.bgOpacity&&(O=d.bgOpacity,d.shade?ba.refresh():bb.setBgOpacity(O)),P=d.maxSize[0]||0,Q=d.maxSize[1]||0,R=d.minSize[0]||0,S=d.minSize[1]||0,d.hasOwnProperty(\"outerImage\")&&(D.attr(\"src\",d.outerImage),delete d.outerImage),bb.refresh()}var d=a.extend({},a.Jcrop.defaults),e,f=navigator.userAgent.toLowerCase(),g=/msie/.test(f),h=/msie [1-6]\\./.test(f);typeof b!=\"object\"&&(b=a(b)[0]),typeof c!=\"object\"&&(c={}),n(c);var z={border:\"none\",visibility:\"visible\",margin:0,padding:0,position:\"absolute\",top:0,left:0},A=a(b),B=!0;if(b.tagName==\"IMG\"){if(A[0].width!=0&&A[0].height!=0)A.width(A[0].width),A.height(A[0].height);else{var C=new Image;C.src=A[0].src,A.width(C.width),A.height(C.height)}var D=A.clone().removeAttr(\"id\").\r\ncss(z).show();D.width(A.width()),D.height(A.height()),A.after(D).hide()}else D=A.css(z).show(),B=!1,d.shade===null&&(d.shade=!0);t(D,d.boxWidth,d.boxHeight);var E=D.width(),F=D.height(),G=a(\"<div />\").width(E).height(F).addClass(j(\"holder\")).css({position:\"relative\",backgroundColor:d.bgColor}).insertAfter(A).append(D);d.addClass&&G.addClass(d.addClass);var H=a(\"<div />\"),I=a(\"<div />\").width(\"100%\").height(\"100%\").css({zIndex:310,position:\"absolute\",overflow:\"hidden\"}),J=a(\"<div />\").width(\"100%\").height(\"100%\").css(\"zIndex\",320),K=a(\"<div />\").css({position:\"absolute\",zIndex:600}).dblclick(function(){var a=_.getFixed();d.onDblClick.call(bs,a)}).insertBefore(D).append(I,J);B&&(H=a(\"<img />\").attr(\"src\",D.attr(\"src\")).css(z).width(E).height(F),I.append(H)),h&&K.css({overflowY:\"hidden\"});var L=d.boundary,M=y().width(E+L*2).height(F+L*2).css({position:\"absolute\",top:i(-L),left:i(-L),zIndex:290}).mousedown(w),N=d.bgColor,O=d.bgOpacity,P,Q,R,S,T,U,V=!0,W,X,Y;e=l(D);var Z=function(){function a(){var a={},b=[\"touchstart\"\r\n,\"touchmove\",\"touchend\"],c=document.createElement(\"div\"),d;try{for(d=0;d<b.length;d++){var e=b[d];e=\"on\"+e;var f=e in c;f||(c.setAttribute(e,\"return;\"),f=typeof c[e]==\"function\"),a[b[d]]=f}return a.touchstart&&a.touchend&&a.touchmove}catch(g){return!1}}function b(){return d.touchSupport===!0||d.touchSupport===!1?d.touchSupport:a()}return{createDragger:function(a){return function(b){return d.disabled?!1:a===\"move\"&&!d.allowMove?!1:(e=l(D),W=!0,o(a,m(Z.cfilter(b)),!0),b.stopPropagation(),b.preventDefault(),!1)}},newSelection:function(a){return w(Z.cfilter(a))},cfilter:function(a){return a.pageX=a.originalEvent.changedTouches[0].pageX,a.pageY=a.originalEvent.changedTouches[0].pageY,a},isSupported:a,support:b()}}(),_=function(){function h(d){d=n(d),c=a=d[0],e=b=d[1]}function i(a){a=n(a),f=a[0]-c,g=a[1]-e,c=a[0],e=a[1]}function j(){return[f,g]}function k(d){var f=d[0],g=d[1];0>a+f&&(f-=f+a),0>b+g&&(g-=g+b),F<e+g&&(g+=F-(e+g)),E<c+f&&(f+=E-(c+f)),a+=f,c+=f,b+=g,e+=g}function l(a){var b=m();switch(a){case\"ne\":return[\r\nb.x2,b.y];case\"nw\":return[b.x,b.y];case\"se\":return[b.x2,b.y2];case\"sw\":return[b.x,b.y2]}}function m(){if(!d.aspectRatio)return p();var f=d.aspectRatio,g=d.minSize[0]/T,h=d.maxSize[0]/T,i=d.maxSize[1]/U,j=c-a,k=e-b,l=Math.abs(j),m=Math.abs(k),n=l/m,r,s,t,u;return h===0&&(h=E*10),i===0&&(i=F*10),n<f?(s=e,t=m*f,r=j<0?a-t:t+a,r<0?(r=0,u=Math.abs((r-a)/f),s=k<0?b-u:u+b):r>E&&(r=E,u=Math.abs((r-a)/f),s=k<0?b-u:u+b)):(r=c,u=l/f,s=k<0?b-u:b+u,s<0?(s=0,t=Math.abs((s-b)*f),r=j<0?a-t:t+a):s>F&&(s=F,t=Math.abs(s-b)*f,r=j<0?a-t:t+a)),r>a?(r-a<g?r=a+g:r-a>h&&(r=a+h),s>b?s=b+(r-a)/f:s=b-(r-a)/f):r<a&&(a-r<g?r=a-g:a-r>h&&(r=a-h),s>b?s=b+(a-r)/f:s=b-(a-r)/f),r<0?(a-=r,r=0):r>E&&(a-=r-E,r=E),s<0?(b-=s,s=0):s>F&&(b-=s-F,s=F),q(o(a,b,r,s))}function n(a){return a[0]<0&&(a[0]=0),a[1]<0&&(a[1]=0),a[0]>E&&(a[0]=E),a[1]>F&&(a[1]=F),[Math.round(a[0]),Math.round(a[1])]}function o(a,b,c,d){var e=a,f=c,g=b,h=d;return c<a&&(e=c,f=a),d<b&&(g=d,h=b),[e,g,f,h]}function p(){var d=c-a,f=e-b,g;return P&&Math.abs(d)>P&&(c=d>0?a+P:a-P),Q&&Math.abs\r\n(f)>Q&&(e=f>0?b+Q:b-Q),S/U&&Math.abs(f)<S/U&&(e=f>0?b+S/U:b-S/U),R/T&&Math.abs(d)<R/T&&(c=d>0?a+R/T:a-R/T),a<0&&(c-=a,a-=a),b<0&&(e-=b,b-=b),c<0&&(a-=c,c-=c),e<0&&(b-=e,e-=e),c>E&&(g=c-E,a-=g,c-=g),e>F&&(g=e-F,b-=g,e-=g),a>E&&(g=a-F,e-=g,b-=g),b>F&&(g=b-F,e-=g,b-=g),q(o(a,b,c,e))}function q(a){return{x:a[0],y:a[1],x2:a[2],y2:a[3],w:a[2]-a[0],h:a[3]-a[1]}}var a=0,b=0,c=0,e=0,f,g;return{flipCoords:o,setPressed:h,setCurrent:i,getOffset:j,moveOffset:k,getCorner:l,getFixed:m}}(),ba=function(){function f(a,b){e.left.css({height:i(b)}),e.right.css({height:i(b)})}function g(){return h(_.getFixed())}function h(a){e.top.css({left:i(a.x),width:i(a.w),height:i(a.y)}),e.bottom.css({top:i(a.y2),left:i(a.x),width:i(a.w),height:i(F-a.y2)}),e.right.css({left:i(a.x2),width:i(E-a.x2)}),e.left.css({width:i(a.x)})}function j(){return a(\"<div />\").css({position:\"absolute\",backgroundColor:d.shadeColor||d.bgColor}).appendTo(c)}function k(){b||(b=!0,c.insertBefore(D),g(),bb.setBgOpacity(1,0,1),H.hide(),l(d.shadeColor||d.bgColor,1),bb.\r\nisAwake()?n(d.bgOpacity,1):n(1,1))}function l(a,b){bq(p(),a,b)}function m(){b&&(c.remove(),H.show(),b=!1,bb.isAwake()?bb.setBgOpacity(d.bgOpacity,1,1):(bb.setBgOpacity(1,1,1),bb.disableHandles()),bq(G,0,1))}function n(a,e){b&&(d.bgFade&&!e?c.animate({opacity:1-a},{queue:!1,duration:d.fadeTime}):c.css({opacity:1-a}))}function o(){d.shade?k():m(),bb.isAwake()&&n(d.bgOpacity)}function p(){return c.children()}var b=!1,c=a(\"<div />\").css({position:\"absolute\",zIndex:240,opacity:0}),e={top:j(),left:j().height(F),right:j().height(F),bottom:j()};return{update:g,updateRaw:h,getShades:p,setBgColor:l,enable:k,disable:m,resize:f,refresh:o,opacity:n}}(),bb=function(){function k(b){var c=a(\"<div />\").css({position:\"absolute\",opacity:d.borderOpacity}).addClass(j(b));return I.append(c),c}function l(b,c){var d=a(\"<div />\").mousedown(s(b)).css({cursor:b+\"-resize\",position:\"absolute\",zIndex:c}).addClass(\"ord-\"+b);return Z.support&&d.bind(\"touchstart.jcrop\",Z.createDragger(b)),J.append(d),d}function m(a){var b=d.handleSize,e=l(a,c++\r\n).css({opacity:d.handleOpacity}).addClass(j(\"handle\"));return b&&e.width(b).height(b),e}function n(a){return l(a,c++).addClass(\"jcrop-dragbar\")}function o(a){var b;for(b=0;b<a.length;b++)g[a[b]]=n(a[b])}function p(a){var b,c;for(c=0;c<a.length;c++){switch(a[c]){case\"n\":b=\"hline\";break;case\"s\":b=\"hline bottom\";break;case\"e\":b=\"vline right\";break;case\"w\":b=\"vline\"}e[a[c]]=k(b)}}function q(a){var b;for(b=0;b<a.length;b++)f[a[b]]=m(a[b])}function r(a,b){d.shade||H.css({top:i(-b),left:i(-a)}),K.css({top:i(b),left:i(a)})}function t(a,b){K.width(Math.round(a)).height(Math.round(b))}function v(){var a=_.getFixed();_.setPressed([a.x,a.y]),_.setCurrent([a.x2,a.y2]),w()}function w(a){if(b)return x(a)}function x(a){var c=_.getFixed();t(c.w,c.h),r(c.x,c.y),d.shade&&ba.updateRaw(c),b||A(),a?d.onSelect.call(bs,u(c)):d.onChange.call(bs,u(c))}function z(a,c,e){if(!b&&!c)return;d.bgFade&&!e?D.animate({opacity:a},{queue:!1,duration:d.fadeTime}):D.css(\"opacity\",a)}function A(){K.show(),d.shade?ba.opacity(O):z(O,!0),b=!0}function B\r\n(){F(),K.hide(),d.shade?ba.opacity(1):z(1),b=!1,d.onRelease.call(bs)}function C(){h&&J.show()}function E(){h=!0;if(d.allowResize)return J.show(),!0}function F(){h=!1,J.hide()}function G(a){a?(X=!0,F()):(X=!1,E())}function L(){G(!1),v()}var b,c=370,e={},f={},g={},h=!1;d.dragEdges&&a.isArray(d.createDragbars)&&o(d.createDragbars),a.isArray(d.createHandles)&&q(d.createHandles),d.drawBorders&&a.isArray(d.createBorders)&&p(d.createBorders),a(document).bind(\"touchstart.jcrop-ios\",function(b){a(b.currentTarget).hasClass(\"jcrop-tracker\")&&b.stopPropagation()});var M=y().mousedown(s(\"move\")).css({cursor:\"move\",position:\"absolute\",zIndex:360});return Z.support&&M.bind(\"touchstart.jcrop\",Z.createDragger(\"move\")),I.append(M),F(),{updateVisible:w,update:x,release:B,refresh:v,isAwake:function(){return b},setCursor:function(a){M.css(\"cursor\",a)},enableHandles:E,enableOnly:function(){h=!0},showHandles:C,disableHandles:F,animMode:G,setBgOpacity:z,done:L}}(),bc=function(){function f(b){M.css({zIndex:450}),b?a(document).bind(\"touchmove.jcrop\"\r\n,k).bind(\"touchend.jcrop\",l):e&&a(document).bind(\"mousemove.jcrop\",h).bind(\"mouseup.jcrop\",i)}function g(){M.css({zIndex:290}),a(document).unbind(\".jcrop\")}function h(a){return b(m(a)),!1}function i(a){return a.preventDefault(),a.stopPropagation(),W&&(W=!1,c(m(a)),bb.isAwake()&&d.onSelect.call(bs,u(_.getFixed())),g(),b=function(){},c=function(){}),!1}function j(a,d,e){return W=!0,b=a,c=d,f(e),!1}function k(a){return b(m(Z.cfilter(a))),!1}function l(a){return i(Z.cfilter(a))}function n(a){M.css(\"cursor\",a)}var b=function(){},c=function(){},e=d.trackDocument;return e||M.mousemove(h).mouseup(i).mouseout(i),D.before(M),{activateHandlers:j,setCursor:n}}(),bd=function(){function e(){d.keySupport&&(b.show(),b.focus())}function f(a){b.hide()}function g(a,b,c){d.allowMove&&(_.moveOffset([b,c]),bb.updateVisible(!0)),a.preventDefault(),a.stopPropagation()}function i(a){if(a.ctrlKey||a.metaKey)return!0;Y=a.shiftKey?!0:!1;var b=Y?10:1;switch(a.keyCode){case 37:g(a,-b,0);break;case 39:g(a,b,0);break;case 38:g(a,0,-b);break;\r\ncase 40:g(a,0,b);break;case 27:d.allowSelect&&bb.release();break;case 9:return!0}return!1}var b=a('<input type=\"radio\" />').css({position:\"fixed\",left:\"-120px\",width:\"12px\"}).addClass(\"jcrop-keymgr\"),c=a(\"<div />\").css({position:\"absolute\",overflow:\"hidden\"}).append(b);return d.keySupport&&(b.keydown(i).blur(f),h||!d.fixedSupport?(b.css({position:\"absolute\",left:\"-20px\"}),c.append(b).insertBefore(D)):b.insertBefore(D)),{watchKeys:e}}();Z.support&&M.bind(\"touchstart.jcrop\",Z.newSelection),J.hide(),br(!0);var bs={setImage:bp,animateTo:bf,setSelect:bg,setOptions:bk,tellSelect:bi,tellScaled:bj,setClass:be,disable:bl,enable:bm,cancel:bn,release:bb.release,destroy:bo,focus:bd.watchKeys,getBounds:function(){return[E*T,F*U]},getWidgetSize:function(){return[E,F]},getScaleFactor:function(){return[T,U]},getOptions:function(){return d},ui:{holder:G,selection:K}};return g&&G.bind(\"selectstart\",function(){return!1}),A.data(\"Jcrop\",bs),bs},a.fn.Jcrop=function(b,c){var d;return this.each(function(){if(a(this).data(\"Jcrop\")){if(\r\nb===\"api\")return a(this).data(\"Jcrop\");a(this).data(\"Jcrop\").setOptions(b)}else this.tagName==\"IMG\"?a.Jcrop.Loader(this,function(){a(this).css({display:\"block\",visibility:\"hidden\"}),d=a.Jcrop(this,b),a.isFunction(c)&&c.call(d)}):(a(this).css({display:\"block\",visibility:\"hidden\"}),d=a.Jcrop(this,b),a.isFunction(c)&&c.call(d))}),this},a.Jcrop.Loader=function(b,c,d){function g(){f.complete?(e.unbind(\".jcloader\"),a.isFunction(c)&&c.call(f)):window.setTimeout(g,50)}var e=a(b),f=e[0];e.bind(\"load.jcloader\",g).bind(\"error.jcloader\",function(b){e.unbind(\".jcloader\"),a.isFunction(d)&&d.call(f)}),f.complete&&a.isFunction(c)&&(e.unbind(\".jcloader\"),c.call(f))},a.Jcrop.defaults={allowSelect:!0,allowMove:!0,allowResize:!0,trackDocument:!0,baseClass:\"jcrop\",addClass:null,bgColor:\"black\",bgOpacity:.6,bgFade:!1,borderOpacity:.4,handleOpacity:.5,handleSize:null,aspectRatio:0,keySupport:!0,createHandles:[\"n\",\"s\",\"e\",\"w\",\"nw\",\"ne\",\"se\",\"sw\"],createDragbars:[\"n\",\"s\",\"e\",\"w\"],createBorders:[\"n\",\"s\",\"e\",\"w\"],drawBorders:!0,dragEdges\r\n:!0,fixedSupport:!0,touchSupport:null,shade:null,boxWidth:0,boxHeight:0,boundary:2,fadeTime:400,animationDelay:20,swingSpeed:3,minSelect:[0,0],maxSize:[0,0],minSize:[0,0],onChange:function(){},onSelect:function(){},onDblClick:function(){},onRelease:function(){}}})(jQuery);\r\n});","Milople_Personalizedcool/js/personalized_based.js":"/**\r\n*\r\n* Do not edit or add to this file if you wish to upgrade the module to newer\r\n* versions in the future. If you wish to customize the module for your\r\n* needs please contact us to https://www.milople.com/contact-us.html\r\n*\r\n* @category    Ecommerce\r\n* @package     Milople_Personlized\r\n* @copyright   Copyright (c) 2016 Milople Technologies Pvt. Ltd. All Rights Reserved.\r\n* @url         https://www.milople.com/magento2-extensions/personalized-products-m2.html\r\n*\r\n**/\r\n\r\nvar fabric = fabric || { version: \"1.6.0-rc.1\" };\r\nif (typeof exports !== 'undefined') {\r\n  exports.fabric = fabric;\r\n}\r\n\r\nif (typeof document !== 'undefined' && typeof window !== 'undefined') {\r\n  fabric.document = document;\r\n  fabric.window = window;\r\n  // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)\r\n  window.fabric = fabric;\r\n}\r\nelse {\r\n  // assume we're running under node.js when document/window are not present\r\n  fabric.document = require(\"jsdom\")\r\n    .jsdom(\"<!DOCTYPE html><html><head></head><body></body></html>\");\r\n\r\n  if (fabric.document.createWindow) {\r\n    fabric.window = fabric.document.createWindow();\r\n  } else {\r\n    fabric.window = fabric.document.parentWindow;\r\n  }\r\n}\r\n\r\n/**\r\n * True when in environment that supports touch events\r\n * @type boolean\r\n */\r\nfabric.isTouchSupported = \"ontouchstart\" in fabric.document.documentElement;\r\n\r\n/**\r\n * True when in environment that's probably Node.js\r\n * @type boolean\r\n */\r\nfabric.isLikelyNode = typeof Buffer !== 'undefined' &&\r\n                      typeof window === 'undefined';\r\n\r\n/* _FROM_SVG_START_ */\r\n/**\r\n * Attributes parsed from all SVG elements\r\n * @type array\r\n */\r\nfabric.SHARED_ATTRIBUTES = [\r\n  \"display\",\r\n  \"transform\",\r\n  \"fill\", \"fill-opacity\", \"fill-rule\",\r\n  \"opacity\",\r\n  \"stroke\", \"stroke-dasharray\", \"stroke-linecap\",\r\n  \"stroke-linejoin\", \"stroke-miterlimit\",\r\n  \"stroke-opacity\", \"stroke-width\",\r\n  \"id\"\r\n];\r\n/* _FROM_SVG_END_ */\r\n\r\n/**\r\n * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.\r\n */\r\nfabric.DPI = 96;\r\nfabric.reNum = '(?:[-+]?(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:e[-+]?\\\\d+)?)';\r\n\r\n\r\n/**\r\n * Device Pixel Ratio\r\n * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html\r\n */\r\nfabric.devicePixelRatio = fabric.window.devicePixelRatio ||\r\n                          fabric.window.webkitDevicePixelRatio ||\r\n                          fabric.window.mozDevicePixelRatio ||\r\n                          1;\r\n\r\n\r\n(function() {\r\n\r\n  /**\r\n   * @private\r\n   * @param {String} eventName\r\n   * @param {Function} handler\r\n   */\r\n  function _removeEventListener(eventName, handler) {\r\n    if (!this.__eventListeners[eventName]) {\r\n      return;\r\n    }\r\n\r\n    if (handler) {\r\n      fabric.util.removeFromArray(this.__eventListeners[eventName], handler);\r\n    }\r\n    else {\r\n      this.__eventListeners[eventName].length = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Observes specified event\r\n   * @deprecated `observe` deprecated since 0.8.34 (use `on` instead)\r\n   * @memberOf fabric.Observable\r\n   * @alias on\r\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\r\n   * @param {Function} handler Function that receives a notification when an event of the specified type occurs\r\n   * @return {Self} thisArg\r\n   * @chainable\r\n   */\r\n  function observe(eventName, handler) {\r\n    if (!this.__eventListeners) {\r\n      this.__eventListeners = { };\r\n    }\r\n    // one object with key/value pairs was passed\r\n    if (arguments.length === 1) {\r\n      for (var prop in eventName) {\r\n        this.on(prop, eventName[prop]);\r\n      }\r\n    }\r\n    else {\r\n      if (!this.__eventListeners[eventName]) {\r\n        this.__eventListeners[eventName] = [ ];\r\n      }\r\n      this.__eventListeners[eventName].push(handler);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Stops event observing for a particular event handler. Calling this method\r\n   * without arguments removes all handlers for all events\r\n   * @deprecated `stopObserving` deprecated since 0.8.34 (use `off` instead)\r\n   * @memberOf fabric.Observable\r\n   * @alias off\r\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\r\n   * @param {Function} handler Function to be deleted from EventListeners\r\n   * @return {Self} thisArg\r\n   * @chainable\r\n   */\r\n  function stopObserving(eventName, handler) {\r\n    if (!this.__eventListeners) {\r\n      return;\r\n    }\r\n\r\n    // remove all key/value pairs (event name -> event handler)\r\n    if (arguments.length === 0) {\r\n      this.__eventListeners = { };\r\n    }\r\n    // one object with key/value pairs was passed\r\n    else if (arguments.length === 1 && typeof arguments[0] === 'object') {\r\n      for (var prop in eventName) {\r\n        _removeEventListener.call(this, prop, eventName[prop]);\r\n      }\r\n    }\r\n    else {\r\n      _removeEventListener.call(this, eventName, handler);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Fires event with an optional options object\r\n   * @deprecated `fire` deprecated since 1.0.7 (use `trigger` instead)\r\n   * @memberOf fabric.Observable\r\n   * @alias trigger\r\n   * @param {String} eventName Event name to fire\r\n   * @param {Object} [options] Options object\r\n   * @return {Self} thisArg\r\n   * @chainable\r\n   */\r\n  function fire(eventName, options) {\r\n    if (!this.__eventListeners) {\r\n      return;\r\n    }\r\n\r\n    var listenersForEvent = this.__eventListeners[eventName];\r\n    if (!listenersForEvent) {\r\n      return;\r\n    }\r\n\r\n    for (var i = 0, len = listenersForEvent.length; i < len; i++) {\r\n      // avoiding try/catch for perf. reasons\r\n      listenersForEvent[i].call(this, options || { });\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @namespace fabric.Observable\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#events}\r\n   * @see {@link http://fabricjs.com/events/|Events demo}\r\n   */\r\n  fabric.Observable = {\r\n    observe: observe,\r\n    stopObserving: stopObserving,\r\n    fire: fire,\r\n\r\n    on: observe,\r\n    off: stopObserving,\r\n    trigger: fire\r\n  };\r\n})();\r\n\r\n\r\n/**\r\n * @namespace fabric.Collection\r\n */\r\nfabric.Collection = {\r\n\r\n  /**\r\n   * Adds objects to collection, then renders canvas (if `renderOnAddRemove` is not `false`)\r\n   * Objects should be instances of (or inherit from) fabric.Object\r\n   * @param {...fabric.Object} object Zero or more fabric instances\r\n   * @return {Self} thisArg\r\n   */\r\n  add: function () {\r\n    this._objects.push.apply(this._objects, arguments);\r\n    for (var i = 0, length = arguments.length; i < length; i++) {\r\n      this._onObjectAdded(arguments[i]);\r\n    }\r\n    this.renderOnAddRemove && this.renderAll();\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)\r\n   * An object should be an instance of (or inherit from) fabric.Object\r\n   * @param {Object} object Object to insert\r\n   * @param {Number} index Index to insert object at\r\n   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs\r\n   * @return {Self} thisArg\r\n   * @chainable\r\n   */\r\n  insertAt: function (object, index, nonSplicing) {\r\n    var objects = this.getObjects();\r\n    if (nonSplicing) {\r\n      objects[index] = object;\r\n    }\r\n    else {\r\n      objects.splice(index, 0, object);\r\n    }\r\n    this._onObjectAdded(object);\r\n    this.renderOnAddRemove && this.renderAll();\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)\r\n   * @param {...fabric.Object} object Zero or more fabric instances\r\n   * @return {Self} thisArg\r\n   * @chainable\r\n   */\r\n  remove: function() {\r\n    var objects = this.getObjects(),\r\n        index;\r\n\r\n    for (var i = 0, length = arguments.length; i < length; i++) {\r\n      index = objects.indexOf(arguments[i]);\r\n\r\n      // only call onObjectRemoved if an object was actually removed\r\n      if (index !== -1) {\r\n        objects.splice(index, 1);\r\n        this._onObjectRemoved(arguments[i]);\r\n      }\r\n    }\r\n\r\n    this.renderOnAddRemove && this.renderAll();\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Executes given function for each object in this group\r\n   * @param {Function} callback\r\n   *                   Callback invoked with current object as first argument,\r\n   *                   index - as second and an array of all objects - as third.\r\n   *                   Iteration happens in reverse order (for performance reasons).\r\n   *                   Callback is invoked in a context of Global Object (e.g. `window`)\r\n   *                   when no `context` argument is given\r\n   *\r\n   * @param {Object} context Context (aka thisObject)\r\n   * @return {Self} thisArg\r\n   */\r\n  forEachObject: function(callback, context) {\r\n    var objects = this.getObjects(),\r\n        i = objects.length;\r\n    while (i--) {\r\n      callback.call(context, objects[i], i, objects);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Returns an array of children objects of this instance\r\n   * Type parameter introduced in 1.3.10\r\n   * @param {String} [type] When specified, only objects of this type are returned\r\n   * @return {Array}\r\n   */\r\n  getObjects: function(type) {\r\n    if (typeof type === 'undefined') {\r\n      return this._objects;\r\n    }\r\n    return this._objects.filter(function(o) {\r\n      return o.type === type;\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Returns object at specified index\r\n   * @param {Number} index\r\n   * @return {Self} thisArg\r\n   */\r\n  item: function (index) {\r\n    return this.getObjects()[index];\r\n  },\r\n\r\n  /**\r\n   * Returns true if collection contains no objects\r\n   * @return {Boolean} true if collection is empty\r\n   */\r\n  isEmpty: function () {\r\n    return this.getObjects().length === 0;\r\n  },\r\n\r\n  /**\r\n   * Returns a size of a collection (i.e: length of an array containing its objects)\r\n   * @return {Number} Collection size\r\n   */\r\n  size: function() {\r\n    return this.getObjects().length;\r\n  },\r\n\r\n  /**\r\n   * Returns true if collection contains an object\r\n   * @param {Object} object Object to check against\r\n   * @return {Boolean} `true` if collection contains an object\r\n   */\r\n  contains: function(object) {\r\n    return this.getObjects().indexOf(object) > -1;\r\n  },\r\n\r\n  /**\r\n   * Returns number representation of a collection complexity\r\n   * @return {Number} complexity\r\n   */\r\n  complexity: function () {\r\n    return this.getObjects().reduce(function (memo, current) {\r\n      memo += current.complexity ? current.complexity() : 0;\r\n      return memo;\r\n    }, 0);\r\n  }\r\n};\r\n\r\n\r\n(function(global) {\r\n\r\n  var sqrt = Math.sqrt,\r\n      atan2 = Math.atan2,\r\n      PiBy180 = Math.PI / 180;\r\n\r\n  /**\r\n   * @namespace fabric.util\r\n   */\r\n  fabric.util = {\r\n\r\n    /**\r\n     * Removes value from an array.\r\n     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Array} array\r\n     * @param {Any} value\r\n     * @return {Array} original array\r\n     */\r\n    removeFromArray: function(array, value) {\r\n      var idx = array.indexOf(value);\r\n      if (idx !== -1) {\r\n        array.splice(idx, 1);\r\n      }\r\n      return array;\r\n    },\r\n\r\n    /**\r\n     * Returns random number between 2 specified ones.\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Number} min lower limit\r\n     * @param {Number} max upper limit\r\n     * @return {Number} random value (between min and max)\r\n     */\r\n    getRandomInt: function(min, max) {\r\n      return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    },\r\n\r\n    /**\r\n     * Transforms degrees to radians.\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Number} degrees value in degrees\r\n     * @return {Number} value in radians\r\n     */\r\n    degreesToRadians: function(degrees) {\r\n      return degrees * PiBy180;\r\n    },\r\n\r\n    /**\r\n     * Transforms radians to degrees.\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Number} radians value in radians\r\n     * @return {Number} value in degrees\r\n     */\r\n    radiansToDegrees: function(radians) {\r\n      return radians / PiBy180;\r\n    },\r\n\r\n    /**\r\n     * Rotates `point` around `origin` with `radians`\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {fabric.Point} point The point to rotate\r\n     * @param {fabric.Point} origin The origin of the rotation\r\n     * @param {Number} radians The radians of the angle for the rotation\r\n     * @return {fabric.Point} The new rotated point\r\n     */\r\n    rotatePoint: function(point, origin, radians) {\r\n      point.subtractEquals(origin);\r\n      var sin = Math.sin(radians),\r\n          cos = Math.cos(radians),\r\n          rx = point.x * cos - point.y * sin,\r\n          ry = point.x * sin + point.y * cos;\r\n      return new fabric.Point(rx, ry).addEquals(origin);\r\n    },\r\n\r\n    /**\r\n     * Apply transform t to point p\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param  {fabric.Point} p The point to transform\r\n     * @param  {Array} t The transform\r\n     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied\r\n     * @return {fabric.Point} The transformed point\r\n     */\r\n    transformPoint: function(p, t, ignoreOffset) {\r\n      if (ignoreOffset) {\r\n        return new fabric.Point(\r\n          t[0] * p.x + t[2] * p.y,\r\n          t[1] * p.x + t[3] * p.y\r\n        );\r\n      }\r\n      return new fabric.Point(\r\n        t[0] * p.x + t[2] * p.y + t[4],\r\n        t[1] * p.x + t[3] * p.y + t[5]\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Invert transformation t\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Array} t The transform\r\n     * @return {Array} The inverted transform\r\n     */\r\n    invertTransform: function(t) {\r\n      var a = 1 / (t[0] * t[3] - t[1] * t[2]),\r\n          r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],\r\n          o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);\r\n      r[4] = -o.x;\r\n      r[5] = -o.y;\r\n      return r;\r\n    },\r\n\r\n    /**\r\n     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Number|String} number number to operate on\r\n     * @param {Number} fractionDigits number of fraction digits to \"leave\"\r\n     * @return {Number}\r\n     */\r\n    toFixed: function(number, fractionDigits) {\r\n      return parseFloat(Number(number).toFixed(fractionDigits));\r\n    },\r\n\r\n    /**\r\n     * Converts from attribute value to pixel value if applicable.\r\n     * Returns converted pixels or original value not converted.\r\n     * @param {Number|String} value number to operate on\r\n     * @return {Number|String}\r\n     */\r\n    parseUnit: function(value, fontSize) {\r\n      var unit = /\\D{0,2}$/.exec(value),\r\n          number = parseFloat(value);\r\n      if (!fontSize) {\r\n        fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\r\n      }\r\n      switch (unit[0]) {\r\n        case 'mm':\r\n          return number * fabric.DPI / 25.4;\r\n\r\n        case 'cm':\r\n          return number * fabric.DPI / 2.54;\r\n\r\n        case 'in':\r\n          return number * fabric.DPI;\r\n\r\n        case 'pt':\r\n          return number * fabric.DPI / 72; // or * 4 / 3\r\n\r\n        case 'pc':\r\n          return number * fabric.DPI / 72 * 12; // or * 16\r\n\r\n        case 'em':\r\n          return number * fontSize;\r\n\r\n        default:\r\n          return number;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Function which always returns `false`.\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @return {Boolean}\r\n     */\r\n    falseFunction: function() {\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Returns klass \"Class\" object of given namespace\r\n     * @memberOf fabric.util\r\n     * @param {String} type Type of object (eg. 'circle')\r\n     * @param {String} namespace Namespace to get klass \"Class\" object from\r\n     * @return {Object} klass \"Class\"\r\n     */\r\n    getKlass: function(type, namespace) {\r\n      // capitalize first letter only\r\n      type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));\r\n      return fabric.util.resolveNamespace(namespace)[type];\r\n    },\r\n\r\n    /**\r\n     * Returns object of given namespace\r\n     * @memberOf fabric.util\r\n     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'\r\n     * @return {Object} Object for given namespace (default fabric)\r\n     */\r\n    resolveNamespace: function(namespace) {\r\n      if (!namespace) {\r\n        return fabric;\r\n      }\r\n\r\n      var parts = namespace.split('.'),\r\n          len = parts.length,\r\n          obj = global || fabric.window;\r\n\r\n      for (var i = 0; i < len; ++i) {\r\n        obj = obj[parts[i]];\r\n      }\r\n\r\n      return obj;\r\n    },\r\n\r\n    /**\r\n     * Loads image element from given url and passes it to a callback\r\n     * @memberOf fabric.util\r\n     * @param {String} url URL representing an image\r\n     * @param {Function} callback Callback; invoked with loaded image\r\n     * @param {Any} [context] Context to invoke callback in\r\n     * @param {Object} [crossOrigin] crossOrigin value to set image element to\r\n     */\r\n    loadImage: function(url, callback, context, crossOrigin) {\r\n      if (!url) {\r\n        callback && callback.call(context, url);\r\n        return;\r\n      }\r\n\r\n      var img = fabric.util.createImage();\r\n\r\n      /** @ignore */\r\n      img.onload = function () {\r\n        callback && callback.call(context, img);\r\n        img = img.onload = img.onerror = null;\r\n      };\r\n\r\n      /** @ignore */\r\n      img.onerror = function() {\r\n        fabric.log('Error loading ' + img.src);\r\n        callback && callback.call(context, null, true);\r\n        img = img.onload = img.onerror = null;\r\n      };\r\n\r\n      // data-urls appear to be buggy with crossOrigin\r\n      // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767\r\n      // see https://code.google.com/p/chromium/issues/detail?id=315152\r\n      //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069\r\n      if (url.indexOf('data') !== 0 && typeof crossOrigin !== 'undefined') {\r\n        img.crossOrigin = crossOrigin;\r\n      }\r\n\r\n      img.src = url;\r\n    },\r\n\r\n    /**\r\n     * Creates corresponding fabric instances from their object representations\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Array} objects Objects to enliven\r\n     * @param {Function} callback Callback to invoke when all objects are created\r\n     * @param {String} namespace Namespace to get klass \"Class\" object from\r\n     * @param {Function} reviver Method for further parsing of object elements,\r\n     * called after each fabric object created.\r\n     */\r\n    enlivenObjects: function(objects, callback, namespace, reviver) {\r\n      objects = objects || [ ];\r\n\r\n      function onLoaded() {\r\n        if (++numLoadedObjects === numTotalObjects) {\r\n          callback && callback(enlivenedObjects);\r\n        }\r\n      }\r\n\r\n      var enlivenedObjects = [ ],\r\n          numLoadedObjects = 0,\r\n          numTotalObjects = objects.length;\r\n\r\n      if (!numTotalObjects) {\r\n        callback && callback(enlivenedObjects);\r\n        return;\r\n      }\r\n\r\n      objects.forEach(function (o, index) {\r\n        // if sparse array\r\n        if (!o || !o.type) {\r\n          onLoaded();\r\n          return;\r\n        }\r\n        var klass = fabric.util.getKlass(o.type, namespace);\r\n        if (klass.async) {\r\n          klass.fromObject(o, function (obj, error) {\r\n            if (!error) {\r\n              enlivenedObjects[index] = obj;\r\n              reviver && reviver(o, enlivenedObjects[index]);\r\n            }\r\n            onLoaded();\r\n          });\r\n        }\r\n        else {\r\n          enlivenedObjects[index] = klass.fromObject(o);\r\n          reviver && reviver(o, enlivenedObjects[index]);\r\n          onLoaded();\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Groups SVG elements (usually those retrieved from SVG document)\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Array} elements SVG elements to group\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Object|fabric.PathGroup}\r\n     */\r\n    groupSVGElements: function(elements, options, path) {\r\n      var object;\r\n\r\n      object = new fabric.PathGroup(elements, options);\r\n\r\n      if (typeof path !== 'undefined') {\r\n        object.setSourcePath(path);\r\n      }\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Populates an object with properties of another object\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Object} source Source object\r\n     * @param {Object} destination Destination object\r\n     * @return {Array} properties Propertie names to include\r\n     */\r\n    populateWithProperties: function(source, destination, properties) {\r\n      if (properties && Object.prototype.toString.call(properties) === '[object Array]') {\r\n        for (var i = 0, len = properties.length; i < len; i++) {\r\n          if (properties[i] in source) {\r\n            destination[properties[i]] = source[properties[i]];\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Draws a dashed line between two points\r\n     *\r\n     * This method is used to draw dashed line around selection area.\r\n     * See <a href=\"http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas\">dotted stroke in canvas</a>\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx context\r\n     * @param {Number} x  start x coordinate\r\n     * @param {Number} y start y coordinate\r\n     * @param {Number} x2 end x coordinate\r\n     * @param {Number} y2 end y coordinate\r\n     * @param {Array} da dash array pattern\r\n     */\r\n    drawDashedLine: function(ctx, x, y, x2, y2, da) {\r\n      var dx = x2 - x,\r\n          dy = y2 - y,\r\n          len = sqrt(dx * dx + dy * dy),\r\n          rot = atan2(dy, dx),\r\n          dc = da.length,\r\n          di = 0,\r\n          draw = true;\r\n\r\n      ctx.save();\r\n      ctx.translate(x, y);\r\n      ctx.moveTo(0, 0);\r\n      ctx.rotate(rot);\r\n\r\n      x = 0;\r\n      while (len > x) {\r\n        x += da[di++ % dc];\r\n        if (x > len) {\r\n          x = len;\r\n        }\r\n        ctx[draw ? 'lineTo' : 'moveTo'](x, 0);\r\n        draw = !draw;\r\n      }\r\n\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Creates canvas element and initializes it via excanvas if necessary\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {CanvasElement} [canvasEl] optional canvas element to initialize;\r\n     * when not given, element is created implicitly\r\n     * @return {CanvasElement} initialized canvas element\r\n     */\r\n    createCanvasElement: function(canvasEl) {\r\n      canvasEl || (canvasEl = fabric.document.createElement('canvas'));\r\n      //jscs:disable requireCamelCaseOrUpperCaseIdentifiers\r\n      if (!canvasEl.getContext && typeof G_vmlCanvasManager !== 'undefined') {\r\n        G_vmlCanvasManager.initElement(canvasEl);\r\n      }\r\n      //jscs:enable requireCamelCaseOrUpperCaseIdentifiers\r\n      return canvasEl;\r\n    },\r\n\r\n    /**\r\n     * Creates image element (works on client and node)\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @return {HTMLImageElement} HTML image element\r\n     */\r\n    createImage: function() {\r\n      return fabric.isLikelyNode\r\n        ? new (require('canvas').Image)()\r\n        : fabric.document.createElement('img');\r\n    },\r\n\r\n    /**\r\n     * Creates accessors (getXXX, setXXX) for a \"class\", based on \"stateProperties\" array\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Object} klass \"Class\" to create accessors for\r\n     */\r\n    createAccessors: function(klass) {\r\n      var proto = klass.prototype;\r\n\r\n      for (var i = proto.stateProperties.length; i--; ) {\r\n\r\n        var propName = proto.stateProperties[i],\r\n            capitalizedPropName = propName.charAt(0).toUpperCase() + propName.slice(1),\r\n            setterName = 'set' + capitalizedPropName,\r\n            getterName = 'get' + capitalizedPropName;\r\n\r\n        // using `new Function` for better introspection\r\n        if (!proto[getterName]) {\r\n          proto[getterName] = (function(property) {\r\n            return new Function('return this.get(\"' + property + '\")');\r\n          })(propName);\r\n        }\r\n        if (!proto[setterName]) {\r\n          proto[setterName] = (function(property) {\r\n            return new Function('value', 'return this.set(\"' + property + '\", value)');\r\n          })(propName);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {fabric.Object} receiver Object implementing `clipTo` method\r\n     * @param {CanvasRenderingContext2D} ctx Context to clip\r\n     */\r\n    clipContext: function(receiver, ctx) {\r\n      ctx.save();\r\n      ctx.beginPath();\r\n      receiver.clipTo(ctx);\r\n      ctx.clip();\r\n    },\r\n\r\n    /**\r\n     * Multiply matrix A by matrix B to nest transformations\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param  {Array} a First transformMatrix\r\n     * @param  {Array} b Second transformMatrix\r\n     * @return {Array} The product of the two transform matrices\r\n     */\r\n    multiplyTransformMatrices: function(a, b) {\r\n      // Matrix multiply a * b\r\n      return [\r\n        a[0] * b[0] + a[2] * b[1],\r\n        a[1] * b[0] + a[3] * b[1],\r\n        a[0] * b[2] + a[2] * b[3],\r\n        a[1] * b[2] + a[3] * b[3],\r\n        a[0] * b[4] + a[2] * b[5] + a[4],\r\n        a[1] * b[4] + a[3] * b[5] + a[5]\r\n      ];\r\n    },\r\n\r\n    /**\r\n     * Returns string representation of function body\r\n     * @param {Function} fn Function to get body of\r\n     * @return {String} Function body\r\n     */\r\n    getFunctionBody: function(fn) {\r\n      return (String(fn).match(/function[^{]*\\{([\\s\\S]*)\\}/) || {})[1];\r\n    },\r\n\r\n    /**\r\n     * Returns true if context has transparent pixel\r\n     * at specified location (taking tolerance into account)\r\n     * @param {CanvasRenderingContext2D} ctx context\r\n     * @param {Number} x x coordinate\r\n     * @param {Number} y y coordinate\r\n     * @param {Number} tolerance Tolerance\r\n     */\r\n    isTransparent: function(ctx, x, y, tolerance) {\r\n\r\n      // If tolerance is > 0 adjust start coords to take into account.\r\n      // If moves off Canvas fix to 0\r\n      if (tolerance > 0) {\r\n        if (x > tolerance) {\r\n          x -= tolerance;\r\n        }\r\n        else {\r\n          x = 0;\r\n        }\r\n        if (y > tolerance) {\r\n          y -= tolerance;\r\n        }\r\n        else {\r\n          y = 0;\r\n        }\r\n      }\r\n\r\n      var _isTransparent = true,\r\n          imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1);\r\n\r\n      // Split image data - for tolerance > 1, pixelDataSize = 4;\r\n      for (var i = 3, l = imageData.data.length; i < l; i += 4) {\r\n        var temp = imageData.data[i];\r\n        _isTransparent = temp <= 0;\r\n        if (_isTransparent === false) {\r\n          break; // Stop if colour found\r\n        }\r\n      }\r\n\r\n      imageData = null;\r\n\r\n      return _isTransparent;\r\n    },\r\n\r\n    /**\r\n     * Parse preserveAspectRatio attribute from element\r\n     * @param {string} attribute to be parsed\r\n     * @return {Object} an object containing align and meetOrSlice attribute\r\n     */\r\n    parsePreserveAspectRatioAttribute: function(attribute) {\r\n      var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',\r\n          aspectRatioAttrs = attribute.split(' '), align;\r\n\r\n      if (aspectRatioAttrs && aspectRatioAttrs.length) {\r\n        meetOrSlice = aspectRatioAttrs.pop();\r\n        if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {\r\n          align = meetOrSlice;\r\n          meetOrSlice = 'meet';\r\n        }\r\n        else if (aspectRatioAttrs.length) {\r\n          align = aspectRatioAttrs.pop();\r\n        }\r\n      }\r\n      //divide align in alignX and alignY\r\n      alignX = align !== 'none' ? align.slice(1, 4) : 'none';\r\n      alignY = align !== 'none' ? align.slice(5, 8) : 'none';\r\n      return {\r\n        meetOrSlice: meetOrSlice,\r\n        alignX: alignX,\r\n        alignY: alignY\r\n      };\r\n    }\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function() {\r\n\r\n  var arcToSegmentsCache = { },\r\n      segmentToBezierCache = { },\r\n      boundsOfCurveCache = { },\r\n      _join = Array.prototype.join;\r\n\r\n  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp\r\n   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here\r\n   * http://mozilla.org/MPL/2.0/\r\n   */\r\n  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {\r\n    var argsString = _join.call(arguments);\r\n    if (arcToSegmentsCache[argsString]) {\r\n      return arcToSegmentsCache[argsString];\r\n    }\r\n\r\n    var PI = Math.PI, th = rotateX * PI / 180,\r\n        sinTh = Math.sin(th),\r\n        cosTh = Math.cos(th),\r\n        fromX = 0, fromY = 0;\r\n\r\n    rx = Math.abs(rx);\r\n    ry = Math.abs(ry);\r\n\r\n    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,\r\n        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,\r\n        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,\r\n        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,\r\n        root = 0;\r\n\r\n    if (pl < 0) {\r\n      var s = Math.sqrt(1 - pl/(rx2 * ry2));\r\n      rx *= s;\r\n      ry *= s;\r\n    }\r\n    else {\r\n      root = (large === sweep ? -1.0 : 1.0) *\r\n              Math.sqrt( pl /(rx2 * py2 + ry2 * px2));\r\n    }\r\n\r\n    var cx = root * rx * py / ry,\r\n        cy = -root * ry * px / rx,\r\n        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,\r\n        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,\r\n        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),\r\n        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);\r\n\r\n    if (sweep === 0 && dtheta > 0) {\r\n      dtheta -= 2 * PI;\r\n    }\r\n    else if (sweep === 1 && dtheta < 0) {\r\n      dtheta += 2 * PI;\r\n    }\r\n\r\n    // Convert into cubic bezier segments <= 90deg\r\n    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),\r\n        result = [], mDelta = dtheta / segments,\r\n        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),\r\n        th3 = mTheta + mDelta;\r\n\r\n    for (var i = 0; i < segments; i++) {\r\n      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);\r\n      fromX = result[i][4];\r\n      fromY = result[i][5];\r\n      mTheta = th3;\r\n      th3 += mDelta;\r\n    }\r\n    arcToSegmentsCache[argsString] = result;\r\n    return result;\r\n  }\r\n\r\n  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {\r\n    var argsString2 = _join.call(arguments);\r\n    if (segmentToBezierCache[argsString2]) {\r\n      return segmentToBezierCache[argsString2];\r\n    }\r\n\r\n    var costh2 = Math.cos(th2),\r\n        sinth2 = Math.sin(th2),\r\n        costh3 = Math.cos(th3),\r\n        sinth3 = Math.sin(th3),\r\n        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,\r\n        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,\r\n        cp1X = fromX + mT * ( - cosTh * rx * sinth2 - sinTh * ry * costh2),\r\n        cp1Y = fromY + mT * ( - sinTh * rx * sinth2 + cosTh * ry * costh2),\r\n        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),\r\n        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);\r\n\r\n    segmentToBezierCache[argsString2] = [\r\n      cp1X, cp1Y,\r\n      cp2X, cp2Y,\r\n      toX, toY\r\n    ];\r\n    return segmentToBezierCache[argsString2];\r\n  }\r\n\r\n  /*\r\n   * Private\r\n   */\r\n  function calcVectorAngle(ux, uy, vx, vy) {\r\n    var ta = Math.atan2(uy, ux),\r\n        tb = Math.atan2(vy, vx);\r\n    if (tb >= ta) {\r\n      return tb - ta;\r\n    }\r\n    else {\r\n      return 2 * Math.PI - (ta - tb);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draws arc\r\n   * @param {CanvasRenderingContext2D} ctx\r\n   * @param {Number} fx\r\n   * @param {Number} fy\r\n   * @param {Array} coords\r\n   */\r\n  fabric.util.drawArc = function(ctx, fx, fy, coords) {\r\n    var rx = coords[0],\r\n        ry = coords[1],\r\n        rot = coords[2],\r\n        large = coords[3],\r\n        sweep = coords[4],\r\n        tx = coords[5],\r\n        ty = coords[6],\r\n        segs = [[ ], [ ], [ ], [ ]],\r\n        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);\r\n\r\n    for (var i = 0, len = segsNorm.length; i < len; i++) {\r\n      segs[i][0] = segsNorm[i][0] + fx;\r\n      segs[i][1] = segsNorm[i][1] + fy;\r\n      segs[i][2] = segsNorm[i][2] + fx;\r\n      segs[i][3] = segsNorm[i][3] + fy;\r\n      segs[i][4] = segsNorm[i][4] + fx;\r\n      segs[i][5] = segsNorm[i][5] + fy;\r\n      ctx.bezierCurveTo.apply(ctx, segs[i]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Calculate bounding box of a elliptic-arc\r\n   * @param {Number} fx start point of arc\r\n   * @param {Number} fy\r\n   * @param {Number} rx horizontal radius\r\n   * @param {Number} ry vertical radius\r\n   * @param {Number} rot angle of horizontal axe\r\n   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points\r\n   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction\r\n   * @param {Number} tx end point of arc\r\n   * @param {Number} ty\r\n   */\r\n  fabric.util.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {\r\n\r\n    var fromX = 0, fromY = 0, bound = [ ], bounds = [ ],\r\n    segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot),\r\n    boundCopy = [[ ], [ ]];\r\n\r\n    for (var i = 0, len = segs.length; i < len; i++) {\r\n      bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);\r\n      boundCopy[0].x = bound[0].x + fx;\r\n      boundCopy[0].y = bound[0].y + fy;\r\n      boundCopy[1].x = bound[1].x + fx;\r\n      boundCopy[1].y = bound[1].y + fy;\r\n      bounds.push(boundCopy[0]);\r\n      bounds.push(boundCopy[1]);\r\n      fromX = segs[i][4];\r\n      fromY = segs[i][5];\r\n    }\r\n    return bounds;\r\n  };\r\n\r\n  /**\r\n   * Calculate bounding box of a beziercurve\r\n   * @param {Number} x0 starting point\r\n   * @param {Number} y0\r\n   * @param {Number} x1 first control point\r\n   * @param {Number} y1\r\n   * @param {Number} x2 secondo control point\r\n   * @param {Number} y2\r\n   * @param {Number} x3 end of beizer\r\n   * @param {Number} y3\r\n   */\r\n  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.\r\n  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {\r\n    var argsString = _join.call(arguments);\r\n    if (boundsOfCurveCache[argsString]) {\r\n      return boundsOfCurveCache[argsString];\r\n    }\r\n\r\n    var sqrt = Math.sqrt,\r\n        min = Math.min, max = Math.max,\r\n        abs = Math.abs, tvalues = [ ],\r\n        bounds = [[ ], [ ]],\r\n        a, b, c, t, t1, t2, b2ac, sqrtb2ac;\r\n\r\n    b = 6 * x0 - 12 * x1 + 6 * x2;\r\n    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\r\n    c = 3 * x1 - 3 * x0;\r\n\r\n    for (var i = 0; i < 2; ++i) {\r\n      if (i > 0) {\r\n        b = 6 * y0 - 12 * y1 + 6 * y2;\r\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\r\n        c = 3 * y1 - 3 * y0;\r\n      }\r\n\r\n      if (abs(a) < 1e-12) {\r\n        if (abs(b) < 1e-12) {\r\n          continue;\r\n        }\r\n        t = -c / b;\r\n        if (0 < t && t < 1) {\r\n          tvalues.push(t);\r\n        }\r\n        continue;\r\n      }\r\n      b2ac = b * b - 4 * c * a;\r\n      if (b2ac < 0) {\r\n        continue;\r\n      }\r\n      sqrtb2ac = sqrt(b2ac);\r\n      t1 = (-b + sqrtb2ac) / (2 * a);\r\n      if (0 < t1 && t1 < 1) {\r\n        tvalues.push(t1);\r\n      }\r\n      t2 = (-b - sqrtb2ac) / (2 * a);\r\n      if (0 < t2 && t2 < 1) {\r\n        tvalues.push(t2);\r\n      }\r\n    }\r\n\r\n    var x, y, j = tvalues.length, jlen = j, mt;\r\n    while (j--) {\r\n      t = tvalues[j];\r\n      mt = 1 - t;\r\n      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\r\n      bounds[0][j] = x;\r\n\r\n      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\r\n      bounds[1][j] = y;\r\n    }\r\n\r\n    bounds[0][jlen] = x0;\r\n    bounds[1][jlen] = y0;\r\n    bounds[0][jlen + 1] = x3;\r\n    bounds[1][jlen + 1] = y3;\r\n    var result = [\r\n      {\r\n        x: min.apply(null, bounds[0]),\r\n        y: min.apply(null, bounds[1])\r\n      },\r\n      {\r\n        x: max.apply(null, bounds[0]),\r\n        y: max.apply(null, bounds[1])\r\n      }\r\n    ];\r\n    boundsOfCurveCache[argsString] = result;\r\n    return result;\r\n  }\r\n\r\n  fabric.util.getBoundsOfCurve = getBoundsOfCurve;\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  var slice = Array.prototype.slice;\r\n\r\n  /* _ES5_COMPAT_START_ */\r\n\r\n  if (!Array.prototype.indexOf) {\r\n    /**\r\n     * Finds index of an element in an array\r\n     * @param {Any} searchElement\r\n     * @param {Number} [fromIndex]\r\n     * @return {Number}\r\n     */\r\n    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\r\n      if (this === void 0 || this === null) {\r\n        throw new TypeError();\r\n      }\r\n      var t = Object(this), len = t.length >>> 0;\r\n      if (len === 0) {\r\n        return -1;\r\n      }\r\n      var n = 0;\r\n      if (arguments.length > 0) {\r\n        n = Number(arguments[1]);\r\n        if (n !== n) { // shortcut for verifying if it's NaN\r\n          n = 0;\r\n        }\r\n        else if (n !== 0 && n !== Number.POSITIVE_INFINITY && n !== Number.NEGATIVE_INFINITY) {\r\n          n = (n > 0 || -1) * Math.floor(Math.abs(n));\r\n        }\r\n      }\r\n      if (n >= len) {\r\n        return -1;\r\n      }\r\n      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\r\n      for (; k < len; k++) {\r\n        if (k in t && t[k] === searchElement) {\r\n          return k;\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n  }\r\n\r\n  if (!Array.prototype.forEach) {\r\n    /**\r\n     * Iterates an array, invoking callback for each element\r\n     * @param {Function} fn Callback to invoke for each element\r\n     * @param {Object} [context] Context to invoke callback in\r\n     * @return {Array}\r\n     */\r\n    Array.prototype.forEach = function(fn, context) {\r\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\r\n        if (i in this) {\r\n          fn.call(context, this[i], i, this);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  if (!Array.prototype.map) {\r\n    /**\r\n     * Returns a result of iterating over an array, invoking callback for each element\r\n     * @param {Function} fn Callback to invoke for each element\r\n     * @param {Object} [context] Context to invoke callback in\r\n     * @return {Array}\r\n     */\r\n    Array.prototype.map = function(fn, context) {\r\n      var result = [ ];\r\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\r\n        if (i in this) {\r\n          result[i] = fn.call(context, this[i], i, this);\r\n        }\r\n      }\r\n      return result;\r\n    };\r\n  }\r\n\r\n  if (!Array.prototype.every) {\r\n    /**\r\n     * Returns true if a callback returns truthy value for all elements in an array\r\n     * @param {Function} fn Callback to invoke for each element\r\n     * @param {Object} [context] Context to invoke callback in\r\n     * @return {Boolean}\r\n     */\r\n    Array.prototype.every = function(fn, context) {\r\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\r\n        if (i in this && !fn.call(context, this[i], i, this)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n  }\r\n\r\n  if (!Array.prototype.some) {\r\n    /**\r\n     * Returns true if a callback returns truthy value for at least one element in an array\r\n     * @param {Function} fn Callback to invoke for each element\r\n     * @param {Object} [context] Context to invoke callback in\r\n     * @return {Boolean}\r\n     */\r\n    Array.prototype.some = function(fn, context) {\r\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\r\n        if (i in this && fn.call(context, this[i], i, this)) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n  }\r\n\r\n  if (!Array.prototype.filter) {\r\n    /**\r\n     * Returns the result of iterating over elements in an array\r\n     * @param {Function} fn Callback to invoke for each element\r\n     * @param {Object} [context] Context to invoke callback in\r\n     * @return {Array}\r\n     */\r\n    Array.prototype.filter = function(fn, context) {\r\n      var result = [ ], val;\r\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\r\n        if (i in this) {\r\n          val = this[i]; // in case fn mutates this\r\n          if (fn.call(context, val, i, this)) {\r\n            result.push(val);\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    };\r\n  }\r\n\r\n  if (!Array.prototype.reduce) {\r\n    /**\r\n     * Returns \"folded\" (reduced) result of iterating over elements in an array\r\n     * @param {Function} fn Callback to invoke for each element\r\n     * @param {Object} [initial] Object to use as the first argument to the first call of the callback\r\n     * @return {Any}\r\n     */\r\n    Array.prototype.reduce = function(fn /*, initial*/) {\r\n      var len = this.length >>> 0,\r\n          i = 0,\r\n          rv;\r\n\r\n      if (arguments.length > 1) {\r\n        rv = arguments[1];\r\n      }\r\n      else {\r\n        do {\r\n          if (i in this) {\r\n            rv = this[i++];\r\n            break;\r\n          }\r\n          // if array contains no values, no initial value to return\r\n          if (++i >= len) {\r\n            throw new TypeError();\r\n          }\r\n        }\r\n        while (true);\r\n      }\r\n      for (; i < len; i++) {\r\n        if (i in this) {\r\n          rv = fn.call(null, rv, this[i], i, this);\r\n        }\r\n      }\r\n      return rv;\r\n    };\r\n  }\r\n\r\n  /* _ES5_COMPAT_END_ */\r\n\r\n  /**\r\n   * Invokes method on all items in a given array\r\n   * @memberOf fabric.util.array\r\n   * @param {Array} array Array to iterate over\r\n   * @param {String} method Name of a method to invoke\r\n   * @return {Array}\r\n   */\r\n  function invoke(array, method) {\r\n    var args = slice.call(arguments, 2), result = [ ];\r\n    for (var i = 0, len = array.length; i < len; i++) {\r\n      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Finds maximum value in array (not necessarily \"first\" one)\r\n   * @memberOf fabric.util.array\r\n   * @param {Array} array Array to iterate over\r\n   * @param {String} byProperty\r\n   * @return {Any}\r\n   */\r\n  function max(array, byProperty) {\r\n    return find(array, byProperty, function(value1, value2) {\r\n      return value1 >= value2;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Finds minimum value in array (not necessarily \"first\" one)\r\n   * @memberOf fabric.util.array\r\n   * @param {Array} array Array to iterate over\r\n   * @param {String} byProperty\r\n   * @return {Any}\r\n   */\r\n  function min(array, byProperty) {\r\n    return find(array, byProperty, function(value1, value2) {\r\n      return value1 < value2;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function find(array, byProperty, condition) {\r\n    if (!array || array.length === 0) {\r\n      return;\r\n    }\r\n\r\n    var i = array.length - 1,\r\n        result = byProperty ? array[i][byProperty] : array[i];\r\n    if (byProperty) {\r\n      while (i--) {\r\n        if (condition(array[i][byProperty], result)) {\r\n          result = array[i][byProperty];\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      while (i--) {\r\n        if (condition(array[i], result)) {\r\n          result = array[i];\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * @namespace fabric.util.array\r\n   */\r\n  fabric.util.array = {\r\n    invoke: invoke,\r\n    min: min,\r\n    max: max\r\n  };\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  /**\r\n   * Copies all enumerable properties of one object to another\r\n   * @memberOf fabric.util.object\r\n   * @param {Object} destination Where to copy to\r\n   * @param {Object} source Where to copy from\r\n   * @return {Object}\r\n   */\r\n  function extend(destination, source) {\r\n    // JScript DontEnum bug is not taken care of\r\n    for (var property in source) {\r\n      destination[property] = source[property];\r\n    }\r\n    return destination;\r\n  }\r\n\r\n  /**\r\n   * Creates an empty object and copies all enumerable properties of another object to it\r\n   * @memberOf fabric.util.object\r\n   * @param {Object} object Object to clone\r\n   * @return {Object}\r\n   */\r\n  function clone(object) {\r\n    return extend({ }, object);\r\n  }\r\n\r\n  /** @namespace fabric.util.object */\r\n  fabric.util.object = {\r\n    extend: extend,\r\n    clone: clone\r\n  };\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  /* _ES5_COMPAT_START_ */\r\n  if (!String.prototype.trim) {\r\n    /**\r\n     * Trims a string (removing whitespace from the beginning and the end)\r\n     * @function external:String#trim\r\n     * @see <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/Trim\">String#trim on MDN</a>\r\n     */\r\n    String.prototype.trim = function () {\r\n      // this trim is not fully ES3 or ES5 compliant, but it should cover most cases for now\r\n      return this.replace(/^[\\s\\xA0]+/, '').replace(/[\\s\\xA0]+$/, '');\r\n    };\r\n  }\r\n  /* _ES5_COMPAT_END_ */\r\n\r\n  /**\r\n   * Camelizes a string\r\n   * @memberOf fabric.util.string\r\n   * @param {String} string String to camelize\r\n   * @return {String} Camelized version of a string\r\n   */\r\n  function camelize(string) {\r\n    return string.replace(/-+(.)?/g, function(match, character) {\r\n      return character ? character.toUpperCase() : '';\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Capitalizes a string\r\n   * @memberOf fabric.util.string\r\n   * @param {String} string String to capitalize\r\n   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized\r\n   * and other letters stay untouched, if false first letter is capitalized\r\n   * and other letters are converted to lowercase.\r\n   * @return {String} Capitalized version of a string\r\n   */\r\n  function capitalize(string, firstLetterOnly) {\r\n    return string.charAt(0).toUpperCase() +\r\n      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());\r\n  }\r\n\r\n  /**\r\n   * Escapes XML in a string\r\n   * @memberOf fabric.util.string\r\n   * @param {String} string String to escape\r\n   * @return {String} Escaped version of a string\r\n   */\r\n  function escapeXml(string) {\r\n    return string.replace(/&/g, '&amp;')\r\n       .replace(/\"/g, '&quot;')\r\n       .replace(/'/g, '&apos;')\r\n       .replace(/</g, '&lt;')\r\n       .replace(/>/g, '&gt;');\r\n  }\r\n\r\n  /**\r\n   * String utilities\r\n   * @namespace fabric.util.string\r\n   */\r\n  fabric.util.string = {\r\n    camelize: camelize,\r\n    capitalize: capitalize,\r\n    escapeXml: escapeXml\r\n  };\r\n}());\r\n\r\n\r\n/* _ES5_COMPAT_START_ */\r\n(function() {\r\n\r\n  var slice = Array.prototype.slice,\r\n      apply = Function.prototype.apply,\r\n      Dummy = function() { };\r\n\r\n  if (!Function.prototype.bind) {\r\n    /**\r\n     * Cross-browser approximation of ES5 Function.prototype.bind (not fully spec conforming)\r\n     * @see <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\">Function#bind on MDN</a>\r\n     * @param {Object} thisArg Object to bind function to\r\n     * @param {Any[]} Values to pass to a bound function\r\n     * @return {Function}\r\n     */\r\n    Function.prototype.bind = function(thisArg) {\r\n      var _this = this, args = slice.call(arguments, 1), bound;\r\n      if (args.length) {\r\n        bound = function() {\r\n          return apply.call(_this, this instanceof Dummy ? this : thisArg, args.concat(slice.call(arguments)));\r\n        };\r\n      }\r\n      else {\r\n        /** @ignore */\r\n        bound = function() {\r\n          return apply.call(_this, this instanceof Dummy ? this : thisArg, arguments);\r\n        };\r\n      }\r\n      Dummy.prototype = this.prototype;\r\n      bound.prototype = new Dummy();\r\n\r\n      return bound;\r\n    };\r\n  }\r\n\r\n})();\r\n/* _ES5_COMPAT_END_ */\r\n\r\n\r\n(function() {\r\n\r\n  var slice = Array.prototype.slice, emptyFunction = function() { },\r\n\r\n      IS_DONTENUM_BUGGY = (function() {\r\n        for (var p in { toString: 1 }) {\r\n          if (p === 'toString') {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      })(),\r\n\r\n      /** @ignore */\r\n      addMethods = function(klass, source, parent) {\r\n        for (var property in source) {\r\n\r\n          if (property in klass.prototype &&\r\n              typeof klass.prototype[property] === 'function' &&\r\n              (source[property] + '').indexOf('callSuper') > -1) {\r\n\r\n            klass.prototype[property] = (function(property) {\r\n              return function() {\r\n\r\n                var superclass = this.constructor.superclass;\r\n                this.constructor.superclass = parent;\r\n                var returnValue = source[property].apply(this, arguments);\r\n                this.constructor.superclass = superclass;\r\n\r\n                if (property !== 'initialize') {\r\n                  return returnValue;\r\n                }\r\n              };\r\n            })(property);\r\n          }\r\n          else {\r\n            klass.prototype[property] = source[property];\r\n          }\r\n\r\n          if (IS_DONTENUM_BUGGY) {\r\n            if (source.toString !== Object.prototype.toString) {\r\n              klass.prototype.toString = source.toString;\r\n            }\r\n            if (source.valueOf !== Object.prototype.valueOf) {\r\n              klass.prototype.valueOf = source.valueOf;\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n  function Subclass() { }\r\n\r\n  function callSuper(methodName) {\r\n    var fn = this.constructor.superclass.prototype[methodName];\r\n    return (arguments.length > 1)\r\n      ? fn.apply(this, slice.call(arguments, 1))\r\n      : fn.call(this);\r\n  }\r\n\r\n  /**\r\n   * Helper for creation of \"classes\".\r\n   * @memberOf fabric.util\r\n   * @param {Function} [parent] optional \"Class\" to inherit from\r\n   * @param {Object} [properties] Properties shared by all instances of this class\r\n   *                  (be careful modifying objects defined here as this would affect all instances)\r\n   */\r\n  function createClass() {\r\n    var parent = null,\r\n        properties = slice.call(arguments, 0);\r\n\r\n    if (typeof properties[0] === 'function') {\r\n      parent = properties.shift();\r\n    }\r\n    function klass() {\r\n      this.initialize.apply(this, arguments);\r\n    }\r\n\r\n    klass.superclass = parent;\r\n    klass.subclasses = [ ];\r\n\r\n    if (parent) {\r\n      Subclass.prototype = parent.prototype;\r\n      klass.prototype = new Subclass();\r\n      parent.subclasses.push(klass);\r\n    }\r\n    for (var i = 0, length = properties.length; i < length; i++) {\r\n      addMethods(klass, properties[i], parent);\r\n    }\r\n    if (!klass.prototype.initialize) {\r\n      klass.prototype.initialize = emptyFunction;\r\n    }\r\n    klass.prototype.constructor = klass;\r\n    klass.prototype.callSuper = callSuper;\r\n    return klass;\r\n  }\r\n\r\n  fabric.util.createClass = createClass;\r\n})();\r\n\r\n\r\n(function () {\r\n\r\n  var unknown = 'unknown';\r\n\r\n  /* EVENT HANDLING */\r\n\r\n  function areHostMethods(object) {\r\n    var methodNames = Array.prototype.slice.call(arguments, 1),\r\n        t, i, len = methodNames.length;\r\n    for (i = 0; i < len; i++) {\r\n      t = typeof object[methodNames[i]];\r\n      if (!(/^(?:function|object|unknown)$/).test(t)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** @ignore */\r\n  var getElement,\r\n      setElement,\r\n      getUniqueId = (function () {\r\n        var uid = 0;\r\n        return function (element) {\r\n          return element.__uniqueID || (element.__uniqueID = 'uniqueID__' + uid++);\r\n        };\r\n      })();\r\n\r\n  (function () {\r\n    var elements = { };\r\n    /** @ignore */\r\n    getElement = function (uid) {\r\n      return elements[uid];\r\n    };\r\n    /** @ignore */\r\n    setElement = function (uid, element) {\r\n      elements[uid] = element;\r\n    };\r\n  })();\r\n\r\n  function createListener(uid, handler) {\r\n    return {\r\n      handler: handler,\r\n      wrappedHandler: createWrappedHandler(uid, handler)\r\n    };\r\n  }\r\n\r\n  function createWrappedHandler(uid, handler) {\r\n    return function (e) {\r\n      handler.call(getElement(uid), e || fabric.window.event);\r\n    };\r\n  }\r\n\r\n  function createDispatcher(uid, eventName) {\r\n    return function (e) {\r\n      if (handlers[uid] && handlers[uid][eventName]) {\r\n        var handlersForEvent = handlers[uid][eventName];\r\n        for (var i = 0, len = handlersForEvent.length; i < len; i++) {\r\n          handlersForEvent[i].call(this, e || fabric.window.event);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  var shouldUseAddListenerRemoveListener = (\r\n        areHostMethods(fabric.document.documentElement, 'addEventListener', 'removeEventListener') &&\r\n        areHostMethods(fabric.window, 'addEventListener', 'removeEventListener')),\r\n\r\n      shouldUseAttachEventDetachEvent = (\r\n        areHostMethods(fabric.document.documentElement, 'attachEvent', 'detachEvent') &&\r\n        areHostMethods(fabric.window, 'attachEvent', 'detachEvent')),\r\n\r\n      // IE branch\r\n      listeners = { },\r\n\r\n      // DOM L0 branch\r\n      handlers = { },\r\n\r\n      addListener, removeListener;\r\n\r\n  if (shouldUseAddListenerRemoveListener) {\r\n    /** @ignore */\r\n    addListener = function (element, eventName, handler) {\r\n      element.addEventListener(eventName, handler, false);\r\n    };\r\n    /** @ignore */\r\n    removeListener = function (element, eventName, handler) {\r\n      element.removeEventListener(eventName, handler, false);\r\n    };\r\n  }\r\n\r\n  else if (shouldUseAttachEventDetachEvent) {\r\n    /** @ignore */\r\n    addListener = function (element, eventName, handler) {\r\n      var uid = getUniqueId(element);\r\n      setElement(uid, element);\r\n      if (!listeners[uid]) {\r\n        listeners[uid] = { };\r\n      }\r\n      if (!listeners[uid][eventName]) {\r\n        listeners[uid][eventName] = [ ];\r\n\r\n      }\r\n      var listener = createListener(uid, handler);\r\n      listeners[uid][eventName].push(listener);\r\n      element.attachEvent('on' + eventName, listener.wrappedHandler);\r\n    };\r\n    /** @ignore */\r\n    removeListener = function (element, eventName, handler) {\r\n      var uid = getUniqueId(element), listener;\r\n      if (listeners[uid] && listeners[uid][eventName]) {\r\n        for (var i = 0, len = listeners[uid][eventName].length; i < len; i++) {\r\n          listener = listeners[uid][eventName][i];\r\n          if (listener && listener.handler === handler) {\r\n            element.detachEvent('on' + eventName, listener.wrappedHandler);\r\n            listeners[uid][eventName][i] = null;\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n  else {\r\n    /** @ignore */\r\n    addListener = function (element, eventName, handler) {\r\n      var uid = getUniqueId(element);\r\n      if (!handlers[uid]) {\r\n        handlers[uid] = { };\r\n      }\r\n      if (!handlers[uid][eventName]) {\r\n        handlers[uid][eventName] = [ ];\r\n        var existingHandler = element['on' + eventName];\r\n        if (existingHandler) {\r\n          handlers[uid][eventName].push(existingHandler);\r\n        }\r\n        element['on' + eventName] = createDispatcher(uid, eventName);\r\n      }\r\n      handlers[uid][eventName].push(handler);\r\n    };\r\n    /** @ignore */\r\n    removeListener = function (element, eventName, handler) {\r\n      var uid = getUniqueId(element);\r\n      if (handlers[uid] && handlers[uid][eventName]) {\r\n        var handlersForEvent = handlers[uid][eventName];\r\n        for (var i = 0, len = handlersForEvent.length; i < len; i++) {\r\n          if (handlersForEvent[i] === handler) {\r\n            handlersForEvent.splice(i, 1);\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Adds an event listener to an element\r\n   * @function\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element\r\n   * @param {String} eventName\r\n   * @param {Function} handler\r\n   */\r\n  fabric.util.addListener = addListener;\r\n\r\n  /**\r\n   * Removes an event listener from an element\r\n   * @function\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element\r\n   * @param {String} eventName\r\n   * @param {Function} handler\r\n   */\r\n  fabric.util.removeListener = removeListener;\r\n\r\n  /**\r\n   * Cross-browser wrapper for getting event's coordinates\r\n   * @memberOf fabric.util\r\n   * @param {Event} event Event object\r\n   */\r\n  function getPointer(event) {\r\n    event || (event = fabric.window.event);\r\n\r\n    var element = event.target ||\r\n                  (typeof event.srcElement !== unknown ? event.srcElement : null),\r\n\r\n        scroll = fabric.util.getScrollLeftTop(element);\r\n\r\n    return {\r\n      x: pointerX(event) + scroll.left,\r\n      y: pointerY(event) + scroll.top\r\n    };\r\n  }\r\n\r\n  var pointerX = function(event) {\r\n    // looks like in IE (<9) clientX at certain point (apparently when mouseup fires on VML element)\r\n    // is represented as COM object, with all the consequences, like \"unknown\" type and error on [[Get]]\r\n    // need to investigate later\r\n    return (typeof event.clientX !== unknown ? event.clientX : 0);\r\n  },\r\n\r\n  pointerY = function(event) {\r\n    return (typeof event.clientY !== unknown ? event.clientY : 0);\r\n  };\r\n\r\n  function _getPointer(event, pageProp, clientProp) {\r\n    var touchProp = event.type === 'touchend' ? 'changedTouches' : 'touches';\r\n\r\n    return (event[touchProp] && event[touchProp][0]\r\n      ? (event[touchProp][0][pageProp] - (event[touchProp][0][pageProp] - event[touchProp][0][clientProp]))\r\n        || event[clientProp]\r\n      : event[clientProp]);\r\n  }\r\n\r\n  if (fabric.isTouchSupported) {\r\n    pointerX = function(event) {\r\n      return _getPointer(event, 'pageX', 'clientX');\r\n    };\r\n    pointerY = function(event) {\r\n      return _getPointer(event, 'pageY', 'clientY');\r\n    };\r\n  }\r\n\r\n  fabric.util.getPointer = getPointer;\r\n\r\n  fabric.util.object.extend(fabric.util, fabric.Observable);\r\n\r\n})();\r\n\r\n\r\n(function () {\r\n\r\n  /**\r\n   * Cross-browser wrapper for setting element's style\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element\r\n   * @param {Object} styles\r\n   * @return {HTMLElement} Element that was passed as a first argument\r\n   */\r\n  function setStyle(element, styles) {\r\n    var elementStyle = element.style;\r\n    if (!elementStyle) {\r\n      return element;\r\n    }\r\n    if (typeof styles === 'string') {\r\n      element.style.cssText += ';' + styles;\r\n      return styles.indexOf('opacity') > -1\r\n        ? setOpacity(element, styles.match(/opacity:\\s*(\\d?\\.?\\d*)/)[1])\r\n        : element;\r\n    }\r\n    for (var property in styles) {\r\n      if (property === 'opacity') {\r\n        setOpacity(element, styles[property]);\r\n      }\r\n      else {\r\n        var normalizedProperty = (property === 'float' || property === 'cssFloat')\r\n          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')\r\n          : property;\r\n        elementStyle[normalizedProperty] = styles[property];\r\n      }\r\n    }\r\n    return element;\r\n  }\r\n\r\n  var parseEl = fabric.document.createElement('div'),\r\n      supportsOpacity = typeof parseEl.style.opacity === 'string',\r\n      supportsFilters = typeof parseEl.style.filter === 'string',\r\n      reOpacity = /alpha\\s*\\(\\s*opacity\\s*=\\s*([^\\)]+)\\)/,\r\n\r\n      /** @ignore */\r\n      setOpacity = function (element) { return element; };\r\n\r\n  if (supportsOpacity) {\r\n    /** @ignore */\r\n    setOpacity = function(element, value) {\r\n      element.style.opacity = value;\r\n      return element;\r\n    };\r\n  }\r\n  else if (supportsFilters) {\r\n    /** @ignore */\r\n    setOpacity = function(element, value) {\r\n      var es = element.style;\r\n      if (element.currentStyle && !element.currentStyle.hasLayout) {\r\n        es.zoom = 1;\r\n      }\r\n      if (reOpacity.test(es.filter)) {\r\n        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');\r\n        es.filter = es.filter.replace(reOpacity, value);\r\n      }\r\n      else {\r\n        es.filter += ' alpha(opacity=' + (value * 100) + ')';\r\n      }\r\n      return element;\r\n    };\r\n  }\r\n\r\n  fabric.util.setStyle = setStyle;\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  var _slice = Array.prototype.slice;\r\n\r\n  /**\r\n   * Takes id and returns an element with that id (if one exists in a document)\r\n   * @memberOf fabric.util\r\n   * @param {String|HTMLElement} id\r\n   * @return {HTMLElement|null}\r\n   */\r\n  function getById(id) {\r\n    return typeof id === 'string' ? fabric.document.getElementById(id) : id;\r\n  }\r\n\r\n  var sliceCanConvertNodelists,\r\n      /**\r\n       * Converts an array-like object (e.g. arguments or NodeList) to an array\r\n       * @memberOf fabric.util\r\n       * @param {Object} arrayLike\r\n       * @return {Array}\r\n       */\r\n      toArray = function(arrayLike) {\r\n        return _slice.call(arrayLike, 0);\r\n      };\r\n\r\n  try {\r\n    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;\r\n  }\r\n  catch (err) { }\r\n\r\n  if (!sliceCanConvertNodelists) {\r\n    toArray = function(arrayLike) {\r\n      var arr = new Array(arrayLike.length), i = arrayLike.length;\r\n      while (i--) {\r\n        arr[i] = arrayLike[i];\r\n      }\r\n      return arr;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Creates specified element with specified attributes\r\n   * @memberOf fabric.util\r\n   * @param {String} tagName Type of an element to create\r\n   * @param {Object} [attributes] Attributes to set on an element\r\n   * @return {HTMLElement} Newly created element\r\n   */\r\n  function makeElement(tagName, attributes) {\r\n    var el = fabric.document.createElement(tagName);\r\n    for (var prop in attributes) {\r\n      if (prop === 'class') {\r\n        el.className = attributes[prop];\r\n      }\r\n      else if (prop === 'for') {\r\n        el.htmlFor = attributes[prop];\r\n      }\r\n      else {\r\n        el.setAttribute(prop, attributes[prop]);\r\n      }\r\n    }\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Adds class to an element\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element Element to add class to\r\n   * @param {String} className Class to add to an element\r\n   */\r\n  function addClass(element, className) {\r\n    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {\r\n      element.className += (element.className ? ' ' : '') + className;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wraps element with another element\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element Element to wrap\r\n   * @param {HTMLElement|String} wrapper Element to wrap with\r\n   * @param {Object} [attributes] Attributes to set on a wrapper\r\n   * @return {HTMLElement} wrapper\r\n   */\r\n  function wrapElement(element, wrapper, attributes) {\r\n    if (typeof wrapper === 'string') {\r\n      wrapper = makeElement(wrapper, attributes);\r\n    }\r\n    if (element.parentNode) {\r\n      element.parentNode.replaceChild(wrapper, element);\r\n    }\r\n    wrapper.appendChild(element);\r\n    return wrapper;\r\n  }\r\n\r\n  /**\r\n   * Returns element scroll offsets\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element Element to operate on\r\n   * @return {Object} Object with left/top values\r\n   */\r\n  function getScrollLeftTop(element) {\r\n\r\n    var left = 0,\r\n        top = 0,\r\n        docElement = fabric.document.documentElement,\r\n        body = fabric.document.body || {\r\n          scrollLeft: 0, scrollTop: 0\r\n        };\r\n\r\n    while (element && element.parentNode) {\r\n\r\n      element = element.parentNode;\r\n\r\n      if (element === fabric.document) {\r\n        left = body.scrollLeft || docElement.scrollLeft || 0;\r\n        top = body.scrollTop ||  docElement.scrollTop || 0;\r\n      }\r\n      else {\r\n        left += element.scrollLeft || 0;\r\n        top += element.scrollTop || 0;\r\n      }\r\n\r\n      if (element.nodeType === 1 &&\r\n          fabric.util.getElementStyle(element, 'position') === 'fixed') {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return { left: left, top: top };\r\n  }\r\n\r\n  /**\r\n   * Returns offset for a given element\r\n   * @function\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element Element to get offset for\r\n   * @return {Object} Object with \"left\" and \"top\" properties\r\n   */\r\n  function getElementOffset(element) {\r\n    var docElem,\r\n        doc = element && element.ownerDocument,\r\n        box = { left: 0, top: 0 },\r\n        offset = { left: 0, top: 0 },\r\n        scrollLeftTop,\r\n        offsetAttributes = {\r\n          borderLeftWidth: 'left',\r\n          borderTopWidth:  'top',\r\n          paddingLeft:     'left',\r\n          paddingTop:      'top'\r\n        };\r\n\r\n    if (!doc) {\r\n      return offset;\r\n    }\r\n\r\n    for (var attr in offsetAttributes) {\r\n      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;\r\n    }\r\n\r\n    docElem = doc.documentElement;\r\n    if ( typeof element.getBoundingClientRect !== 'undefined' ) {\r\n      box = element.getBoundingClientRect();\r\n    }\r\n\r\n    scrollLeftTop = getScrollLeftTop(element);\r\n\r\n    return {\r\n      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,\r\n      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Returns style attribute value of a given element\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element Element to get style attribute for\r\n   * @param {String} attr Style attribute to get for element\r\n   * @return {String} Style attribute value of the given element.\r\n   */\r\n  var getElementStyle;\r\n  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {\r\n    getElementStyle = function(element, attr) {\r\n      var style = fabric.document.defaultView.getComputedStyle(element, null);\r\n      return style ? style[attr] : undefined;\r\n    };\r\n  }\r\n  else {\r\n    getElementStyle = function(element, attr) {\r\n      var value = element.style[attr];\r\n      if (!value && element.currentStyle) {\r\n        value = element.currentStyle[attr];\r\n      }\r\n      return value;\r\n    };\r\n  }\r\n\r\n  (function () {\r\n    var style = fabric.document.documentElement.style,\r\n        selectProp = 'userSelect' in style\r\n          ? 'userSelect'\r\n          : 'MozUserSelect' in style\r\n            ? 'MozUserSelect'\r\n            : 'WebkitUserSelect' in style\r\n              ? 'WebkitUserSelect'\r\n              : 'KhtmlUserSelect' in style\r\n                ? 'KhtmlUserSelect'\r\n                : '';\r\n\r\n    /**\r\n     * Makes element unselectable\r\n     * @memberOf fabric.util\r\n     * @param {HTMLElement} element Element to make unselectable\r\n     * @return {HTMLElement} Element that was passed in\r\n     */\r\n    function makeElementUnselectable(element) {\r\n      if (typeof element.onselectstart !== 'undefined') {\r\n        element.onselectstart = fabric.util.falseFunction;\r\n      }\r\n      if (selectProp) {\r\n        element.style[selectProp] = 'none';\r\n      }\r\n      else if (typeof element.unselectable === 'string') {\r\n        element.unselectable = 'on';\r\n      }\r\n      return element;\r\n    }\r\n\r\n    /**\r\n     * Makes element selectable\r\n     * @memberOf fabric.util\r\n     * @param {HTMLElement} element Element to make selectable\r\n     * @return {HTMLElement} Element that was passed in\r\n     */\r\n    function makeElementSelectable(element) {\r\n      if (typeof element.onselectstart !== 'undefined') {\r\n        element.onselectstart = null;\r\n      }\r\n      if (selectProp) {\r\n        element.style[selectProp] = '';\r\n      }\r\n      else if (typeof element.unselectable === 'string') {\r\n        element.unselectable = '';\r\n      }\r\n      return element;\r\n    }\r\n\r\n    fabric.util.makeElementUnselectable = makeElementUnselectable;\r\n    fabric.util.makeElementSelectable = makeElementSelectable;\r\n  })();\r\n\r\n  (function() {\r\n\r\n    /**\r\n     * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading\r\n     * @memberOf fabric.util\r\n     * @param {String} url URL of a script to load\r\n     * @param {Function} callback Callback to execute when script is finished loading\r\n     */\r\n    function getScript(url, callback) {\r\n      var headEl = fabric.document.getElementsByTagName('head')[0],\r\n          scriptEl = fabric.document.createElement('script'),\r\n          loading = true;\r\n\r\n      /** @ignore */\r\n      scriptEl.onload = /** @ignore */ scriptEl.onreadystatechange = function(e) {\r\n        if (loading) {\r\n          if (typeof this.readyState === 'string' &&\r\n              this.readyState !== 'loaded' &&\r\n              this.readyState !== 'complete') {\r\n            return;\r\n          }\r\n          loading = false;\r\n          callback(e || fabric.window.event);\r\n          scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;\r\n        }\r\n      };\r\n      scriptEl.src = url;\r\n      headEl.appendChild(scriptEl);\r\n      // causes issue in Opera\r\n      // headEl.removeChild(scriptEl);\r\n    }\r\n\r\n    fabric.util.getScript = getScript;\r\n  })();\r\n\r\n  fabric.util.getById = getById;\r\n  fabric.util.toArray = toArray;\r\n  fabric.util.makeElement = makeElement;\r\n  fabric.util.addClass = addClass;\r\n  fabric.util.wrapElement = wrapElement;\r\n  fabric.util.getScrollLeftTop = getScrollLeftTop;\r\n  fabric.util.getElementOffset = getElementOffset;\r\n  fabric.util.getElementStyle = getElementStyle;\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  function addParamToUrl(url, param) {\r\n    return url + (/\\?/.test(url) ? '&' : '?') + param;\r\n  }\r\n\r\n  var makeXHR = (function() {\r\n    var factories = [\r\n      function() { return new ActiveXObject('Microsoft.XMLHTTP'); },\r\n      function() { return new ActiveXObject('Msxml2.XMLHTTP'); },\r\n      function() { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); },\r\n      function() { return new XMLHttpRequest(); }\r\n    ];\r\n    for (var i = factories.length; i--; ) {\r\n      try {\r\n        var req = factories[i]();\r\n        if (req) {\r\n          return factories[i];\r\n        }\r\n      }\r\n      catch (err) { }\r\n    }\r\n  })();\r\n\r\n  function emptyFn() { }\r\n\r\n  /**\r\n   * Cross-browser abstraction for sending XMLHttpRequest\r\n   * @memberOf fabric.util\r\n   * @param {String} url URL to send XMLHttpRequest to\r\n   * @param {Object} [options] Options object\r\n   * @param {String} [options.method=\"GET\"]\r\n   * @param {Function} options.onComplete Callback to invoke when request is completed\r\n   * @return {XMLHttpRequest} request\r\n   */\r\n  function request(url, options) {\r\n\r\n    options || (options = { });\r\n\r\n    var method = options.method ? options.method.toUpperCase() : 'GET',\r\n        onComplete = options.onComplete || function() { },\r\n        xhr = makeXHR(),\r\n        body;\r\n\r\n    /** @ignore */\r\n    xhr.onreadystatechange = function() {\r\n      if (xhr.readyState === 4) {\r\n        onComplete(xhr);\r\n        xhr.onreadystatechange = emptyFn;\r\n      }\r\n    };\r\n\r\n    if (method === 'GET') {\r\n      body = null;\r\n      if (typeof options.parameters === 'string') {\r\n        url = addParamToUrl(url, options.parameters);\r\n      }\r\n    }\r\n\r\n    xhr.open(method, url, true);\r\n\r\n    if (method === 'POST' || method === 'PUT') {\r\n      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n    }\r\n\r\n    xhr.send(body);\r\n    return xhr;\r\n  }\r\n\r\n  fabric.util.request = request;\r\n})();\r\n\r\n\r\n/**\r\n * Wrapper around `console.log` (when available)\r\n * @param {Any} [values] Values to log\r\n */\r\nfabric.log = function() { };\r\n\r\n/**\r\n * Wrapper around `console.warn` (when available)\r\n * @param {Any} [values] Values to log as a warning\r\n */\r\nfabric.warn = function() { };\r\n\r\n/* jshint ignore:start */\r\nif (typeof console !== 'undefined') {\r\n\r\n  ['log', 'warn'].forEach(function(methodName) {\r\n\r\n    if (typeof console[methodName] !== 'undefined' &&\r\n        typeof console[methodName].apply === 'function') {\r\n\r\n      fabric[methodName] = function() {\r\n        return console[methodName].apply(console, arguments);\r\n      };\r\n    }\r\n  });\r\n}\r\n/* jshint ignore:end */\r\n\r\n\r\n(function() {\r\n\r\n  /**\r\n   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.\r\n   * @memberOf fabric.util\r\n   * @param {Object} [options] Animation options\r\n   * @param {Function} [options.onChange] Callback; invoked on every value change\r\n   * @param {Function} [options.onComplete] Callback; invoked when value change is completed\r\n   * @param {Number} [options.startValue=0] Starting value\r\n   * @param {Number} [options.endValue=100] Ending value\r\n   * @param {Number} [options.byValue=100] Value to modify the property by\r\n   * @param {Function} [options.easing] Easing function\r\n   * @param {Number} [options.duration=500] Duration of change (in ms)\r\n   */\r\n  function animate(options) {\r\n\r\n    requestAnimFrame(function(timestamp) {\r\n      options || (options = { });\r\n\r\n      var start = timestamp || +new Date(),\r\n          duration = options.duration || 500,\r\n          finish = start + duration, time,\r\n          onChange = options.onChange || function() { },\r\n          abort = options.abort || function() { return false; },\r\n          easing = options.easing || function(t, b, c, d) {return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;},\r\n          startValue = 'startValue' in options ? options.startValue : 0,\r\n          endValue = 'endValue' in options ? options.endValue : 100,\r\n          byValue = options.byValue || endValue - startValue;\r\n\r\n      options.onStart && options.onStart();\r\n\r\n      (function tick(ticktime) {\r\n        time = ticktime || +new Date();\r\n        var currentTime = time > finish ? duration : (time - start);\r\n        if (abort()) {\r\n          options.onComplete && options.onComplete();\r\n          return;\r\n        }\r\n        onChange(easing(currentTime, startValue, byValue, duration));\r\n        if (time > finish) {\r\n          options.onComplete && options.onComplete();\r\n          return;\r\n        }\r\n        requestAnimFrame(tick);\r\n      })(start);\r\n    });\r\n\r\n  }\r\n\r\n  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||\r\n                          fabric.window.webkitRequestAnimationFrame ||\r\n                          fabric.window.mozRequestAnimationFrame    ||\r\n                          fabric.window.oRequestAnimationFrame      ||\r\n                          fabric.window.msRequestAnimationFrame     ||\r\n                          function(callback) {\r\n                            fabric.window.setTimeout(callback, 1000 / 60);\r\n                          };\r\n\r\n  /**\r\n   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method\r\n   * @memberOf fabric.util\r\n   * @param {Function} callback Callback to invoke\r\n   * @param {DOMElement} element optional Element to associate with animation\r\n   */\r\n  function requestAnimFrame() {\r\n    return _requestAnimFrame.apply(fabric.window, arguments);\r\n  }\r\n\r\n  fabric.util.animate = animate;\r\n  fabric.util.requestAnimFrame = requestAnimFrame;\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  function normalize(a, c, p, s) {\r\n    if (a < Math.abs(c)) {\r\n      a = c;\r\n      s = p / 4;\r\n    }\r\n    else {\r\n      s = p / (2 * Math.PI) * Math.asin(c / a);\r\n    }\r\n    return { a: a, c: c, p: p, s: s };\r\n  }\r\n\r\n  function elastic(opts, t, d) {\r\n    return opts.a *\r\n      Math.pow(2, 10 * (t -= 1)) *\r\n      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );\r\n  }\r\n\r\n  /**\r\n   * Cubic easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutCubic(t, b, c, d) {\r\n    return c * ((t = t / d - 1) * t * t + 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Cubic easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutCubic(t, b, c, d) {\r\n    t /= d/2;\r\n    if (t < 1) {\r\n      return c / 2 * t * t * t + b;\r\n    }\r\n    return c / 2 * ((t -= 2) * t * t + 2) + b;\r\n  }\r\n\r\n  /**\r\n   * Quartic easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInQuart(t, b, c, d) {\r\n    return c * (t /= d) * t * t * t + b;\r\n  }\r\n\r\n  /**\r\n   * Quartic easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutQuart(t, b, c, d) {\r\n    return -c * ((t = t / d - 1) * t * t * t - 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Quartic easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutQuart(t, b, c, d) {\r\n    t /= d / 2;\r\n    if (t < 1) {\r\n      return c / 2 * t * t * t * t + b;\r\n    }\r\n    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\r\n  }\r\n\r\n  /**\r\n   * Quintic easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInQuint(t, b, c, d) {\r\n    return c * (t /= d) * t * t * t * t + b;\r\n  }\r\n\r\n  /**\r\n   * Quintic easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutQuint(t, b, c, d) {\r\n    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Quintic easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutQuint(t, b, c, d) {\r\n    t /= d / 2;\r\n    if (t < 1) {\r\n      return c / 2 * t * t * t * t * t + b;\r\n    }\r\n    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\r\n  }\r\n\r\n  /**\r\n   * Sinusoidal easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInSine(t, b, c, d) {\r\n    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\r\n  }\r\n\r\n  /**\r\n   * Sinusoidal easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutSine(t, b, c, d) {\r\n    return c * Math.sin(t / d * (Math.PI / 2)) + b;\r\n  }\r\n\r\n  /**\r\n   * Sinusoidal easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutSine(t, b, c, d) {\r\n    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Exponential easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInExpo(t, b, c, d) {\r\n    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\r\n  }\r\n\r\n  /**\r\n   * Exponential easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutExpo(t, b, c, d) {\r\n    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Exponential easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutExpo(t, b, c, d) {\r\n    if (t === 0) {\r\n      return b;\r\n    }\r\n    if (t === d) {\r\n      return b + c;\r\n    }\r\n    t /= d / 2;\r\n    if (t < 1) {\r\n      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\r\n    }\r\n    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\r\n  }\r\n\r\n  /**\r\n   * Circular easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInCirc(t, b, c, d) {\r\n    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Circular easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutCirc(t, b, c, d) {\r\n    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\r\n  }\r\n\r\n  /**\r\n   * Circular easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutCirc(t, b, c, d) {\r\n    t /= d / 2;\r\n    if (t < 1) {\r\n      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\r\n    }\r\n    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Elastic easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInElastic(t, b, c, d) {\r\n    var s = 1.70158, p = 0, a = c;\r\n    if (t === 0) {\r\n      return b;\r\n    }\r\n    t /= d;\r\n    if (t === 1) {\r\n      return b + c;\r\n    }\r\n    if (!p) {\r\n      p = d * 0.3;\r\n    }\r\n    var opts = normalize(a, c, p, s);\r\n    return -elastic(opts, t, d) + b;\r\n  }\r\n\r\n  /**\r\n   * Elastic easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutElastic(t, b, c, d) {\r\n    var s = 1.70158, p = 0, a = c;\r\n    if (t === 0) {\r\n      return b;\r\n    }\r\n    t /= d;\r\n    if (t === 1) {\r\n      return b + c;\r\n    }\r\n    if (!p) {\r\n      p = d * 0.3;\r\n    }\r\n    var opts = normalize(a, c, p, s);\r\n    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;\r\n  }\r\n\r\n  /**\r\n   * Elastic easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutElastic(t, b, c, d) {\r\n    var s = 1.70158, p = 0, a = c;\r\n    if (t === 0) {\r\n      return b;\r\n    }\r\n    t /= d / 2;\r\n    if (t === 2) {\r\n      return b + c;\r\n    }\r\n    if (!p) {\r\n      p = d * (0.3 * 1.5);\r\n    }\r\n    var opts = normalize(a, c, p, s);\r\n    if (t < 1) {\r\n      return -0.5 * elastic(opts, t, d) + b;\r\n    }\r\n    return opts.a * Math.pow(2, -10 * (t -= 1)) *\r\n      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;\r\n  }\r\n\r\n  /**\r\n   * Backwards easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInBack(t, b, c, d, s) {\r\n    if (s === undefined) {\r\n      s = 1.70158;\r\n    }\r\n    return c * (t /= d) * t * ((s + 1) * t - s) + b;\r\n  }\r\n\r\n  /**\r\n   * Backwards easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutBack(t, b, c, d, s) {\r\n    if (s === undefined) {\r\n      s = 1.70158;\r\n    }\r\n    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Backwards easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutBack(t, b, c, d, s) {\r\n    if (s === undefined) {\r\n      s = 1.70158;\r\n    }\r\n    t /= d / 2;\r\n    if (t < 1) {\r\n      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;\r\n    }\r\n    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\r\n  }\r\n\r\n  /**\r\n   * Bouncing easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInBounce(t, b, c, d) {\r\n    return c - easeOutBounce (d - t, 0, c, d) + b;\r\n  }\r\n\r\n  /**\r\n   * Bouncing easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutBounce(t, b, c, d) {\r\n    if ((t /= d) < (1 / 2.75)) {\r\n      return c * (7.5625 * t * t) + b;\r\n    }\r\n    else if (t < (2/2.75)) {\r\n      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;\r\n    }\r\n    else if (t < (2.5/2.75)) {\r\n      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;\r\n    }\r\n    else {\r\n      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bouncing easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutBounce(t, b, c, d) {\r\n    if (t < d / 2) {\r\n      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;\r\n    }\r\n    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;\r\n  }\r\n\r\n  /**\r\n   * Easing functions\r\n   * See <a href=\"http://gizma.com/easing/\">Easing Equations by Robert Penner</a>\r\n   * @namespace fabric.util.ease\r\n   */\r\n  fabric.util.ease = {\r\n\r\n    /**\r\n     * Quadratic easing in\r\n     * @memberOf fabric.util.ease\r\n     */\r\n    easeInQuad: function(t, b, c, d) {\r\n      return c * (t /= d) * t + b;\r\n    },\r\n\r\n    /**\r\n     * Quadratic easing out\r\n     * @memberOf fabric.util.ease\r\n     */\r\n    easeOutQuad: function(t, b, c, d) {\r\n      return -c * (t /= d) * (t - 2) + b;\r\n    },\r\n\r\n    /**\r\n     * Quadratic easing in and out\r\n     * @memberOf fabric.util.ease\r\n     */\r\n    easeInOutQuad: function(t, b, c, d) {\r\n      t /= (d / 2);\r\n      if (t < 1) {\r\n        return c / 2 * t * t + b;\r\n      }\r\n      return -c / 2 * ((--t) * (t - 2) - 1) + b;\r\n    },\r\n\r\n    /**\r\n     * Cubic easing in\r\n     * @memberOf fabric.util.ease\r\n     */\r\n    easeInCubic: function(t, b, c, d) {\r\n      return c * (t /= d) * t * t + b;\r\n    },\r\n\r\n    easeOutCubic: easeOutCubic,\r\n    easeInOutCubic: easeInOutCubic,\r\n    easeInQuart: easeInQuart,\r\n    easeOutQuart: easeOutQuart,\r\n    easeInOutQuart: easeInOutQuart,\r\n    easeInQuint: easeInQuint,\r\n    easeOutQuint: easeOutQuint,\r\n    easeInOutQuint: easeInOutQuint,\r\n    easeInSine: easeInSine,\r\n    easeOutSine: easeOutSine,\r\n    easeInOutSine: easeInOutSine,\r\n    easeInExpo: easeInExpo,\r\n    easeOutExpo: easeOutExpo,\r\n    easeInOutExpo: easeInOutExpo,\r\n    easeInCirc: easeInCirc,\r\n    easeOutCirc: easeOutCirc,\r\n    easeInOutCirc: easeInOutCirc,\r\n    easeInElastic: easeInElastic,\r\n    easeOutElastic: easeOutElastic,\r\n    easeInOutElastic: easeInOutElastic,\r\n    easeInBack: easeInBack,\r\n    easeOutBack: easeOutBack,\r\n    easeInOutBack: easeInOutBack,\r\n    easeInBounce: easeInBounce,\r\n    easeOutBounce: easeOutBounce,\r\n    easeInOutBounce: easeInOutBounce\r\n  };\r\n\r\n}());\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  /**\r\n   * @name fabric\r\n   * @namespace\r\n   */\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      capitalize = fabric.util.string.capitalize,\r\n      clone = fabric.util.object.clone,\r\n      toFixed = fabric.util.toFixed,\r\n      parseUnit = fabric.util.parseUnit,\r\n      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,\r\n\r\n      reAllowedSVGTagNames = /^(path|circle|polygon|polyline|ellipse|rect|line|image|text)$/i,\r\n      reViewBoxTagNames = /^(symbol|image|marker|pattern|view|svg)$/i,\r\n      reNotAllowedAncestors = /^(?:pattern|defs|symbol|metadata)$/i,\r\n      reAllowedParents = /^(symbol|g|a|svg)$/i,\r\n\r\n      attributesMap = {\r\n        cx:                   'left',\r\n        x:                    'left',\r\n        r:                    'radius',\r\n        cy:                   'top',\r\n        y:                    'top',\r\n        display:              'visible',\r\n        visibility:           'visible',\r\n        transform:            'transformMatrix',\r\n        'fill-opacity':       'fillOpacity',\r\n        'fill-rule':          'fillRule',\r\n        'font-family':        'fontFamily',\r\n        'font-size':          'fontSize',\r\n        'font-style':         'fontStyle',\r\n        'font-weight':        'fontWeight',\r\n        'stroke-dasharray':   'strokeDashArray',\r\n        'stroke-linecap':     'strokeLineCap',\r\n        'stroke-linejoin':    'strokeLineJoin',\r\n        'stroke-miterlimit':  'strokeMiterLimit',\r\n        'stroke-opacity':     'strokeOpacity',\r\n        'stroke-width':       'strokeWidth',\r\n        'text-decoration':    'textDecoration',\r\n        'text-anchor':        'originX'\r\n      },\r\n\r\n      colorAttributes = {\r\n        stroke: 'strokeOpacity',\r\n        fill:   'fillOpacity'\r\n      };\r\n\r\n  fabric.cssRules = { };\r\n  fabric.gradientDefs = { };\r\n\r\n  function normalizeAttr(attr) {\r\n    // transform attribute names\r\n    if (attr in attributesMap) {\r\n      return attributesMap[attr];\r\n    }\r\n    return attr;\r\n  }\r\n\r\n  function normalizeValue(attr, value, parentAttributes, fontSize) {\r\n    var isArray = Object.prototype.toString.call(value) === '[object Array]',\r\n        parsed;\r\n\r\n    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {\r\n      value = '';\r\n    }\r\n    else if (attr === 'strokeDashArray') {\r\n      value = value.replace(/,/g, ' ').split(/\\s+/).map(function(n) {\r\n        return parseFloat(n);\r\n      });\r\n    }\r\n    else if (attr === 'transformMatrix') {\r\n      if (parentAttributes && parentAttributes.transformMatrix) {\r\n        value = multiplyTransformMatrices(\r\n          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));\r\n      }\r\n      else {\r\n        value = fabric.parseTransformAttribute(value);\r\n      }\r\n    }\r\n    else if (attr === 'visible') {\r\n      value = (value === 'none' || value === 'hidden') ? false : true;\r\n      // display=none on parent element always takes precedence over child element\r\n      if (parentAttributes && parentAttributes.visible === false) {\r\n        value = false;\r\n      }\r\n    }\r\n    else if (attr === 'originX' /* text-anchor */) {\r\n      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';\r\n    }\r\n    else {\r\n      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);\r\n    }\r\n\r\n    return (!isArray && isNaN(parsed) ? value : parsed);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Object} attributes Array of attributes to parse\r\n   */\r\n  function _setStrokeFillOpacity(attributes) {\r\n    for (var attr in colorAttributes) {\r\n\r\n      if (!attributes[attr] || typeof attributes[colorAttributes[attr]] === 'undefined') {\r\n        continue;\r\n      }\r\n\r\n      if (attributes[attr].indexOf('url(') === 0) {\r\n        continue;\r\n      }\r\n\r\n      var color = new fabric.Color(attributes[attr]);\r\n      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();\r\n    }\r\n    return attributes;\r\n  }\r\n\r\n  /**\r\n   * Parses \"transform\" attribute, returning an array of values\r\n   * @static\r\n   * @function\r\n   * @memberOf fabric\r\n   * @param {String} attributeValue String containing attribute value\r\n   * @return {Array} Array of 6 elements representing transformation matrix\r\n   */\r\n  fabric.parseTransformAttribute = (function() {\r\n    function rotateMatrix(matrix, args) {\r\n      var angle = args[0];\r\n\r\n      matrix[0] = Math.cos(angle);\r\n      matrix[1] = Math.sin(angle);\r\n      matrix[2] = -Math.sin(angle);\r\n      matrix[3] = Math.cos(angle);\r\n    }\r\n\r\n    function scaleMatrix(matrix, args) {\r\n      var multiplierX = args[0],\r\n          multiplierY = (args.length === 2) ? args[1] : args[0];\r\n\r\n      matrix[0] = multiplierX;\r\n      matrix[3] = multiplierY;\r\n    }\r\n\r\n    function skewXMatrix(matrix, args) {\r\n      matrix[2] = Math.tan(fabric.util.degreesToRadians(args[0]));\r\n    }\r\n\r\n    function skewYMatrix(matrix, args) {\r\n      matrix[1] = Math.tan(fabric.util.degreesToRadians(args[0]));\r\n    }\r\n\r\n    function translateMatrix(matrix, args) {\r\n      matrix[4] = args[0];\r\n      if (args.length === 2) {\r\n        matrix[5] = args[1];\r\n      }\r\n    }\r\n\r\n    // identity matrix\r\n    var iMatrix = [\r\n          1, // a\r\n          0, // b\r\n          0, // c\r\n          1, // d\r\n          0, // e\r\n          0  // f\r\n        ],\r\n\r\n        // == begin transform regexp\r\n        number = fabric.reNum,\r\n\r\n        commaWsp = '(?:\\\\s+,?\\\\s*|,\\\\s*)',\r\n\r\n        skewX = '(?:(skewX)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*\\\\))',\r\n\r\n        skewY = '(?:(skewY)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*\\\\))',\r\n\r\n        rotate = '(?:(rotate)\\\\s*\\\\(\\\\s*(' + number + ')(?:' +\r\n                    commaWsp + '(' + number + ')' +\r\n                    commaWsp + '(' + number + '))?\\\\s*\\\\))',\r\n\r\n        scale = '(?:(scale)\\\\s*\\\\(\\\\s*(' + number + ')(?:' +\r\n                    commaWsp + '(' + number + '))?\\\\s*\\\\))',\r\n\r\n        translate = '(?:(translate)\\\\s*\\\\(\\\\s*(' + number + ')(?:' +\r\n                    commaWsp + '(' + number + '))?\\\\s*\\\\))',\r\n\r\n        matrix = '(?:(matrix)\\\\s*\\\\(\\\\s*' +\r\n                  '(' + number + ')' + commaWsp +\r\n                  '(' + number + ')' + commaWsp +\r\n                  '(' + number + ')' + commaWsp +\r\n                  '(' + number + ')' + commaWsp +\r\n                  '(' + number + ')' + commaWsp +\r\n                  '(' + number + ')' +\r\n                  '\\\\s*\\\\))',\r\n\r\n        transform = '(?:' +\r\n                    matrix + '|' +\r\n                    translate + '|' +\r\n                    scale + '|' +\r\n                    rotate + '|' +\r\n                    skewX + '|' +\r\n                    skewY +\r\n                    ')',\r\n\r\n        transforms = '(?:' + transform + '(?:' + commaWsp + transform + ')*' + ')',\r\n\r\n        transformList = '^\\\\s*(?:' + transforms + '?)\\\\s*$',\r\n\r\n        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute\r\n        reTransformList = new RegExp(transformList),\r\n        // == end transform regexp\r\n\r\n        reTransform = new RegExp(transform, 'g');\r\n\r\n    return function(attributeValue) {\r\n\r\n      // start with identity matrix\r\n      var matrix = iMatrix.concat(),\r\n          matrices = [ ];\r\n\r\n      // return if no argument was given or\r\n      // an argument does not match transform attribute regexp\r\n      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {\r\n        return matrix;\r\n      }\r\n\r\n      attributeValue.replace(reTransform, function(match) {\r\n\r\n        var m = new RegExp(transform).exec(match).filter(function (match) {\r\n              return (match !== '' && match != null);\r\n            }),\r\n            operation = m[1],\r\n            args = m.slice(2).map(parseFloat);\r\n\r\n        switch (operation) {\r\n          case 'translate':\r\n            translateMatrix(matrix, args);\r\n            break;\r\n          case 'rotate':\r\n            args[0] = fabric.util.degreesToRadians(args[0]);\r\n            rotateMatrix(matrix, args);\r\n            break;\r\n          case 'scale':\r\n            scaleMatrix(matrix, args);\r\n            break;\r\n          case 'skewX':\r\n            skewXMatrix(matrix, args);\r\n            break;\r\n          case 'skewY':\r\n            skewYMatrix(matrix, args);\r\n            break;\r\n          case 'matrix':\r\n            matrix = args;\r\n            break;\r\n        }\r\n\r\n        // snapshot current matrix into matrices array\r\n        matrices.push(matrix.concat());\r\n        // reset\r\n        matrix = iMatrix.concat();\r\n      });\r\n\r\n      var combinedMatrix = matrices[0];\r\n      while (matrices.length > 1) {\r\n        matrices.shift();\r\n        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);\r\n      }\r\n      return combinedMatrix;\r\n    };\r\n  })();\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function parseStyleString(style, oStyle) {\r\n    var attr, value;\r\n    style.replace(/;\\s*$/, '').split(';').forEach(function (chunk) {\r\n      var pair = chunk.split(':');\r\n\r\n      attr = normalizeAttr(pair[0].trim().toLowerCase());\r\n      value = normalizeValue(attr, pair[1].trim());\r\n\r\n      oStyle[attr] = value;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function parseStyleObject(style, oStyle) {\r\n    var attr, value;\r\n    for (var prop in style) {\r\n      if (typeof style[prop] === 'undefined') {\r\n        continue;\r\n      }\r\n\r\n      attr = normalizeAttr(prop.toLowerCase());\r\n      value = normalizeValue(attr, style[prop]);\r\n\r\n      oStyle[attr] = value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function getGlobalStylesForElement(element, svgUid) {\r\n    var styles = { };\r\n    for (var rule in fabric.cssRules[svgUid]) {\r\n      if (elementMatchesRule(element, rule.split(' '))) {\r\n        for (var property in fabric.cssRules[svgUid][rule]) {\r\n          styles[property] = fabric.cssRules[svgUid][rule][property];\r\n        }\r\n      }\r\n    }\r\n    return styles;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function elementMatchesRule(element, selectors) {\r\n    var firstMatching, parentMatching = true;\r\n    //start from rightmost selector.\r\n    firstMatching = selectorMatches(element, selectors.pop());\r\n    if (firstMatching && selectors.length) {\r\n      parentMatching = doesSomeParentMatch(element, selectors);\r\n    }\r\n    return firstMatching && parentMatching && (selectors.length === 0);\r\n  }\r\n\r\n  function doesSomeParentMatch(element, selectors) {\r\n    var selector, parentMatching = true;\r\n    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {\r\n      if (parentMatching) {\r\n        selector = selectors.pop();\r\n      }\r\n      element = element.parentNode;\r\n      parentMatching = selectorMatches(element, selector);\r\n    }\r\n    return selectors.length === 0;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function selectorMatches(element, selector) {\r\n    var nodeName = element.nodeName,\r\n        classNames = element.getAttribute('class'),\r\n        id = element.getAttribute('id'), matcher;\r\n    // i check if a selector matches slicing away part from it.\r\n    // if i get empty string i should match\r\n    matcher = new RegExp('^' + nodeName, 'i');\r\n    selector = selector.replace(matcher, '');\r\n    if (id && selector.length) {\r\n      matcher = new RegExp('#' + id + '(?![a-zA-Z\\\\-]+)', 'i');\r\n      selector = selector.replace(matcher, '');\r\n    }\r\n    if (classNames && selector.length) {\r\n      classNames = classNames.split(' ');\r\n      for (var i = classNames.length; i--;) {\r\n        matcher = new RegExp('\\\\.' + classNames[i] + '(?![a-zA-Z\\\\-]+)', 'i');\r\n        selector = selector.replace(matcher, '');\r\n      }\r\n    }\r\n    return selector.length === 0;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * to support IE8 missing getElementById on SVGdocument\r\n   */\r\n  function elementById(doc, id) {\r\n    var el;\r\n    doc.getElementById && (el = doc.getElementById(id));\r\n    if (el) {\r\n      return el;\r\n    }\r\n    var node, i, idAttr, nodelist = doc.getElementsByTagName('*');\r\n    for (i = 0; i < nodelist.length; i++) {\r\n      node = nodelist[i];\r\n      if (idAttr === node.getAttribute('id')) {\r\n        return node;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function parseUseDirectives(doc) {\r\n    var nodelist = doc.getElementsByTagName('use'), i = 0;\r\n    while (nodelist.length && i < nodelist.length) {\r\n      var el = nodelist[i],\r\n          xlink = el.getAttribute('xlink:href').substr(1),\r\n          x = el.getAttribute('x') || 0,\r\n          y = el.getAttribute('y') || 0,\r\n          el2 = elementById(doc, xlink).cloneNode(true),\r\n          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',\r\n          parentNode, oldLength = nodelist.length, attr, j, attrs, l;\r\n\r\n      applyViewboxTransform(el2);\r\n      if (/^svg$/i.test(el2.nodeName)) {\r\n        var el3 = el2.ownerDocument.createElement('g');\r\n        for (j = 0, attrs = el2.attributes, l = attrs.length; j < l; j++) {\r\n          attr = attrs.item(j);\r\n          el3.setAttribute(attr.nodeName, attr.nodeValue);\r\n        }\r\n        while (el2.firstChild != null) {\r\n          el3.appendChild(el2.firstChild);\r\n        }\r\n        el2 = el3;\r\n      }\r\n\r\n      for (j = 0, attrs = el.attributes, l = attrs.length; j < l; j++) {\r\n        attr = attrs.item(j);\r\n        if (attr.nodeName === 'x' || attr.nodeName === 'y' || attr.nodeName === 'xlink:href') {\r\n          continue;\r\n        }\r\n\r\n        if (attr.nodeName === 'transform') {\r\n          currentTrans = attr.nodeValue + ' ' + currentTrans;\r\n        }\r\n        else {\r\n          el2.setAttribute(attr.nodeName, attr.nodeValue);\r\n        }\r\n      }\r\n\r\n      el2.setAttribute('transform', currentTrans);\r\n      el2.setAttribute('instantiated_by_use', '1');\r\n      el2.removeAttribute('id');\r\n      parentNode = el.parentNode;\r\n      parentNode.replaceChild(el2, el);\r\n      // some browsers do not shorten nodelist after replaceChild (IE8)\r\n      if (nodelist.length === oldLength) {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n\r\n  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute\r\n  // matches, e.g.: +14.56e-12, etc.\r\n  var reViewBoxAttrValue = new RegExp(\r\n    '^' +\r\n    '\\\\s*(' + fabric.reNum + '+)\\\\s*,?' +\r\n    '\\\\s*(' + fabric.reNum + '+)\\\\s*,?' +\r\n    '\\\\s*(' + fabric.reNum + '+)\\\\s*,?' +\r\n    '\\\\s*(' + fabric.reNum + '+)\\\\s*' +\r\n    '$'\r\n  );\r\n\r\n  /**\r\n   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements\r\n   */\r\n  function applyViewboxTransform(element) {\r\n\r\n    var viewBoxAttr = element.getAttribute('viewBox'),\r\n        scaleX = 1,\r\n        scaleY = 1,\r\n        minX = 0,\r\n        minY = 0,\r\n        viewBoxWidth, viewBoxHeight, matrix, el,\r\n        widthAttr = element.getAttribute('width'),\r\n        heightAttr = element.getAttribute('height'),\r\n        x = element.getAttribute('x') || 0,\r\n        y = element.getAttribute('y') || 0,\r\n        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',\r\n        missingViewBox = (!viewBoxAttr || !reViewBoxTagNames.test(element.tagName)\r\n                           || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),\r\n        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),\r\n        toBeParsed = missingViewBox && missingDimAttr,\r\n        parsedDim = { }, translateMatrix = '';\r\n\r\n    parsedDim.width = 0;\r\n    parsedDim.height = 0;\r\n    parsedDim.toBeParsed = toBeParsed;\r\n\r\n    if (toBeParsed) {\r\n      return parsedDim;\r\n    }\r\n\r\n    if (missingViewBox) {\r\n      parsedDim.width = parseUnit(widthAttr);\r\n      parsedDim.height = parseUnit(heightAttr);\r\n      return parsedDim;\r\n    }\r\n\r\n    minX = -parseFloat(viewBoxAttr[1]),\r\n    minY = -parseFloat(viewBoxAttr[2]),\r\n    viewBoxWidth = parseFloat(viewBoxAttr[3]),\r\n    viewBoxHeight = parseFloat(viewBoxAttr[4]);\r\n\r\n    if (!missingDimAttr) {\r\n      parsedDim.width = parseUnit(widthAttr);\r\n      parsedDim.height = parseUnit(heightAttr);\r\n      scaleX = parsedDim.width / viewBoxWidth;\r\n      scaleY = parsedDim.height / viewBoxHeight;\r\n    }\r\n    else {\r\n      parsedDim.width = viewBoxWidth;\r\n      parsedDim.height = viewBoxHeight;\r\n    }\r\n\r\n    // default is to preserve aspect ratio\r\n    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);\r\n    if (preserveAspectRatio.alignX !== 'none') {\r\n      //translate all container for the effect of Mid, Min, Max\r\n      scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);\r\n    }\r\n\r\n    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {\r\n      return parsedDim;\r\n    }\r\n\r\n    if (x || y) {\r\n      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';\r\n    }\r\n\r\n    matrix = translateMatrix + ' matrix(' + scaleX +\r\n                  ' 0' +\r\n                  ' 0 ' +\r\n                  scaleY + ' ' +\r\n                  (minX * scaleX) + ' ' +\r\n                  (minY * scaleY) + ') ';\r\n\r\n    if (element.tagName === 'svg') {\r\n      el = element.ownerDocument.createElement('g');\r\n      while (element.firstChild != null) {\r\n        el.appendChild(element.firstChild);\r\n      }\r\n      element.appendChild(el);\r\n    }\r\n    else {\r\n      el = element;\r\n      matrix = el.getAttribute('transform') + matrix;\r\n    }\r\n\r\n    el.setAttribute('transform', matrix);\r\n    return parsedDim;\r\n  }\r\n\r\n  /**\r\n   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback\r\n   * @static\r\n   * @function\r\n   * @memberOf fabric\r\n   * @param {SVGDocument} doc SVG document to parse\r\n   * @param {Function} callback Callback to call when parsing is finished; It's being passed an array of elements (parsed from a document).\r\n   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\r\n   */\r\n  fabric.parseSVGDocument = (function() {\r\n\r\n    function hasAncestorWithNodeName(element, nodeName) {\r\n      while (element && (element = element.parentNode)) {\r\n        if (nodeName.test(element.nodeName) && !element.getAttribute('instantiated_by_use')) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    return function(doc, callback, reviver) {\r\n      if (!doc) {\r\n        return;\r\n      }\r\n\r\n      parseUseDirectives(doc);\r\n\r\n      var startTime = new Date(),\r\n          svgUid =  fabric.Object.__uid++,\r\n          options = applyViewboxTransform(doc),\r\n          descendants = fabric.util.toArray(doc.getElementsByTagName('*'));\r\n\r\n      options.svgUid = svgUid;\r\n\r\n      if (descendants.length === 0 && fabric.isLikelyNode) {\r\n        // we're likely in node, where \"o3-xml\" library fails to gEBTN(\"*\")\r\n        // https://github.com/ajaxorg/node-o3-xml/issues/21\r\n        descendants = doc.selectNodes('//*[name(.)!=\"svg\"]');\r\n        var arr = [ ];\r\n        for (var i = 0, len = descendants.length; i < len; i++) {\r\n          arr[i] = descendants[i];\r\n        }\r\n        descendants = arr;\r\n      }\r\n\r\n      var elements = descendants.filter(function(el) {\r\n        applyViewboxTransform(el);\r\n        return reAllowedSVGTagNames.test(el.tagName) &&\r\n              !hasAncestorWithNodeName(el, reNotAllowedAncestors); // http://www.w3.org/TR/SVG/struct.html#DefsElement\r\n      });\r\n\r\n      if (!elements || (elements && !elements.length)) {\r\n        callback && callback([], {});\r\n        return;\r\n      }\r\n\r\n      fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);\r\n      fabric.cssRules[svgUid] = fabric.getCSSRules(doc);\r\n      // Precedence of rules:   style > class > attribute\r\n      fabric.parseElements(elements, function(instances) {\r\n        fabric.documentParsingTime = new Date() - startTime;\r\n        if (callback) {\r\n          callback(instances, options);\r\n        }\r\n      }, clone(options), reviver);\r\n    };\r\n  })();\r\n\r\n  /**\r\n   * Used for caching SVG documents (loaded via `fabric.Canvas#loadSVGFromURL`)\r\n   * @namespace\r\n   */\r\n  var svgCache = {\r\n\r\n    /**\r\n     * @param {String} name\r\n     * @param {Function} callback\r\n     */\r\n    has: function (name, callback) {\r\n      callback(false);\r\n    },\r\n\r\n    get: function () {\r\n      /* NOOP */\r\n    },\r\n\r\n    set: function () {\r\n      /* NOOP */\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function _enlivenCachedObject(cachedObject) {\r\n\r\n    var objects = cachedObject.objects,\r\n        options = cachedObject.options;\r\n\r\n    objects = objects.map(function (o) {\r\n      return fabric[capitalize(o.type)].fromObject(o);\r\n    });\r\n\r\n    return ({ objects: objects, options: options });\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function _createSVGPattern(markup, canvas, property) {\r\n    if (canvas[property] && canvas[property].toSVG) {\r\n      markup.push(\r\n        '\\t<pattern x=\"0\" y=\"0\" id=\"', property, 'Pattern\" ',\r\n          'width=\"', canvas[property].source.width,\r\n          '\" height=\"', canvas[property].source.height,\r\n          '\" patternUnits=\"userSpaceOnUse\">\\n',\r\n        '\\t\\t<image x=\"0\" y=\"0\" ',\r\n        'width=\"', canvas[property].source.width,\r\n        '\" height=\"', canvas[property].source.height,\r\n        '\" xlink:href=\"', canvas[property].source.src,\r\n        '\"></image>\\n\\t</pattern>\\n'\r\n      );\r\n    }\r\n  }\r\n\r\n  var reFontDeclaration = new RegExp(\r\n    '(normal|italic)?\\\\s*(normal|small-caps)?\\\\s*' +\r\n    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\\\s*(' +\r\n      fabric.reNum +\r\n    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\\\/(normal|' + fabric.reNum + '))?\\\\s+(.*)');\r\n\r\n  extend(fabric, {\r\n    /**\r\n     * Parses a short font declaration, building adding its properties to a style object\r\n     * @static\r\n     * @function\r\n     * @memberOf fabric\r\n     * @param {String} value font declaration\r\n     * @param {Object} oStyle definition\r\n     */\r\n    parseFontDeclaration: function(value, oStyle) {\r\n      var match = value.match(reFontDeclaration);\r\n\r\n      if (!match) {\r\n        return;\r\n      }\r\n      var fontStyle = match[1],\r\n          // font variant is not used\r\n          // fontVariant = match[2],\r\n          fontWeight = match[3],\r\n          fontSize = match[4],\r\n          lineHeight = match[5],\r\n          fontFamily = match[6];\r\n\r\n      if (fontStyle) {\r\n        oStyle.fontStyle = fontStyle;\r\n      }\r\n      if (fontWeight) {\r\n        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);\r\n      }\r\n      if (fontSize) {\r\n        oStyle.fontSize = parseUnit(fontSize);\r\n      }\r\n      if (fontFamily) {\r\n        oStyle.fontFamily = fontFamily;\r\n      }\r\n      if (lineHeight) {\r\n        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Parses an SVG document, returning all of the gradient declarations found in it\r\n     * @static\r\n     * @function\r\n     * @memberOf fabric\r\n     * @param {SVGDocument} doc SVG document to parse\r\n     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element\r\n     */\r\n    getGradientDefs: function(doc) {\r\n      var linearGradientEls = doc.getElementsByTagName('linearGradient'),\r\n          radialGradientEls = doc.getElementsByTagName('radialGradient'),\r\n          el, i, j = 0, id, xlink, elList = [ ],\r\n          gradientDefs = { }, idsToXlinkMap = { };\r\n\r\n      elList.length = linearGradientEls.length + radialGradientEls.length;\r\n      i = linearGradientEls.length;\r\n      while (i--) {\r\n        elList[j++] = linearGradientEls[i];\r\n      }\r\n      i = radialGradientEls.length;\r\n      while (i--) {\r\n        elList[j++] = radialGradientEls[i];\r\n      }\r\n\r\n      while (j--) {\r\n        el = elList[j];\r\n        xlink = el.getAttribute('xlink:href');\r\n        id = el.getAttribute('id');\r\n        if (xlink) {\r\n          idsToXlinkMap[id] = xlink.substr(1);\r\n        }\r\n        gradientDefs[id] = el;\r\n      }\r\n\r\n      for (id in idsToXlinkMap) {\r\n        var el2 = gradientDefs[idsToXlinkMap[id]].cloneNode(true);\r\n        el = gradientDefs[id];\r\n        while (el2.firstChild) {\r\n          el.appendChild(el2.firstChild);\r\n        }\r\n      }\r\n      return gradientDefs;\r\n    },\r\n\r\n    /**\r\n     * Returns an object of attributes' name/value, given element and an array of attribute names;\r\n     * Parses parent \"g\" nodes recursively upwards.\r\n     * @static\r\n     * @memberOf fabric\r\n     * @param {DOMElement} element Element to parse\r\n     * @param {Array} attributes Array of attributes to parse\r\n     * @return {Object} object containing parsed attributes' names/values\r\n     */\r\n    parseAttributes: function(element, attributes, svgUid) {\r\n\r\n      if (!element) {\r\n        return;\r\n      }\r\n\r\n      var value,\r\n          parentAttributes = { },\r\n          fontSize;\r\n\r\n      if (typeof svgUid === 'undefined') {\r\n        svgUid = element.getAttribute('svgUid');\r\n      }\r\n      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards\r\n      if (element.parentNode && reAllowedParents.test(element.parentNode.nodeName)) {\r\n        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);\r\n      }\r\n      fontSize = (parentAttributes && parentAttributes.fontSize ) ||\r\n                 element.getAttribute('font-size') || fabric.Text.DEFAULT_SVG_FONT_SIZE;\r\n\r\n      var ownAttributes = attributes.reduce(function(memo, attr) {\r\n        value = element.getAttribute(attr);\r\n        if (value) {\r\n          attr = normalizeAttr(attr);\r\n          value = normalizeValue(attr, value, parentAttributes, fontSize);\r\n\r\n          memo[attr] = value;\r\n        }\r\n        return memo;\r\n      }, { });\r\n\r\n      // add values parsed from style, which take precedence over attributes\r\n      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)\r\n      ownAttributes = extend(ownAttributes,\r\n        extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element)));\r\n      if (ownAttributes.font) {\r\n        fabric.parseFontDeclaration(ownAttributes.font, ownAttributes);\r\n      }\r\n      return _setStrokeFillOpacity(extend(parentAttributes, ownAttributes));\r\n    },\r\n\r\n    /**\r\n     * Transforms an array of svg elements to corresponding fabric.* instances\r\n     * @static\r\n     * @memberOf fabric\r\n     * @param {Array} elements Array of elements to parse\r\n     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)\r\n     * @param {Object} [options] Options object\r\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\r\n     */\r\n    parseElements: function(elements, callback, options, reviver) {\r\n      new fabric.ElementsParser(elements, callback, options, reviver).parse();\r\n    },\r\n\r\n    /**\r\n     * Parses \"style\" attribute, retuning an object with values\r\n     * @static\r\n     * @memberOf fabric\r\n     * @param {SVGElement} element Element to parse\r\n     * @return {Object} Objects with values parsed from style attribute of an element\r\n     */\r\n    parseStyleAttribute: function(element) {\r\n      var oStyle = { },\r\n          style = element.getAttribute('style');\r\n\r\n      if (!style) {\r\n        return oStyle;\r\n      }\r\n\r\n      if (typeof style === 'string') {\r\n        parseStyleString(style, oStyle);\r\n      }\r\n      else {\r\n        parseStyleObject(style, oStyle);\r\n      }\r\n\r\n      return oStyle;\r\n    },\r\n\r\n    /**\r\n     * Parses \"points\" attribute, returning an array of values\r\n     * @static\r\n     * @memberOf fabric\r\n     * @param {String} points points attribute string\r\n     * @return {Array} array of points\r\n     */\r\n    parsePointsAttribute: function(points) {\r\n\r\n      // points attribute is required and must not be empty\r\n      if (!points) {\r\n        return null;\r\n      }\r\n\r\n      // replace commas with whitespace and remove bookending whitespace\r\n      points = points.replace(/,/g, ' ').trim();\r\n\r\n      points = points.split(/\\s+/);\r\n      var parsedPoints = [ ], i, len;\r\n\r\n      i = 0;\r\n      len = points.length;\r\n      for (; i < len; i+=2) {\r\n        parsedPoints.push({\r\n          x: parseFloat(points[i]),\r\n          y: parseFloat(points[i + 1])\r\n        });\r\n      }\r\n\r\n      // odd number of points is an error\r\n      // if (parsedPoints.length % 2 !== 0) {\r\n      //   return null;\r\n      // }\r\n\r\n      return parsedPoints;\r\n    },\r\n\r\n    /**\r\n     * Returns CSS rules for a given SVG document\r\n     * @static\r\n     * @function\r\n     * @memberOf fabric\r\n     * @param {SVGDocument} doc SVG document to parse\r\n     * @return {Object} CSS rules of this document\r\n     */\r\n    getCSSRules: function(doc) {\r\n      var styles = doc.getElementsByTagName('style'),\r\n          allRules = { }, rules;\r\n\r\n      // very crude parsing of style contents\r\n      for (var i = 0, len = styles.length; i < len; i++) {\r\n        var styleContents = styles[i].textContent;\r\n\r\n        // remove comments\r\n        styleContents = styleContents.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');\r\n        if (styleContents.trim() === '') {\r\n          continue;\r\n        }\r\n        rules = styleContents.match(/[^{]*\\{[\\s\\S]*?\\}/g);\r\n        rules = rules.map(function(rule) { return rule.trim(); });\r\n\r\n        rules.forEach(function(rule) {\r\n\r\n          var match = rule.match(/([\\s\\S]*?)\\s*\\{([^}]*)\\}/),\r\n          ruleObj = { }, declaration = match[2].trim(),\r\n          propertyValuePairs = declaration.replace(/;$/, '').split(/\\s*;\\s*/);\r\n\r\n          for (var i = 0, len = propertyValuePairs.length; i < len; i++) {\r\n            var pair = propertyValuePairs[i].split(/\\s*:\\s*/),\r\n                property = normalizeAttr(pair[0]),\r\n                value = normalizeValue(property, pair[1], pair[0]);\r\n            ruleObj[property] = value;\r\n          }\r\n          rule = match[1];\r\n          rule.split(',').forEach(function(_rule) {\r\n            _rule = _rule.replace(/^svg/i, '').trim();\r\n            if (_rule === '') {\r\n              return;\r\n            }\r\n            allRules[_rule] = fabric.util.object.clone(ruleObj);\r\n          });\r\n        });\r\n      }\r\n      return allRules;\r\n    },\r\n\r\n    /**\r\n     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects. Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)\r\n     * @memberOf fabric\r\n     * @param {String} url\r\n     * @param {Function} callback\r\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\r\n     */\r\n    loadSVGFromURL: function(url, callback, reviver) {\r\n\r\n      url = url.replace(/^\\n\\s*/, '').trim();\r\n      svgCache.has(url, function (hasUrl) {\r\n        if (hasUrl) {\r\n          svgCache.get(url, function (value) {\r\n            var enlivedRecord = _enlivenCachedObject(value);\r\n            callback(enlivedRecord.objects, enlivedRecord.options);\r\n          });\r\n        }\r\n        else {\r\n          new fabric.util.request(url, {\r\n            method: 'get',\r\n            onComplete: onComplete\r\n          });\r\n        }\r\n      });\r\n\r\n      function onComplete(r) {\r\n\r\n        var xml = r.responseXML;\r\n        if (xml && !xml.documentElement && fabric.window.ActiveXObject && r.responseText) {\r\n          xml = new ActiveXObject('Microsoft.XMLDOM');\r\n          xml.async = 'false';\r\n          //IE chokes on DOCTYPE\r\n          xml.loadXML(r.responseText.replace(/<!DOCTYPE[\\s\\S]*?(\\[[\\s\\S]*\\])*?>/i, ''));\r\n        }\r\n        if (!xml || !xml.documentElement) {\r\n          return;\r\n        }\r\n\r\n        fabric.parseSVGDocument(xml.documentElement, function (results, options) {\r\n          svgCache.set(url, {\r\n            objects: fabric.util.array.invoke(results, 'toObject'),\r\n            options: options\r\n          });\r\n          callback(results, options);\r\n        }, reviver);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects\r\n     * @memberOf fabric\r\n     * @param {String} string\r\n     * @param {Function} callback\r\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\r\n     */\r\n    loadSVGFromString: function(string, callback, reviver) {\r\n      string = string.trim();\r\n      var doc;\r\n      if (typeof DOMParser !== 'undefined') {\r\n        var parser = new DOMParser();\r\n        if (parser && parser.parseFromString) {\r\n          doc = parser.parseFromString(string, 'text/xml');\r\n        }\r\n      }\r\n      else if (fabric.window.ActiveXObject) {\r\n        doc = new ActiveXObject('Microsoft.XMLDOM');\r\n        doc.async = 'false';\r\n        // IE chokes on DOCTYPE\r\n        doc.loadXML(string.replace(/<!DOCTYPE[\\s\\S]*?(\\[[\\s\\S]*\\])*?>/i, ''));\r\n      }\r\n\r\n      fabric.parseSVGDocument(doc.documentElement, function (results, options) {\r\n        callback(results, options);\r\n      }, reviver);\r\n    },\r\n\r\n    /**\r\n     * Creates markup containing SVG font faces\r\n     * @param {Array} objects Array of fabric objects\r\n     * @return {String}\r\n     */\r\n    createSVGFontFacesMarkup: function(objects) {\r\n      var markup = '';\r\n\r\n      for (var i = 0, len = objects.length; i < len; i++) {\r\n        if (objects[i].type !== 'text' || !objects[i].path) {\r\n          continue;\r\n        }\r\n\r\n        markup += [\r\n          //jscs:disable validateIndentation\r\n          '@font-face {',\r\n            'font-family: ', objects[i].fontFamily, '; ',\r\n            'src: url(\\'', objects[i].path, '\\')',\r\n          '}\\n'\r\n          //jscs:enable validateIndentation\r\n        ].join('');\r\n      }\r\n\r\n      if (markup) {\r\n        markup = [\r\n          //jscs:disable validateIndentation\r\n          '\\t<style type=\"text/css\">',\r\n            '<![CDATA[',\r\n              markup,\r\n            ']]>',\r\n          '</style>\\n'\r\n          //jscs:enable validateIndentation\r\n        ].join('');\r\n      }\r\n\r\n      return markup;\r\n    },\r\n\r\n    /**\r\n     * Creates markup containing SVG referenced elements like patterns, gradients etc.\r\n     * @param {fabric.Canvas} canvas instance of fabric.Canvas\r\n     * @return {String}\r\n     */\r\n    createSVGRefElementsMarkup: function(canvas) {\r\n      var markup = [ ];\r\n\r\n      _createSVGPattern(markup, canvas, 'backgroundColor');\r\n      _createSVGPattern(markup, canvas, 'overlayColor');\r\n\r\n      return markup.join('');\r\n    }\r\n  });\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\nfabric.ElementsParser = function(elements, callback, options, reviver) {\r\n  this.elements = elements;\r\n  this.callback = callback;\r\n  this.options = options;\r\n  this.reviver = reviver;\r\n  this.svgUid = (options && options.svgUid) || 0;\r\n};\r\n\r\nfabric.ElementsParser.prototype.parse = function() {\r\n  this.instances = new Array(this.elements.length);\r\n  this.numElements = this.elements.length;\r\n\r\n  this.createObjects();\r\n};\r\n\r\nfabric.ElementsParser.prototype.createObjects = function() {\r\n  for (var i = 0, len = this.elements.length; i < len; i++) {\r\n    this.elements[i].setAttribute('svgUid', this.svgUid);\r\n    (function(_this, i) {\r\n      setTimeout(function() {\r\n        _this.createObject(_this.elements[i], i);\r\n      }, 0);\r\n    })(this, i);\r\n  }\r\n};\r\n\r\nfabric.ElementsParser.prototype.createObject = function(el, index) {\r\n  var klass = fabric[fabric.util.string.capitalize(el.tagName)];\r\n  if (klass && klass.fromElement) {\r\n    try {\r\n      this._createObject(klass, el, index);\r\n    }\r\n    catch (err) {\r\n      fabric.log(err);\r\n    }\r\n  }\r\n  else {\r\n    this.checkIfDone();\r\n  }\r\n};\r\n\r\nfabric.ElementsParser.prototype._createObject = function(klass, el, index) {\r\n  if (klass.async) {\r\n    klass.fromElement(el, this.createCallback(index, el), this.options);\r\n  }\r\n  else {\r\n    var obj = klass.fromElement(el, this.options);\r\n    this.resolveGradient(obj, 'fill');\r\n    this.resolveGradient(obj, 'stroke');\r\n    this.reviver && this.reviver(el, obj);\r\n    this.instances[index] = obj;\r\n    this.checkIfDone();\r\n  }\r\n};\r\n\r\nfabric.ElementsParser.prototype.createCallback = function(index, el) {\r\n  var _this = this;\r\n  return function(obj) {\r\n    _this.resolveGradient(obj, 'fill');\r\n    _this.resolveGradient(obj, 'stroke');\r\n    _this.reviver && _this.reviver(el, obj);\r\n    _this.instances[index] = obj;\r\n    _this.checkIfDone();\r\n  };\r\n};\r\n\r\nfabric.ElementsParser.prototype.resolveGradient = function(obj, property) {\r\n\r\n  var instanceFillValue = obj.get(property);\r\n  if (!(/^url\\(/).test(instanceFillValue)) {\r\n    return;\r\n  }\r\n  var gradientId = instanceFillValue.slice(5, instanceFillValue.length - 1);\r\n  if (fabric.gradientDefs[this.svgUid][gradientId]) {\r\n    obj.set(property,\r\n      fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][gradientId], obj));\r\n  }\r\n};\r\n\r\nfabric.ElementsParser.prototype.checkIfDone = function() {\r\n  if (--this.numElements === 0) {\r\n    this.instances = this.instances.filter(function(el) {\r\n      return el != null;\r\n    });\r\n    this.callback(this.instances);\r\n  }\r\n};\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */\r\n\r\n  var fabric = global.fabric || (global.fabric = { });\r\n\r\n  if (fabric.Point) {\r\n    fabric.warn('fabric.Point is already defined');\r\n    return;\r\n  }\r\n\r\n  fabric.Point = Point;\r\n\r\n  /**\r\n   * Point class\r\n   * @class fabric.Point\r\n   * @memberOf fabric\r\n   * @constructor\r\n   * @param {Number} x\r\n   * @param {Number} y\r\n   * @return {fabric.Point} thisArg\r\n   */\r\n  function Point(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  Point.prototype = /** @lends fabric.Point.prototype */ {\r\n\r\n    constructor: Point,\r\n\r\n    /**\r\n     * Adds another point to this one and returns another one\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point} new Point instance with added values\r\n     */\r\n    add: function (that) {\r\n      return new Point(this.x + that.x, this.y + that.y);\r\n    },\r\n\r\n    /**\r\n     * Adds another point to this one\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point} thisArg\r\n     */\r\n    addEquals: function (that) {\r\n      this.x += that.x;\r\n      this.y += that.y;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Adds value to this point and returns a new one\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point} new Point with added value\r\n     */\r\n    scalarAdd: function (scalar) {\r\n      return new Point(this.x + scalar, this.y + scalar);\r\n    },\r\n\r\n    /**\r\n     * Adds value to this point\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point} thisArg\r\n     */\r\n    scalarAddEquals: function (scalar) {\r\n      this.x += scalar;\r\n      this.y += scalar;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Subtracts another point from this point and returns a new one\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point} new Point object with subtracted values\r\n     */\r\n    subtract: function (that) {\r\n      return new Point(this.x - that.x, this.y - that.y);\r\n    },\r\n\r\n    /**\r\n     * Subtracts another point from this point\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point} thisArg\r\n     */\r\n    subtractEquals: function (that) {\r\n      this.x -= that.x;\r\n      this.y -= that.y;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Subtracts value from this point and returns a new one\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point}\r\n     */\r\n    scalarSubtract: function (scalar) {\r\n      return new Point(this.x - scalar, this.y - scalar);\r\n    },\r\n\r\n    /**\r\n     * Subtracts value from this point\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point} thisArg\r\n     */\r\n    scalarSubtractEquals: function (scalar) {\r\n      this.x -= scalar;\r\n      this.y -= scalar;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Miltiplies this point by a value and returns a new one\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point}\r\n     */\r\n    multiply: function (scalar) {\r\n      return new Point(this.x * scalar, this.y * scalar);\r\n    },\r\n\r\n    /**\r\n     * Miltiplies this point by a value\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point} thisArg\r\n     */\r\n    multiplyEquals: function (scalar) {\r\n      this.x *= scalar;\r\n      this.y *= scalar;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Divides this point by a value and returns a new one\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point}\r\n     */\r\n    divide: function (scalar) {\r\n      return new Point(this.x / scalar, this.y / scalar);\r\n    },\r\n\r\n    /**\r\n     * Divides this point by a value\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point} thisArg\r\n     */\r\n    divideEquals: function (scalar) {\r\n      this.x /= scalar;\r\n      this.y /= scalar;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns true if this point is equal to another one\r\n     * @param {fabric.Point} that\r\n     * @return {Boolean}\r\n     */\r\n    eq: function (that) {\r\n      return (this.x === that.x && this.y === that.y);\r\n    },\r\n\r\n    /**\r\n     * Returns true if this point is less than another one\r\n     * @param {fabric.Point} that\r\n     * @return {Boolean}\r\n     */\r\n    lt: function (that) {\r\n      return (this.x < that.x && this.y < that.y);\r\n    },\r\n\r\n    /**\r\n     * Returns true if this point is less than or equal to another one\r\n     * @param {fabric.Point} that\r\n     * @return {Boolean}\r\n     */\r\n    lte: function (that) {\r\n      return (this.x <= that.x && this.y <= that.y);\r\n    },\r\n\r\n    /**\r\n\r\n     * Returns true if this point is greater another one\r\n     * @param {fabric.Point} that\r\n     * @return {Boolean}\r\n     */\r\n    gt: function (that) {\r\n      return (this.x > that.x && this.y > that.y);\r\n    },\r\n\r\n    /**\r\n     * Returns true if this point is greater than or equal to another one\r\n     * @param {fabric.Point} that\r\n     * @return {Boolean}\r\n     */\r\n    gte: function (that) {\r\n      return (this.x >= that.x && this.y >= that.y);\r\n    },\r\n\r\n    /**\r\n     * Returns new point which is the result of linear interpolation with this one and another one\r\n     * @param {fabric.Point} that\r\n     * @param {Number} t\r\n     * @return {fabric.Point}\r\n     */\r\n    lerp: function (that, t) {\r\n      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);\r\n    },\r\n\r\n    /**\r\n     * Returns distance from this point and another one\r\n     * @param {fabric.Point} that\r\n     * @return {Number}\r\n     */\r\n    distanceFrom: function (that) {\r\n      var dx = this.x - that.x,\r\n          dy = this.y - that.y;\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n    },\r\n\r\n    /**\r\n     * Returns the point between this point and another one\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point}\r\n     */\r\n    midPointFrom: function (that) {\r\n      return new Point(this.x + (that.x - this.x)/2, this.y + (that.y - this.y)/2);\r\n    },\r\n\r\n    /**\r\n     * Returns a new point which is the min of this and another one\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point}\r\n     */\r\n    min: function (that) {\r\n      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));\r\n    },\r\n\r\n    /**\r\n     * Returns a new point which is the max of this and another one\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point}\r\n     */\r\n    max: function (that) {\r\n      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));\r\n    },\r\n\r\n    /**\r\n     * Returns string representation of this point\r\n     * @return {String}\r\n     */\r\n    toString: function () {\r\n      return this.x + ',' + this.y;\r\n    },\r\n\r\n    /**\r\n     * Sets x/y of this point\r\n     * @param {Number} x\r\n     * @param {Number} y\r\n     */\r\n    setXY: function (x, y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    },\r\n\r\n    /**\r\n     * Sets x/y of this point from another point\r\n     * @param {fabric.Point} that\r\n     */\r\n    setFromPoint: function (that) {\r\n      this.x = that.x;\r\n      this.y = that.y;\r\n    },\r\n\r\n    /**\r\n     * Swaps x/y of this point and another point\r\n     * @param {fabric.Point} that\r\n     */\r\n    swap: function (that) {\r\n      var x = this.x,\r\n          y = this.y;\r\n      this.x = that.x;\r\n      this.y = that.y;\r\n      that.x = x;\r\n      that.y = y;\r\n    }\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */\r\n  var fabric = global.fabric || (global.fabric = { });\r\n\r\n  if (fabric.Intersection) {\r\n    fabric.warn('fabric.Intersection is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Intersection class\r\n   * @class fabric.Intersection\r\n   * @memberOf fabric\r\n   * @constructor\r\n   */\r\n  function Intersection(status) {\r\n    this.status = status;\r\n    this.points = [];\r\n  }\r\n\r\n  fabric.Intersection = Intersection;\r\n\r\n  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {\r\n\r\n    /**\r\n     * Appends a point to intersection\r\n     * @param {fabric.Point} point\r\n     */\r\n    appendPoint: function (point) {\r\n      this.points.push(point);\r\n    },\r\n\r\n    /**\r\n     * Appends points to intersection\r\n     * @param {Array} points\r\n     */\r\n    appendPoints: function (points) {\r\n      this.points = this.points.concat(points);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Checks if one line intersects another\r\n   * @static\r\n   * @param {fabric.Point} a1\r\n   * @param {fabric.Point} a2\r\n   * @param {fabric.Point} b1\r\n   * @param {fabric.Point} b2\r\n   * @return {fabric.Intersection}\r\n   */\r\n  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {\r\n    var result,\r\n        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),\r\n        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),\r\n        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\r\n    if (uB !== 0) {\r\n      var ua = uaT / uB,\r\n          ub = ubT / uB;\r\n      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\r\n        result = new Intersection('Intersection');\r\n        result.points.push(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));\r\n      }\r\n      else {\r\n        result = new Intersection();\r\n      }\r\n    }\r\n    else {\r\n      if (uaT === 0 || ubT === 0) {\r\n        result = new Intersection('Coincident');\r\n      }\r\n      else {\r\n        result = new Intersection('Parallel');\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Checks if line intersects polygon\r\n   * @static\r\n   * @param {fabric.Point} a1\r\n   * @param {fabric.Point} a2\r\n   * @param {Array} points\r\n   * @return {fabric.Intersection}\r\n   */\r\n  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {\r\n    var result = new Intersection(),\r\n        length = points.length;\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      var b1 = points[i],\r\n          b2 = points[(i + 1) % length],\r\n          inter = Intersection.intersectLineLine(a1, a2, b1, b2);\r\n\r\n      result.appendPoints(inter.points);\r\n    }\r\n    if (result.points.length > 0) {\r\n      result.status = 'Intersection';\r\n    }\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Checks if polygon intersects another polygon\r\n   * @static\r\n   * @param {Array} points1\r\n   * @param {Array} points2\r\n   * @return {fabric.Intersection}\r\n   */\r\n  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {\r\n    var result = new Intersection(),\r\n        length = points1.length;\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      var a1 = points1[i],\r\n          a2 = points1[(i + 1) % length],\r\n          inter = Intersection.intersectLinePolygon(a1, a2, points2);\r\n\r\n      result.appendPoints(inter.points);\r\n    }\r\n    if (result.points.length > 0) {\r\n      result.status = 'Intersection';\r\n    }\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Checks if polygon intersects rectangle\r\n   * @static\r\n   * @param {Array} points\r\n   * @param {Number} r1\r\n   * @param {Number} r2\r\n   * @return {fabric.Intersection}\r\n   */\r\n  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {\r\n    var min = r1.min(r2),\r\n        max = r1.max(r2),\r\n        topRight = new fabric.Point(max.x, min.y),\r\n        bottomLeft = new fabric.Point(min.x, max.y),\r\n        inter1 = Intersection.intersectLinePolygon(min, topRight, points),\r\n        inter2 = Intersection.intersectLinePolygon(topRight, max, points),\r\n        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),\r\n        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),\r\n        result = new Intersection();\r\n\r\n    result.appendPoints(inter1.points);\r\n    result.appendPoints(inter2.points);\r\n    result.appendPoints(inter3.points);\r\n    result.appendPoints(inter4.points);\r\n\r\n    if (result.points.length > 0) {\r\n      result.status = 'Intersection';\r\n    }\r\n    return result;\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { });\r\n\r\n  if (fabric.Color) {\r\n    fabric.warn('fabric.Color is already defined.');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Color class\r\n   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;\r\n   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.\r\n   *\r\n   * @class fabric.Color\r\n   * @param {String} color optional in hex or rgb(a) format\r\n   * @return {fabric.Color} thisArg\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}\r\n   */\r\n  function Color(color) {\r\n    if (!color) {\r\n      this.setSource([0, 0, 0, 1]);\r\n    }\r\n    else {\r\n      this._tryParsingColor(color);\r\n    }\r\n  }\r\n\r\n  fabric.Color = Color;\r\n\r\n  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {\r\n\r\n    /**\r\n     * @private\r\n     * @param {String|Array} color Color value to parse\r\n     */\r\n    _tryParsingColor: function(color) {\r\n      var source;\r\n\r\n      if (color in Color.colorNameMap) {\r\n        color = Color.colorNameMap[color];\r\n      }\r\n\r\n      if (color === 'transparent') {\r\n        this.setSource([255, 255, 255, 0]);\r\n        return;\r\n      }\r\n\r\n      source = Color.sourceFromHex(color);\r\n\r\n      if (!source) {\r\n        source = Color.sourceFromRgb(color);\r\n      }\r\n      if (!source) {\r\n        source = Color.sourceFromHsl(color);\r\n      }\r\n      if (source) {\r\n        this.setSource(source);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\r\n     * @private\r\n     * @param {Number} r Red color value\r\n     * @param {Number} g Green color value\r\n     * @param {Number} b Blue color value\r\n     * @return {Array} Hsl color\r\n     */\r\n    _rgbToHsl: function(r, g, b) {\r\n      r /= 255, g /= 255, b /= 255;\r\n\r\n      var h, s, l,\r\n          max = fabric.util.array.max([r, g, b]),\r\n          min = fabric.util.array.min([r, g, b]);\r\n\r\n      l = (max + min) / 2;\r\n\r\n      if (max === min) {\r\n        h = s = 0; // achromatic\r\n      }\r\n      else {\r\n        var d = max - min;\r\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n        switch (max) {\r\n          case r:\r\n            h = (g - b) / d + (g < b ? 6 : 0);\r\n            break;\r\n          case g:\r\n            h = (b - r) / d + 2;\r\n            break;\r\n          case b:\r\n            h = (r - g) / d + 4;\r\n            break;\r\n        }\r\n        h /= 6;\r\n      }\r\n\r\n      return [\r\n        Math.round(h * 360),\r\n        Math.round(s * 100),\r\n        Math.round(l * 100)\r\n      ];\r\n    },\r\n\r\n    /**\r\n     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])\r\n     * @return {Array}\r\n     */\r\n    getSource: function() {\r\n      return this._source;\r\n    },\r\n\r\n    /**\r\n     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])\r\n     * @param {Array} source\r\n     */\r\n    setSource: function(source) {\r\n      this._source = source;\r\n    },\r\n\r\n    /**\r\n     * Returns color represenation in RGB format\r\n     * @return {String} ex: rgb(0-255,0-255,0-255)\r\n     */\r\n    toRgb: function() {\r\n      var source = this.getSource();\r\n      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';\r\n    },\r\n\r\n    /**\r\n     * Returns color represenation in RGBA format\r\n     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)\r\n     */\r\n    toRgba: function() {\r\n      var source = this.getSource();\r\n      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';\r\n    },\r\n\r\n    /**\r\n     * Returns color represenation in HSL format\r\n     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)\r\n     */\r\n    toHsl: function() {\r\n      var source = this.getSource(),\r\n          hsl = this._rgbToHsl(source[0], source[1], source[2]);\r\n\r\n      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';\r\n    },\r\n\r\n    /**\r\n     * Returns color represenation in HSLA format\r\n     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)\r\n     */\r\n    toHsla: function() {\r\n      var source = this.getSource(),\r\n          hsl = this._rgbToHsl(source[0], source[1], source[2]);\r\n\r\n      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';\r\n    },\r\n\r\n    /**\r\n     * Returns color represenation in HEX format\r\n     * @return {String} ex: FF5555\r\n     */\r\n    toHex: function() {\r\n      var source = this.getSource(), r, g, b;\r\n\r\n      r = source[0].toString(16);\r\n      r = (r.length === 1) ? ('0' + r) : r;\r\n\r\n      g = source[1].toString(16);\r\n      g = (g.length === 1) ? ('0' + g) : g;\r\n\r\n      b = source[2].toString(16);\r\n      b = (b.length === 1) ? ('0' + b) : b;\r\n\r\n      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();\r\n    },\r\n\r\n    /**\r\n     * Gets value of alpha channel for this color\r\n     * @return {Number} 0-1\r\n     */\r\n    getAlpha: function() {\r\n      return this.getSource()[3];\r\n    },\r\n\r\n    /**\r\n     * Sets value of alpha channel for this color\r\n     * @param {Number} alpha Alpha value 0-1\r\n     * @return {fabric.Color} thisArg\r\n     */\r\n    setAlpha: function(alpha) {\r\n      var source = this.getSource();\r\n      source[3] = alpha;\r\n      this.setSource(source);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Transforms color to its grayscale representation\r\n     * @return {fabric.Color} thisArg\r\n     */\r\n    toGrayscale: function() {\r\n      var source = this.getSource(),\r\n          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),\r\n          currentAlpha = source[3];\r\n      this.setSource([average, average, average, currentAlpha]);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Transforms color to its black and white representation\r\n     * @param {Number} threshold\r\n     * @return {fabric.Color} thisArg\r\n     */\r\n    toBlackWhite: function(threshold) {\r\n      var source = this.getSource(),\r\n          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),\r\n          currentAlpha = source[3];\r\n\r\n      threshold = threshold || 127;\r\n\r\n      average = (Number(average) < Number(threshold)) ? 0 : 255;\r\n      this.setSource([average, average, average, currentAlpha]);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Overlays color with another color\r\n     * @param {String|fabric.Color} otherColor\r\n     * @return {fabric.Color} thisArg\r\n     */\r\n    overlayWith: function(otherColor) {\r\n      if (!(otherColor instanceof Color)) {\r\n        otherColor = new Color(otherColor);\r\n      }\r\n\r\n      var result = [],\r\n          alpha = this.getAlpha(),\r\n          otherAlpha = 0.5,\r\n          source = this.getSource(),\r\n          otherSource = otherColor.getSource();\r\n\r\n      for (var i = 0; i < 3; i++) {\r\n        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));\r\n      }\r\n\r\n      result[3] = alpha;\r\n      this.setSource(result);\r\n      return this;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))\r\n   * @static\r\n   * @field\r\n   * @memberOf fabric.Color\r\n   */\r\n  fabric.Color.reRGBa = /^rgba?\\(\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*(?:\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/;\r\n\r\n  /**\r\n   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))\r\n   * @static\r\n   * @field\r\n   * @memberOf fabric.Color\r\n   */\r\n  fabric.Color.reHSLa = /^hsla?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}\\%)\\s*,\\s*(\\d{1,3}\\%)\\s*(?:\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/;\r\n\r\n  /**\r\n   * Regex matching color in HEX format (ex: #FF5555, 010155, aff)\r\n   * @static\r\n   * @field\r\n   * @memberOf fabric.Color\r\n   */\r\n  fabric.Color.reHex = /^#?([0-9a-f]{6}|[0-9a-f]{3})$/i;\r\n\r\n  /**\r\n   * Map of the 17 basic color names with HEX code\r\n   * @static\r\n   * @field\r\n   * @memberOf fabric.Color\r\n   * @see: http://www.w3.org/TR/CSS2/syndata.html#color-units\r\n   */\r\n  fabric.Color.colorNameMap = {\r\n    aqua:    '#00FFFF',\r\n    black:   '#000000',\r\n    blue:    '#0000FF',\r\n    fuchsia: '#FF00FF',\r\n    gray:    '#808080',\r\n    green:   '#008000',\r\n    lime:    '#00FF00',\r\n    maroon:  '#800000',\r\n    navy:    '#000080',\r\n    olive:   '#808000',\r\n    orange:  '#FFA500',\r\n    purple:  '#800080',\r\n    red:     '#FF0000',\r\n    silver:  '#C0C0C0',\r\n    teal:    '#008080',\r\n    white:   '#FFFFFF',\r\n    yellow:  '#FFFF00'\r\n  };\r\n\r\n  /**\r\n   * @private\r\n   * @param {Number} p\r\n   * @param {Number} q\r\n   * @param {Number} t\r\n   * @return {Number}\r\n   */\r\n  function hue2rgb(p, q, t) {\r\n    if (t < 0) {\r\n      t += 1;\r\n    }\r\n    if (t > 1) {\r\n      t -= 1;\r\n    }\r\n    if (t < 1/6) {\r\n      return p + (q - p) * 6 * t;\r\n    }\r\n    if (t < 1/2) {\r\n      return q;\r\n    }\r\n    if (t < 2/3) {\r\n      return p + (q - p) * (2/3 - t) * 6;\r\n    }\r\n    return p;\r\n  }\r\n\r\n  /**\r\n   * Returns new color object, when given a color in RGB format\r\n   * @memberOf fabric.Color\r\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)\r\n   * @return {fabric.Color}\r\n   */\r\n  fabric.Color.fromRgb = function(color) {\r\n    return Color.fromSource(Color.sourceFromRgb(color));\r\n  };\r\n\r\n  /**\r\n   * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format\r\n   * @memberOf fabric.Color\r\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)\r\n   * @return {Array} source\r\n   */\r\n  fabric.Color.sourceFromRgb = function(color) {\r\n    var match = color.match(Color.reRGBa);\r\n    if (match) {\r\n      var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),\r\n          g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),\r\n          b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);\r\n\r\n      return [\r\n        parseInt(r, 10),\r\n        parseInt(g, 10),\r\n        parseInt(b, 10),\r\n        match[4] ? parseFloat(match[4]) : 1\r\n      ];\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns new color object, when given a color in RGBA format\r\n   * @static\r\n   * @function\r\n   * @memberOf fabric.Color\r\n   * @param {String} color\r\n   * @return {fabric.Color}\r\n   */\r\n  fabric.Color.fromRgba = Color.fromRgb;\r\n\r\n  /**\r\n   * Returns new color object, when given a color in HSL format\r\n   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)\r\n   * @memberOf fabric.Color\r\n   * @return {fabric.Color}\r\n   */\r\n  fabric.Color.fromHsl = function(color) {\r\n    return Color.fromSource(Color.sourceFromHsl(color));\r\n  };\r\n\r\n  /**\r\n   * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.\r\n   * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\r\n   * @memberOf fabric.Color\r\n   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)\r\n   * @return {Array} source\r\n   * @see http://http://www.w3.org/TR/css3-color/#hsl-color\r\n   */\r\n  fabric.Color.sourceFromHsl = function(color) {\r\n    var match = color.match(Color.reHSLa);\r\n    if (!match) {\r\n      return;\r\n    }\r\n\r\n    var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,\r\n        s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),\r\n        l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),\r\n        r, g, b;\r\n\r\n    if (s === 0) {\r\n      r = g = b = l;\r\n    }\r\n    else {\r\n      var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,\r\n          p = l * 2 - q;\r\n\r\n      r = hue2rgb(p, q, h + 1/3);\r\n      g = hue2rgb(p, q, h);\r\n      b = hue2rgb(p, q, h - 1/3);\r\n    }\r\n\r\n    return [\r\n      Math.round(r * 255),\r\n      Math.round(g * 255),\r\n      Math.round(b * 255),\r\n      match[4] ? parseFloat(match[4]) : 1\r\n    ];\r\n  };\r\n\r\n  /**\r\n   * Returns new color object, when given a color in HSLA format\r\n   * @static\r\n   * @function\r\n   * @memberOf fabric.Color\r\n   * @param {String} color\r\n   * @return {fabric.Color}\r\n   */\r\n  fabric.Color.fromHsla = Color.fromHsl;\r\n\r\n  /**\r\n   * Returns new color object, when given a color in HEX format\r\n   * @static\r\n   * @memberOf fabric.Color\r\n   * @param {String} color Color value ex: FF5555\r\n   * @return {fabric.Color}\r\n   */\r\n  fabric.Color.fromHex = function(color) {\r\n    return Color.fromSource(Color.sourceFromHex(color));\r\n  };\r\n\r\n  /**\r\n   * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in HEX format\r\n   * @static\r\n   * @memberOf fabric.Color\r\n   * @param {String} color ex: FF5555\r\n   * @return {Array} source\r\n   */\r\n  fabric.Color.sourceFromHex = function(color) {\r\n    if (color.match(Color.reHex)) {\r\n      var value = color.slice(color.indexOf('#') + 1),\r\n          isShortNotation = (value.length === 3),\r\n          r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),\r\n          g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),\r\n          b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6);\r\n\r\n      return [\r\n        parseInt(r, 16),\r\n        parseInt(g, 16),\r\n        parseInt(b, 16),\r\n        1\r\n      ];\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])\r\n   * @static\r\n   * @memberOf fabric.Color\r\n   * @param {Array} source\r\n   * @return {fabric.Color}\r\n   */\r\n  fabric.Color.fromSource = function(source) {\r\n    var oColor = new Color();\r\n    oColor.setSource(source);\r\n    return oColor;\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function() {\r\n\r\n  /* _FROM_SVG_START_ */\r\n  function getColorStop(el) {\r\n    var style = el.getAttribute('style'),\r\n        offset = el.getAttribute('offset') || 0,\r\n        color, colorAlpha, opacity;\r\n\r\n    // convert percents to absolute values\r\n    offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);\r\n    offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;\r\n    if (style) {\r\n      var keyValuePairs = style.split(/\\s*;\\s*/);\r\n\r\n      if (keyValuePairs[keyValuePairs.length - 1] === '') {\r\n        keyValuePairs.pop();\r\n      }\r\n\r\n      for (var i = keyValuePairs.length; i--; ) {\r\n\r\n        var split = keyValuePairs[i].split(/\\s*:\\s*/),\r\n            key = split[0].trim(),\r\n            value = split[1].trim();\r\n\r\n        if (key === 'stop-color') {\r\n          color = value;\r\n        }\r\n        else if (key === 'stop-opacity') {\r\n          opacity = value;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!color) {\r\n      color = el.getAttribute('stop-color') || 'rgb(0,0,0)';\r\n    }\r\n    if (!opacity) {\r\n      opacity = el.getAttribute('stop-opacity');\r\n    }\r\n\r\n    color = new fabric.Color(color);\r\n    colorAlpha = color.getAlpha();\r\n    opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);\r\n    opacity *= colorAlpha;\r\n\r\n    return {\r\n      offset: offset,\r\n      color: color.toRgb(),\r\n      opacity: opacity\r\n    };\r\n  }\r\n\r\n  function getLinearCoords(el) {\r\n    return {\r\n      x1: el.getAttribute('x1') || 0,\r\n      y1: el.getAttribute('y1') || 0,\r\n      x2: el.getAttribute('x2') || '100%',\r\n      y2: el.getAttribute('y2') || 0\r\n    };\r\n  }\r\n\r\n  function getRadialCoords(el) {\r\n    return {\r\n      x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',\r\n      y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',\r\n      r1: 0,\r\n      x2: el.getAttribute('cx') || '50%',\r\n      y2: el.getAttribute('cy') || '50%',\r\n      r2: el.getAttribute('r') || '50%'\r\n    };\r\n  }\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Gradient class\r\n   * @class fabric.Gradient\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#gradients}\r\n   * @see {@link fabric.Gradient#initialize} for constructor definition\r\n   */\r\n  fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {\r\n\r\n    /**\r\n     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups\r\n     * @type Number\r\n     * @default 0\r\n     */\r\n    offsetX: 0,\r\n\r\n    /**\r\n     * Vertical offset for aligning gradients coming from SVG when outside pathgroups\r\n     * @type Number\r\n     * @default 0\r\n     */\r\n    offsetY: 0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} [options] Options object with type, coords, gradientUnits and colorStops\r\n     * @return {fabric.Gradient} thisArg\r\n     */\r\n    initialize: function(options) {\r\n      options || (options = { });\r\n\r\n      var coords = { };\r\n\r\n      this.id = fabric.Object.__uid++;\r\n      this.type = options.type || 'linear';\r\n\r\n      coords = {\r\n        x1: options.coords.x1 || 0,\r\n        y1: options.coords.y1 || 0,\r\n        x2: options.coords.x2 || 0,\r\n        y2: options.coords.y2 || 0\r\n      };\r\n\r\n      if (this.type === 'radial') {\r\n        coords.r1 = options.coords.r1 || 0;\r\n        coords.r2 = options.coords.r2 || 0;\r\n      }\r\n      this.coords = coords;\r\n      this.colorStops = options.colorStops.slice();\r\n      if (options.gradientTransform) {\r\n        this.gradientTransform = options.gradientTransform;\r\n      }\r\n      this.offsetX = options.offsetX || this.offsetX;\r\n      this.offsetY = options.offsetY || this.offsetY;\r\n    },\r\n\r\n    /**\r\n     * Adds another colorStop\r\n     * @param {Object} colorStop Object with offset and color\r\n     * @return {fabric.Gradient} thisArg\r\n     */\r\n    addColorStop: function(colorStop) {\r\n      for (var position in colorStop) {\r\n        var color = new fabric.Color(colorStop[position]);\r\n        this.colorStops.push({\r\n          offset: position,\r\n          color: color.toRgb(),\r\n          opacity: color.getAlpha()\r\n        });\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of a gradient\r\n     * @return {Object}\r\n     */\r\n    toObject: function() {\r\n      return {\r\n        type: this.type,\r\n        coords: this.coords,\r\n        colorStops: this.colorStops,\r\n        offsetX: this.offsetX,\r\n        offsetY: this.offsetY\r\n      };\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of an gradient\r\n     * @param {Object} object Object to create a gradient for\r\n     * @param {Boolean} normalize Whether coords should be normalized\r\n     * @return {String} SVG representation of an gradient (linear/radial)\r\n     */\r\n    toSVG: function(object) {\r\n      var coords = fabric.util.object.clone(this.coords),\r\n          markup, commonAttributes;\r\n\r\n      // colorStops must be sorted ascending\r\n      this.colorStops.sort(function(a, b) {\r\n        return a.offset - b.offset;\r\n      });\r\n\r\n      if (!(object.group && object.group.type === 'path-group')) {\r\n        for (var prop in coords) {\r\n          if (prop === 'x1' || prop === 'x2' || prop === 'r2') {\r\n            coords[prop] += this.offsetX - object.width / 2;\r\n          }\r\n          else if (prop === 'y1' || prop === 'y2') {\r\n            coords[prop] += this.offsetY - object.height / 2;\r\n          }\r\n        }\r\n      }\r\n\r\n      commonAttributes = 'id=\"SVGID_' + this.id +\r\n                     '\" gradientUnits=\"userSpaceOnUse\"';\r\n      if (this.gradientTransform) {\r\n        commonAttributes += ' gradientTransform=\"matrix(' + this.gradientTransform.join(' ') + ')\" ';\r\n      }\r\n      if (this.type === 'linear') {\r\n        markup = [\r\n          //jscs:disable validateIndentation\r\n          '<linearGradient ',\r\n            commonAttributes,\r\n            ' x1=\"', coords.x1,\r\n            '\" y1=\"', coords.y1,\r\n            '\" x2=\"', coords.x2,\r\n            '\" y2=\"', coords.y2,\r\n          '\">\\n'\r\n          //jscs:enable validateIndentation\r\n        ];\r\n      }\r\n      else if (this.type === 'radial') {\r\n        markup = [\r\n          //jscs:disable validateIndentation\r\n          '<radialGradient ',\r\n            commonAttributes,\r\n            ' cx=\"', coords.x2,\r\n            '\" cy=\"', coords.y2,\r\n            '\" r=\"', coords.r2,\r\n            '\" fx=\"', coords.x1,\r\n            '\" fy=\"', coords.y1,\r\n          '\">\\n'\r\n          //jscs:enable validateIndentation\r\n        ];\r\n      }\r\n\r\n      for (var i = 0; i < this.colorStops.length; i++) {\r\n        markup.push(\r\n          //jscs:disable validateIndentation\r\n          '<stop ',\r\n            'offset=\"', (this.colorStops[i].offset * 100) + '%',\r\n            '\" style=\"stop-color:', this.colorStops[i].color,\r\n            (this.colorStops[i].opacity != null ? ';stop-opacity: ' + this.colorStops[i].opacity : ';'),\r\n          '\"/>\\n'\r\n          //jscs:enable validateIndentation\r\n        );\r\n      }\r\n\r\n      markup.push((this.type === 'linear' ? '</linearGradient>\\n' : '</radialGradient>\\n'));\r\n\r\n      return markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns an instance of CanvasGradient\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @return {CanvasGradient}\r\n     */\r\n    toLive: function(ctx, object) {\r\n      var gradient, prop, coords = fabric.util.object.clone(this.coords);\r\n\r\n      if (!this.type) {\r\n        return;\r\n      }\r\n\r\n      if (object.group && object.group.type === 'path-group') {\r\n        for (prop in coords) {\r\n          if (prop === 'x1' || prop === 'x2') {\r\n            coords[prop] += -this.offsetX + object.width / 2;\r\n          }\r\n          else if (prop === 'y1' || prop === 'y2') {\r\n            coords[prop] += -this.offsetY + object.height / 2;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.type === 'linear') {\r\n        gradient = ctx.createLinearGradient(\r\n          coords.x1, coords.y1, coords.x2, coords.y2);\r\n      }\r\n      else if (this.type === 'radial') {\r\n        gradient = ctx.createRadialGradient(\r\n          coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);\r\n      }\r\n\r\n      for (var i = 0, len = this.colorStops.length; i < len; i++) {\r\n        var color = this.colorStops[i].color,\r\n            opacity = this.colorStops[i].opacity,\r\n            offset = this.colorStops[i].offset;\r\n\r\n        if (typeof opacity !== 'undefined') {\r\n          color = new fabric.Color(color).setAlpha(opacity).toRgba();\r\n        }\r\n        gradient.addColorStop(parseFloat(offset), color);\r\n      }\r\n\r\n      return gradient;\r\n    }\r\n  });\r\n\r\n  fabric.util.object.extend(fabric.Gradient, {\r\n\r\n    /* _FROM_SVG_START_ */\r\n    /**\r\n     * Returns {@link fabric.Gradient} instance from an SVG element\r\n     * @static\r\n     * @memberOf fabric.Gradient\r\n     * @param {SVGGradientElement} el SVG gradient element\r\n     * @param {fabric.Object} instance\r\n     * @return {fabric.Gradient} Gradient instance\r\n     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement\r\n     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement\r\n     */\r\n    fromElement: function(el, instance) {\r\n\r\n      /**\r\n       *  @example:\r\n       *\r\n       *  <linearGradient id=\"linearGrad1\">\r\n       *    <stop offset=\"0%\" stop-color=\"white\"/>\r\n       *    <stop offset=\"100%\" stop-color=\"black\"/>\r\n       *  </linearGradient>\r\n       *\r\n       *  OR\r\n       *\r\n       *  <linearGradient id=\"linearGrad2\">\r\n       *    <stop offset=\"0\" style=\"stop-color:rgb(255,255,255)\"/>\r\n       *    <stop offset=\"1\" style=\"stop-color:rgb(0,0,0)\"/>\r\n       *  </linearGradient>\r\n       *\r\n       *  OR\r\n       *\r\n       *  <radialGradient id=\"radialGrad1\">\r\n       *    <stop offset=\"0%\" stop-color=\"white\" stop-opacity=\"1\" />\r\n       *    <stop offset=\"50%\" stop-color=\"black\" stop-opacity=\"0.5\" />\r\n       *    <stop offset=\"100%\" stop-color=\"white\" stop-opacity=\"1\" />\r\n       *  </radialGradient>\r\n       *\r\n       *  OR\r\n       *\r\n       *  <radialGradient id=\"radialGrad2\">\r\n       *    <stop offset=\"0\" stop-color=\"rgb(255,255,255)\" />\r\n       *    <stop offset=\"0.5\" stop-color=\"rgb(0,0,0)\" />\r\n       *    <stop offset=\"1\" stop-color=\"rgb(255,255,255)\" />\r\n       *  </radialGradient>\r\n       *\r\n       */\r\n\r\n      var colorStopEls = el.getElementsByTagName('stop'),\r\n          type = (el.nodeName === 'linearGradient' ? 'linear' : 'radial'),\r\n          gradientUnits = el.getAttribute('gradientUnits') || 'objectBoundingBox',\r\n          gradientTransform = el.getAttribute('gradientTransform'),\r\n          colorStops = [],\r\n          coords = { }, ellipseMatrix;\r\n\r\n      if (type === 'linear') {\r\n        coords = getLinearCoords(el);\r\n      }\r\n      else if (type === 'radial') {\r\n        coords = getRadialCoords(el);\r\n      }\r\n\r\n      for (var i = colorStopEls.length; i--; ) {\r\n        colorStops.push(getColorStop(colorStopEls[i]));\r\n      }\r\n\r\n      ellipseMatrix = _convertPercentUnitsToValues(instance, coords, gradientUnits);\r\n\r\n      var gradient = new fabric.Gradient({\r\n        type: type,\r\n        coords: coords,\r\n        colorStops: colorStops,\r\n        offsetX: -instance.left,\r\n        offsetY: -instance.top\r\n      });\r\n\r\n      if (gradientTransform || ellipseMatrix !== '') {\r\n        gradient.gradientTransform = fabric.parseTransformAttribute((gradientTransform || '') + ellipseMatrix);\r\n      }\r\n      return gradient;\r\n    },\r\n    /* _FROM_SVG_END_ */\r\n\r\n    /**\r\n     * Returns {@link fabric.Gradient} instance from its object representation\r\n     * @static\r\n     * @memberOf fabric.Gradient\r\n     * @param {Object} obj\r\n     * @param {Object} [options] Options object\r\n     */\r\n    forObject: function(obj, options) {\r\n      options || (options = { });\r\n      _convertPercentUnitsToValues(obj, options.coords, 'userSpaceOnUse');\r\n      return new fabric.Gradient(options);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function _convertPercentUnitsToValues(object, options, gradientUnits) {\r\n    var propValue, addFactor = 0, multFactor = 1, ellipseMatrix = '';\r\n    for (var prop in options) {\r\n      propValue = parseFloat(options[prop], 10);\r\n      if (typeof options[prop] === 'string' && /^\\d+%$/.test(options[prop])) {\r\n        multFactor = 0.01;\r\n      }\r\n      else {\r\n        multFactor = 1;\r\n      }\r\n      if (prop === 'x1' || prop === 'x2' || prop === 'r2') {\r\n        multFactor *= gradientUnits === 'objectBoundingBox' ? object.width : 1;\r\n        addFactor = gradientUnits === 'objectBoundingBox' ? object.left || 0 : 0;\r\n      }\r\n      else if (prop === 'y1' || prop === 'y2') {\r\n        multFactor *= gradientUnits === 'objectBoundingBox' ? object.height : 1;\r\n        addFactor = gradientUnits === 'objectBoundingBox' ? object.top || 0 : 0;\r\n      }\r\n      options[prop] = propValue * multFactor + addFactor;\r\n    }\r\n    if (object.type === 'ellipse' &&\r\n        options.r2 !== null &&\r\n        gradientUnits === 'objectBoundingBox' &&\r\n        object.rx !== object.ry) {\r\n\r\n      var scaleFactor = object.ry/object.rx;\r\n      ellipseMatrix = ' scale(1, ' + scaleFactor + ')';\r\n      if (options.y1) {\r\n        options.y1 /= scaleFactor;\r\n      }\r\n      if (options.y2) {\r\n        options.y2 /= scaleFactor;\r\n      }\r\n    }\r\n    return ellipseMatrix;\r\n  }\r\n})();\r\n\r\n\r\n/**\r\n * Pattern class\r\n * @class fabric.Pattern\r\n * @see {@link http://fabricjs.com/patterns/|Pattern demo}\r\n * @see {@link http://fabricjs.com/dynamic-patterns/|DynamicPattern demo}\r\n * @see {@link fabric.Pattern#initialize} for constructor definition\r\n */\r\nfabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {\r\n\r\n  /**\r\n   * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)\r\n   * @type String\r\n   * @default\r\n   */\r\n  repeat: 'repeat',\r\n\r\n  /**\r\n   * Pattern horizontal offset from object's left/top corner\r\n   * @type Number\r\n   * @default\r\n   */\r\n  offsetX: 0,\r\n\r\n  /**\r\n   * Pattern vertical offset from object's left/top corner\r\n   * @type Number\r\n   * @default\r\n   */\r\n  offsetY: 0,\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Pattern} thisArg\r\n   */\r\n  initialize: function(options) {\r\n    options || (options = { });\r\n\r\n    this.id = fabric.Object.__uid++;\r\n\r\n    if (options.source) {\r\n      if (typeof options.source === 'string') {\r\n        // function string\r\n        if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {\r\n          this.source = new Function(fabric.util.getFunctionBody(options.source));\r\n        }\r\n        else {\r\n          // img src string\r\n          var _this = this;\r\n          this.source = fabric.util.createImage();\r\n          fabric.util.loadImage(options.source, function(img) {\r\n            _this.source = img;\r\n          });\r\n        }\r\n      }\r\n      else {\r\n        // img element\r\n        this.source = options.source;\r\n      }\r\n    }\r\n    if (options.repeat) {\r\n      this.repeat = options.repeat;\r\n    }\r\n    if (options.offsetX) {\r\n      this.offsetX = options.offsetX;\r\n    }\r\n    if (options.offsetY) {\r\n      this.offsetY = options.offsetY;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns object representation of a pattern\r\n   * @return {Object} Object representation of a pattern instance\r\n   */\r\n  toObject: function() {\r\n\r\n    var source;\r\n\r\n    // callback\r\n    if (typeof this.source === 'function') {\r\n      source = String(this.source);\r\n    }\r\n    // <img> element\r\n    else if (typeof this.source.src === 'string') {\r\n      source = this.source.src;\r\n    }\r\n    // <canvas> element\r\n    else if (typeof this.source === 'object' && this.source.toDataURL) {\r\n      source = this.source.toDataURL();\r\n    }\r\n\r\n    return {\r\n      source: source,\r\n      repeat: this.repeat,\r\n      offsetX: this.offsetX,\r\n      offsetY: this.offsetY\r\n    };\r\n  },\r\n\r\n  /* _TO_SVG_START_ */\r\n  /**\r\n   * Returns SVG representation of a pattern\r\n   * @param {fabric.Object} object\r\n   * @return {String} SVG representation of a pattern\r\n   */\r\n  toSVG: function(object) {\r\n    var patternSource = typeof this.source === 'function' ? this.source() : this.source,\r\n        patternWidth = patternSource.width / object.getWidth(),\r\n        patternHeight = patternSource.height / object.getHeight(),\r\n        patternOffsetX = this.offsetX / object.getWidth(),\r\n        patternOffsetY = this.offsetY / object.getHeight(),\r\n        patternImgSrc = '';\r\n    if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {\r\n      patternHeight = 1;\r\n    }\r\n    if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {\r\n      patternWidth = 1;\r\n    }\r\n    if (patternSource.src) {\r\n      patternImgSrc = patternSource.src;\r\n    }\r\n    else if (patternSource.toDataURL) {\r\n      patternImgSrc = patternSource.toDataURL();\r\n    }\r\n\r\n    return '<pattern id=\"SVGID_' + this.id +\r\n                  '\" x=\"' + patternOffsetX +\r\n                  '\" y=\"' + patternOffsetY +\r\n                  '\" width=\"' + patternWidth +\r\n                  '\" height=\"' + patternHeight + '\">\\n' +\r\n             '<image x=\"0\" y=\"0\"' +\r\n                    ' width=\"' + patternSource.width +\r\n                    '\" height=\"' + patternSource.height +\r\n                    '\" xlink:href=\"' + patternImgSrc +\r\n             '\"></image>\\n' +\r\n           '</pattern>\\n';\r\n  },\r\n  /* _TO_SVG_END_ */\r\n\r\n  /**\r\n   * Returns an instance of CanvasPattern\r\n   * @param {CanvasRenderingContext2D} ctx Context to create pattern\r\n   * @return {CanvasPattern}\r\n   */\r\n  toLive: function(ctx) {\r\n    var source = typeof this.source === 'function'\r\n      ? this.source()\r\n      : this.source;\r\n\r\n    // if the image failed to load, return, and allow rest to continue loading\r\n    if (!source) {\r\n      return '';\r\n    }\r\n\r\n    // if an image\r\n    if (typeof source.src !== 'undefined') {\r\n      if (!source.complete) {\r\n        return '';\r\n      }\r\n      if (source.naturalWidth === 0 || source.naturalHeight === 0) {\r\n        return '';\r\n      }\r\n    }\r\n    return ctx.createPattern(source, this.repeat);\r\n  }\r\n});\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      toFixed = fabric.util.toFixed;\r\n\r\n  if (fabric.Shadow) {\r\n    fabric.warn('fabric.Shadow is already defined.');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Shadow class\r\n   * @class fabric.Shadow\r\n   * @see {@link http://fabricjs.com/shadows/|Shadow demo}\r\n   * @see {@link fabric.Shadow#initialize} for constructor definition\r\n   */\r\n  fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {\r\n\r\n    /**\r\n     * Shadow color\r\n     * @type String\r\n     * @default\r\n     */\r\n    color: 'rgb(0,0,0)',\r\n\r\n    /**\r\n     * Shadow blur\r\n     * @type Number\r\n     */\r\n    blur: 0,\r\n\r\n    /**\r\n     * Shadow horizontal offset\r\n     * @type Number\r\n     * @default\r\n     */\r\n    offsetX: 0,\r\n\r\n    /**\r\n     * Shadow vertical offset\r\n     * @type Number\r\n     * @default\r\n     */\r\n    offsetY: 0,\r\n\r\n    /**\r\n     * Whether the shadow should affect stroke operations\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    affectStroke: false,\r\n\r\n    /**\r\n     * Indicates whether toObject should include default values\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    includeDefaultValues: true,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetX properties or string (e.g. \"rgba(0,0,0,0.2) 2px 2px 10px, \"2px 2px 10px rgba(0,0,0,0.2)\")\r\n     * @return {fabric.Shadow} thisArg\r\n     */\r\n    initialize: function(options) {\r\n\r\n      if (typeof options === 'string') {\r\n        options = this._parseShadow(options);\r\n      }\r\n\r\n      for (var prop in options) {\r\n        this[prop] = options[prop];\r\n      }\r\n\r\n      this.id = fabric.Object.__uid++;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} shadow Shadow value to parse\r\n     * @return {Object} Shadow object with color, offsetX, offsetY and blur\r\n     */\r\n    _parseShadow: function(shadow) {\r\n      var shadowStr = shadow.trim(),\r\n          offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [ ],\r\n          color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';\r\n\r\n      return {\r\n        color: color.trim(),\r\n        offsetX: parseInt(offsetsAndBlur[1], 10) || 0,\r\n        offsetY: parseInt(offsetsAndBlur[2], 10) || 0,\r\n        blur: parseInt(offsetsAndBlur[3], 10) || 0\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Returns a string representation of an instance\r\n     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow\r\n     * @return {String} Returns CSS3 text-shadow declaration\r\n     */\r\n    toString: function() {\r\n      return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of a shadow\r\n     * @param {fabric.Object} object\r\n     * @return {String} SVG representation of a shadow\r\n     */\r\n    toSVG: function(object) {\r\n      var fBoxX = 40, fBoxY = 40;\r\n\r\n      if (object.width && object.height) {\r\n        //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion\r\n        // we add some extra space to filter box to contain the blur ( 20 )\r\n        fBoxX = toFixed((Math.abs(this.offsetX) + this.blur) / object.width, 2) * 100 + 20;\r\n        fBoxY = toFixed((Math.abs(this.offsetY) + this.blur) / object.height, 2) * 100 + 20;\r\n      }\r\n\r\n      return (\r\n        '<filter id=\"SVGID_' + this.id + '\" y=\"-' + fBoxY + '%\" height=\"' + (100 + 2 * fBoxY) + '%\" ' +\r\n          'x=\"-' + fBoxX + '%\" width=\"' + (100 + 2 * fBoxX) + '%\" ' + '>\\n' +\r\n          '\\t<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"' +\r\n            toFixed(this.blur ? this.blur / 2 : 0, 3) + '\"></feGaussianBlur>\\n' +\r\n          '\\t<feOffset dx=\"' + this.offsetX + '\" dy=\"' + this.offsetY + '\" result=\"oBlur\" ></feOffset>\\n' +\r\n          '\\t<feFlood flood-color=\"' + this.color + '\"/>\\n' +\r\n          '\\t<feComposite in2=\"oBlur\" operator=\"in\" />\\n' +\r\n          '\\t<feMerge>\\n' +\r\n            '\\t\\t<feMergeNode></feMergeNode>\\n' +\r\n            '\\t\\t<feMergeNode in=\"SourceGraphic\"></feMergeNode>\\n' +\r\n          '\\t</feMerge>\\n' +\r\n        '</filter>\\n');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns object representation of a shadow\r\n     * @return {Object} Object representation of a shadow instance\r\n     */\r\n    toObject: function() {\r\n      if (this.includeDefaultValues) {\r\n        return {\r\n          color: this.color,\r\n          blur: this.blur,\r\n          offsetX: this.offsetX,\r\n          offsetY: this.offsetY\r\n        };\r\n      }\r\n      var obj = { }, proto = fabric.Shadow.prototype;\r\n      if (this.color !== proto.color) {\r\n        obj.color = this.color;\r\n      }\r\n      if (this.blur !== proto.blur) {\r\n        obj.blur = this.blur;\r\n      }\r\n      if (this.offsetX !== proto.offsetX) {\r\n        obj.offsetX = this.offsetX;\r\n      }\r\n      if (this.offsetY !== proto.offsetY) {\r\n        obj.offsetY = this.offsetY;\r\n      }\r\n      return obj;\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Regex matching shadow offsetX, offsetY and blur (ex: \"2px 2px 10px rgba(0,0,0,0.2)\", \"rgb(0,255,0) 2px 2px\")\r\n   * @static\r\n   * @field\r\n   * @memberOf fabric.Shadow\r\n   */\r\n  fabric.Shadow.reOffsetsAndBlur = /(?:\\s|^)(-?\\d+(?:px)?(?:\\s?|$))?(-?\\d+(?:px)?(?:\\s?|$))?(\\d+(?:px)?)?(?:\\s?|$)(?:$|\\s)/;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function () {\r\n\r\n  'use strict';\r\n\r\n  if (fabric.StaticCanvas) {\r\n    fabric.warn('fabric.StaticCanvas is already defined.');\r\n    return;\r\n  }\r\n\r\n  // aliases for faster resolution\r\n  var extend = fabric.util.object.extend,\r\n      getElementOffset = fabric.util.getElementOffset,\r\n      removeFromArray = fabric.util.removeFromArray,\r\n\r\n      CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');\r\n\r\n  /**\r\n   * Static canvas class\r\n   * @class fabric.StaticCanvas\r\n   * @mixes fabric.Collection\r\n   * @mixes fabric.Observable\r\n   * @see {@link http://fabricjs.com/static_canvas/|StaticCanvas demo}\r\n   * @see {@link fabric.StaticCanvas#initialize} for constructor definition\r\n   * @fires before:render\r\n   * @fires after:render\r\n   * @fires canvas:cleared\r\n   * @fires object:added\r\n   * @fires object:removed\r\n   */\r\n  fabric.StaticCanvas = fabric.util.createClass(/** @lends fabric.StaticCanvas.prototype */ {\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\r\n     * @param {Object} [options] Options object\r\n     * @return {Object} thisArg\r\n     */\r\n    initialize: function(el, options) {\r\n      options || (options = { });\r\n\r\n      this._initStatic(el, options);\r\n      fabric.StaticCanvas.activeInstance = this;\r\n    },\r\n\r\n    /**\r\n     * Background color of canvas instance.\r\n     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.\r\n     * @type {(String|fabric.Pattern)}\r\n     * @default\r\n     */\r\n    backgroundColor: '',\r\n\r\n    /**\r\n     * Background image of canvas instance.\r\n     * Should be set via {@link fabric.StaticCanvas#setBackgroundImage}.\r\n     * <b>Backwards incompatibility note:</b> The \"backgroundImageOpacity\"\r\n     * and \"backgroundImageStretch\" properties are deprecated since 1.3.9.\r\n     * Use {@link fabric.Image#opacity}, {@link fabric.Image#width} and {@link fabric.Image#height}.\r\n     * @type fabric.Image\r\n     * @default\r\n     */\r\n    backgroundImage: null,\r\n\r\n    /**\r\n     * Overlay color of canvas instance.\r\n     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}\r\n     * @since 1.3.9\r\n     * @type {(String|fabric.Pattern)}\r\n     * @default\r\n     */\r\n    overlayColor: '',\r\n\r\n    /**\r\n     * Overlay image of canvas instance.\r\n     * Should be set via {@link fabric.StaticCanvas#setOverlayImage}.\r\n     * <b>Backwards incompatibility note:</b> The \"overlayImageLeft\"\r\n     * and \"overlayImageTop\" properties are deprecated since 1.3.9.\r\n     * Use {@link fabric.Image#left} and {@link fabric.Image#top}.\r\n     * @type fabric.Image\r\n     * @default\r\n     */\r\n    overlayImage: null,\r\n\r\n    /**\r\n     * Indicates whether toObject/toDatalessObject should include default values\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    includeDefaultValues: true,\r\n\r\n    /**\r\n     * Indicates whether objects' state should be saved\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    stateful: true,\r\n\r\n    /**\r\n     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove} should also re-render canvas.\r\n     * Disabling this option could give a great performance boost when adding/removing a lot of objects to/from canvas at once\r\n     * (followed by a manual rendering after addition/deletion)\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    renderOnAddRemove: true,\r\n\r\n    /**\r\n     * Function that determines clipping of entire canvas area\r\n     * Being passed context as first argument. See clipping canvas area in {@link https://github.com/kangax/fabric.js/wiki/FAQ}\r\n     * @type Function\r\n     * @default\r\n     */\r\n    clipTo: null,\r\n\r\n    /**\r\n     * Indicates whether object controls (borders/controls) are rendered above overlay image\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    controlsAboveOverlay: false,\r\n\r\n    /**\r\n     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    allowTouchScrolling: false,\r\n\r\n    /**\r\n     * Indicates whether this canvas will use image smoothing, this is on by default in browsers\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    imageSmoothingEnabled: true,\r\n\r\n    /**\r\n     * Indicates whether objects should remain in current stack position when selected. When false objects are brought to top and rendered as part of the selection group\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    preserveObjectStacking: false,\r\n\r\n    /**\r\n     * The transformation (in the format of Canvas transform) which focuses the viewport\r\n     * @type Array\r\n     * @default\r\n     */\r\n    viewportTransform: [1, 0, 0, 1, 0, 0],\r\n\r\n    /**\r\n     * Callback; invoked right before object is about to be scaled/rotated\r\n     */\r\n    onBeforeScaleRotate: function () {\r\n      /* NOOP */\r\n    },\r\n\r\n    /**\r\n     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens\r\n     */\r\n    enableRetinaScaling: true,\r\n\r\n    /**\r\n     * @private\r\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initStatic: function(el, options) {\r\n      this._objects = [];\r\n\r\n      this._createLowerCanvas(el);\r\n      this._initOptions(options);\r\n      this._setImageSmoothing();\r\n\r\n      // only initialize retina scaling once\r\n      if (!this.interactive) {\r\n        this._initRetinaScaling();\r\n      }\r\n\r\n      if (options.overlayImage) {\r\n        this.setOverlayImage(options.overlayImage, this.renderAll.bind(this));\r\n      }\r\n      if (options.backgroundImage) {\r\n        this.setBackgroundImage(options.backgroundImage, this.renderAll.bind(this));\r\n      }\r\n      if (options.backgroundColor) {\r\n        this.setBackgroundColor(options.backgroundColor, this.renderAll.bind(this));\r\n      }\r\n      if (options.overlayColor) {\r\n        this.setOverlayColor(options.overlayColor, this.renderAll.bind(this));\r\n      }\r\n      this.calcOffset();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _initRetinaScaling: function() {\r\n      if (fabric.devicePixelRatio === 1 || !this.enableRetinaScaling) {\r\n        return;\r\n      }\r\n\r\n      this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);\r\n      this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);\r\n\r\n      this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);\r\n    },\r\n\r\n    /**\r\n     * Calculates canvas element offset relative to the document\r\n     * This method is also attached as \"resize\" event handler of window\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable\r\n     */\r\n    calcOffset: function () {\r\n      this._offset = getElementOffset(this.lowerCanvasEl);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas\r\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to\r\n     * @param {Function} callback callback to invoke when image is loaded and set as an overlay\r\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}\r\n     * @example <caption>Normal overlayImage with left/top = 0</caption>\r\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\r\n     *   // Needed to position overlayImage at 0/0\r\n     *   originX: 'left',\r\n     *   originY: 'top'\r\n     * });\r\n     * @example <caption>overlayImage with different properties</caption>\r\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\r\n     *   opacity: 0.5,\r\n     *   angle: 45,\r\n     *   left: 400,\r\n     *   top: 400,\r\n     *   originX: 'left',\r\n     *   originY: 'top'\r\n     * });\r\n     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>\r\n     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img) {\r\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\r\n     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));\r\n     * });\r\n     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>\r\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\r\n     *   width: canvas.width,\r\n     *   height: canvas.height,\r\n     *   // Needed to position overlayImage at 0/0\r\n     *   originX: 'left',\r\n     *   originY: 'top'\r\n     * });\r\n     * @example <caption>overlayImage loaded from cross-origin</caption>\r\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\r\n     *   opacity: 0.5,\r\n     *   angle: 45,\r\n     *   left: 400,\r\n     *   top: 400,\r\n     *   originX: 'left',\r\n     *   originY: 'top',\r\n     *   crossOrigin: 'anonymous'\r\n     * });\r\n     */\r\n    setOverlayImage: function (image, callback, options) {\r\n      return this.__setBgOverlayImage('overlayImage', image, callback, options);\r\n    },\r\n\r\n    /**\r\n     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas\r\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to\r\n     * @param {Function} callback Callback to invoke when image is loaded and set as background\r\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/YH9yD/|jsFiddle demo}\r\n     * @example <caption>Normal backgroundImage with left/top = 0</caption>\r\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\r\n     *   // Needed to position backgroundImage at 0/0\r\n     *   originX: 'left',\r\n     *   originY: 'top'\r\n     * });\r\n     * @example <caption>backgroundImage with different properties</caption>\r\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\r\n     *   opacity: 0.5,\r\n     *   angle: 45,\r\n     *   left: 400,\r\n     *   top: 400,\r\n     *   originX: 'left',\r\n     *   originY: 'top'\r\n     * });\r\n     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>\r\n     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img) {\r\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\r\n     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));\r\n     * });\r\n     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>\r\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\r\n     *   width: canvas.width,\r\n     *   height: canvas.height,\r\n     *   // Needed to position backgroundImage at 0/0\r\n     *   originX: 'left',\r\n     *   originY: 'top'\r\n     * });\r\n     * @example <caption>backgroundImage loaded from cross-origin</caption>\r\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\r\n     *   opacity: 0.5,\r\n     *   angle: 45,\r\n     *   left: 400,\r\n     *   top: 400,\r\n     *   originX: 'left',\r\n     *   originY: 'top',\r\n     *   crossOrigin: 'anonymous'\r\n     * });\r\n     */\r\n    setBackgroundImage: function (image, callback, options) {\r\n      return this.__setBgOverlayImage('backgroundImage', image, callback, options);\r\n    },\r\n\r\n    /**\r\n     * Sets {@link fabric.StaticCanvas#overlayColor|background color} for this canvas\r\n     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set background color to\r\n     * @param {Function} callback Callback to invoke when background color is set\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}\r\n     * @example <caption>Normal overlayColor - color value</caption>\r\n     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\r\n     * @example <caption>fabric.Pattern used as overlayColor</caption>\r\n     * canvas.setOverlayColor({\r\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\r\n     * }, canvas.renderAll.bind(canvas));\r\n     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>\r\n     * canvas.setOverlayColor({\r\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\r\n     *   repeat: 'repeat',\r\n     *   offsetX: 200,\r\n     *   offsetY: 100\r\n     * }, canvas.renderAll.bind(canvas));\r\n     */\r\n    setOverlayColor: function(overlayColor, callback) {\r\n      return this.__setBgOverlayColor('overlayColor', overlayColor, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas\r\n     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to\r\n     * @param {Function} callback Callback to invoke when background color is set\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}\r\n     * @example <caption>Normal backgroundColor - color value</caption>\r\n     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\r\n     * @example <caption>fabric.Pattern used as backgroundColor</caption>\r\n     * canvas.setBackgroundColor({\r\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\r\n     * }, canvas.renderAll.bind(canvas));\r\n     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>\r\n     * canvas.setBackgroundColor({\r\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\r\n     *   repeat: 'repeat',\r\n     *   offsetX: 200,\r\n     *   offsetY: 100\r\n     * }, canvas.renderAll.bind(canvas));\r\n     */\r\n    setBackgroundColor: function(backgroundColor, callback) {\r\n      return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-imagesmoothingenabled|WhatWG Canvas Standard}\r\n     */\r\n    _setImageSmoothing: function() {\r\n      var ctx = this.getContext();\r\n\r\n      if (typeof ctx.imageSmoothingEnabled !== 'undefined') {\r\n        ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;\r\n        return;\r\n      }\r\n      ctx.webkitImageSmoothingEnabled = this.imageSmoothingEnabled;\r\n      ctx.mozImageSmoothingEnabled    = this.imageSmoothingEnabled;\r\n      ctx.msImageSmoothingEnabled     = this.imageSmoothingEnabled;\r\n      ctx.oImageSmoothingEnabled      = this.imageSmoothingEnabled;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}\r\n     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})\r\n     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to\r\n     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay\r\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.\r\n     */\r\n    __setBgOverlayImage: function(property, image, callback, options) {\r\n      if (typeof image === 'string') {\r\n        fabric.util.loadImage(image, function(img) {\r\n          this[property] = new fabric.Image(img, options);\r\n          callback && callback();\r\n        }, this, options && options.crossOrigin);\r\n      }\r\n      else {\r\n        options && image.setOptions(options);\r\n        this[property] = image;\r\n        callback && callback();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}\r\n     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})\r\n     * @param {(Object|String|null)} color Object with pattern information, color value or null\r\n     * @param {Function} [callback] Callback is invoked when color is set\r\n     */\r\n    __setBgOverlayColor: function(property, color, callback) {\r\n      if (color && color.source) {\r\n        var _this = this;\r\n        fabric.util.loadImage(color.source, function(img) {\r\n          _this[property] = new fabric.Pattern({\r\n            source: img,\r\n            repeat: color.repeat,\r\n            offsetX: color.offsetX,\r\n            offsetY: color.offsetY\r\n          });\r\n          callback && callback();\r\n        });\r\n      }\r\n      else {\r\n        this[property] = color;\r\n        callback && callback();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _createCanvasElement: function() {\r\n      var element = fabric.document.createElement('canvas');\r\n      if (!element.style) {\r\n        element.style = { };\r\n      }\r\n      if (!element) {\r\n        throw CANVAS_INIT_ERROR;\r\n      }\r\n      this._initCanvasElement(element);\r\n      return element;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {HTMLElement} element\r\n     */\r\n    _initCanvasElement: function(element) {\r\n      fabric.util.createCanvasElement(element);\r\n\r\n      if (typeof element.getContext === 'undefined') {\r\n        throw CANVAS_INIT_ERROR;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initOptions: function (options) {\r\n      for (var prop in options) {\r\n        this[prop] = options[prop];\r\n      }\r\n\r\n      this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0;\r\n      this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0;\r\n\r\n      if (!this.lowerCanvasEl.style) {\r\n        return;\r\n      }\r\n\r\n      this.lowerCanvasEl.width = this.width;\r\n      this.lowerCanvasEl.height = this.height;\r\n\r\n      this.lowerCanvasEl.style.width = this.width + 'px';\r\n      this.lowerCanvasEl.style.height = this.height + 'px';\r\n\r\n      this.viewportTransform = this.viewportTransform.slice();\r\n    },\r\n\r\n    /**\r\n     * Creates a bottom canvas\r\n     * @private\r\n     * @param {HTMLElement} [canvasEl]\r\n     */\r\n    _createLowerCanvas: function (canvasEl) {\r\n      this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();\r\n      this._initCanvasElement(this.lowerCanvasEl);\r\n\r\n      fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');\r\n\r\n      if (this.interactive) {\r\n        this._applyCanvasStyle(this.lowerCanvasEl);\r\n      }\r\n\r\n      this.contextContainer = this.lowerCanvasEl.getContext('2d');\r\n    },\r\n\r\n    /**\r\n     * Returns canvas width (in px)\r\n     * @return {Number}\r\n     */\r\n    getWidth: function () {\r\n      return this.width;\r\n    },\r\n\r\n    /**\r\n     * Returns canvas height (in px)\r\n     * @return {Number}\r\n     */\r\n    getHeight: function () {\r\n      return this.height;\r\n    },\r\n\r\n    /**\r\n     * Sets width of this canvas instance\r\n     * @param {Number|String} value                         Value to set width to\r\n     * @param {Object}        [options]                     Options object\r\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\r\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    setWidth: function (value, options) {\r\n      return this.setDimensions({ width: value }, options);\r\n    },\r\n\r\n    /**\r\n     * Sets height of this canvas instance\r\n     * @param {Number|String} value                         Value to set height to\r\n     * @param {Object}        [options]                     Options object\r\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\r\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    setHeight: function (value, options) {\r\n      return this.setDimensions({ height: value }, options);\r\n    },\r\n\r\n    /**\r\n     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)\r\n     * @param {Object}        dimensions                    Object with width/height properties\r\n     * @param {Number|String} [dimensions.width]            Width of canvas element\r\n     * @param {Number|String} [dimensions.height]           Height of canvas element\r\n     * @param {Object}        [options]                     Options object\r\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\r\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    setDimensions: function (dimensions, options) {\r\n      var cssValue;\r\n\r\n      options = options || {};\r\n\r\n      for (var prop in dimensions) {\r\n        cssValue = dimensions[prop];\r\n\r\n        if (!options.cssOnly) {\r\n          this._setBackstoreDimension(prop, dimensions[prop]);\r\n          cssValue += 'px';\r\n        }\r\n\r\n        if (!options.backstoreOnly) {\r\n          this._setCssDimension(prop, cssValue);\r\n        }\r\n      }\r\n\r\n      this._setImageSmoothing();\r\n      this.calcOffset();\r\n\r\n      if (!options.cssOnly) {\r\n        this.renderAll();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Helper for setting width/height\r\n     * @private\r\n     * @param {String} prop property (width|height)\r\n     * @param {Number} value value to set property to\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    _setBackstoreDimension: function (prop, value) {\r\n      this.lowerCanvasEl[prop] = value;\r\n\r\n      if (this.upperCanvasEl) {\r\n        this.upperCanvasEl[prop] = value;\r\n      }\r\n\r\n      if (this.cacheCanvasEl) {\r\n        this.cacheCanvasEl[prop] = value;\r\n      }\r\n\r\n      this[prop] = value;\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Helper for setting css width/height\r\n     * @private\r\n     * @param {String} prop property (width|height)\r\n     * @param {String} value value to set property to\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    _setCssDimension: function (prop, value) {\r\n      this.lowerCanvasEl.style[prop] = value;\r\n\r\n      if (this.upperCanvasEl) {\r\n        this.upperCanvasEl.style[prop] = value;\r\n      }\r\n\r\n      if (this.wrapperEl) {\r\n        this.wrapperEl.style[prop] = value;\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns canvas zoom level\r\n     * @return {Number}\r\n     */\r\n    getZoom: function () {\r\n      return Math.sqrt(this.viewportTransform[0] * this.viewportTransform[3]);\r\n    },\r\n\r\n    /**\r\n     * Sets viewport transform of this canvas instance\r\n     * @param {Array} vpt the transform in the form of context.transform\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    setViewportTransform: function (vpt) {\r\n      var activeGroup = this.getActiveGroup();\r\n      this.viewportTransform = vpt;\r\n      this.renderAll();\r\n      for (var i = 0, len = this._objects.length; i < len; i++) {\r\n        this._objects[i].setCoords();\r\n      }\r\n      if (activeGroup) {\r\n        activeGroup.setCoords();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets zoom level of this canvas instance, zoom centered around point\r\n     * @param {fabric.Point} point to zoom with respect to\r\n     * @param {Number} value to set zoom to, less than 1 zooms out\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    zoomToPoint: function (point, value) {\r\n      // TODO: just change the scale, preserve other transformations\r\n      var before = point;\r\n      point = fabric.util.transformPoint(point, fabric.util.invertTransform(this.viewportTransform));\r\n      this.viewportTransform[0] = value;\r\n      this.viewportTransform[3] = value;\r\n      var after = fabric.util.transformPoint(point, this.viewportTransform);\r\n      this.viewportTransform[4] += before.x - after.x;\r\n      this.viewportTransform[5] += before.y - after.y;\r\n      this.renderAll();\r\n      for (var i = 0, len = this._objects.length; i < len; i++) {\r\n        this._objects[i].setCoords();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets zoom level of this canvas instance\r\n     * @param {Number} value to set zoom to, less than 1 zooms out\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    setZoom: function (value) {\r\n      this.zoomToPoint(new fabric.Point(0, 0), value);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Pan viewport so as to place point at top left corner of canvas\r\n     * @param {fabric.Point} point to move to\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    absolutePan: function (point) {\r\n      this.viewportTransform[4] = -point.x;\r\n      this.viewportTransform[5] = -point.y;\r\n      this.renderAll();\r\n      for (var i = 0, len = this._objects.length; i < len; i++) {\r\n        this._objects[i].setCoords();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Pans viewpoint relatively\r\n     * @param {fabric.Point} point (position vector) to move by\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    relativePan: function (point) {\r\n      return this.absolutePan(new fabric.Point(\r\n        -point.x - this.viewportTransform[4],\r\n        -point.y - this.viewportTransform[5]\r\n      ));\r\n    },\r\n\r\n    /**\r\n     * Returns &lt;canvas> element corresponding to this instance\r\n     * @return {HTMLCanvasElement}\r\n     */\r\n    getElement: function () {\r\n      return this.lowerCanvasEl;\r\n    },\r\n\r\n    /**\r\n     * Returns currently selected object, if any\r\n     * @return {fabric.Object}\r\n     */\r\n    getActiveObject: function() {\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Returns currently selected group of object, if any\r\n     * @return {fabric.Group}\r\n     */\r\n    getActiveGroup: function() {\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Given a context, renders an object on that context\r\n     * @param {CanvasRenderingContext2D} ctx Context to render object on\r\n     * @param {fabric.Object} object Object to render\r\n     * @private\r\n     */\r\n    _draw: function (ctx, object) {\r\n      if (!object) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n      var v = this.viewportTransform;\r\n      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\r\n      if (this._shouldRenderObject(object)) {\r\n        object.render(ctx);\r\n      }\r\n      ctx.restore();\r\n      if (!this.controlsAboveOverlay) {\r\n        object._renderControls(ctx);\r\n      }\r\n    },\r\n\r\n    _shouldRenderObject: function(object) {\r\n      if (!object) {\r\n        return false;\r\n      }\r\n      return (object !== this.getActiveGroup() || !this.preserveObjectStacking);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {fabric.Object} obj Object that was added\r\n     */\r\n    _onObjectAdded: function(obj) {\r\n      this.stateful && obj.setupState();\r\n      obj._set('canvas', this);\r\n      obj.setCoords();\r\n      this.fire('object:added', { target: obj });\r\n      obj.fire('added');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {fabric.Object} obj Object that was removed\r\n     */\r\n    _onObjectRemoved: function(obj) {\r\n      // removing active object should fire \"selection:cleared\" events\r\n      if (this.getActiveObject() === obj) {\r\n        this.fire('before:selection:cleared', { target: obj });\r\n        this._discardActiveObject();\r\n        this.fire('selection:cleared');\r\n      }\r\n\r\n      this.fire('object:removed', { target: obj });\r\n      obj.fire('removed');\r\n    },\r\n\r\n    /**\r\n     * Clears specified context of canvas element\r\n     * @param {CanvasRenderingContext2D} ctx Context to clear\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    clearContext: function(ctx) {\r\n      ctx.clearRect(0, 0, this.width, this.height);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns context of canvas where objects are drawn\r\n     * @return {CanvasRenderingContext2D}\r\n     */\r\n    getContext: function () {\r\n      return this.contextContainer;\r\n    },\r\n\r\n    /**\r\n     * Clears all contexts (background, main, top) of an instance\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    clear: function () {\r\n      this._objects.length = 0;\r\n      if (this.discardActiveGroup) {\r\n        this.discardActiveGroup();\r\n      }\r\n      if (this.discardActiveObject) {\r\n        this.discardActiveObject();\r\n      }\r\n      this.clearContext(this.contextContainer);\r\n      if (this.contextTop) {\r\n        this.clearContext(this.contextTop);\r\n      }\r\n      this.fire('canvas:cleared');\r\n      this.renderAll();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Renders both the top canvas and the secondary container canvas.\r\n     * @param {Boolean} [allOnTop] Whether we want to force all images to be rendered on the top canvas\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable\r\n     */\r\n    renderAll: function (allOnTop) {\r\n      var canvasToDrawOn = this[(allOnTop === true && this.interactive) ? 'contextTop' : 'contextContainer'],\r\n          activeGroup = this.getActiveGroup();\r\n\r\n      if (this.contextTop && this.selection && !this._groupSelector) {\r\n        this.clearContext(this.contextTop);\r\n      }\r\n\r\n      if (!allOnTop) {\r\n        this.clearContext(canvasToDrawOn);\r\n      }\r\n\r\n      this.fire('before:render');\r\n\r\n      if (this.clipTo) {\r\n        fabric.util.clipContext(this, canvasToDrawOn);\r\n      }\r\n\r\n      this._renderBackground(canvasToDrawOn);\r\n      this._renderObjects(canvasToDrawOn, activeGroup);\r\n      this._renderActiveGroup(canvasToDrawOn, activeGroup);\r\n\r\n      if (this.clipTo) {\r\n        canvasToDrawOn.restore();\r\n      }\r\n\r\n      this._renderOverlay(canvasToDrawOn);\r\n\r\n      if (this.controlsAboveOverlay && this.interactive) {\r\n        this.drawControls(canvasToDrawOn);\r\n      }\r\n\r\n      this.fire('after:render');\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {fabric.Group} activeGroup\r\n     */\r\n    _renderObjects: function(ctx, activeGroup) {\r\n      var i, length;\r\n\r\n      // fast path\r\n      if (!activeGroup || this.preserveObjectStacking) {\r\n        for (i = 0, length = this._objects.length; i < length; ++i) {\r\n          this._draw(ctx, this._objects[i]);\r\n        }\r\n      }\r\n      else {\r\n        for (i = 0, length = this._objects.length; i < length; ++i) {\r\n          if (this._objects[i] && !activeGroup.contains(this._objects[i])) {\r\n            this._draw(ctx, this._objects[i]);\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {fabric.Group} activeGroup\r\n     */\r\n    _renderActiveGroup: function(ctx, activeGroup) {\r\n\r\n      // delegate rendering to group selection (if one exists)\r\n      if (activeGroup) {\r\n\r\n        //Store objects in group preserving order, then replace\r\n        var sortedObjects = [];\r\n        this.forEachObject(function (object) {\r\n          if (activeGroup.contains(object)) {\r\n            sortedObjects.push(object);\r\n          }\r\n        });\r\n        // forEachObject reverses the object, so we reverse again\r\n        activeGroup._set('_objects', sortedObjects.reverse());\r\n        this._draw(ctx, activeGroup);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderBackground: function(ctx) {\r\n      if (this.backgroundColor) {\r\n        ctx.fillStyle = this.backgroundColor.toLive\r\n          ? this.backgroundColor.toLive(ctx)\r\n          : this.backgroundColor;\r\n\r\n        ctx.fillRect(\r\n          this.backgroundColor.offsetX || 0,\r\n          this.backgroundColor.offsetY || 0,\r\n          this.width,\r\n          this.height);\r\n      }\r\n      if (this.backgroundImage) {\r\n        this._draw(ctx, this.backgroundImage);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderOverlay: function(ctx) {\r\n      if (this.overlayColor) {\r\n        ctx.fillStyle = this.overlayColor.toLive\r\n          ? this.overlayColor.toLive(ctx)\r\n          : this.overlayColor;\r\n\r\n        ctx.fillRect(\r\n          this.overlayColor.offsetX || 0,\r\n          this.overlayColor.offsetY || 0,\r\n          this.width,\r\n          this.height);\r\n      }\r\n      if (this.overlayImage) {\r\n        this._draw(ctx, this.overlayImage);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Method to render only the top canvas.\r\n     * Also used to render the group selection box.\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    renderTop: function () {\r\n      var ctx = this.contextTop || this.contextContainer;\r\n      this.clearContext(ctx);\r\n\r\n      // we render the top context - last object\r\n      if (this.selection && this._groupSelector) {\r\n        this._drawSelection();\r\n      }\r\n\r\n      // delegate rendering to group selection if one exists\r\n      // used for drawing selection borders/controls\r\n      var activeGroup = this.getActiveGroup();\r\n      if (activeGroup) {\r\n        activeGroup.render(ctx);\r\n      }\r\n\r\n      this._renderOverlay(ctx);\r\n\r\n      this.fire('after:render');\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns coordinates of a center of canvas.\r\n     * Returned value is an object with top and left properties\r\n     * @return {Object} object with \"top\" and \"left\" number values\r\n     */\r\n    getCenter: function () {\r\n      return {\r\n        top: this.getHeight() / 2,\r\n        left: this.getWidth() / 2\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Centers object horizontally.\r\n     * You might need to call `setCoords` on an object after centering, to update controls area.\r\n     * @param {fabric.Object} object Object to center horizontally\r\n     * @return {fabric.Canvas} thisArg\r\n     */\r\n    centerObjectH: function (object) {\r\n      this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));\r\n      this.renderAll();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Centers object vertically.\r\n     * You might need to call `setCoords` on an object after centering, to update controls area.\r\n     * @param {fabric.Object} object Object to center vertically\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    centerObjectV: function (object) {\r\n      this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));\r\n      this.renderAll();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Centers object vertically and horizontally.\r\n     * You might need to call `setCoords` on an object after centering, to update controls area.\r\n     * @param {fabric.Object} object Object to center vertically and horizontally\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    centerObject: function(object) {\r\n      var center = this.getCenter();\r\n\r\n      this._centerObject(object, new fabric.Point(center.left, center.top));\r\n      this.renderAll();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {fabric.Object} object Object to center\r\n     * @param {fabric.Point} center Center point\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    _centerObject: function(object, center) {\r\n      object.setPositionByOrigin(center, 'center', 'center');\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returs dataless JSON representation of canvas\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {String} json string\r\n     */\r\n    toDatalessJSON: function (propertiesToInclude) {\r\n      return this.toDatalessObject(propertiesToInclude);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of canvas\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function (propertiesToInclude) {\r\n      return this._toObjectMethod('toObject', propertiesToInclude);\r\n    },\r\n\r\n    /**\r\n     * Returns dataless object representation of canvas\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toDatalessObject: function (propertiesToInclude) {\r\n      return this._toObjectMethod('toDatalessObject', propertiesToInclude);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _toObjectMethod: function (methodName, propertiesToInclude) {\r\n\r\n      var data = {\r\n        objects: this._toObjects(methodName, propertiesToInclude)\r\n      };\r\n\r\n      extend(data, this.__serializeBgOverlay());\r\n\r\n      fabric.util.populateWithProperties(this, data, propertiesToInclude);\r\n\r\n      return data;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _toObjects: function(methodName, propertiesToInclude) {\r\n      return this.getObjects().map(function(instance) {\r\n        return this._toObject(instance, methodName, propertiesToInclude);\r\n      }, this);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _toObject: function(instance, methodName, propertiesToInclude) {\r\n      var originalValue;\r\n\r\n      if (!this.includeDefaultValues) {\r\n        originalValue = instance.includeDefaultValues;\r\n        instance.includeDefaultValues = false;\r\n      }\r\n\r\n      //If the object is part of the current selection group, it should\r\n      //be transformed appropriately\r\n      //i.e. it should be serialised as it would appear if the selection group\r\n      //were to be destroyed.\r\n      var originalProperties = this._realizeGroupTransformOnObject(instance),\r\n          object = instance[methodName](propertiesToInclude);\r\n      if (!this.includeDefaultValues) {\r\n        instance.includeDefaultValues = originalValue;\r\n      }\r\n\r\n      //Undo the damage we did by changing all of its properties\r\n      this._unwindGroupTransformOnObject(instance, originalProperties);\r\n\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Realises an object's group transformation on it\r\n     * @private\r\n     * @param {fabric.Object} [instance] the object to transform (gets mutated)\r\n     * @returns the original values of instance which were changed\r\n     */\r\n    _realizeGroupTransformOnObject: function(instance) {\r\n      var layoutProps = ['angle', 'flipX', 'flipY', 'height', 'left', 'scaleX', 'scaleY', 'top', 'width'];\r\n      if (instance.group && instance.group === this.getActiveGroup()) {\r\n        //Copy all the positionally relevant properties across now\r\n        var originalValues = {};\r\n        layoutProps.forEach(function(prop) {\r\n          originalValues[prop] = instance[prop];\r\n        });\r\n        this.getActiveGroup().realizeTransform(instance);\r\n        return originalValues;\r\n      }\r\n      else {\r\n        return null;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Restores the changed properties of instance\r\n     * @private\r\n     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)\r\n     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject\r\n     */\r\n    _unwindGroupTransformOnObject: function(instance, originalValues) {\r\n      if (originalValues) {\r\n        instance.set(originalValues);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    __serializeBgOverlay: function() {\r\n      var data = {\r\n        background: (this.backgroundColor && this.backgroundColor.toObject)\r\n          ? this.backgroundColor.toObject()\r\n          : this.backgroundColor\r\n      };\r\n\r\n      if (this.overlayColor) {\r\n        data.overlay = this.overlayColor.toObject\r\n          ? this.overlayColor.toObject()\r\n          : this.overlayColor;\r\n      }\r\n      if (this.backgroundImage) {\r\n        data.backgroundImage = this.backgroundImage.toObject();\r\n      }\r\n      if (this.overlayImage) {\r\n        data.overlayImage = this.overlayImage.toObject();\r\n      }\r\n\r\n      return data;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,\r\n     * a zoomed canvas will then produce zoomed SVG output.\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    svgViewportTransformation: true,\r\n\r\n    /**\r\n     * Returns SVG representation of canvas\r\n     * @function\r\n     * @param {Object} [options] Options object for SVG output\r\n     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included\r\n     * @param {Object} [options.viewBox] SVG viewbox object\r\n     * @param {Number} [options.viewBox.x] x-cooridnate of viewbox\r\n     * @param {Number} [options.viewBox.y] y-coordinate of viewbox\r\n     * @param {Number} [options.viewBox.width] Width of viewbox\r\n     * @param {Number} [options.viewBox.height] Height of viewbox\r\n     * @param {String} [options.encoding=UTF-8] Encoding of SVG output\r\n     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.\r\n     * @return {String} SVG string\r\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#serialization}\r\n     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}\r\n     * @example <caption>Normal SVG output</caption>\r\n     * var svg = canvas.toSVG();\r\n     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>\r\n     * var svg = canvas.toSVG({suppressPreamble: true});\r\n     * @example <caption>SVG output with viewBox attribute</caption>\r\n     * var svg = canvas.toSVG({\r\n     *   viewBox: {\r\n     *     x: 100,\r\n     *     y: 100,\r\n     *     width: 200,\r\n     *     height: 300\r\n     *   }\r\n     * });\r\n     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>\r\n     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});\r\n     * @example <caption>Modify SVG output with reviver function</caption>\r\n     * var svg = canvas.toSVG(null, function(svg) {\r\n     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');\r\n     * });\r\n     */\r\n    toSVG: function(options, reviver) {\r\n      options || (options = { });\r\n\r\n      var markup = [];\r\n\r\n      this._setSVGPreamble(markup, options);\r\n      this._setSVGHeader(markup, options);\r\n\r\n      this._setSVGBgOverlayColor(markup, 'backgroundColor');\r\n      this._setSVGBgOverlayImage(markup, 'backgroundImage');\r\n\r\n      this._setSVGObjects(markup, reviver);\r\n\r\n      this._setSVGBgOverlayColor(markup, 'overlayColor');\r\n      this._setSVGBgOverlayImage(markup, 'overlayImage');\r\n\r\n      markup.push('</svg>');\r\n\r\n      return markup.join('');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGPreamble: function(markup, options) {\r\n      if (!options.suppressPreamble) {\r\n        markup.push(\r\n          '<?xml version=\"1.0\" encoding=\"', (options.encoding || 'UTF-8'), '\" standalone=\"no\" ?>\\n',\r\n            '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" ',\r\n              '\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n'\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGHeader: function(markup, options) {\r\n      var width, height, vpt;\r\n\r\n      if (options.viewBox) {\r\n        width = options.viewBox.width;\r\n        height = options.viewBox.height;\r\n      }\r\n      else {\r\n        width = this.width;\r\n        height = this.height;\r\n        if (!this.svgViewportTransformation) {\r\n          vpt = this.viewportTransform;\r\n          width /= vpt[0];\r\n          height /= vpt[3];\r\n        }\r\n      }\r\n\r\n      markup.push(\r\n        '<svg ',\r\n          'xmlns=\"http://www.w3.org/2000/svg\" ',\r\n          'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ',\r\n          'version=\"1.1\" ',\r\n          'width=\"', width, '\" ',\r\n          'height=\"', height, '\" ',\r\n          (this.backgroundColor && !this.backgroundColor.toLive\r\n            ? 'style=\"background-color: ' + this.backgroundColor + '\" '\r\n            : null),\r\n          (options.viewBox\r\n              ? 'viewBox=\"' +\r\n                options.viewBox.x + ' ' +\r\n                options.viewBox.y + ' ' +\r\n                options.viewBox.width + ' ' +\r\n                options.viewBox.height + '\" '\r\n              : null),\r\n          'xml:space=\"preserve\">\\n',\r\n        '<desc>Created with Fabric.js ', fabric.version, '</desc>\\n',\r\n        '<defs>',\r\n          fabric.createSVGFontFacesMarkup(this.getObjects()),\r\n          fabric.createSVGRefElementsMarkup(this),\r\n        '</defs>\\n'\r\n      );\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGObjects: function(markup, reviver) {\r\n      for (var i = 0, objects = this.getObjects(), len = objects.length; i < len; i++) {\r\n        var instance = objects[i],\r\n            //If the object is in a selection group, simulate what would happen to that\r\n            //object when the group is deselected\r\n            originalProperties = this._realizeGroupTransformOnObject(instance);\r\n        markup.push(instance.toSVG(reviver));\r\n        this._unwindGroupTransformOnObject(instance, originalProperties);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGBgOverlayImage: function(markup, property) {\r\n      if (this[property] && this[property].toSVG) {\r\n        markup.push(this[property].toSVG());\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGBgOverlayColor: function(markup, property) {\r\n      if (this[property] && this[property].source) {\r\n        markup.push(\r\n          '<rect x=\"', this[property].offsetX, '\" y=\"', this[property].offsetY, '\" ',\r\n            'width=\"',\r\n              (this[property].repeat === 'repeat-y' || this[property].repeat === 'no-repeat'\r\n                ? this[property].source.width\r\n                : this.width),\r\n            '\" height=\"',\r\n              (this[property].repeat === 'repeat-x' || this[property].repeat === 'no-repeat'\r\n                ? this[property].source.height\r\n                : this.height),\r\n            '\" fill=\"url(#' + property + 'Pattern)\"',\r\n          '></rect>\\n'\r\n        );\r\n      }\r\n      else if (this[property] && property === 'overlayColor') {\r\n        markup.push(\r\n          '<rect x=\"0\" y=\"0\" ',\r\n            'width=\"', this.width,\r\n            '\" height=\"', this.height,\r\n            '\" fill=\"', this[property], '\"',\r\n          '></rect>\\n'\r\n        );\r\n      }\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Moves an object to the bottom of the stack of drawn objects\r\n     * @param {fabric.Object} object Object to send to back\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    sendToBack: function (object) {\r\n      removeFromArray(this._objects, object);\r\n      this._objects.unshift(object);\r\n      return this.renderAll && this.renderAll();\r\n    },\r\n\r\n    /**\r\n     * Moves an object to the top of the stack of drawn objects\r\n     * @param {fabric.Object} object Object to send\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    bringToFront: function (object) {\r\n      removeFromArray(this._objects, object);\r\n      this._objects.push(object);\r\n      return this.renderAll && this.renderAll();\r\n    },\r\n\r\n    /**\r\n     * Moves an object down in stack of drawn objects\r\n     * @param {fabric.Object} object Object to send\r\n     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    sendBackwards: function (object, intersecting) {\r\n      var idx = this._objects.indexOf(object);\r\n\r\n      // if object is not on the bottom of stack\r\n      if (idx !== 0) {\r\n        var newIdx = this._findNewLowerIndex(object, idx, intersecting);\r\n\r\n        removeFromArray(this._objects, object);\r\n        this._objects.splice(newIdx, 0, object);\r\n        this.renderAll && this.renderAll();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _findNewLowerIndex: function(object, idx, intersecting) {\r\n      var newIdx;\r\n\r\n      if (intersecting) {\r\n        newIdx = idx;\r\n\r\n        // traverse down the stack looking for the nearest intersecting object\r\n        for (var i = idx - 1; i >= 0; --i) {\r\n\r\n          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||\r\n                               object.isContainedWithinObject(this._objects[i]) ||\r\n                               this._objects[i].isContainedWithinObject(object);\r\n\r\n          if (isIntersecting) {\r\n            newIdx = i;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        newIdx = idx - 1;\r\n      }\r\n\r\n      return newIdx;\r\n    },\r\n\r\n    /**\r\n     * Moves an object up in stack of drawn objects\r\n     * @param {fabric.Object} object Object to send\r\n     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    bringForward: function (object, intersecting) {\r\n      var idx = this._objects.indexOf(object);\r\n\r\n      // if object is not on top of stack (last item in an array)\r\n      if (idx !== this._objects.length - 1) {\r\n        var newIdx = this._findNewUpperIndex(object, idx, intersecting);\r\n\r\n        removeFromArray(this._objects, object);\r\n        this._objects.splice(newIdx, 0, object);\r\n        this.renderAll && this.renderAll();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _findNewUpperIndex: function(object, idx, intersecting) {\r\n      var newIdx;\r\n\r\n      if (intersecting) {\r\n        newIdx = idx;\r\n\r\n        // traverse up the stack looking for the nearest intersecting object\r\n        for (var i = idx + 1; i < this._objects.length; ++i) {\r\n\r\n          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||\r\n                               object.isContainedWithinObject(this._objects[i]) ||\r\n                               this._objects[i].isContainedWithinObject(object);\r\n\r\n          if (isIntersecting) {\r\n            newIdx = i;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        newIdx = idx + 1;\r\n      }\r\n\r\n      return newIdx;\r\n    },\r\n\r\n    /**\r\n     * Moves an object to specified level in stack of drawn objects\r\n     * @param {fabric.Object} object Object to send\r\n     * @param {Number} index Position to move to\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    moveTo: function (object, index) {\r\n      removeFromArray(this._objects, object);\r\n      this._objects.splice(index, 0, object);\r\n      return this.renderAll && this.renderAll();\r\n    },\r\n\r\n    /**\r\n     * Clears a canvas element and removes all event listeners\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    dispose: function () {\r\n      this.clear();\r\n      this.interactive && this.removeListeners();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a string representation of an instance\r\n     * @return {String} string representation of an instance\r\n     */\r\n    toString: function () {\r\n      return '#<fabric.Canvas (' + this.complexity() + '): ' +\r\n               '{ objects: ' + this.getObjects().length + ' }>';\r\n    }\r\n  });\r\n\r\n  extend(fabric.StaticCanvas.prototype, fabric.Observable);\r\n  extend(fabric.StaticCanvas.prototype, fabric.Collection);\r\n  extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);\r\n\r\n  extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {\r\n\r\n    /**\r\n     * @static\r\n     * @type String\r\n     * @default\r\n     */\r\n    EMPTY_JSON: '{\"objects\": [], \"background\": \"white\"}',\r\n\r\n    /**\r\n     * Provides a way to check support of some of the canvas methods\r\n     * (either those of HTMLCanvasElement itself, or rendering context)\r\n     *\r\n     * @param {String} methodName Method to check support for;\r\n     *                            Could be one of \"getImageData\", \"toDataURL\", \"toDataURLWithQuality\" or \"setLineDash\"\r\n     * @return {Boolean | null} `true` if method is supported (or at least exists),\r\n     *                          `null` if canvas element or context can not be initialized\r\n     */\r\n    supports: function (methodName) {\r\n      var el = fabric.util.createCanvasElement();\r\n\r\n      if (!el || !el.getContext) {\r\n        return null;\r\n      }\r\n\r\n      var ctx = el.getContext('2d');\r\n      if (!ctx) {\r\n        return null;\r\n      }\r\n\r\n      switch (methodName) {\r\n\r\n        case 'getImageData':\r\n          return typeof ctx.getImageData !== 'undefined';\r\n\r\n        case 'setLineDash':\r\n          return typeof ctx.setLineDash !== 'undefined';\r\n\r\n        case 'toDataURL':\r\n          return typeof el.toDataURL !== 'undefined';\r\n\r\n        case 'toDataURLWithQuality':\r\n          try {\r\n            el.toDataURL('image/jpeg', 0);\r\n            return true;\r\n          }\r\n          catch (e) { }\r\n          return false;\r\n\r\n        default:\r\n          return null;\r\n      }\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns JSON representation of canvas\r\n   * @function\r\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n   * @return {String} JSON string\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#serialization}\r\n   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}\r\n   * @example <caption>JSON without additional properties</caption>\r\n   * var json = canvas.toJSON();\r\n   * @example <caption>JSON with additional properties included</caption>\r\n   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'lockUniScaling']);\r\n   * @example <caption>JSON without default values</caption>\r\n   * canvas.includeDefaultValues = false;\r\n   * var json = canvas.toJSON();\r\n   */\r\n  fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;\r\n\r\n})();\r\n\r\n\r\n/**\r\n * BaseBrush class\r\n * @class fabric.BaseBrush\r\n * @see {@link http://fabricjs.com/freedrawing/|Freedrawing demo}\r\n */\r\nfabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {\r\n\r\n  /**\r\n   * Color of a brush\r\n   * @type String\r\n   * @default\r\n   */\r\n  color:            'rgb(0, 0, 0)',\r\n\r\n  /**\r\n   * Width of a brush\r\n   * @type Number\r\n   * @default\r\n   */\r\n  width:            1,\r\n\r\n  /**\r\n   * Shadow object representing shadow of this shape.\r\n   * <b>Backwards incompatibility note:</b> This property replaces \"shadowColor\" (String), \"shadowOffsetX\" (Number),\r\n   * \"shadowOffsetY\" (Number) and \"shadowBlur\" (Number) since v1.2.12\r\n   * @type fabric.Shadow\r\n   * @default\r\n   */\r\n  shadow:           null,\r\n\r\n  /**\r\n   * Line endings style of a brush (one of \"butt\", \"round\", \"square\")\r\n   * @type String\r\n   * @default\r\n   */\r\n  strokeLineCap:    'round',\r\n\r\n  /**\r\n   * Corner style of a brush (one of \"bevil\", \"round\", \"miter\")\r\n   * @type String\r\n   * @default\r\n   */\r\n  strokeLineJoin:   'round',\r\n\r\n  /**\r\n   * Stroke Dash Array.\r\n   * @type Array\r\n   * @default\r\n   */\r\n  strokeDashArray:  null,\r\n\r\n  /**\r\n   * Sets shadow of an object\r\n   * @param {Object|String} [options] Options object or string (e.g. \"2px 2px 10px rgba(0,0,0,0.2)\")\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  setShadow: function(options) {\r\n    this.shadow = new fabric.Shadow(options);\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Sets brush styles\r\n   * @private\r\n   */\r\n  _setBrushStyles: function() {\r\n    var ctx = this.canvas.contextTop;\r\n\r\n    ctx.strokeStyle = this.color;\r\n    ctx.lineWidth = this.width;\r\n    ctx.lineCap = this.strokeLineCap;\r\n    ctx.lineJoin = this.strokeLineJoin;\r\n    if (this.strokeDashArray && fabric.StaticCanvas.supports('setLineDash')) {\r\n      ctx.setLineDash(this.strokeDashArray);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets brush shadow styles\r\n   * @private\r\n   */\r\n  _setShadow: function() {\r\n    if (!this.shadow) {\r\n      return;\r\n    }\r\n\r\n    var ctx = this.canvas.contextTop;\r\n\r\n    ctx.shadowColor = this.shadow.color;\r\n    ctx.shadowBlur = this.shadow.blur;\r\n    ctx.shadowOffsetX = this.shadow.offsetX;\r\n    ctx.shadowOffsetY = this.shadow.offsetY;\r\n  },\r\n\r\n  /**\r\n   * Removes brush shadow styles\r\n   * @private\r\n   */\r\n  _resetShadow: function() {\r\n    var ctx = this.canvas.contextTop;\r\n\r\n    ctx.shadowColor = '';\r\n    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\r\n  }\r\n});\r\n\r\n\r\n(function() {\r\n\r\n  /**\r\n   * PencilBrush class\r\n   * @class fabric.PencilBrush\r\n   * @extends fabric.BaseBrush\r\n   */\r\n  fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {fabric.Canvas} canvas\r\n     * @return {fabric.PencilBrush} Instance of a pencil brush\r\n     */\r\n    initialize: function(canvas) {\r\n      this.canvas = canvas;\r\n      this._points = [ ];\r\n    },\r\n\r\n    /**\r\n     * Inovoked on mouse down\r\n     * @param {Object} pointer\r\n     */\r\n    onMouseDown: function(pointer) {\r\n      this._prepareForDrawing(pointer);\r\n      // capture coordinates immediately\r\n      // this allows to draw dots (when movement never occurs)\r\n      this._captureDrawingPath(pointer);\r\n      this._render();\r\n    },\r\n\r\n    /**\r\n     * Inovoked on mouse move\r\n     * @param {Object} pointer\r\n     */\r\n    onMouseMove: function(pointer) {\r\n      this._captureDrawingPath(pointer);\r\n      // redraw curve\r\n      // clear top canvas\r\n      this.canvas.clearContext(this.canvas.contextTop);\r\n      this._render();\r\n    },\r\n\r\n    /**\r\n     * Invoked on mouse up\r\n     */\r\n    onMouseUp: function() {\r\n      this._finalizeAndAddPath();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} pointer Actual mouse position related to the canvas.\r\n     */\r\n    _prepareForDrawing: function(pointer) {\r\n\r\n      var p = new fabric.Point(pointer.x, pointer.y);\r\n\r\n      this._reset();\r\n      this._addPoint(p);\r\n\r\n      this.canvas.contextTop.moveTo(p.x, p.y);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {fabric.Point} point Point to be added to points array\r\n     */\r\n    _addPoint: function(point) {\r\n      this._points.push(point);\r\n    },\r\n\r\n    /**\r\n     * Clear points array and set contextTop canvas style.\r\n     * @private\r\n     */\r\n    _reset: function() {\r\n      this._points.length = 0;\r\n\r\n      this._setBrushStyles();\r\n      this._setShadow();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} pointer Actual mouse position related to the canvas.\r\n     */\r\n    _captureDrawingPath: function(pointer) {\r\n      var pointerPoint = new fabric.Point(pointer.x, pointer.y);\r\n      this._addPoint(pointerPoint);\r\n    },\r\n\r\n    /**\r\n     * Draw a smooth path on the topCanvas using quadraticCurveTo\r\n     * @private\r\n     */\r\n    _render: function() {\r\n      var ctx  = this.canvas.contextTop,\r\n          v = this.canvas.viewportTransform,\r\n          p1 = this._points[0],\r\n          p2 = this._points[1];\r\n\r\n      ctx.save();\r\n      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\r\n      ctx.beginPath();\r\n\r\n      //if we only have 2 points in the path and they are the same\r\n      //it means that the user only clicked the canvas without moving the mouse\r\n      //then we should be drawing a dot. A path isn't drawn between two identical dots\r\n      //that's why we set them apart a bit\r\n      if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {\r\n        p1.x -= 0.5;\r\n        p2.x += 0.5;\r\n      }\r\n      ctx.moveTo(p1.x, p1.y);\r\n\r\n      for (var i = 1, len = this._points.length; i < len; i++) {\r\n        // we pick the point between pi + 1 & pi + 2 as the\r\n        // end point and p1 as our control point.\r\n        var midPoint = p1.midPointFrom(p2);\r\n        ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\r\n\r\n        p1 = this._points[i];\r\n        p2 = this._points[i + 1];\r\n      }\r\n      // Draw last line as a straight line while\r\n      // we wait for the next point to be able to calculate\r\n      // the bezier control point\r\n      ctx.lineTo(p1.x, p1.y);\r\n      ctx.stroke();\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Converts points to SVG path\r\n     * @param {Array} points Array of points\r\n     * @param {Number} minX\r\n     * @param {Number} minY\r\n     * @return {String} SVG path\r\n     */\r\n    convertPointsToSVGPath: function(points) {\r\n      var path = [],\r\n          p1 = new fabric.Point(points[0].x, points[0].y),\r\n          p2 = new fabric.Point(points[1].x, points[1].y);\r\n\r\n      path.push('M ', points[0].x, ' ', points[0].y, ' ');\r\n      for (var i = 1, len = points.length; i < len; i++) {\r\n        var midPoint = p1.midPointFrom(p2);\r\n        // p1 is our bezier control point\r\n        // midpoint is our endpoint\r\n        // start point is p(i-1) value.\r\n        path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');\r\n        p1 = new fabric.Point(points[i].x, points[i].y);\r\n        if ((i + 1) < points.length) {\r\n          p2 = new fabric.Point(points[i + 1].x, points[i + 1].y);\r\n        }\r\n      }\r\n      path.push('L ', p1.x, ' ', p1.y, ' ');\r\n      return path;\r\n    },\r\n\r\n    /**\r\n     * Creates fabric.Path object to add on canvas\r\n     * @param {String} pathData Path data\r\n     * @return {fabric.Path} Path to add on canvas\r\n     */\r\n    createPath: function(pathData) {\r\n      var path = new fabric.Path(pathData, {\r\n                   fill: null,\r\n                   stroke: this.color,\r\n                   strokeWidth: this.width,\r\n                   strokeLineCap: this.strokeLineCap,\r\n                   strokeLineJoin: this.strokeLineJoin,\r\n                   strokeDashArray: this.strokeDashArray,\r\n                   originX: 'center',\r\n                   originY: 'center'\r\n                 });\r\n\r\n      if (this.shadow) {\r\n        this.shadow.affectStroke = true;\r\n        path.setShadow(this.shadow);\r\n      }\r\n\r\n      return path;\r\n    },\r\n\r\n    /**\r\n     * On mouseup after drawing the path on contextTop canvas\r\n     * we use the points captured to create an new fabric path object\r\n     * and add it to the fabric canvas.\r\n     */\r\n    _finalizeAndAddPath: function() {\r\n      var ctx = this.canvas.contextTop;\r\n      ctx.closePath();\r\n\r\n      var pathData = this.convertPointsToSVGPath(this._points).join('');\r\n      if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {\r\n        // do not create 0 width/height paths, as they are\r\n        // rendered inconsistently across browsers\r\n        // Firefox 4, for example, renders a dot,\r\n        // whereas Chrome 10 renders nothing\r\n        this.canvas.renderAll();\r\n        return;\r\n      }\r\n\r\n      var path = this.createPath(pathData);\r\n\r\n      this.canvas.add(path);\r\n      path.setCoords();\r\n\r\n      this.canvas.clearContext(this.canvas.contextTop);\r\n      this._resetShadow();\r\n      this.canvas.renderAll();\r\n\r\n      // fire event 'path' created\r\n      this.canvas.fire('path:created', { path: path });\r\n    }\r\n  });\r\n})();\r\n\r\n\r\n/**\r\n * CircleBrush class\r\n * @class fabric.CircleBrush\r\n */\r\nfabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {\r\n\r\n  /**\r\n   * Width of a brush\r\n   * @type Number\r\n   * @default\r\n   */\r\n  width: 10,\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {fabric.Canvas} canvas\r\n   * @return {fabric.CircleBrush} Instance of a circle brush\r\n   */\r\n  initialize: function(canvas) {\r\n    this.canvas = canvas;\r\n    this.points = [ ];\r\n  },\r\n\r\n  /**\r\n   * Invoked inside on mouse down and mouse move\r\n   * @param {Object} pointer\r\n   */\r\n  drawDot: function(pointer) {\r\n    var point = this.addPoint(pointer),\r\n        ctx = this.canvas.contextTop,\r\n        v = this.canvas.viewportTransform;\r\n    ctx.save();\r\n    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\r\n\r\n    ctx.fillStyle = point.fill;\r\n    ctx.beginPath();\r\n    ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n\r\n    ctx.restore();\r\n  },\r\n\r\n  /**\r\n   * Invoked on mouse down\r\n   */\r\n  onMouseDown: function(pointer) {\r\n    this.points.length = 0;\r\n    this.canvas.clearContext(this.canvas.contextTop);\r\n    this._setShadow();\r\n    this.drawDot(pointer);\r\n  },\r\n\r\n  /**\r\n   * Invoked on mouse move\r\n   * @param {Object} pointer\r\n   */\r\n  onMouseMove: function(pointer) {\r\n    this.drawDot(pointer);\r\n  },\r\n\r\n  /**\r\n   * Invoked on mouse up\r\n   */\r\n  onMouseUp: function() {\r\n    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;\r\n    this.canvas.renderOnAddRemove = false;\r\n\r\n    var circles = [ ];\r\n\r\n    for (var i = 0, len = this.points.length; i < len; i++) {\r\n      var point = this.points[i],\r\n          circle = new fabric.Circle({\r\n            radius: point.radius,\r\n            left: point.x,\r\n            top: point.y,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            fill: point.fill\r\n          });\r\n\r\n      this.shadow && circle.setShadow(this.shadow);\r\n\r\n      circles.push(circle);\r\n    }\r\n    var group = new fabric.Group(circles, { originX: 'center', originY: 'center' });\r\n    group.canvas = this.canvas;\r\n\r\n    this.canvas.add(group);\r\n    this.canvas.fire('path:created', { path: group });\r\n\r\n    this.canvas.clearContext(this.canvas.contextTop);\r\n    this._resetShadow();\r\n    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\r\n    this.canvas.renderAll();\r\n  },\r\n\r\n  /**\r\n   * @param {Object} pointer\r\n   * @return {fabric.Point} Just added pointer point\r\n   */\r\n  addPoint: function(pointer) {\r\n    var pointerPoint = new fabric.Point(pointer.x, pointer.y),\r\n\r\n        circleRadius = fabric.util.getRandomInt(\r\n                        Math.max(0, this.width - 20), this.width + 20) / 2,\r\n\r\n        circleColor = new fabric.Color(this.color)\r\n                        .setAlpha(fabric.util.getRandomInt(0, 100) / 100)\r\n                        .toRgba();\r\n\r\n    pointerPoint.radius = circleRadius;\r\n    pointerPoint.fill = circleColor;\r\n\r\n    this.points.push(pointerPoint);\r\n\r\n    return pointerPoint;\r\n  }\r\n});\r\n\r\n\r\n/**\r\n * SprayBrush class\r\n * @class fabric.SprayBrush\r\n */\r\nfabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {\r\n\r\n  /**\r\n   * Width of a spray\r\n   * @type Number\r\n   * @default\r\n   */\r\n  width:              10,\r\n\r\n  /**\r\n   * Density of a spray (number of dots per chunk)\r\n   * @type Number\r\n   * @default\r\n   */\r\n  density:            20,\r\n\r\n  /**\r\n   * Width of spray dots\r\n   * @type Number\r\n   * @default\r\n   */\r\n  dotWidth:           1,\r\n\r\n  /**\r\n   * Width variance of spray dots\r\n   * @type Number\r\n   * @default\r\n   */\r\n  dotWidthVariance:   1,\r\n\r\n  /**\r\n   * Whether opacity of a dot should be random\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  randomOpacity:        false,\r\n\r\n  /**\r\n   * Whether overlapping dots (rectangles) should be removed (for performance reasons)\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  optimizeOverlapping:  true,\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {fabric.Canvas} canvas\r\n   * @return {fabric.SprayBrush} Instance of a spray brush\r\n   */\r\n  initialize: function(canvas) {\r\n    this.canvas = canvas;\r\n    this.sprayChunks = [ ];\r\n  },\r\n\r\n  /**\r\n   * Invoked on mouse down\r\n   * @param {Object} pointer\r\n   */\r\n  onMouseDown: function(pointer) {\r\n    this.sprayChunks.length = 0;\r\n    this.canvas.clearContext(this.canvas.contextTop);\r\n    this._setShadow();\r\n\r\n    this.addSprayChunk(pointer);\r\n    this.render();\r\n  },\r\n\r\n  /**\r\n   * Invoked on mouse move\r\n   * @param {Object} pointer\r\n   */\r\n  onMouseMove: function(pointer) {\r\n    this.addSprayChunk(pointer);\r\n    this.render();\r\n  },\r\n\r\n  /**\r\n   * Invoked on mouse up\r\n   */\r\n  onMouseUp: function() {\r\n    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;\r\n    this.canvas.renderOnAddRemove = false;\r\n\r\n    var rects = [ ];\r\n\r\n    for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {\r\n      var sprayChunk = this.sprayChunks[i];\r\n\r\n      for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {\r\n\r\n        var rect = new fabric.Rect({\r\n          width: sprayChunk[j].width,\r\n          height: sprayChunk[j].width,\r\n          left: sprayChunk[j].x + 1,\r\n          top: sprayChunk[j].y + 1,\r\n          originX: 'center',\r\n          originY: 'center',\r\n          fill: this.color\r\n        });\r\n\r\n        this.shadow && rect.setShadow(this.shadow);\r\n        rects.push(rect);\r\n      }\r\n    }\r\n\r\n    if (this.optimizeOverlapping) {\r\n      rects = this._getOptimizedRects(rects);\r\n    }\r\n\r\n    var group = new fabric.Group(rects, { originX: 'center', originY: 'center' });\r\n    group.canvas = this.canvas;\r\n\r\n    this.canvas.add(group);\r\n    this.canvas.fire('path:created', { path: group });\r\n\r\n    this.canvas.clearContext(this.canvas.contextTop);\r\n    this._resetShadow();\r\n    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\r\n    this.canvas.renderAll();\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {Array} rects\r\n   */\r\n  _getOptimizedRects: function(rects) {\r\n\r\n    // avoid creating duplicate rects at the same coordinates\r\n    var uniqueRects = { }, key;\r\n\r\n    for (var i = 0, len = rects.length; i < len; i++) {\r\n      key = rects[i].left + '' + rects[i].top;\r\n      if (!uniqueRects[key]) {\r\n        uniqueRects[key] = rects[i];\r\n      }\r\n    }\r\n    var uniqueRectsArray = [ ];\r\n    for (key in uniqueRects) {\r\n      uniqueRectsArray.push(uniqueRects[key]);\r\n    }\r\n\r\n    return uniqueRectsArray;\r\n  },\r\n\r\n  /**\r\n   * Renders brush\r\n   */\r\n  render: function() {\r\n    var ctx = this.canvas.contextTop;\r\n    ctx.fillStyle = this.color;\r\n\r\n    var v = this.canvas.viewportTransform;\r\n    ctx.save();\r\n    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\r\n\r\n    for (var i = 0, len = this.sprayChunkPoints.length; i < len; i++) {\r\n      var point = this.sprayChunkPoints[i];\r\n      if (typeof point.opacity !== 'undefined') {\r\n        ctx.globalAlpha = point.opacity;\r\n      }\r\n      ctx.fillRect(point.x, point.y, point.width, point.width);\r\n    }\r\n    ctx.restore();\r\n  },\r\n\r\n  /**\r\n   * @param {Object} pointer\r\n   */\r\n  addSprayChunk: function(pointer) {\r\n    this.sprayChunkPoints = [ ];\r\n\r\n    var x, y, width, radius = this.width / 2;\r\n\r\n    for (var i = 0; i < this.density; i++) {\r\n\r\n      x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);\r\n      y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);\r\n\r\n      if (this.dotWidthVariance) {\r\n        width = fabric.util.getRandomInt(\r\n          // bottom clamp width to 1\r\n          Math.max(1, this.dotWidth - this.dotWidthVariance),\r\n          this.dotWidth + this.dotWidthVariance);\r\n      }\r\n      else {\r\n        width = this.dotWidth;\r\n      }\r\n\r\n      var point = new fabric.Point(x, y);\r\n      point.width = width;\r\n\r\n      if (this.randomOpacity) {\r\n        point.opacity = fabric.util.getRandomInt(0, 100) / 100;\r\n      }\r\n\r\n      this.sprayChunkPoints.push(point);\r\n    }\r\n\r\n    this.sprayChunks.push(this.sprayChunkPoints);\r\n  }\r\n});\r\n\r\n\r\n/**\r\n * PatternBrush class\r\n * @class fabric.PatternBrush\r\n * @extends fabric.BaseBrush\r\n */\r\nfabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {\r\n\r\n  getPatternSrc: function() {\r\n\r\n    var dotWidth = 20,\r\n        dotDistance = 5,\r\n        patternCanvas = fabric.document.createElement('canvas'),\r\n        patternCtx = patternCanvas.getContext('2d');\r\n\r\n    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;\r\n\r\n    patternCtx.fillStyle = this.color;\r\n    patternCtx.beginPath();\r\n    patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);\r\n    patternCtx.closePath();\r\n    patternCtx.fill();\r\n\r\n    return patternCanvas;\r\n  },\r\n\r\n  getPatternSrcFunction: function() {\r\n    return String(this.getPatternSrc).replace('this.color', '\"' + this.color + '\"');\r\n  },\r\n\r\n  /**\r\n   * Creates \"pattern\" instance property\r\n   */\r\n  getPattern: function() {\r\n    return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');\r\n  },\r\n\r\n  /**\r\n   * Sets brush styles\r\n   */\r\n  _setBrushStyles: function() {\r\n    this.callSuper('_setBrushStyles');\r\n    this.canvas.contextTop.strokeStyle = this.getPattern();\r\n  },\r\n\r\n  /**\r\n   * Creates path\r\n   */\r\n  createPath: function(pathData) {\r\n    var path = this.callSuper('createPath', pathData);\r\n    path.stroke = new fabric.Pattern({\r\n      source: this.source || this.getPatternSrcFunction()\r\n    });\r\n    return path;\r\n  }\r\n});\r\n\r\n\r\n(function() {\r\n\r\n  var getPointer = fabric.util.getPointer,\r\n      degreesToRadians = fabric.util.degreesToRadians,\r\n      radiansToDegrees = fabric.util.radiansToDegrees,\r\n      atan2 = Math.atan2,\r\n      abs = Math.abs,\r\n\r\n      STROKE_OFFSET = 0.5;\r\n\r\n  /**\r\n   * Canvas class\r\n   * @class fabric.Canvas\r\n   * @extends fabric.StaticCanvas\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#canvas}\r\n   * @see {@link fabric.Canvas#initialize} for constructor definition\r\n   *\r\n   * @fires object:modified\r\n   * @fires object:rotating\r\n   * @fires object:scaling\r\n   * @fires object:moving\r\n   * @fires object:selected\r\n   *\r\n   * @fires before:selection:cleared\r\n   * @fires selection:cleared\r\n   * @fires selection:created\r\n   *\r\n   * @fires path:created\r\n   * @fires mouse:down\r\n   * @fires mouse:move\r\n   * @fires mouse:up\r\n   * @fires mouse:over\r\n   * @fires mouse:out\r\n   *\r\n   */\r\n  fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\r\n     * @param {Object} [options] Options object\r\n     * @return {Object} thisArg\r\n     */\r\n    initialize: function(el, options) {\r\n      options || (options = { });\r\n\r\n      this._initStatic(el, options);\r\n      this._initInteractive();\r\n      this._createCacheCanvas();\r\n\r\n      fabric.Canvas.activeInstance = this;\r\n    },\r\n\r\n    /**\r\n     * When true, objects can be transformed by one side (unproportionally)\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    uniScaleTransform:      false,\r\n\r\n    /**\r\n     * When true, objects use center point as the origin of scale transformation.\r\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\r\n     * @since 1.3.4\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    centeredScaling:        false,\r\n\r\n    /**\r\n     * When true, objects use center point as the origin of rotate transformation.\r\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\r\n     * @since 1.3.4\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    centeredRotation:       false,\r\n\r\n    /**\r\n     * Indicates that canvas is interactive. This property should not be changed.\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    interactive:            true,\r\n\r\n    /**\r\n     * Indicates whether group selection should be enabled\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    selection:              true,\r\n\r\n    /**\r\n     * Color of selection\r\n     * @type String\r\n     * @default\r\n     */\r\n    selectionColor:         'rgba(100, 100, 255, 0.3)', // blue\r\n\r\n    /**\r\n     * Default dash array pattern\r\n     * If not empty the selection border is dashed\r\n     * @type Array\r\n     */\r\n    selectionDashArray:     [ ],\r\n\r\n    /**\r\n     * Color of the border of selection (usually slightly darker than color of selection itself)\r\n     * @type String\r\n     * @default\r\n     */\r\n    selectionBorderColor:   'rgba(255, 255, 255, 0.3)',\r\n\r\n    /**\r\n     * Width of a line used in object/group selection\r\n     * @type Number\r\n     * @default\r\n     */\r\n    selectionLineWidth:     1,\r\n\r\n    /**\r\n     * Default cursor value used when hovering over an object on canvas\r\n     * @type String\r\n     * @default\r\n     */\r\n    hoverCursor:            'move',\r\n\r\n    /**\r\n     * Default cursor value used when moving an object on canvas\r\n     * @type String\r\n     * @default\r\n     */\r\n    moveCursor:             'move',\r\n\r\n    /**\r\n     * Default cursor value used for the entire canvas\r\n     * @type String\r\n     * @default\r\n     */\r\n    defaultCursor:          'default',\r\n\r\n    /**\r\n     * Cursor value used during free drawing\r\n     * @type String\r\n     * @default\r\n     */\r\n    freeDrawingCursor:      'crosshair',\r\n\r\n    /**\r\n     * Cursor value used for rotation point\r\n     * @type String\r\n     * @default\r\n     */\r\n    rotationCursor:         'crosshair',\r\n\r\n    /**\r\n     * Default element class that's given to wrapper (div) element of canvas\r\n     * @type String\r\n     * @default\r\n     */\r\n    containerClass:         'canvas-container',\r\n\r\n    /**\r\n     * When true, object detection happens on per-pixel basis rather than on per-bounding-box\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    perPixelTargetFind:     false,\r\n\r\n    /**\r\n     * Number of pixels around target pixel to tolerate (consider active) during object detection\r\n     * @type Number\r\n     * @default\r\n     */\r\n    targetFindTolerance:    0,\r\n\r\n    /**\r\n     * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    skipTargetFind:         false,\r\n\r\n    /**\r\n     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.\r\n     * After mousedown, mousemove creates a shape,\r\n     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.\r\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4/#free_drawing}\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    isDrawingMode:          false,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _initInteractive: function() {\r\n      this._currentTransform = null;\r\n      this._groupSelector = null;\r\n      this._initWrapperElement();\r\n      this._createUpperCanvas();\r\n      this._initEventListeners();\r\n\r\n      this._initRetinaScaling();\r\n\r\n      this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);\r\n\r\n      this.calcOffset();\r\n    },\r\n\r\n    /**\r\n     * Resets the current transform to its original values and chooses the type of resizing based on the event\r\n     * @private\r\n     * @param {Event} e Event object fired on mousemove\r\n     */\r\n    _resetCurrentTransform: function(e) {\r\n      var t = this._currentTransform;\r\n\r\n      t.target.set({\r\n        scaleX: t.original.scaleX,\r\n        scaleY: t.original.scaleY,\r\n        left: t.original.left,\r\n        top: t.original.top\r\n      });\r\n\r\n      if (this._shouldCenterTransform(e, t.target)) {\r\n        if (t.action === 'rotate') {\r\n          this._setOriginToCenter(t.target);\r\n        }\r\n        else {\r\n          if (t.originX !== 'center') {\r\n            if (t.originX === 'right') {\r\n              t.mouseXSign = -1;\r\n            }\r\n            else {\r\n              t.mouseXSign = 1;\r\n            }\r\n          }\r\n          if (t.originY !== 'center') {\r\n            if (t.originY === 'bottom') {\r\n              t.mouseYSign = -1;\r\n            }\r\n            else {\r\n              t.mouseYSign = 1;\r\n            }\r\n          }\r\n\r\n          t.originX = 'center';\r\n          t.originY = 'center';\r\n        }\r\n      }\r\n      else {\r\n        t.originX = t.original.originX;\r\n        t.originY = t.original.originY;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Checks if point is contained within an area of given object\r\n     * @param {Event} e Event object\r\n     * @param {fabric.Object} target Object to test against\r\n     * @return {Boolean} true if point is contained within an area of given object\r\n     */\r\n    containsPoint: function (e, target) {\r\n      var pointer = this.getPointer(e, true),\r\n          xy = this._normalizePointer(target, pointer);\r\n\r\n      // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html\r\n      // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html\r\n      return (target.containsPoint(xy) || target._findTargetCorner(pointer));\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _normalizePointer: function (object, pointer) {\r\n      var activeGroup = this.getActiveGroup(),\r\n          x = pointer.x,\r\n          y = pointer.y,\r\n          isObjectInGroup = (\r\n            activeGroup &&\r\n            object.type !== 'group' &&\r\n            activeGroup.contains(object)),\r\n          lt;\r\n\r\n      if (isObjectInGroup) {\r\n        lt = fabric.util.transformPoint(activeGroup.getCenterPoint(), this.viewportTransform, true);\r\n        x -= lt.x;\r\n        y -= lt.y;\r\n        x /= activeGroup.scaleX;\r\n        y /= activeGroup.scaleY;\r\n      }\r\n      return { x: x, y: y };\r\n    },\r\n\r\n    /**\r\n     * Returns true if object is transparent at a certain location\r\n     * @param {fabric.Object} target Object to check\r\n     * @param {Number} x Left coordinate\r\n     * @param {Number} y Top coordinate\r\n     * @return {Boolean}\r\n     */\r\n    isTargetTransparent: function (target, x, y) {\r\n      var hasBorders = target.hasBorders,\r\n          transparentCorners = target.transparentCorners;\r\n\r\n      target.hasBorders = target.transparentCorners = false;\r\n\r\n      this._draw(this.contextCache, target);\r\n\r\n      target.hasBorders = hasBorders;\r\n      target.transparentCorners = transparentCorners;\r\n\r\n      var isTransparent = fabric.util.isTransparent(\r\n        this.contextCache, x, y, this.targetFindTolerance);\r\n\r\n      this.clearContext(this.contextCache);\r\n\r\n      return isTransparent;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object\r\n     * @param {fabric.Object} target\r\n     */\r\n    _shouldClearSelection: function (e, target) {\r\n      var activeGroup = this.getActiveGroup(),\r\n          activeObject = this.getActiveObject();\r\n\r\n      return (\r\n        !target\r\n        ||\r\n        (target &&\r\n          activeGroup &&\r\n          !activeGroup.contains(target) &&\r\n          activeGroup !== target &&\r\n          !e.shiftKey)\r\n        ||\r\n        (target && !target.evented)\r\n        ||\r\n        (target &&\r\n          !target.selectable &&\r\n          activeObject &&\r\n          activeObject !== target)\r\n      );\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object\r\n     * @param {fabric.Object} target\r\n     */\r\n    _shouldCenterTransform: function (e, target) {\r\n      if (!target) {\r\n        return;\r\n      }\r\n\r\n      var t = this._currentTransform,\r\n          centerTransform;\r\n\r\n      if (t.action === 'scale' || t.action === 'scaleX' || t.action === 'scaleY') {\r\n        centerTransform = this.centeredScaling || target.centeredScaling;\r\n      }\r\n      else if (t.action === 'rotate') {\r\n        centerTransform = this.centeredRotation || target.centeredRotation;\r\n      }\r\n\r\n      return centerTransform ? !e.altKey : e.altKey;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getOriginFromCorner: function(target, corner) {\r\n      var origin = {\r\n        x: target.originX,\r\n        y: target.originY\r\n      };\r\n\r\n      if (corner === 'ml' || corner === 'tl' || corner === 'bl') {\r\n        origin.x = 'right';\r\n      }\r\n      else if (corner === 'mr' || corner === 'tr' || corner === 'br') {\r\n        origin.x = 'left';\r\n      }\r\n\r\n      if (corner === 'tl' || corner === 'mt' || corner === 'tr') {\r\n        origin.y = 'bottom';\r\n      }\r\n      else if (corner === 'bl' || corner === 'mb' || corner === 'br') {\r\n        origin.y = 'top';\r\n      }\r\n\r\n      return origin;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getActionFromCorner: function(target, corner) {\r\n      var action = 'drag';\r\n      if (corner) {\r\n        action = (corner === 'ml' || corner === 'mr')\r\n          ? 'scaleX'\r\n          : (corner === 'mt' || corner === 'mb')\r\n            ? 'scaleY'\r\n            : corner === 'mtr'\r\n              ? 'rotate'\r\n              : 'scale';\r\n      }\r\n      return action;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object\r\n     * @param {fabric.Object} target\r\n     */\r\n    _setupCurrentTransform: function (e, target) {\r\n      if (!target) {\r\n        return;\r\n      }\r\n\r\n      var pointer = this.getPointer(e),\r\n          corner = target._findTargetCorner(this.getPointer(e, true)),\r\n          action = this._getActionFromCorner(target, corner),\r\n          origin = this._getOriginFromCorner(target, corner);\r\n\r\n      this._currentTransform = {\r\n        target: target,\r\n        action: action,\r\n        scaleX: target.scaleX,\r\n        scaleY: target.scaleY,\r\n        offsetX: pointer.x - target.left,\r\n        offsetY: pointer.y - target.top,\r\n        originX: origin.x,\r\n        originY: origin.y,\r\n        ex: pointer.x,\r\n        ey: pointer.y,\r\n        left: target.left,\r\n        top: target.top,\r\n        theta: degreesToRadians(target.angle),\r\n        width: target.width * target.scaleX,\r\n        mouseXSign: 1,\r\n        mouseYSign: 1\r\n      };\r\n\r\n      this._currentTransform.original = {\r\n        left: target.left,\r\n        top: target.top,\r\n        scaleX: target.scaleX,\r\n        scaleY: target.scaleY,\r\n        originX: origin.x,\r\n        originY: origin.y\r\n      };\r\n\r\n      this._resetCurrentTransform(e);\r\n    },\r\n\r\n    /**\r\n     * Translates object by \"setting\" its left/top\r\n     * @private\r\n     * @param {Number} x pointer's x coordinate\r\n     * @param {Number} y pointer's y coordinate\r\n     */\r\n    _translateObject: function (x, y) {\r\n      var target = this._currentTransform.target;\r\n\r\n      if (!target.get('lockMovementX')) {\r\n        target.set('left', x - this._currentTransform.offsetX);\r\n      }\r\n      if (!target.get('lockMovementY')) {\r\n        target.set('top', y - this._currentTransform.offsetY);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Scales object by invoking its scaleX/scaleY methods\r\n     * @private\r\n     * @param {Number} x pointer's x coordinate\r\n     * @param {Number} y pointer's y coordinate\r\n     * @param {String} by Either 'x' or 'y' - specifies dimension constraint by which to scale an object.\r\n     *                    When not provided, an object is scaled by both dimensions equally\r\n     */\r\n    _scaleObject: function (x, y, by) {\r\n      var t = this._currentTransform,\r\n          target = t.target,\r\n          lockScalingX = target.get('lockScalingX'),\r\n          lockScalingY = target.get('lockScalingY'),\r\n          lockScalingFlip = target.get('lockScalingFlip');\r\n\r\n      if (lockScalingX && lockScalingY) {\r\n        return;\r\n      }\r\n\r\n      // Get the constraint point\r\n      var constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY),\r\n          localMouse = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY);\r\n\r\n      this._setLocalMouse(localMouse, t);\r\n\r\n      // Actually scale the object\r\n      this._setObjectScale(localMouse, t, lockScalingX, lockScalingY, by, lockScalingFlip);\r\n\r\n      // Make sure the constraints apply\r\n      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setObjectScale: function(localMouse, transform, lockScalingX, lockScalingY, by, lockScalingFlip) {\r\n      var target = transform.target, forbidScalingX = false, forbidScalingY = false,\r\n          dim = target._getNonTransformedDimensions();\r\n\r\n      transform.newScaleX = localMouse.x / dim.x;\r\n      transform.newScaleY = localMouse.y / dim.y;\r\n\r\n      if (lockScalingFlip && transform.newScaleX <= 0 && transform.newScaleX < target.scaleX) {\r\n        forbidScalingX = true;\r\n      }\r\n\r\n      if (lockScalingFlip && transform.newScaleY <= 0 && transform.newScaleY < target.scaleY) {\r\n        forbidScalingY = true;\r\n      }\r\n\r\n      if (by === 'equally' && !lockScalingX && !lockScalingY) {\r\n        forbidScalingX || forbidScalingY || this._scaleObjectEqually(localMouse, target, transform);\r\n      }\r\n      else if (!by) {\r\n        forbidScalingX || lockScalingX || target.set('scaleX', transform.newScaleX);\r\n        forbidScalingY || lockScalingY || target.set('scaleY', transform.newScaleY);\r\n      }\r\n      else if (by === 'x' && !target.get('lockUniScaling')) {\r\n        forbidScalingX || lockScalingX || target.set('scaleX', transform.newScaleX);\r\n      }\r\n      else if (by === 'y' && !target.get('lockUniScaling')) {\r\n        forbidScalingY || lockScalingY || target.set('scaleY', transform.newScaleY);\r\n      }\r\n\r\n      forbidScalingX || forbidScalingY || this._flipObject(transform, by);\r\n\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _scaleObjectEqually: function(localMouse, target, transform) {\r\n\r\n      var dist = localMouse.y + localMouse.x,\r\n          dim = target._getNonTransformedDimensions(),\r\n          lastDist = dim.y * transform.original.scaleY +\r\n                     dim.x * transform.original.scaleX;\r\n\r\n      // We use transform.scaleX/Y instead of target.scaleX/Y\r\n      // because the object may have a min scale and we'll loose the proportions\r\n      transform.newScaleX = transform.original.scaleX * dist / lastDist;\r\n      transform.newScaleY = transform.original.scaleY * dist / lastDist;\r\n\r\n      target.set('scaleX', transform.newScaleX);\r\n      target.set('scaleY', transform.newScaleY);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _flipObject: function(transform, by) {\r\n      if (transform.newScaleX < 0 && by !== 'y') {\r\n        if (transform.originX === 'left') {\r\n          transform.originX = 'right';\r\n        }\r\n        else if (transform.originX === 'right') {\r\n          transform.originX = 'left';\r\n        }\r\n      }\r\n\r\n      if (transform.newScaleY < 0 && by !== 'x') {\r\n        if (transform.originY === 'top') {\r\n          transform.originY = 'bottom';\r\n        }\r\n        else if (transform.originY === 'bottom') {\r\n          transform.originY = 'top';\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setLocalMouse: function(localMouse, t) {\r\n      var target = t.target;\r\n\r\n      if (t.originX === 'right') {\r\n        localMouse.x *= -1;\r\n      }\r\n      else if (t.originX === 'center') {\r\n        localMouse.x *= t.mouseXSign * 2;\r\n\r\n        if (localMouse.x < 0) {\r\n          t.mouseXSign = -t.mouseXSign;\r\n        }\r\n      }\r\n\r\n      if (t.originY === 'bottom') {\r\n        localMouse.y *= -1;\r\n      }\r\n      else if (t.originY === 'center') {\r\n        localMouse.y *= t.mouseYSign * 2;\r\n\r\n        if (localMouse.y < 0) {\r\n          t.mouseYSign = -t.mouseYSign;\r\n        }\r\n      }\r\n\r\n      // adjust the mouse coordinates when dealing with padding\r\n      if (abs(localMouse.x) > target.padding) {\r\n        if (localMouse.x < 0) {\r\n          localMouse.x += target.padding;\r\n        }\r\n        else {\r\n          localMouse.x -= target.padding;\r\n        }\r\n      }\r\n      else { // mouse is within the padding, set to 0\r\n        localMouse.x = 0;\r\n      }\r\n\r\n      if (abs(localMouse.y) > target.padding) {\r\n        if (localMouse.y < 0) {\r\n          localMouse.y += target.padding;\r\n        }\r\n        else {\r\n          localMouse.y -= target.padding;\r\n        }\r\n      }\r\n      else {\r\n        localMouse.y = 0;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Rotates object by invoking its rotate method\r\n     * @private\r\n     * @param {Number} x pointer's x coordinate\r\n     * @param {Number} y pointer's y coordinate\r\n     */\r\n    _rotateObject: function (x, y) {\r\n\r\n      var t = this._currentTransform;\r\n\r\n      if (t.target.get('lockRotation')) {\r\n        return;\r\n      }\r\n\r\n      var lastAngle = atan2(t.ey - t.top, t.ex - t.left),\r\n          curAngle = atan2(y - t.top, x - t.left),\r\n          angle = radiansToDegrees(curAngle - lastAngle + t.theta);\r\n\r\n      // normalize angle to positive value\r\n      if (angle < 0) {\r\n        angle = 360 + angle;\r\n      }\r\n\r\n      t.target.angle = angle % 360;\r\n    },\r\n\r\n    /**\r\n     * Set the cursor type of the canvas element\r\n     * @param {String} value Cursor type of the canvas element.\r\n     * @see http://www.w3.org/TR/css3-ui/#cursor\r\n     */\r\n    setCursor: function (value) {\r\n      this.upperCanvasEl.style.cursor = value;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _resetObjectTransform: function (target) {\r\n      target.scaleX = 1;\r\n      target.scaleY = 1;\r\n      target.setAngle(0);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _drawSelection: function () {\r\n      var ctx = this.contextTop,\r\n          groupSelector = this._groupSelector,\r\n          left = groupSelector.left,\r\n          top = groupSelector.top,\r\n          aleft = abs(left),\r\n          atop = abs(top);\r\n\r\n      ctx.fillStyle = this.selectionColor;\r\n\r\n      ctx.fillRect(\r\n        groupSelector.ex - ((left > 0) ? 0 : -left),\r\n        groupSelector.ey - ((top > 0) ? 0 : -top),\r\n        aleft,\r\n        atop\r\n      );\r\n\r\n      ctx.lineWidth = this.selectionLineWidth;\r\n      ctx.strokeStyle = this.selectionBorderColor;\r\n\r\n      // selection border\r\n      if (this.selectionDashArray.length > 1) {\r\n\r\n        var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0: aleft),\r\n            py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0: atop);\r\n\r\n        ctx.beginPath();\r\n\r\n        fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);\r\n        fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);\r\n        fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);\r\n        fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);\r\n\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n      }\r\n      else {\r\n        ctx.strokeRect(\r\n          groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),\r\n          groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),\r\n          aleft,\r\n          atop\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _isLastRenderedObject: function(e) {\r\n      return (\r\n        this.controlsAboveOverlay &&\r\n        this.lastRenderedObjectWithControlsAboveOverlay &&\r\n        this.lastRenderedObjectWithControlsAboveOverlay.visible &&\r\n        this.containsPoint(e, this.lastRenderedObjectWithControlsAboveOverlay) &&\r\n        this.lastRenderedObjectWithControlsAboveOverlay._findTargetCorner(this.getPointer(e, true)));\r\n    },\r\n\r\n    /**\r\n     * Method that determines what object we are clicking on\r\n     * @param {Event} e mouse event\r\n     * @param {Boolean} skipGroup when true, group is skipped and only objects are traversed through\r\n     */\r\n    findTarget: function (e, skipGroup) {\r\n      if (this.skipTargetFind) {\r\n        return;\r\n      }\r\n\r\n      if (this._isLastRenderedObject(e)) {\r\n        return this.lastRenderedObjectWithControlsAboveOverlay;\r\n      }\r\n\r\n      // first check current group (if one exists)\r\n      var activeGroup = this.getActiveGroup();\r\n      if (activeGroup && !skipGroup && this.containsPoint(e, activeGroup)) {\r\n        return activeGroup;\r\n      }\r\n\r\n      var target = this._searchPossibleTargets(e, skipGroup);\r\n      this._fireOverOutEvents(target, e);\r\n\r\n      return target;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _fireOverOutEvents: function(target, e) {\r\n      if (target) {\r\n        if (this._hoveredTarget !== target) {\r\n          if (this._hoveredTarget) {\r\n            this.fire('mouse:out', { target: this._hoveredTarget, e: e });\r\n            this._hoveredTarget.fire('mouseout');\r\n          }\r\n          this.fire('mouse:over', { target: target, e: e });\r\n          target.fire('mouseover');\r\n          this._hoveredTarget = target;\r\n        }\r\n      }\r\n      else if (this._hoveredTarget) {\r\n        this.fire('mouse:out', { target: this._hoveredTarget, e: e });\r\n        this._hoveredTarget.fire('mouseout');\r\n        this._hoveredTarget = null;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _checkTarget: function(e, obj, pointer) {\r\n      if (obj &&\r\n          obj.visible &&\r\n          obj.evented &&\r\n          this.containsPoint(e, obj)){\r\n        if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {\r\n          var isTransparent = this.isTargetTransparent(obj, pointer.x, pointer.y);\r\n          if (!isTransparent) {\r\n            return true;\r\n          }\r\n        }\r\n        else {\r\n          return true;\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _searchPossibleTargets: function(e, skipGroup) {\r\n\r\n      // Cache all targets where their bounding box contains point.\r\n      var target,\r\n          pointer = this.getPointer(e, true),\r\n          i = this._objects.length;\r\n      // Do not check for currently grouped objects, since we check the parent group itself.\r\n      // untill we call this function specifically to search inside the activeGroup\r\n      while (i--) {\r\n        if ((!this._objects[i].group || skipGroup) && this._checkTarget(e, this._objects[i], pointer)){\r\n          this.relatedTarget = this._objects[i];\r\n          target = this._objects[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      return target;\r\n    },\r\n\r\n    /**\r\n     * Returns pointer coordinates relative to canvas.\r\n     * @param {Event} e\r\n     * @return {Object} object with \"x\" and \"y\" number values\r\n     */\r\n    getPointer: function (e, ignoreZoom, upperCanvasEl) {\r\n      if (!upperCanvasEl) {\r\n        upperCanvasEl = this.upperCanvasEl;\r\n      }\r\n      var pointer = getPointer(e),\r\n          bounds = upperCanvasEl.getBoundingClientRect(),\r\n          boundsWidth = bounds.width || 0,\r\n          boundsHeight = bounds.height || 0,\r\n          cssScale;\r\n\r\n      if (!boundsWidth || !boundsHeight ) {\r\n        if ('top' in bounds && 'bottom' in bounds) {\r\n          boundsHeight = Math.abs( bounds.top - bounds.bottom );\r\n        }\r\n        if ('right' in bounds && 'left' in bounds) {\r\n          boundsWidth = Math.abs( bounds.right - bounds.left );\r\n        }\r\n      }\r\n\r\n      this.calcOffset();\r\n\r\n      pointer.x = pointer.x - this._offset.left;\r\n      pointer.y = pointer.y - this._offset.top;\r\n      if (!ignoreZoom) {\r\n        pointer = fabric.util.transformPoint(\r\n          pointer,\r\n          fabric.util.invertTransform(this.viewportTransform)\r\n        );\r\n      }\r\n\r\n      if (boundsWidth === 0 || boundsHeight === 0) {\r\n        // If bounds are not available (i.e. not visible), do not apply scale.\r\n        cssScale = { width: 1, height: 1 };\r\n      }\r\n      else {\r\n        cssScale = {\r\n          width: upperCanvasEl.width / boundsWidth,\r\n          height: upperCanvasEl.height / boundsHeight\r\n        };\r\n      }\r\n\r\n      return {\r\n        x: pointer.x * cssScale.width,\r\n        y: pointer.y * cssScale.height\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized\r\n     */\r\n    _createUpperCanvas: function () {\r\n      var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\\s*lower-canvas\\s*/, '');\r\n\r\n      this.upperCanvasEl = this._createCanvasElement();\r\n      fabric.util.addClass(this.upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);\r\n\r\n      this.wrapperEl.appendChild(this.upperCanvasEl);\r\n\r\n      this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl);\r\n      this._applyCanvasStyle(this.upperCanvasEl);\r\n      this.contextTop = this.upperCanvasEl.getContext('2d');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _createCacheCanvas: function () {\r\n      this.cacheCanvasEl = this._createCanvasElement();\r\n      this.cacheCanvasEl.setAttribute('width', this.width);\r\n      this.cacheCanvasEl.setAttribute('height', this.height);\r\n      this.contextCache = this.cacheCanvasEl.getContext('2d');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _initWrapperElement: function () {\r\n      this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {\r\n        'class': this.containerClass\r\n      });\r\n      fabric.util.setStyle(this.wrapperEl, {\r\n        width: this.getWidth() + 'px',\r\n        height: this.getHeight() + 'px',\r\n        position: 'relative'\r\n      });\r\n      fabric.util.makeElementUnselectable(this.wrapperEl);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {HTMLElement} element canvas element to apply styles on\r\n     */\r\n    _applyCanvasStyle: function (element) {\r\n      var width = this.getWidth() || element.width,\r\n          height = this.getHeight() || element.height;\r\n\r\n      fabric.util.setStyle(element, {\r\n        position: 'absolute',\r\n        width: width + 'px',\r\n        height: height + 'px',\r\n        left: 0,\r\n        top: 0\r\n      });\r\n      element.width = width;\r\n      element.height = height;\r\n      fabric.util.makeElementUnselectable(element);\r\n    },\r\n\r\n    /**\r\n     * Copys the the entire inline style from one element (fromEl) to another (toEl)\r\n     * @private\r\n     * @param {Element} fromEl Element style is copied from\r\n     * @param {Element} toEl Element copied style is applied to\r\n     */\r\n    _copyCanvasStyle: function (fromEl, toEl) {\r\n      toEl.style.cssText = fromEl.style.cssText;\r\n    },\r\n\r\n    /**\r\n     * Returns context of canvas where object selection is drawn\r\n     * @return {CanvasRenderingContext2D}\r\n     */\r\n    getSelectionContext: function() {\r\n      return this.contextTop;\r\n    },\r\n\r\n    /**\r\n     * Returns &lt;canvas> element on which object selection is drawn\r\n     * @return {HTMLCanvasElement}\r\n     */\r\n    getSelectionElement: function () {\r\n      return this.upperCanvasEl;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} object\r\n     */\r\n    _setActiveObject: function(object) {\r\n      if (this._activeObject) {\r\n        this._activeObject.set('active', false);\r\n      }\r\n      this._activeObject = object;\r\n      object.set('active', true);\r\n    },\r\n\r\n    /**\r\n     * Sets given object as the only active object on canvas\r\n     * @param {fabric.Object} object Object to set as an active one\r\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    setActiveObject: function (object, e) {\r\n      this._setActiveObject(object);\r\n      this.renderAll();\r\n      this.fire('object:selected', { target: object, e: e });\r\n      object.fire('selected', { e: e });\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns currently active object\r\n     * @return {fabric.Object} active object\r\n     */\r\n    getActiveObject: function () {\r\n      return this._activeObject;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _discardActiveObject: function() {\r\n      if (this._activeObject) {\r\n        this._activeObject.set('active', false);\r\n      }\r\n      this._activeObject = null;\r\n    },\r\n\r\n    /**\r\n     * Discards currently active object\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    discardActiveObject: function (e) {\r\n      this._discardActiveObject();\r\n      this.renderAll();\r\n      this.fire('selection:cleared', { e: e });\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {fabric.Group} group\r\n     */\r\n    _setActiveGroup: function(group) {\r\n      this._activeGroup = group;\r\n      if (group) {\r\n        group.set('active', true);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets active group to a speicified one\r\n     * @param {fabric.Group} group Group to set as a current one\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    setActiveGroup: function (group, e) {\r\n      this._setActiveGroup(group);\r\n      if (group) {\r\n        this.fire('object:selected', { target: group, e: e });\r\n        group.fire('selected', { e: e });\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns currently active group\r\n     * @return {fabric.Group} Current group\r\n     */\r\n    getActiveGroup: function () {\r\n      return this._activeGroup;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _discardActiveGroup: function() {\r\n      var g = this.getActiveGroup();\r\n      if (g) {\r\n        g.destroy();\r\n      }\r\n      this.setActiveGroup(null);\r\n    },\r\n\r\n    /**\r\n     * Discards currently active group\r\n     * @return {fabric.Canvas} thisArg\r\n     */\r\n    discardActiveGroup: function (e) {\r\n      this._discardActiveGroup();\r\n      this.fire('selection:cleared', { e: e });\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Deactivates all objects on canvas, removing any active group or object\r\n     * @return {fabric.Canvas} thisArg\r\n     */\r\n    deactivateAll: function () {\r\n      var allObjects = this.getObjects(),\r\n          i = 0,\r\n          len = allObjects.length;\r\n      for ( ; i < len; i++) {\r\n        allObjects[i].set('active', false);\r\n      }\r\n      this._discardActiveGroup();\r\n      this._discardActiveObject();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Deactivates all objects and dispatches appropriate events\r\n     * @return {fabric.Canvas} thisArg\r\n     */\r\n    deactivateAllWithDispatch: function (e) {\r\n      var activeObject = this.getActiveGroup() || this.getActiveObject();\r\n      if (activeObject) {\r\n        this.fire('before:selection:cleared', { target: activeObject, e: e });\r\n      }\r\n      this.deactivateAll();\r\n      if (activeObject) {\r\n        this.fire('selection:cleared', { e: e });\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Draws objects' controls (borders/controls)\r\n     * @param {CanvasRenderingContext2D} ctx Context to render controls on\r\n     */\r\n    drawControls: function(ctx) {\r\n      var activeGroup = this.getActiveGroup();\r\n      if (activeGroup) {\r\n        this._drawGroupControls(ctx, activeGroup);\r\n      }\r\n      else {\r\n        this._drawObjectsControls(ctx);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _drawGroupControls: function(ctx, activeGroup) {\r\n      activeGroup._renderControls(ctx);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _drawObjectsControls: function(ctx) {\r\n      for (var i = 0, len = this._objects.length; i < len; ++i) {\r\n        if (!this._objects[i] || !this._objects[i].active) {\r\n          continue;\r\n        }\r\n        this._objects[i]._renderControls(ctx);\r\n        this.lastRenderedObjectWithControlsAboveOverlay = this._objects[i];\r\n      }\r\n    }\r\n  });\r\n\r\n  // copying static properties manually to work around Opera's bug,\r\n  // where \"prototype\" property is enumerable and overrides existing prototype\r\n  for (var prop in fabric.StaticCanvas) {\r\n    if (prop !== 'prototype') {\r\n      fabric.Canvas[prop] = fabric.StaticCanvas[prop];\r\n    }\r\n  }\r\n\r\n  if (fabric.isTouchSupported) {\r\n    /** @ignore */\r\n    fabric.Canvas.prototype._setCursorFromEvent = function() { };\r\n  }\r\n\r\n  /**\r\n   * @class fabric.Element\r\n   * @alias fabric.Canvas\r\n   * @deprecated Use {@link fabric.Canvas} instead.\r\n   * @constructor\r\n   */\r\n  fabric.Element = fabric.Canvas;\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  var cursorOffset = {\r\n    mt: 0, // n\r\n    tr: 1, // ne\r\n    mr: 2, // e\r\n    br: 3, // se\r\n    mb: 4, // s\r\n    bl: 5, // sw\r\n    ml: 6, // w\r\n    tl: 7 // nw\r\n  },\r\n  addListener = fabric.util.addListener,\r\n  removeListener = fabric.util.removeListener;\r\n\r\n  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\r\n\r\n    /**\r\n     * Map of cursor style values for each of the object controls\r\n     * @private\r\n     */\r\n    cursorMap: [\r\n      'n-resize',\r\n      'ne-resize',\r\n      'e-resize',\r\n      'se-resize',\r\n      's-resize',\r\n      'sw-resize',\r\n      'w-resize',\r\n      'nw-resize'\r\n    ],\r\n\r\n    /**\r\n     * Adds mouse listeners to canvas\r\n     * @private\r\n     */\r\n    _initEventListeners: function () {\r\n\r\n      this._bindEvents();\r\n\r\n      addListener(fabric.window, 'resize', this._onResize);\r\n\r\n      // mouse events\r\n      addListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);\r\n      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);\r\n      addListener(this.upperCanvasEl, 'mousewheel', this._onMouseWheel);\r\n\r\n      // touch events\r\n      addListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);\r\n      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);\r\n\r\n      if (typeof eventjs !== 'undefined' && 'add' in eventjs) {\r\n        eventjs.add(this.upperCanvasEl, 'gesture', this._onGesture);\r\n        eventjs.add(this.upperCanvasEl, 'drag', this._onDrag);\r\n        eventjs.add(this.upperCanvasEl, 'orientation', this._onOrientationChange);\r\n        eventjs.add(this.upperCanvasEl, 'shake', this._onShake);\r\n        eventjs.add(this.upperCanvasEl, 'longpress', this._onLongPress);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _bindEvents: function() {\r\n      this._onMouseDown = this._onMouseDown.bind(this);\r\n      this._onMouseMove = this._onMouseMove.bind(this);\r\n      this._onMouseUp = this._onMouseUp.bind(this);\r\n      this._onResize = this._onResize.bind(this);\r\n      this._onGesture = this._onGesture.bind(this);\r\n      this._onDrag = this._onDrag.bind(this);\r\n      this._onShake = this._onShake.bind(this);\r\n      this._onLongPress = this._onLongPress.bind(this);\r\n      this._onOrientationChange = this._onOrientationChange.bind(this);\r\n      this._onMouseWheel = this._onMouseWheel.bind(this);\r\n    },\r\n\r\n    /**\r\n     * Removes all event listeners\r\n     */\r\n    removeListeners: function() {\r\n      removeListener(fabric.window, 'resize', this._onResize);\r\n\r\n      removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);\r\n      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);\r\n      removeListener(this.upperCanvasEl, 'mousewheel', this._onMouseWheel);\r\n\r\n      removeListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);\r\n      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);\r\n\r\n      if (typeof eventjs !== 'undefined' && 'remove' in eventjs) {\r\n        eventjs.remove(this.upperCanvasEl, 'gesture', this._onGesture);\r\n        eventjs.remove(this.upperCanvasEl, 'drag', this._onDrag);\r\n        eventjs.remove(this.upperCanvasEl, 'orientation', this._onOrientationChange);\r\n        eventjs.remove(this.upperCanvasEl, 'shake', this._onShake);\r\n        eventjs.remove(this.upperCanvasEl, 'longpress', this._onLongPress);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} [e] Event object fired on Event.js gesture\r\n     * @param {Event} [self] Inner Event object\r\n     */\r\n    _onGesture: function(e, self) {\r\n      this.__onTransformGesture && this.__onTransformGesture(e, self);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} [e] Event object fired on Event.js drag\r\n     * @param {Event} [self] Inner Event object\r\n     */\r\n    _onDrag: function(e, self) {\r\n      this.__onDrag && this.__onDrag(e, self);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} [e] Event object fired on Event.js wheel event\r\n     * @param {Event} [self] Inner Event object\r\n     */\r\n    _onMouseWheel: function(e, self) {\r\n      this.__onMouseWheel && this.__onMouseWheel(e, self);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} [e] Event object fired on Event.js orientation change\r\n     * @param {Event} [self] Inner Event object\r\n     */\r\n    _onOrientationChange: function(e, self) {\r\n      this.__onOrientationChange && this.__onOrientationChange(e, self);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} [e] Event object fired on Event.js shake\r\n     * @param {Event} [self] Inner Event object\r\n     */\r\n    _onShake: function(e, self) {\r\n      this.__onShake && this.__onShake(e, self);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} [e] Event object fired on Event.js shake\r\n     * @param {Event} [self] Inner Event object\r\n     */\r\n    _onLongPress: function(e, self) {\r\n      this.__onLongPress && this.__onLongPress(e, self);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object fired on mousedown\r\n     */\r\n    _onMouseDown: function (e) {\r\n      this.__onMouseDown(e);\r\n\r\n      addListener(fabric.document, 'touchend', this._onMouseUp);\r\n      addListener(fabric.document, 'touchmove', this._onMouseMove);\r\n\r\n      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);\r\n      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);\r\n\r\n      if (e.type === 'touchstart') {\r\n        // Unbind mousedown to prevent double triggers from touch devices\r\n        removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);\r\n      }\r\n      else {\r\n        addListener(fabric.document, 'mouseup', this._onMouseUp);\r\n        addListener(fabric.document, 'mousemove', this._onMouseMove);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object fired on mouseup\r\n     */\r\n    _onMouseUp: function (e) {\r\n      this.__onMouseUp(e);\r\n\r\n      removeListener(fabric.document, 'mouseup', this._onMouseUp);\r\n      removeListener(fabric.document, 'touchend', this._onMouseUp);\r\n\r\n      removeListener(fabric.document, 'mousemove', this._onMouseMove);\r\n      removeListener(fabric.document, 'touchmove', this._onMouseMove);\r\n\r\n      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);\r\n      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);\r\n\r\n      if (e.type === 'touchend') {\r\n        // Wait 400ms before rebinding mousedown to prevent double triggers\r\n        // from touch devices\r\n        var _this = this;\r\n        setTimeout(function() {\r\n          addListener(_this.upperCanvasEl, 'mousedown', _this._onMouseDown);\r\n        }, 400);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object fired on mousemove\r\n     */\r\n    _onMouseMove: function (e) {\r\n      !this.allowTouchScrolling && e.preventDefault && e.preventDefault();\r\n      this.__onMouseMove(e);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _onResize: function () {\r\n      this.calcOffset();\r\n    },\r\n\r\n    /**\r\n     * Decides whether the canvas should be redrawn in mouseup and mousedown events.\r\n     * @private\r\n     * @param {Object} target\r\n     * @param {Object} pointer\r\n     */\r\n    _shouldRender: function(target, pointer) {\r\n      var activeObject = this.getActiveGroup() || this.getActiveObject();\r\n\r\n      return !!(\r\n        (target && (\r\n          target.isMoving ||\r\n          target !== activeObject))\r\n        ||\r\n        (!target && !!activeObject)\r\n        ||\r\n        (!target && !activeObject && !this._groupSelector)\r\n        ||\r\n        (pointer &&\r\n          this._previousPointer &&\r\n          this.selection && (\r\n          pointer.x !== this._previousPointer.x ||\r\n          pointer.y !== this._previousPointer.y))\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Method that defines the actions when mouse is released on canvas.\r\n     * The method resets the currentTransform parameters, store the image corner\r\n     * position in the image object and render the canvas on top.\r\n     * @private\r\n     * @param {Event} e Event object fired on mouseup\r\n     */\r\n    __onMouseUp: function (e) {\r\n      var target;\r\n\r\n      if (this.isDrawingMode && this._isCurrentlyDrawing) {\r\n        this._onMouseUpInDrawingMode(e);\r\n        return;\r\n      }\r\n\r\n      if (this._currentTransform) {\r\n        this._finalizeCurrentTransform();\r\n        target = this._currentTransform.target;\r\n      }\r\n      else {\r\n        target = this.findTarget(e, true);\r\n      }\r\n\r\n      var shouldRender = this._shouldRender(target, this.getPointer(e));\r\n\r\n      this._maybeGroupObjects(e);\r\n\r\n      if (target) {\r\n        target.isMoving = false;\r\n      }\r\n\r\n      shouldRender && this.renderAll();\r\n\r\n      this._handleCursorAndEvent(e, target);\r\n    },\r\n\r\n    _handleCursorAndEvent: function(e, target) {\r\n      this._setCursorFromEvent(e, target);\r\n\r\n      // TODO: why are we doing this?\r\n      var _this = this;\r\n      setTimeout(function () {\r\n        _this._setCursorFromEvent(e, target);\r\n      }, 50);\r\n\r\n      this.fire('mouse:up', { target: target, e: e });\r\n      target && target.fire('mouseup', { e: e });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _finalizeCurrentTransform: function() {\r\n\r\n      var transform = this._currentTransform,\r\n          target = transform.target;\r\n\r\n      if (target._scaling) {\r\n        target._scaling = false;\r\n      }\r\n\r\n      target.setCoords();\r\n\r\n      // only fire :modified event if target coordinates were changed during mousedown-mouseup\r\n      if (this.stateful && target.hasStateChanged()) {\r\n        this.fire('object:modified', { target: target });\r\n        target.fire('modified');\r\n      }\r\n\r\n      this._restoreOriginXY(target);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} target Object to restore\r\n     */\r\n    _restoreOriginXY: function(target) {\r\n      if (this._previousOriginX && this._previousOriginY) {\r\n\r\n        var originPoint = target.translateToOriginPoint(\r\n          target.getCenterPoint(),\r\n          this._previousOriginX,\r\n          this._previousOriginY);\r\n\r\n        target.originX = this._previousOriginX;\r\n        target.originY = this._previousOriginY;\r\n\r\n        target.left = originPoint.x;\r\n        target.top = originPoint.y;\r\n\r\n        this._previousOriginX = null;\r\n        this._previousOriginY = null;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object fired on mousedown\r\n     */\r\n    _onMouseDownInDrawingMode: function(e) {\r\n      this._isCurrentlyDrawing = true;\r\n      this.discardActiveObject(e).renderAll();\r\n      if (this.clipTo) {\r\n        fabric.util.clipContext(this, this.contextTop);\r\n      }\r\n      var ivt = fabric.util.invertTransform(this.viewportTransform),\r\n          pointer = fabric.util.transformPoint(this.getPointer(e, true), ivt);\r\n      this.freeDrawingBrush.onMouseDown(pointer);\r\n      this.fire('mouse:down', { e: e });\r\n\r\n      var target = this.findTarget(e);\r\n      if (typeof target !== 'undefined') {\r\n        target.fire('mousedown', { e: e, target: target });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object fired on mousemove\r\n     */\r\n    _onMouseMoveInDrawingMode: function(e) {\r\n      if (this._isCurrentlyDrawing) {\r\n        var ivt = fabric.util.invertTransform(this.viewportTransform),\r\n            pointer = fabric.util.transformPoint(this.getPointer(e, true), ivt);\r\n        this.freeDrawingBrush.onMouseMove(pointer);\r\n      }\r\n      this.setCursor(this.freeDrawingCursor);\r\n      this.fire('mouse:move', { e: e });\r\n\r\n      var target = this.findTarget(e);\r\n      if (typeof target !== 'undefined') {\r\n        target.fire('mousemove', { e: e, target: target });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object fired on mouseup\r\n     */\r\n    _onMouseUpInDrawingMode: function(e) {\r\n      this._isCurrentlyDrawing = false;\r\n      if (this.clipTo) {\r\n        this.contextTop.restore();\r\n      }\r\n      this.freeDrawingBrush.onMouseUp();\r\n      this.fire('mouse:up', { e: e });\r\n\r\n      var target = this.findTarget(e);\r\n      if (typeof target !== 'undefined') {\r\n        target.fire('mouseup', { e: e, target: target });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Method that defines the actions when mouse is clic ked on canvas.\r\n     * The method inits the currentTransform parameters and renders all the\r\n     * canvas so the current image can be placed on the top canvas and the rest\r\n     * in on the container one.\r\n     * @private\r\n     * @param {Event} e Event object fired on mousedown\r\n     */\r\n    __onMouseDown: function (e) {\r\n\r\n      // accept only left clicks\r\n      var isLeftClick  = 'which' in e ? e.which === 1 : e.button === 1;\r\n      if (!isLeftClick && !fabric.isTouchSupported) {\r\n        return;\r\n      }\r\n\r\n      if (this.isDrawingMode) {\r\n        this._onMouseDownInDrawingMode(e);\r\n        return;\r\n      }\r\n\r\n      // ignore if some object is being transformed at this moment\r\n      if (this._currentTransform) {\r\n        return;\r\n      }\r\n\r\n      var target = this.findTarget(e),\r\n          pointer = this.getPointer(e, true);\r\n\r\n      // save pointer for check in __onMouseUp event\r\n      this._previousPointer = pointer;\r\n\r\n      var shouldRender = this._shouldRender(target, pointer),\r\n          shouldGroup = this._shouldGroup(e, target);\r\n\r\n      if (this._shouldClearSelection(e, target)) {\r\n        this._clearSelection(e, target, pointer);\r\n      }\r\n      else if (shouldGroup) {\r\n        this._handleGrouping(e, target);\r\n        target = this.getActiveGroup();\r\n      }\r\n\r\n      if (target && target.selectable && !shouldGroup) {\r\n        this._beforeTransform(e, target);\r\n        this._setupCurrentTransform(e, target);\r\n      }\r\n      // we must renderAll so that active image is placed on the top canvas\r\n      shouldRender && this.renderAll();\r\n\r\n      this.fire('mouse:down', { target: target, e: e });\r\n      target && target.fire('mousedown', { e: e });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _beforeTransform: function(e, target) {\r\n      this.stateful && target.saveState();\r\n\r\n      // determine if it's a drag or rotate case\r\n      if (target._findTargetCorner(this.getPointer(e))) {\r\n        this.onBeforeScaleRotate(target);\r\n      }\r\n\r\n      if (target !== this.getActiveGroup() && target !== this.getActiveObject()) {\r\n        this.deactivateAll();\r\n        this.setActiveObject(target, e);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _clearSelection: function(e, target, pointer) {\r\n      this.deactivateAllWithDispatch(e);\r\n\r\n      if (target && target.selectable) {\r\n        this.setActiveObject(target, e);\r\n      }\r\n      else if (this.selection) {\r\n        this._groupSelector = {\r\n          ex: pointer.x,\r\n          ey: pointer.y,\r\n          top: 0,\r\n          left: 0\r\n        };\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} target Object for that origin is set to center\r\n     */\r\n    _setOriginToCenter: function(target) {\r\n      this._previousOriginX = this._currentTransform.target.originX;\r\n      this._previousOriginY = this._currentTransform.target.originY;\r\n\r\n      var center = target.getCenterPoint();\r\n\r\n      target.originX = 'center';\r\n      target.originY = 'center';\r\n\r\n      target.left = center.x;\r\n      target.top = center.y;\r\n\r\n      this._currentTransform.left = target.left;\r\n      this._currentTransform.top = target.top;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} target Object for that center is set to origin\r\n     */\r\n    _setCenterToOrigin: function(target) {\r\n      var originPoint = target.translateToOriginPoint(\r\n        target.getCenterPoint(),\r\n        this._previousOriginX,\r\n        this._previousOriginY);\r\n\r\n      target.originX = this._previousOriginX;\r\n      target.originY = this._previousOriginY;\r\n\r\n      target.left = originPoint.x;\r\n      target.top = originPoint.y;\r\n\r\n      this._previousOriginX = null;\r\n      this._previousOriginY = null;\r\n    },\r\n\r\n    /**\r\n     * Method that defines the actions when mouse is hovering the canvas.\r\n     * The currentTransform parameter will definde whether the user is rotating/scaling/translating\r\n     * an image or neither of them (only hovering). A group selection is also possible and would cancel\r\n     * all any other type of action.\r\n     * In case of an image transformation only the top canvas will be rendered.\r\n     * @private\r\n     * @param {Event} e Event object fired on mousemove\r\n     */\r\n    __onMouseMove: function (e) {\r\n\r\n      var target, pointer;\r\n\r\n      if (this.isDrawingMode) {\r\n        this._onMouseMoveInDrawingMode(e);\r\n        return;\r\n      }\r\n      if (typeof e.touches !== 'undefined' && e.touches.length > 1) {\r\n        return;\r\n      }\r\n\r\n      var groupSelector = this._groupSelector;\r\n\r\n      // We initially clicked in an empty area, so we draw a box for multiple selection\r\n      if (groupSelector) {\r\n        pointer = this.getPointer(e, true);\r\n\r\n        groupSelector.left = pointer.x - groupSelector.ex;\r\n        groupSelector.top = pointer.y - groupSelector.ey;\r\n\r\n        this.renderTop();\r\n      }\r\n      else if (!this._currentTransform) {\r\n\r\n        target = this.findTarget(e);\r\n\r\n        if (!target || target && !target.selectable) {\r\n          this.setCursor(this.defaultCursor);\r\n        }\r\n        else {\r\n          this._setCursorFromEvent(e, target);\r\n        }\r\n      }\r\n      else {\r\n        this._transformObject(e);\r\n      }\r\n\r\n      this.fire('mouse:move', { target: target, e: e });\r\n      target && target.fire('mousemove', { e: e });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event fired on mousemove\r\n     */\r\n    _transformObject: function(e) {\r\n      var pointer = this.getPointer(e),\r\n          transform = this._currentTransform;\r\n\r\n      transform.reset = false,\r\n      transform.target.isMoving = true;\r\n\r\n      this._beforeScaleTransform(e, transform);\r\n      this._performTransformAction(e, transform, pointer);\r\n\r\n      this.renderAll();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _performTransformAction: function(e, transform, pointer) {\r\n      var x = pointer.x,\r\n          y = pointer.y,\r\n          target = transform.target,\r\n          action = transform.action;\r\n\r\n      if (action === 'rotate') {\r\n        this._rotateObject(x, y);\r\n        this._fire('rotating', target, e);\r\n      }\r\n      else if (action === 'scale') {\r\n        this._onScale(e, transform, x, y);\r\n        this._fire('scaling', target, e);\r\n      }\r\n      else if (action === 'scaleX') {\r\n        this._scaleObject(x, y, 'x');\r\n        this._fire('scaling', target, e);\r\n      }\r\n      else if (action === 'scaleY') {\r\n        this._scaleObject(x, y, 'y');\r\n        this._fire('scaling', target, e);\r\n      }\r\n      else {\r\n        this._translateObject(x, y);\r\n        this._fire('moving', target, e);\r\n        this.setCursor(this.moveCursor);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _fire: function(eventName, target, e) {\r\n      this.fire('object:' + eventName, { target: target, e: e });\r\n      target.fire(eventName, { e: e });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _beforeScaleTransform: function(e, transform) {\r\n      if (transform.action === 'scale' || transform.action === 'scaleX' || transform.action === 'scaleY') {\r\n        var centerTransform = this._shouldCenterTransform(e, transform.target);\r\n\r\n        // Switch from a normal resize to center-based\r\n        if ((centerTransform && (transform.originX !== 'center' || transform.originY !== 'center')) ||\r\n           // Switch from center-based resize to normal one\r\n           (!centerTransform && transform.originX === 'center' && transform.originY === 'center')\r\n        ) {\r\n          this._resetCurrentTransform(e);\r\n          transform.reset = true;\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _onScale: function(e, transform, x, y) {\r\n      // rotate object only if shift key is not pressed\r\n      // and if it is not a group we are transforming\r\n      if ((e.shiftKey || this.uniScaleTransform) && !transform.target.get('lockUniScaling')) {\r\n        transform.currentAction = 'scale';\r\n        this._scaleObject(x, y);\r\n      }\r\n      else {\r\n        // Switch from a normal resize to proportional\r\n        if (!transform.reset && transform.currentAction === 'scale') {\r\n          this._resetCurrentTransform(e, transform.target);\r\n        }\r\n\r\n        transform.currentAction = 'scaleEqually';\r\n        this._scaleObject(x, y, 'equally');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets the cursor depending on where the canvas is being hovered.\r\n     * Note: very buggy in Opera\r\n     * @param {Event} e Event object\r\n     * @param {Object} target Object that the mouse is hovering, if so.\r\n     */\r\n    _setCursorFromEvent: function (e, target) {\r\n      if (!target || !target.selectable) {\r\n        this.setCursor(this.defaultCursor);\r\n        return false;\r\n      }\r\n      else {\r\n        var activeGroup = this.getActiveGroup(),\r\n            // only show proper corner when group selection is not active\r\n            corner = target._findTargetCorner\r\n                      && (!activeGroup || !activeGroup.contains(target))\r\n                      && target._findTargetCorner(this.getPointer(e, true));\r\n\r\n        if (!corner) {\r\n          this.setCursor(target.hoverCursor || this.hoverCursor);\r\n        }\r\n        else {\r\n          this._setCornerCursor(corner, target);\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setCornerCursor: function(corner, target) {\r\n      if (corner in cursorOffset) {\r\n        this.setCursor(this._getRotatedCornerCursor(corner, target));\r\n      }\r\n      else if (corner === 'mtr' && target.hasRotatingPoint) {\r\n        this.setCursor(this.rotationCursor);\r\n      }\r\n      else {\r\n        this.setCursor(this.defaultCursor);\r\n        return false;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getRotatedCornerCursor: function(corner, target) {\r\n      var n = Math.round((target.getAngle() % 360) / 45);\r\n\r\n      if (n < 0) {\r\n        n += 8; // full circle ahead\r\n      }\r\n      n += cursorOffset[corner];\r\n      // normalize n to be from 0 to 7\r\n      n %= 8;\r\n\r\n      return this.cursorMap[n];\r\n    }\r\n  });\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  var min = Math.min,\r\n      max = Math.max;\r\n\r\n  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object\r\n     * @param {fabric.Object} target\r\n     * @return {Boolean}\r\n     */\r\n    _shouldGroup: function(e, target) {\r\n      var activeObject = this.getActiveObject();\r\n      return e.shiftKey &&\r\n            (this.getActiveGroup() || (activeObject && activeObject !== target))\r\n            && this.selection;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object\r\n     * @param {fabric.Object} target\r\n     */\r\n    _handleGrouping: function (e, target) {\r\n\r\n      if (target === this.getActiveGroup()) {\r\n\r\n        // if it's a group, find target again, this time skipping group\r\n        target = this.findTarget(e, true);\r\n\r\n        // if even object is not found, bail out\r\n        if (!target || target.isType('group')) {\r\n          return;\r\n        }\r\n      }\r\n      if (this.getActiveGroup()) {\r\n        this._updateActiveGroup(target, e);\r\n      }\r\n      else {\r\n        this._createActiveGroup(target, e);\r\n      }\r\n\r\n      if (this._activeGroup) {\r\n        this._activeGroup.saveCoords();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _updateActiveGroup: function(target, e) {\r\n      var activeGroup = this.getActiveGroup();\r\n\r\n      if (activeGroup.contains(target)) {\r\n\r\n        activeGroup.removeWithUpdate(target);\r\n        this._resetObjectTransform(activeGroup);\r\n        target.set('active', false);\r\n\r\n        if (activeGroup.size() === 1) {\r\n          // remove group alltogether if after removal it only contains 1 object\r\n          this.discardActiveGroup(e);\r\n          // activate last remaining object\r\n          this.setActiveObject(activeGroup.item(0));\r\n          return;\r\n        }\r\n      }\r\n      else {\r\n        activeGroup.addWithUpdate(target);\r\n        this._resetObjectTransform(activeGroup);\r\n      }\r\n      this.fire('selection:created', { target: activeGroup, e: e });\r\n      activeGroup.set('active', true);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _createActiveGroup: function(target, e) {\r\n\r\n      if (this._activeObject && target !== this._activeObject) {\r\n\r\n        var group = this._createGroup(target);\r\n        group.addWithUpdate();\r\n\r\n        this.setActiveGroup(group);\r\n        this._activeObject = null;\r\n\r\n        this.fire('selection:created', { target: group, e: e });\r\n      }\r\n\r\n      target.set('active', true);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} target\r\n     */\r\n    _createGroup: function(target) {\r\n\r\n      var objects = this.getObjects(),\r\n          isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),\r\n          groupObjects = isActiveLower\r\n            ? [ this._activeObject, target ]\r\n            : [ target, this._activeObject ];\r\n\r\n      return new fabric.Group(groupObjects, {\r\n        canvas: this\r\n      });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e mouse event\r\n     */\r\n    _groupSelectedObjects: function (e) {\r\n\r\n      var group = this._collectObjects();\r\n\r\n      // do not create group for 1 element only\r\n      if (group.length === 1) {\r\n        this.setActiveObject(group[0], e);\r\n      }\r\n      else if (group.length > 1) {\r\n        group = new fabric.Group(group.reverse(), {\r\n          canvas: this\r\n        });\r\n        group.addWithUpdate();\r\n        this.setActiveGroup(group, e);\r\n        group.saveCoords();\r\n        this.fire('selection:created', { target: group });\r\n        this.renderAll();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _collectObjects: function() {\r\n      var group = [ ],\r\n          currentObject,\r\n          x1 = this._groupSelector.ex,\r\n          y1 = this._groupSelector.ey,\r\n          x2 = x1 + this._groupSelector.left,\r\n          y2 = y1 + this._groupSelector.top,\r\n          selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),\r\n          selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),\r\n          isClick = x1 === x2 && y1 === y2;\r\n\r\n      for (var i = this._objects.length; i--; ) {\r\n        currentObject = this._objects[i];\r\n\r\n        if (!currentObject || !currentObject.selectable || !currentObject.visible) {\r\n          continue;\r\n        }\r\n\r\n        if (currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2) ||\r\n            currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||\r\n            currentObject.containsPoint(selectionX1Y1) ||\r\n            currentObject.containsPoint(selectionX2Y2)\r\n        ) {\r\n          currentObject.set('active', true);\r\n          group.push(currentObject);\r\n\r\n          // only add one object if it's a click\r\n          if (isClick) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return group;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _maybeGroupObjects: function(e) {\r\n      if (this.selection && this._groupSelector) {\r\n        this._groupSelectedObjects(e);\r\n      }\r\n\r\n      var activeGroup = this.getActiveGroup();\r\n      if (activeGroup) {\r\n        activeGroup.setObjectsCoords().setCoords();\r\n        activeGroup.isMoving = false;\r\n        this.setCursor(this.defaultCursor);\r\n      }\r\n\r\n      // clear selection and current transformation\r\n      this._groupSelector = null;\r\n      this._currentTransform = null;\r\n    }\r\n  });\r\n\r\n})();\r\n\r\n\r\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\r\n\r\n  /**\r\n   * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately\r\n   * @param {Object} [options] Options object\r\n   * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\r\n   * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\r\n   * @param {Number} [options.multiplier=1] Multiplier to scale by\r\n   * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\r\n   * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\r\n   * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\r\n   * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\r\n   * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\r\n   * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}\r\n   * @example <caption>Generate jpeg dataURL with lower quality</caption>\r\n   * var dataURL = canvas.toDataURL({\r\n   *   format: 'jpeg',\r\n   *   quality: 0.8\r\n   * });\r\n   * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>\r\n   * var dataURL = canvas.toDataURL({\r\n   *   format: 'png',\r\n   *   left: 100,\r\n   *   top: 100,\r\n   *   width: 200,\r\n   *   height: 200\r\n   * });\r\n   * @example <caption>Generate double scaled png dataURL</caption>\r\n   * var dataURL = canvas.toDataURL({\r\n   *   format: 'png',\r\n   *   multiplier: 2\r\n   * });\r\n   */\r\n  toDataURL: function (options) {\r\n    options || (options = { });\r\n\r\n    var format = options.format || 'png',\r\n        quality = options.quality || 1,\r\n        multiplier = options.multiplier || 1,\r\n        cropping = {\r\n          left: options.left,\r\n          top: options.top,\r\n          width: options.width,\r\n          height: options.height\r\n        };\r\n\r\n    if (multiplier !== 1) {\r\n      return this.__toDataURLWithMultiplier(format, quality, cropping, multiplier);\r\n    }\r\n    else {\r\n      return this.__toDataURL(format, quality, cropping);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  __toDataURL: function(format, quality, cropping) {\r\n\r\n    this.renderAll(true);\r\n\r\n    var canvasEl = this.upperCanvasEl || this.lowerCanvasEl,\r\n        croppedCanvasEl = this.__getCroppedCanvas(canvasEl, cropping);\r\n\r\n    // to avoid common confusion https://github.com/kangax/fabric.js/issues/806\r\n    if (format === 'jpg') {\r\n      format = 'jpeg';\r\n    }\r\n\r\n    var data = (fabric.StaticCanvas.supports('toDataURLWithQuality'))\r\n              ? (croppedCanvasEl || canvasEl).toDataURL('image/' + format, quality)\r\n              : (croppedCanvasEl || canvasEl).toDataURL('image/' + format);\r\n\r\n    this.contextTop && this.clearContext(this.contextTop);\r\n    this.renderAll();\r\n\r\n    if (croppedCanvasEl) {\r\n      croppedCanvasEl = null;\r\n    }\r\n\r\n    return data;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  __getCroppedCanvas: function(canvasEl, cropping) {\r\n\r\n    var croppedCanvasEl,\r\n        croppedCtx,\r\n        shouldCrop = 'left' in cropping ||\r\n                     'top' in cropping ||\r\n                     'width' in cropping ||\r\n                     'height' in cropping;\r\n\r\n    if (shouldCrop) {\r\n\r\n      croppedCanvasEl = fabric.util.createCanvasElement();\r\n      croppedCtx = croppedCanvasEl.getContext('2d');\r\n\r\n      croppedCanvasEl.width = cropping.width || this.width;\r\n      croppedCanvasEl.height = cropping.height || this.height;\r\n\r\n      croppedCtx.drawImage(canvasEl, -cropping.left || 0, -cropping.top || 0);\r\n    }\r\n\r\n    return croppedCanvasEl;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  __toDataURLWithMultiplier: function(format, quality, cropping, multiplier) {\r\n\r\n    var origWidth = this.getWidth(),\r\n        origHeight = this.getHeight(),\r\n        scaledWidth = origWidth * multiplier,\r\n        scaledHeight = origHeight * multiplier,\r\n        activeObject = this.getActiveObject(),\r\n        activeGroup = this.getActiveGroup(),\r\n\r\n        ctx = this.contextTop || this.contextContainer;\r\n\r\n    if (multiplier > 1) {\r\n      this.setWidth(scaledWidth).setHeight(scaledHeight);\r\n    }\r\n    ctx.scale(multiplier, multiplier);\r\n\r\n    if (cropping.left) {\r\n      cropping.left *= multiplier;\r\n    }\r\n    if (cropping.top) {\r\n      cropping.top *= multiplier;\r\n    }\r\n    if (cropping.width) {\r\n      cropping.width *= multiplier;\r\n    }\r\n    else if (multiplier < 1) {\r\n      cropping.width = scaledWidth;\r\n    }\r\n    if (cropping.height) {\r\n      cropping.height *= multiplier;\r\n    }\r\n    else if (multiplier < 1) {\r\n      cropping.height = scaledHeight;\r\n    }\r\n\r\n    if (activeGroup) {\r\n      // not removing group due to complications with restoring it with correct state afterwords\r\n      this._tempRemoveBordersControlsFromGroup(activeGroup);\r\n    }\r\n    else if (activeObject && this.deactivateAll) {\r\n      this.deactivateAll();\r\n    }\r\n\r\n    this.renderAll(true);\r\n\r\n    var data = this.__toDataURL(format, quality, cropping);\r\n\r\n    // restoring width, height for `renderAll` to draw\r\n    // background properly (while context is scaled)\r\n    this.width = origWidth;\r\n    this.height = origHeight;\r\n\r\n    ctx.scale(1 / multiplier,  1 / multiplier);\r\n    this.setWidth(origWidth).setHeight(origHeight);\r\n\r\n    if (activeGroup) {\r\n      this._restoreBordersControlsOnGroup(activeGroup);\r\n    }\r\n    else if (activeObject && this.setActiveObject) {\r\n      this.setActiveObject(activeObject);\r\n    }\r\n\r\n    this.contextTop && this.clearContext(this.contextTop);\r\n    this.renderAll();\r\n\r\n    return data;\r\n  },\r\n\r\n  /**\r\n   * Exports canvas element to a dataurl image (allowing to change image size via multiplier).\r\n   * @deprecated since 1.0.13\r\n   * @param {String} format (png|jpeg)\r\n   * @param {Number} multiplier\r\n   * @param {Number} quality (0..1)\r\n   * @return {String}\r\n   */\r\n  toDataURLWithMultiplier: function (format, multiplier, quality) {\r\n    return this.toDataURL({\r\n      format: format,\r\n      multiplier: multiplier,\r\n      quality: quality\r\n    });\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _tempRemoveBordersControlsFromGroup: function(group) {\r\n    group.origHasControls = group.hasControls;\r\n    group.origBorderColor = group.borderColor;\r\n\r\n    group.hasControls = true;\r\n    group.borderColor = 'rgba(0,0,0,0)';\r\n\r\n    group.forEachObject(function(o) {\r\n      o.origBorderColor = o.borderColor;\r\n      o.borderColor = 'rgba(0,0,0,0)';\r\n    });\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _restoreBordersControlsOnGroup: function(group) {\r\n    group.hideControls = group.origHideControls;\r\n    group.borderColor = group.origBorderColor;\r\n\r\n    group.forEachObject(function(o) {\r\n      o.borderColor = o.origBorderColor;\r\n      delete o.origBorderColor;\r\n    });\r\n  }\r\n});\r\n\r\n\r\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\r\n\r\n  /**\r\n   * Populates canvas with data from the specified dataless JSON.\r\n   * JSON format must conform to the one of {@link fabric.Canvas#toDatalessJSON}\r\n   * @deprecated since 1.2.2\r\n   * @param {String|Object} json JSON string or object\r\n   * @param {Function} callback Callback, invoked when json is parsed\r\n   *                            and corresponding objects (e.g: {@link fabric.Image})\r\n   *                            are initialized\r\n   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.\r\n   * @return {fabric.Canvas} instance\r\n   * @chainable\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#deserialization}\r\n   */\r\n  loadFromDatalessJSON: function (json, callback, reviver) {\r\n    return this.loadFromJSON(json, callback, reviver);\r\n  },\r\n\r\n  /**\r\n   * Populates canvas with data from the specified JSON.\r\n   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}\r\n   * @param {String|Object} json JSON string or object\r\n   * @param {Function} callback Callback, invoked when json is parsed\r\n   *                            and corresponding objects (e.g: {@link fabric.Image})\r\n   *                            are initialized\r\n   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.\r\n   * @return {fabric.Canvas} instance\r\n   * @chainable\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#deserialization}\r\n   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}\r\n   * @example <caption>loadFromJSON</caption>\r\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));\r\n   * @example <caption>loadFromJSON with reviver</caption>\r\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {\r\n   *   // `o` = json object\r\n   *   // `object` = fabric.Object instance\r\n   *   // ... do some stuff ...\r\n   * });\r\n   */\r\n  loadFromJSON: function (json, callback, reviver) {\r\n    if (!json) {\r\n      return;\r\n    }\r\n\r\n    // serialize if it wasn't already\r\n    var serialized = (typeof json === 'string')\r\n      ? JSON.parse(json)\r\n      : json;\r\n\r\n    this.clear();\r\n\r\n    var _this = this;\r\n    this._enlivenObjects(serialized.objects, function () {\r\n      _this._setBgOverlay(serialized, callback);\r\n    }, reviver);\r\n\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {Object} serialized Object with background and overlay information\r\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\r\n   */\r\n  _setBgOverlay: function(serialized, callback) {\r\n    var _this = this,\r\n        loaded = {\r\n          backgroundColor: false,\r\n          overlayColor: false,\r\n          backgroundImage: false,\r\n          overlayImage: false\r\n        };\r\n\r\n    if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {\r\n      callback && callback();\r\n      return;\r\n    }\r\n\r\n    var cbIfLoaded = function () {\r\n      if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {\r\n        _this.renderAll();\r\n        callback && callback();\r\n      }\r\n    };\r\n\r\n    this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);\r\n    this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);\r\n    this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);\r\n    this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);\r\n\r\n    cbIfLoaded();\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)\r\n   * @param {(Object|String)} value Value to set\r\n   * @param {Object} loaded Set loaded property to true if property is set\r\n   * @param {Object} callback Callback function to invoke after property is set\r\n   */\r\n  __setBgOverlay: function(property, value, loaded, callback) {\r\n    var _this = this;\r\n\r\n    if (!value) {\r\n      loaded[property] = true;\r\n      return;\r\n    }\r\n\r\n    if (property === 'backgroundImage' || property === 'overlayImage') {\r\n      fabric.Image.fromObject(value, function(img) {\r\n        _this[property] = img;\r\n        loaded[property] = true;\r\n        callback && callback();\r\n      });\r\n    }\r\n    else {\r\n      this['set' + fabric.util.string.capitalize(property, true)](value, function() {\r\n        loaded[property] = true;\r\n        callback && callback();\r\n      });\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {Array} objects\r\n   * @param {Function} callback\r\n   * @param {Function} [reviver]\r\n   */\r\n  _enlivenObjects: function (objects, callback, reviver) {\r\n    var _this = this;\r\n\r\n    if (!objects || objects.length === 0) {\r\n      callback && callback();\r\n      return;\r\n    }\r\n\r\n    var renderOnAddRemove = this.renderOnAddRemove;\r\n    this.renderOnAddRemove = false;\r\n\r\n    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\r\n      enlivenedObjects.forEach(function(obj, index) {\r\n        _this.insertAt(obj, index, true);\r\n      });\r\n\r\n      _this.renderOnAddRemove = renderOnAddRemove;\r\n      callback && callback();\r\n    }, null, reviver);\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {String} format\r\n   * @param {Function} callback\r\n   */\r\n  _toDataURL: function (format, callback) {\r\n    this.clone(function (clone) {\r\n      callback(clone.toDataURL(format));\r\n    });\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {String} format\r\n   * @param {Number} multiplier\r\n   * @param {Function} callback\r\n   */\r\n  _toDataURLWithMultiplier: function (format, multiplier, callback) {\r\n    this.clone(function (clone) {\r\n      callback(clone.toDataURLWithMultiplier(format, multiplier));\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Clones canvas instance\r\n   * @param {Object} [callback] Receives cloned instance as a first argument\r\n   * @param {Array} [properties] Array of properties to include in the cloned canvas and children\r\n   */\r\n  clone: function (callback, properties) {\r\n    var data = JSON.stringify(this.toJSON(properties));\r\n    this.cloneWithoutData(function(clone) {\r\n      clone.loadFromJSON(data, function() {\r\n        callback && callback(clone);\r\n      });\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Clones canvas instance without cloning existing data.\r\n   * This essentially copies canvas dimensions, clipping properties, etc.\r\n   * but leaves data empty (so that you can populate it with your own)\r\n   * @param {Object} [callback] Receives cloned instance as a first argument\r\n   */\r\n  cloneWithoutData: function(callback) {\r\n    var el = fabric.document.createElement('canvas');\r\n\r\n    el.width = this.getWidth();\r\n    el.height = this.getHeight();\r\n\r\n    var clone = new fabric.Canvas(el);\r\n    clone.clipTo = this.clipTo;\r\n    if (this.backgroundImage) {\r\n      clone.setBackgroundImage(this.backgroundImage.src, function() {\r\n        clone.renderAll();\r\n        callback && callback(clone);\r\n      });\r\n      clone.backgroundImageOpacity = this.backgroundImageOpacity;\r\n      clone.backgroundImageStretch = this.backgroundImageStretch;\r\n    }\r\n    else {\r\n      callback && callback(clone);\r\n    }\r\n  }\r\n});\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      toFixed = fabric.util.toFixed,\r\n      capitalize = fabric.util.string.capitalize,\r\n      degreesToRadians = fabric.util.degreesToRadians,\r\n      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');\r\n\r\n  if (fabric.Object) {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Root object class from which all 2d shape classes inherit from\r\n   * @class fabric.Object\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#objects}\r\n   * @see {@link fabric.Object#initialize} for constructor definition\r\n   *\r\n   * @fires added\r\n   * @fires removed\r\n   *\r\n   * @fires selected\r\n   * @fires modified\r\n   * @fires rotating\r\n   * @fires scaling\r\n   * @fires moving\r\n   *\r\n   * @fires mousedown\r\n   * @fires mouseup\r\n   */\r\n  fabric.Object = fabric.util.createClass(/** @lends fabric.Object.prototype */ {\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#clipTo|clipping function}\r\n     * @method getClipTo\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Function}\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#clipTo|clipping function}\r\n     * @method setClipTo\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Function} clipTo Clipping function\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#transformMatrix|transformMatrix}\r\n     * @method getTransformMatrix\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Array} transformMatrix\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#transformMatrix|transformMatrix}\r\n     * @method setTransformMatrix\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Array} transformMatrix\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#visible|visible} state\r\n     * @method getVisible\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Boolean} True if visible\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#visible|visible} state\r\n     * @method setVisible\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Boolean} value visible value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#shadow|shadow}\r\n     * @method getShadow\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Object} Shadow instance\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#stroke|stroke}\r\n     * @method getStroke\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {String} stroke value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#stroke|stroke}\r\n     * @method setStroke\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {String} value stroke value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#strokeWidth|strokeWidth}\r\n     * @method getStrokeWidth\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number} strokeWidth value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#strokeWidth|strokeWidth}\r\n     * @method setStrokeWidth\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Number} value strokeWidth value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#originX|originX}\r\n     * @method getOriginX\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {String} originX value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#originX|originX}\r\n     * @method setOriginX\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {String} value originX value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#originY|originY}\r\n     * @method getOriginY\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {String} originY value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#originY|originY}\r\n     * @method setOriginY\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {String} value originY value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#fill|fill}\r\n     * @method getFill\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {String} Fill value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#fill|fill}\r\n     * @method setFill\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {String} value Fill value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#opacity|opacity}\r\n     * @method getOpacity\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number} Opacity value (0-1)\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#opacity|opacity}\r\n     * @method setOpacity\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Number} value Opacity value (0-1)\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#angle|angle} (in degrees)\r\n     * @method getAngle\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number}\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#top|top position}\r\n     * @method getTop\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number} Top value (in pixels)\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#top|top position}\r\n     * @method setTop\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Number} value Top value (in pixels)\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#left|left position}\r\n     * @method getLeft\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number} Left value (in pixels)\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#left|left position}\r\n     * @method setLeft\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Number} value Left value (in pixels)\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#scaleX|scaleX} value\r\n     * @method getScaleX\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number} scaleX value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#scaleX|scaleX} value\r\n     * @method setScaleX\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Number} value scaleX value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#scaleY|scaleY} value\r\n     * @method getScaleY\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number} scaleY value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#scaleY|scaleY} value\r\n     * @method setScaleY\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Number} value scaleY value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#flipX|flipX} value\r\n     * @method getFlipX\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Boolean} flipX value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#flipX|flipX} value\r\n     * @method setFlipX\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Boolean} value flipX value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#flipY|flipY} value\r\n     * @method getFlipY\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Boolean} flipY value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#flipY|flipY} value\r\n     * @method setFlipY\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Boolean} value flipY value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Type of an object (rect, circle, path, etc.).\r\n     * Note that this property is meant to be read-only and not meant to be modified.\r\n     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.\r\n     * @type String\r\n     * @default\r\n     */\r\n    type:                     'object',\r\n\r\n    /**\r\n     * Horizontal origin of transformation of an object (one of \"left\", \"right\", \"center\")\r\n     * See http://jsfiddle.net/1ow02gea/40/ on how originX/originY affect objects in groups\r\n     * @type String\r\n     * @default\r\n     */\r\n    originX:                  'left',\r\n\r\n    /**\r\n     * Vertical origin of transformation of an object (one of \"top\", \"bottom\", \"center\")\r\n     * See http://jsfiddle.net/1ow02gea/40/ on how originX/originY affect objects in groups\r\n     * @type String\r\n     * @default\r\n     */\r\n    originY:                  'top',\r\n\r\n    /**\r\n     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}\r\n     * @type Number\r\n     * @default\r\n     */\r\n    top:                      0,\r\n\r\n    /**\r\n     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}\r\n     * @type Number\r\n     * @default\r\n     */\r\n    left:                     0,\r\n\r\n    /**\r\n     * Object width\r\n     * @type Number\r\n     * @default\r\n     */\r\n    width:                    0,\r\n\r\n    /**\r\n     * Object height\r\n     * @type Number\r\n     * @default\r\n     */\r\n    height:                   0,\r\n\r\n    /**\r\n     * Object scale factor (horizontal)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    scaleX:                   1,\r\n\r\n    /**\r\n     * Object scale factor (vertical)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    scaleY:                   1,\r\n\r\n    /**\r\n     * When true, an object is rendered as flipped horizontally\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    flipX:                    false,\r\n\r\n    /**\r\n     * When true, an object is rendered as flipped vertically\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    flipY:                    false,\r\n\r\n    /**\r\n     * Opacity of an object\r\n     * @type Number\r\n     * @default\r\n     */\r\n    opacity:                  1,\r\n\r\n    /**\r\n     * Angle of rotation of an object (in degrees)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    angle:                    0,\r\n\r\n    /**\r\n     * Size of object's controlling corners (in pixels)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    cornerSize:               12,\r\n\r\n    /**\r\n     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    transparentCorners:       true,\r\n\r\n    /**\r\n     * Default cursor value used when hovering over this object on canvas\r\n     * @type String\r\n     * @default\r\n     */\r\n    hoverCursor:              null,\r\n\r\n    /**\r\n     * Padding between object and its controlling borders (in pixels)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    padding:                  0,\r\n\r\n    /**\r\n     * Color of controlling borders of an object (when it's active)\r\n     * @type String\r\n     * @default\r\n     */\r\n    borderColor:              'rgba(102,153,255,0.75)',\r\n\r\n    /**\r\n     * Color of controlling corners of an object (when it's active)\r\n     * @type String\r\n     * @default\r\n     */\r\n    cornerColor:              'rgba(102,153,255,0.5)',\r\n\r\n    /**\r\n     * When true, this object will use center point as the origin of transformation\r\n     * when being scaled via the controls.\r\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\r\n     * @since 1.3.4\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    centeredScaling:          false,\r\n\r\n    /**\r\n     * When true, this object will use center point as the origin of transformation\r\n     * when being rotated via the controls.\r\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\r\n     * @since 1.3.4\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    centeredRotation:         true,\r\n\r\n    /**\r\n     * Color of object's fill\r\n     * @type String\r\n     * @default\r\n     */\r\n    fill:                     'rgb(0,0,0)',\r\n\r\n    /**\r\n     * Fill rule used to fill an object\r\n     * accepted values are nonzero, evenodd\r\n     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)\r\n     * @type String\r\n     * @default\r\n     */\r\n    fillRule:                 'nonzero',\r\n\r\n    /**\r\n     * Composite rule used for canvas globalCompositeOperation\r\n     * @type String\r\n     * @default\r\n     */\r\n    globalCompositeOperation: 'source-over',\r\n\r\n    /**\r\n     * Background color of an object. Only works with text objects at the moment.\r\n     * @type String\r\n     * @default\r\n     */\r\n    backgroundColor:          '',\r\n\r\n    /**\r\n     * When defined, an object is rendered via stroke and this property specifies its color\r\n     * @type String\r\n     * @default\r\n     */\r\n    stroke:                   null,\r\n\r\n    /**\r\n     * Width of a stroke used to render this object\r\n     * @type Number\r\n     * @default\r\n     */\r\n    strokeWidth:              1,\r\n\r\n    /**\r\n     * Array specifying dash pattern of an object's stroke (stroke must be defined)\r\n     * @type Array\r\n     */\r\n    strokeDashArray:          null,\r\n\r\n    /**\r\n     * Line endings style of an object's stroke (one of \"butt\", \"round\", \"square\")\r\n     * @type String\r\n     * @default\r\n     */\r\n    strokeLineCap:            'butt',\r\n\r\n    /**\r\n     * Corner style of an object's stroke (one of \"bevil\", \"round\", \"miter\")\r\n     * @type String\r\n     * @default\r\n     */\r\n    strokeLineJoin:           'miter',\r\n\r\n    /**\r\n     * Maximum miter length (used for strokeLineJoin = \"miter\") of an object's stroke\r\n     * @type Number\r\n     * @default\r\n     */\r\n    strokeMiterLimit:         10,\r\n\r\n    /**\r\n     * Shadow object representing shadow of this shape\r\n     * @type fabric.Shadow\r\n     * @default\r\n     */\r\n    shadow:                   null,\r\n\r\n    /**\r\n     * Opacity of object's controlling borders when object is active and moving\r\n     * @type Number\r\n     * @default\r\n     */\r\n    borderOpacityWhenMoving:  0.4,\r\n\r\n    /**\r\n     * Scale factor of object's controlling borders\r\n     * @type Number\r\n     * @default\r\n     */\r\n    borderScaleFactor:        1,\r\n\r\n    /**\r\n     * Transform matrix (similar to SVG's transform matrix)\r\n     * @type Array\r\n     */\r\n    transformMatrix:          null,\r\n\r\n    /**\r\n     * Minimum allowed scale value of an object\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minScaleLimit:            0.01,\r\n\r\n    /**\r\n     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).\r\n     * But events still fire on it.\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    selectable:               true,\r\n\r\n    /**\r\n     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    evented:                  true,\r\n\r\n    /**\r\n     * When set to `false`, an object is not rendered on canvas\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    visible:                  true,\r\n\r\n    /**\r\n     * When set to `false`, object's controls are not displayed and can not be used to manipulate object\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    hasControls:              true,\r\n\r\n    /**\r\n     * When set to `false`, object's controlling borders are not rendered\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    hasBorders:               true,\r\n\r\n    /**\r\n     * When set to `false`, object's controlling rotating point will not be visible or selectable\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    hasRotatingPoint:         true,\r\n\r\n    /**\r\n     * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    rotatingPointOffset:      40,\r\n\r\n    /**\r\n     * When set to `true`, objects are \"found\" on canvas on per-pixel basis rather than according to bounding box\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    perPixelTargetFind:       false,\r\n\r\n    /**\r\n     * When `false`, default object's values are not included in its serialization\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    includeDefaultValues:     true,\r\n\r\n    /**\r\n     * Function that determines clipping of an object (context is passed as a first argument)\r\n     * Note that context origin is at the object's center point (not left/top corner)\r\n     * @type Function\r\n     */\r\n    clipTo:                   null,\r\n\r\n    /**\r\n     * When `true`, object horizontal movement is locked\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    lockMovementX:            false,\r\n\r\n    /**\r\n     * When `true`, object vertical movement is locked\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    lockMovementY:            false,\r\n\r\n    /**\r\n     * When `true`, object rotation is locked\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    lockRotation:             false,\r\n\r\n    /**\r\n     * When `true`, object horizontal scaling is locked\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    lockScalingX:             false,\r\n\r\n    /**\r\n     * When `true`, object vertical scaling is locked\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    lockScalingY:             false,\r\n\r\n    /**\r\n     * When `true`, object non-uniform scaling is locked\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    lockUniScaling:           false,\r\n\r\n    /**\r\n     * When `true`, object cannot be flipped by scaling into negative values\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n\r\n    lockScalingFlip:          false,\r\n    /**\r\n     * List of properties to consider when checking if state\r\n     * of an object is changed (fabric.Object#hasStateChanged)\r\n     * as well as for history (undo/redo) purposes\r\n     * @type Array\r\n     */\r\n    stateProperties:  (\r\n      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +\r\n      'stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit ' +\r\n      'angle opacity fill fillRule globalCompositeOperation shadow clipTo visible backgroundColor ' +\r\n      'alignX alignY meetOrSlice'\r\n    ).split(' '),\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} [options] Options object\r\n     */\r\n    initialize: function(options) {\r\n      if (options) {\r\n        this.setOptions(options);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initGradient: function(options) {\r\n      if (options.fill && options.fill.colorStops && !(options.fill instanceof fabric.Gradient)) {\r\n        this.set('fill', new fabric.Gradient(options.fill));\r\n      }\r\n      if (options.stroke && options.stroke.colorStops && !(options.stroke instanceof fabric.Gradient)) {\r\n        this.set('stroke', new fabric.Gradient(options.stroke));\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initPattern: function(options) {\r\n      if (options.fill && options.fill.source && !(options.fill instanceof fabric.Pattern)) {\r\n        this.set('fill', new fabric.Pattern(options.fill));\r\n      }\r\n      if (options.stroke && options.stroke.source && !(options.stroke instanceof fabric.Pattern)) {\r\n        this.set('stroke', new fabric.Pattern(options.stroke));\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initClipping: function(options) {\r\n      if (!options.clipTo || typeof options.clipTo !== 'string') {\r\n        return;\r\n      }\r\n\r\n      var functionBody = fabric.util.getFunctionBody(options.clipTo);\r\n      if (typeof functionBody !== 'undefined') {\r\n        this.clipTo = new Function('ctx', functionBody);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets object's properties from options\r\n     * @param {Object} [options] Options object\r\n     */\r\n    setOptions: function(options) {\r\n      for (var prop in options) {\r\n        this.set(prop, options[prop]);\r\n      }\r\n      this._initGradient(options);\r\n      this._initPattern(options);\r\n      this._initClipping(options);\r\n    },\r\n\r\n    /**\r\n     * Transforms context when rendering an object\r\n     * @param {CanvasRenderingContext2D} ctx Context\r\n     * @param {Boolean} fromLeft When true, context is transformed to object's top/left corner. This is used when rendering text on Node\r\n     */\r\n    transform: function(ctx, fromLeft) {\r\n      if (this.group && this.canvas.preserveObjectStacking && this.group === this.canvas._activeGroup) {\r\n        this.group.transform(ctx);\r\n      }\r\n      var center = fromLeft ? this._getLeftTopCoords() : this.getCenterPoint();\r\n      ctx.translate(center.x, center.y);\r\n      ctx.rotate(degreesToRadians(this.angle));\r\n      ctx.scale(\r\n        this.scaleX * (this.flipX ? -1 : 1),\r\n        this.scaleY * (this.flipY ? -1 : 1)\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Returns an object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,\r\n\r\n          object = {\r\n            type:                     this.type,\r\n            originX:                  this.originX,\r\n            originY:                  this.originY,\r\n            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),\r\n            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),\r\n            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),\r\n            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),\r\n            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,\r\n            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,\r\n            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),\r\n            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,\r\n            strokeLineCap:            this.strokeLineCap,\r\n            strokeLineJoin:           this.strokeLineJoin,\r\n            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),\r\n            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),\r\n            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),\r\n            angle:                    toFixed(this.getAngle(), NUM_FRACTION_DIGITS),\r\n            flipX:                    this.flipX,\r\n            flipY:                    this.flipY,\r\n            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),\r\n            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,\r\n            visible:                  this.visible,\r\n            clipTo:                   this.clipTo && String(this.clipTo),\r\n            backgroundColor:          this.backgroundColor,\r\n            fillRule:                 this.fillRule,\r\n            globalCompositeOperation: this.globalCompositeOperation,\r\n            transformMatrix:          this.transformMatrix ? this.transformMatrix.concat() : this.transformMatrix\r\n          };\r\n\r\n      if (!this.includeDefaultValues) {\r\n        object = this._removeDefaultValues(object);\r\n      }\r\n\r\n      fabric.util.populateWithProperties(this, object, propertiesToInclude);\r\n\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Returns (dataless) object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toDatalessObject: function(propertiesToInclude) {\r\n      // will be overwritten by subclasses\r\n      return this.toObject(propertiesToInclude);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} object\r\n     */\r\n    _removeDefaultValues: function(object) {\r\n      var prototype = fabric.util.getKlass(object.type).prototype,\r\n          stateProperties = prototype.stateProperties;\r\n\r\n      stateProperties.forEach(function(prop) {\r\n        if (object[prop] === prototype[prop]) {\r\n          delete object[prop];\r\n        }\r\n        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&\r\n                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';\r\n\r\n        // basically a check for [] === []\r\n        if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {\r\n          delete object[prop];\r\n        }\r\n      });\r\n\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Returns a string representation of an instance\r\n     * @return {String}\r\n     */\r\n    toString: function() {\r\n      return '#<fabric.' + capitalize(this.type) + '>';\r\n    },\r\n\r\n    /**\r\n     * Basic getter\r\n     * @param {String} property Property name\r\n     * @return {Any} value of a property\r\n     */\r\n    get: function(property) {\r\n      return this[property];\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setObject: function(obj) {\r\n      for (var prop in obj) {\r\n        this._set(prop, obj[prop]);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\r\n     * @param {String|Object} key Property name or object (if object, iterate over the object properties)\r\n     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    set: function(key, value) {\r\n      if (typeof key === 'object') {\r\n        this._setObject(key);\r\n      }\r\n      else {\r\n        if (typeof value === 'function' && key !== 'clipTo') {\r\n          this._set(key, value(this.get(key)));\r\n        }\r\n        else {\r\n          this._set(key, value);\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} key\r\n     * @param {Any} value\r\n     * @return {fabric.Object} thisArg\r\n     */\r\n    _set: function(key, value) {\r\n      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY');\r\n\r\n      if (shouldConstrainValue) {\r\n        value = this._constrainScale(value);\r\n      }\r\n      if (key === 'scaleX' && value < 0) {\r\n        this.flipX = !this.flipX;\r\n        value *= -1;\r\n      }\r\n      else if (key === 'scaleY' && value < 0) {\r\n        this.flipY = !this.flipY;\r\n        value *= -1;\r\n      }\r\n      else if (key === 'width' || key === 'height') {\r\n        this.minScaleLimit = toFixed(Math.min(0.1, 1/Math.max(this.width, this.height)), 2);\r\n      }\r\n      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {\r\n        value = new fabric.Shadow(value);\r\n      }\r\n\r\n      this[key] = value;\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * This callback function is called by the parent group of an object every\r\n     * time a non-delegated property changes on the group. It is passed the key\r\n     * and value as parameters. Not adding in this function's signature to avoid\r\n     * Travis build error about unused variables.\r\n     */\r\n    setOnGroup: function() {\r\n      // implemented by sub-classes, as needed.\r\n    },\r\n\r\n    /**\r\n     * Toggles specified property from `true` to `false` or from `false` to `true`\r\n     * @param {String} property Property to toggle\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    toggle: function(property) {\r\n      var value = this.get(property);\r\n      if (typeof value === 'boolean') {\r\n        this.set(property, !value);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets sourcePath of an object\r\n     * @param {String} value Value to set sourcePath to\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    setSourcePath: function(value) {\r\n      this.sourcePath = value;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves viewportTransform from Object's canvas if possible\r\n     * @method getViewportTransform\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Boolean} flipY value // TODO\r\n     */\r\n    getViewportTransform: function() {\r\n      if (this.canvas && this.canvas.viewportTransform) {\r\n        return this.canvas.viewportTransform;\r\n      }\r\n      return [1, 0, 0, 1, 0, 0];\r\n    },\r\n\r\n    /**\r\n     * Renders an object on a specified context\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Boolean} [noTransform] When true, context is not transformed\r\n     */\r\n    render: function(ctx, noTransform) {\r\n      // do not render if width/height are zeros or object is not visible\r\n      if ((this.width === 0 && this.height === 0) || !this.visible) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n\r\n      //setup fill rule for current object\r\n      this._setupCompositeOperation(ctx);\r\n      if (!noTransform) {\r\n        this.transform(ctx);\r\n      }\r\n      this._setStrokeStyles(ctx);\r\n      this._setFillStyles(ctx);\r\n      if (this.transformMatrix) {\r\n        ctx.transform.apply(ctx, this.transformMatrix);\r\n      }\r\n      this._setOpacity(ctx);\r\n      this._setShadow(ctx);\r\n      this.clipTo && fabric.util.clipContext(this, ctx);\r\n      this._render(ctx, noTransform);\r\n      this.clipTo && ctx.restore();\r\n\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _setOpacity: function(ctx) {\r\n      if (this.group) {\r\n        this.group._setOpacity(ctx);\r\n      }\r\n      ctx.globalAlpha *= this.opacity;\r\n    },\r\n\r\n    _setStrokeStyles: function(ctx) {\r\n      if (this.stroke) {\r\n        ctx.lineWidth = this.strokeWidth;\r\n        ctx.lineCap = this.strokeLineCap;\r\n        ctx.lineJoin = this.strokeLineJoin;\r\n        ctx.miterLimit = this.strokeMiterLimit;\r\n        ctx.strokeStyle = this.stroke.toLive\r\n          ? this.stroke.toLive(ctx, this)\r\n          : this.stroke;\r\n      }\r\n    },\r\n\r\n    _setFillStyles: function(ctx) {\r\n      if (this.fill) {\r\n        ctx.fillStyle = this.fill.toLive\r\n          ? this.fill.toLive(ctx, this)\r\n          : this.fill;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Renders controls and borders for the object\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Boolean} [noTransform] When true, context is not transformed\r\n     */\r\n    _renderControls: function(ctx, noTransform) {\r\n      if (!this.active || noTransform) {\r\n        return;\r\n      }\r\n      var vpt = this.getViewportTransform();\r\n      ctx.save();\r\n      var center;\r\n      if (this.group) {\r\n        center = fabric.util.transformPoint(this.group.getCenterPoint(), vpt);\r\n        ctx.translate(center.x, center.y);\r\n        ctx.rotate(degreesToRadians(this.group.angle));\r\n      }\r\n      center = fabric.util.transformPoint(this.getCenterPoint(), vpt, null != this.group);\r\n      if (this.group) {\r\n        center.x *= this.group.scaleX;\r\n        center.y *= this.group.scaleY;\r\n      }\r\n      ctx.translate(center.x, center.y);\r\n      ctx.rotate(degreesToRadians(this.angle));\r\n      this.drawBorders(ctx);\r\n      this.drawControls(ctx);\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _setShadow: function(ctx) {\r\n      if (!this.shadow) {\r\n        return;\r\n      }\r\n\r\n      var multX = (this.canvas && this.canvas.viewportTransform[0]) || 1,\r\n          multY = (this.canvas && this.canvas.viewportTransform[3]) || 1;\r\n\r\n      ctx.shadowColor = this.shadow.color;\r\n      ctx.shadowBlur = this.shadow.blur * (multX + multY) * (this.scaleX + this.scaleY) / 4;\r\n      ctx.shadowOffsetX = this.shadow.offsetX * multX * this.scaleX;\r\n      ctx.shadowOffsetY = this.shadow.offsetY * multY * this.scaleY;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _removeShadow: function(ctx) {\r\n      if (!this.shadow) {\r\n        return;\r\n      }\r\n\r\n      ctx.shadowColor = '';\r\n      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderFill: function(ctx) {\r\n      if (!this.fill) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n      if (this.fill.gradientTransform) {\r\n        var g = this.fill.gradientTransform;\r\n        ctx.transform.apply(ctx, g);\r\n      }\r\n      if (this.fill.toLive) {\r\n        ctx.translate(\r\n          -this.width / 2 + this.fill.offsetX || 0,\r\n          -this.height / 2 + this.fill.offsetY || 0);\r\n      }\r\n      if (this.fillRule === 'evenodd') {\r\n        ctx.fill('evenodd');\r\n      }\r\n      else {\r\n        ctx.fill();\r\n      }\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderStroke: function(ctx) {\r\n      if (!this.stroke || this.strokeWidth === 0) {\r\n        return;\r\n      }\r\n\r\n      if (this.shadow && !this.shadow.affectStroke) {\r\n        this._removeShadow(ctx);\r\n      }\r\n\r\n      ctx.save();\r\n\r\n      if (this.strokeDashArray) {\r\n        // Spec requires the concatenation of two copies the dash list when the number of elements is odd\r\n        if (1 & this.strokeDashArray.length) {\r\n          this.strokeDashArray.push.apply(this.strokeDashArray, this.strokeDashArray);\r\n        }\r\n        if (supportsLineDash) {\r\n          ctx.setLineDash(this.strokeDashArray);\r\n          this._stroke && this._stroke(ctx);\r\n        }\r\n        else {\r\n          this._renderDashedStroke && this._renderDashedStroke(ctx);\r\n        }\r\n        ctx.stroke();\r\n      }\r\n      else {\r\n        if (this.stroke.gradientTransform) {\r\n          var g = this.stroke.gradientTransform;\r\n          ctx.transform.apply(ctx, g);\r\n        }\r\n        this._stroke ? this._stroke(ctx) : ctx.stroke();\r\n      }\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Clones an instance\r\n     * @param {Function} callback Callback is invoked with a clone as a first argument\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {fabric.Object} clone of an instance\r\n     */\r\n    clone: function(callback, propertiesToInclude) {\r\n      if (this.constructor.fromObject) {\r\n        return this.constructor.fromObject(this.toObject(propertiesToInclude), callback);\r\n      }\r\n      return new fabric.Object(this.toObject(propertiesToInclude));\r\n    },\r\n\r\n    /**\r\n     * Creates an instance of fabric.Image out of an object\r\n     * @param {Function} callback callback, invoked with an instance as a first argument\r\n     * @return {fabric.Object} thisArg\r\n     */\r\n    cloneAsImage: function(callback) {\r\n      var dataUrl = this.toDataURL();\r\n      fabric.util.loadImage(dataUrl, function(img) {\r\n        if (callback) {\r\n          callback(new fabric.Image(img));\r\n        }\r\n      });\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Converts an object into a data-url-like string\r\n     * @param {Object} options Options object\r\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\r\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\r\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\r\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\r\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\r\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\r\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\r\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\r\n     */\r\n    toDataURL: function(options) {\r\n      options || (options = { });\r\n\r\n      var el = fabric.util.createCanvasElement(),\r\n          boundingRect = this.getBoundingRect();\r\n\r\n      el.width = boundingRect.width;\r\n      el.height = boundingRect.height;\r\n\r\n      fabric.util.wrapElement(el, 'div');\r\n      var canvas = new fabric.StaticCanvas(el);\r\n\r\n      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806\r\n      if (options.format === 'jpg') {\r\n        options.format = 'jpeg';\r\n      }\r\n\r\n      if (options.format === 'jpeg') {\r\n        canvas.backgroundColor = '#fff';\r\n      }\r\n\r\n      var origParams = {\r\n        active: this.get('active'),\r\n        left: this.getLeft(),\r\n        top: this.getTop()\r\n      };\r\n\r\n      this.set('active', false);\r\n      this.setPositionByOrigin(new fabric.Point(el.width / 2, el.height / 2), 'center', 'center');\r\n\r\n      var originalCanvas = this.canvas;\r\n      canvas.add(this);\r\n      var data = canvas.toDataURL(options);\r\n\r\n      this.set(origParams).setCoords();\r\n      this.canvas = originalCanvas;\r\n\r\n      canvas.dispose();\r\n      canvas = null;\r\n\r\n      return data;\r\n    },\r\n\r\n    /**\r\n     * Returns true if specified type is identical to the type of an instance\r\n     * @param {String} type Type to check against\r\n     * @return {Boolean}\r\n     */\r\n    isType: function(type) {\r\n      return this.type === type;\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return 0;\r\n    },\r\n\r\n    /**\r\n     * Returns a JSON representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} JSON\r\n     */\r\n    toJSON: function(propertiesToInclude) {\r\n      // delegate, not alias\r\n      return this.toObject(propertiesToInclude);\r\n    },\r\n\r\n    /**\r\n     * Sets gradient (fill or stroke) of an object\r\n     * <b>Backwards incompatibility note:</b> This method was named \"setGradientFill\" until v1.1.0\r\n     * @param {String} property Property name 'stroke' or 'fill'\r\n     * @param {Object} [options] Options object\r\n     * @param {String} [options.type] Type of gradient 'radial' or 'linear'\r\n     * @param {Number} [options.x1=0] x-coordinate of start point\r\n     * @param {Number} [options.y1=0] y-coordinate of start point\r\n     * @param {Number} [options.x2=0] x-coordinate of end point\r\n     * @param {Number} [options.y2=0] y-coordinate of end point\r\n     * @param {Number} [options.r1=0] Radius of start point (only for radial gradients)\r\n     * @param {Number} [options.r2=0] Radius of end point (only for radial gradients)\r\n     * @param {Object} [options.colorStops] Color stops object eg. {0: 'ff0000', 1: '000000'}\r\n     * @param {Object} [options.gradientTransform] transforMatrix for gradient\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/58y8b/|jsFiddle demo}\r\n     * @example <caption>Set linear gradient</caption>\r\n     * object.setGradient('fill', {\r\n     *   type: 'linear',\r\n     *   x1: -object.width / 2,\r\n     *   y1: 0,\r\n     *   x2: object.width / 2,\r\n     *   y2: 0,\r\n     *   colorStops: {\r\n     *     0: 'red',\r\n     *     0.5: '#005555',\r\n     *     1: 'rgba(0,0,255,0.5)'\r\n     *   }\r\n     * });\r\n     * canvas.renderAll();\r\n     * @example <caption>Set radial gradient</caption>\r\n     * object.setGradient('fill', {\r\n     *   type: 'radial',\r\n     *   x1: 0,\r\n     *   y1: 0,\r\n     *   x2: 0,\r\n     *   y2: 0,\r\n     *   r1: object.width / 2,\r\n     *   r2: 10,\r\n     *   colorStops: {\r\n     *     0: 'red',\r\n     *     0.5: '#005555',\r\n     *     1: 'rgba(0,0,255,0.5)'\r\n     *   }\r\n     * });\r\n     * canvas.renderAll();\r\n     */\r\n    setGradient: function(property, options) {\r\n      options || (options = { });\r\n\r\n      var gradient = { colorStops: [] };\r\n\r\n      gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');\r\n      gradient.coords = {\r\n        x1: options.x1,\r\n        y1: options.y1,\r\n        x2: options.x2,\r\n        y2: options.y2\r\n      };\r\n\r\n      if (options.r1 || options.r2) {\r\n        gradient.coords.r1 = options.r1;\r\n        gradient.coords.r2 = options.r2;\r\n      }\r\n\r\n      options.gradientTransform && (gradient.gradientTransform = options.gradientTransform);\r\n\r\n      for (var position in options.colorStops) {\r\n        var color = new fabric.Color(options.colorStops[position]);\r\n        gradient.colorStops.push({\r\n          offset: position,\r\n          color: color.toRgb(),\r\n          opacity: color.getAlpha()\r\n        });\r\n      }\r\n\r\n      return this.set(property, fabric.Gradient.forObject(this, gradient));\r\n    },\r\n\r\n    /**\r\n     * Sets pattern fill of an object\r\n     * @param {Object} options Options object\r\n     * @param {(String|HTMLImageElement)} options.source Pattern source\r\n     * @param {String} [options.repeat=repeat] Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)\r\n     * @param {Number} [options.offsetX=0] Pattern horizontal offset from object's left/top corner\r\n     * @param {Number} [options.offsetY=0] Pattern vertical offset from object's left/top corner\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/QT3pa/|jsFiddle demo}\r\n     * @example <caption>Set pattern</caption>\r\n     * fabric.util.loadImage('http://fabricjs.com/assets/escheresque_ste.png', function(img) {\r\n     *   object.setPatternFill({\r\n     *     source: img,\r\n     *     repeat: 'repeat'\r\n     *   });\r\n     *   canvas.renderAll();\r\n     * });\r\n     */\r\n    setPatternFill: function(options) {\r\n      return this.set('fill', new fabric.Pattern(options));\r\n    },\r\n\r\n    /**\r\n     * Sets {@link fabric.Object#shadow|shadow} of an object\r\n     * @param {Object|String} [options] Options object or string (e.g. \"2px 2px 10px rgba(0,0,0,0.2)\")\r\n     * @param {String} [options.color=rgb(0,0,0)] Shadow color\r\n     * @param {Number} [options.blur=0] Shadow blur\r\n     * @param {Number} [options.offsetX=0] Shadow horizontal offset\r\n     * @param {Number} [options.offsetY=0] Shadow vertical offset\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/7gvJG/|jsFiddle demo}\r\n     * @example <caption>Set shadow with string notation</caption>\r\n     * object.setShadow('2px 2px 10px rgba(0,0,0,0.2)');\r\n     * canvas.renderAll();\r\n     * @example <caption>Set shadow with object notation</caption>\r\n     * object.setShadow({\r\n     *   color: 'red',\r\n     *   blur: 10,\r\n     *   offsetX: 20,\r\n     *   offsetY: 20\r\n     * });\r\n     * canvas.renderAll();\r\n     */\r\n    setShadow: function(options) {\r\n      return this.set('shadow', options ? new fabric.Shadow(options) : null);\r\n    },\r\n\r\n    /**\r\n     * Sets \"color\" of an instance (alias of `set('fill', &hellip;)`)\r\n     * @param {String} color Color value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    setColor: function(color) {\r\n      this.set('fill', color);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets \"angle\" of an instance\r\n     * @param {Number} angle Angle value (in degrees)\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    setAngle: function(angle) {\r\n      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;\r\n\r\n      if (shouldCenterOrigin) {\r\n        this._setOriginToCenter();\r\n      }\r\n\r\n      this.set('angle', angle);\r\n\r\n      if (shouldCenterOrigin) {\r\n        this._resetOrigin();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Centers object horizontally on canvas to which it was added last.\r\n     * You might need to call `setCoords` on an object after centering, to update controls area.\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    centerH: function () {\r\n      this.canvas.centerObjectH(this);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Centers object vertically on canvas to which it was added last.\r\n     * You might need to call `setCoords` on an object after centering, to update controls area.\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    centerV: function () {\r\n      this.canvas.centerObjectV(this);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Centers object vertically and horizontally on canvas to which is was added last\r\n     * You might need to call `setCoords` on an object after centering, to update controls area.\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    center: function () {\r\n      this.canvas.centerObject(this);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Removes object from canvas to which it was added last\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    remove: function() {\r\n      this.canvas.remove(this);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns coordinates of a pointer relative to an object\r\n     * @param {Event} e Event to operate upon\r\n     * @param {Object} [pointer] Pointer to operate upon (instead of event)\r\n     * @return {Object} Coordinates of a pointer (x, y)\r\n     */\r\n    getLocalPointer: function(e, pointer) {\r\n      pointer = pointer || this.canvas.getPointer(e);\r\n      var pClicked = new fabric.Point(pointer.x, pointer.y),\r\n          objectLeftTop = this._getLeftTopCoords();\r\n      if (this.angle) {\r\n        pClicked = fabric.util.rotatePoint(\r\n          pClicked, objectLeftTop, fabric.util.degreesToRadians(-this.angle));\r\n      }\r\n      return {\r\n        x: pClicked.x - objectLeftTop.x,\r\n        y: pClicked.y - objectLeftTop.y\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Sets canvas globalCompositeOperation for specific object\r\n     * custom composition operation for the particular object can be specifed using globalCompositeOperation property\r\n     * @param {CanvasRenderingContext2D} ctx Rendering canvas context\r\n     */\r\n    _setupCompositeOperation: function (ctx) {\r\n      if (this.globalCompositeOperation) {\r\n        ctx.globalCompositeOperation = this.globalCompositeOperation;\r\n      }\r\n    }\r\n  });\r\n\r\n  fabric.util.createAccessors(fabric.Object);\r\n\r\n  /**\r\n   * Alias for {@link fabric.Object.prototype.setAngle}\r\n   * @alias rotate -> setAngle\r\n   * @memberOf fabric.Object\r\n   */\r\n  fabric.Object.prototype.rotate = fabric.Object.prototype.setAngle;\r\n\r\n  extend(fabric.Object.prototype, fabric.Observable);\r\n\r\n  /**\r\n   * Defines the number of fraction digits to use when serializing object values.\r\n   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.\r\n   * @static\r\n   * @memberOf fabric.Object\r\n   * @constant\r\n   * @type Number\r\n   */\r\n  fabric.Object.NUM_FRACTION_DIGITS = 2;\r\n\r\n  /**\r\n   * Unique id used internally when creating SVG elements\r\n   * @static\r\n   * @memberOf fabric.Object\r\n   * @type Number\r\n   */\r\n  fabric.Object.__uid = 0;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function() {\r\n\r\n  var degreesToRadians = fabric.util.degreesToRadians,\r\n      originXOffset = {\r\n        left: -0.5,\r\n        center: 0,\r\n        right: 0.5\r\n      },\r\n      originYOffset = {\r\n        top: -0.5,\r\n        center: 0,\r\n        bottom: 0.5\r\n      };\r\n\r\n  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n    /**\r\n     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\r\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\r\n     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @return {fabric.Point}\r\n     */\r\n    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {\r\n      var x = point.x,\r\n          y = point.y,\r\n          offsetX = originXOffset[toOriginX] - originXOffset[fromOriginX],\r\n          offsetY = originYOffset[toOriginY] - originYOffset[fromOriginY],\r\n          dim;\r\n      if (offsetX || offsetY) {\r\n        dim = this._getTransformedDimensions();\r\n        x = point.x + offsetX * dim.x;\r\n        y = point.y + offsetY * dim.y;\r\n      }\r\n      return new fabric.Point(x, y);\r\n    },\r\n\r\n    /**\r\n     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\r\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\r\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @return {fabric.Point}\r\n     */\r\n    translateToCenterPoint: function(point, originX, originY) {\r\n      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');\r\n      if (this.angle) {\r\n        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));\r\n      }\r\n      return p;\r\n    },\r\n\r\n    /**\r\n     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)\r\n     * @param {fabric.Point} center The point which corresponds to center of the object\r\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @return {fabric.Point}\r\n     */\r\n    translateToOriginPoint: function(center, originX, originY) {\r\n      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);\r\n      if (this.angle) {\r\n        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));\r\n      }\r\n      return p;\r\n    },\r\n\r\n    /**\r\n     * Returns the real center coordinates of the object\r\n     * @return {fabric.Point}\r\n     */\r\n    getCenterPoint: function() {\r\n      var leftTop = new fabric.Point(this.left, this.top);\r\n      return this.translateToCenterPoint(leftTop, this.originX, this.originY);\r\n    },\r\n\r\n    /**\r\n     * Returns the coordinates of the object based on center coordinates\r\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\r\n     * @return {fabric.Point}\r\n     */\r\n    // getOriginPoint: function(center) {\r\n    //   return this.translateToOriginPoint(center, this.originX, this.originY);\r\n    // },\r\n\r\n    /**\r\n     * Returns the coordinates of the object as if it has a different origin\r\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @return {fabric.Point}\r\n     */\r\n    getPointByOrigin: function(originX, originY) {\r\n      var center = this.getCenterPoint();\r\n      return this.translateToOriginPoint(center, originX, originY);\r\n    },\r\n\r\n    /**\r\n     * Returns the point in local coordinates\r\n     * @param {fabric.Point} point The point relative to the global coordinate system\r\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @return {fabric.Point}\r\n     */\r\n    toLocalPoint: function(point, originX, originY) {\r\n      var center = this.getCenterPoint(),\r\n          p, p2;\r\n\r\n      if (originX && originY) {\r\n        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);\r\n      }\r\n      else {\r\n        p = new fabric.Point(this.left, this.top);\r\n      }\r\n\r\n      p2 = new fabric.Point(point.x, point.y);\r\n      if (this.angle) {\r\n        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));\r\n      }\r\n      return p2.subtractEquals(p);\r\n    },\r\n\r\n    /**\r\n     * Returns the point in global coordinates\r\n     * @param {fabric.Point} The point relative to the local coordinate system\r\n     * @return {fabric.Point}\r\n     */\r\n    // toGlobalPoint: function(point) {\r\n    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));\r\n    // },\r\n\r\n    /**\r\n     * Sets the position of the object taking into consideration the object's origin\r\n     * @param {fabric.Point} pos The new position of the object\r\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @return {void}\r\n     */\r\n    setPositionByOrigin: function(pos, originX, originY) {\r\n      var center = this.translateToCenterPoint(pos, originX, originY),\r\n          position = this.translateToOriginPoint(center, this.originX, this.originY);\r\n\r\n      this.set('left', position.x);\r\n      this.set('top', position.y);\r\n    },\r\n\r\n    /**\r\n     * @param {String} to One of 'left', 'center', 'right'\r\n     */\r\n    adjustPosition: function(to) {\r\n      var angle = degreesToRadians(this.angle),\r\n          hypotFull = this.getWidth(),\r\n          xFull = Math.cos(angle) * hypotFull,\r\n          yFull = Math.sin(angle) * hypotFull;\r\n\r\n      //TODO: this function does not consider mixed situation like top, center.\r\n      this.left += xFull * (originXOffset[to] - originXOffset[this.originX]);\r\n      this.top += yFull * (originXOffset[to] - originXOffset[this.originX]);\r\n\r\n      this.setCoords();\r\n      this.originX = to;\r\n    },\r\n\r\n    /**\r\n     * Sets the origin/position of the object to it's center point\r\n     * @private\r\n     * @return {void}\r\n     */\r\n    _setOriginToCenter: function() {\r\n      this._originalOriginX = this.originX;\r\n      this._originalOriginY = this.originY;\r\n\r\n      var center = this.getCenterPoint();\r\n\r\n      this.originX = 'center';\r\n      this.originY = 'center';\r\n\r\n      this.left = center.x;\r\n      this.top = center.y;\r\n    },\r\n\r\n    /**\r\n     * Resets the origin/position of the object to it's original origin\r\n     * @private\r\n     * @return {void}\r\n     */\r\n    _resetOrigin: function() {\r\n      var originPoint = this.translateToOriginPoint(\r\n        this.getCenterPoint(),\r\n        this._originalOriginX,\r\n        this._originalOriginY);\r\n\r\n      this.originX = this._originalOriginX;\r\n      this.originY = this._originalOriginY;\r\n\r\n      this.left = originPoint.x;\r\n      this.top = originPoint.y;\r\n\r\n      this._originalOriginX = null;\r\n      this._originalOriginY = null;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getLeftTopCoords: function() {\r\n      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');\r\n    }\r\n  });\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  function getCoords(oCoords) {\r\n    return [\r\n      new fabric.Point(oCoords.tl.x, oCoords.tl.y),\r\n      new fabric.Point(oCoords.tr.x, oCoords.tr.y),\r\n      new fabric.Point(oCoords.br.x, oCoords.br.y),\r\n      new fabric.Point(oCoords.bl.x, oCoords.bl.y)\r\n    ];\r\n  }\r\n\r\n  var degreesToRadians = fabric.util.degreesToRadians;\r\n\r\n  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n    /**\r\n     * Object containing coordinates of object's controls\r\n     * @type Object\r\n     * @default\r\n     */\r\n    oCoords: null,\r\n\r\n    /**\r\n     * Checks if object intersects with an area formed by 2 points\r\n     * @param {Object} pointTL top-left point of area\r\n     * @param {Object} pointBR bottom-right point of area\r\n     * @return {Boolean} true if object intersects with an area formed by 2 points\r\n     */\r\n    intersectsWithRect: function(pointTL, pointBR) {\r\n      var oCoords = getCoords(this.oCoords),\r\n          intersection = fabric.Intersection.intersectPolygonRectangle(\r\n            oCoords,\r\n            pointTL,\r\n            pointBR\r\n          );\r\n      return intersection.status === 'Intersection';\r\n    },\r\n\r\n    /**\r\n     * Checks if object intersects with another object\r\n     * @param {Object} other Object to test\r\n     * @return {Boolean} true if object intersects with another object\r\n     */\r\n    intersectsWithObject: function(other) {\r\n      var intersection = fabric.Intersection.intersectPolygonPolygon(\r\n            getCoords(this.oCoords),\r\n            getCoords(other.oCoords)\r\n          );\r\n\r\n      return intersection.status === 'Intersection';\r\n    },\r\n\r\n    /**\r\n     * Checks if object is fully contained within area of another object\r\n     * @param {Object} other Object to test\r\n     * @return {Boolean} true if object is fully contained within area of another object\r\n     */\r\n    isContainedWithinObject: function(other) {\r\n      var boundingRect = other.getBoundingRect(),\r\n          point1 = new fabric.Point(boundingRect.left, boundingRect.top),\r\n          point2 = new fabric.Point(boundingRect.left + boundingRect.width, boundingRect.top + boundingRect.height);\r\n\r\n      return this.isContainedWithinRect(point1, point2);\r\n    },\r\n\r\n    /**\r\n     * Checks if object is fully contained within area formed by 2 points\r\n     * @param {Object} pointTL top-left point of area\r\n     * @param {Object} pointBR bottom-right point of area\r\n     * @return {Boolean} true if object is fully contained within area formed by 2 points\r\n     */\r\n    isContainedWithinRect: function(pointTL, pointBR) {\r\n      var boundingRect = this.getBoundingRect();\r\n\r\n      return (\r\n        boundingRect.left >= pointTL.x &&\r\n        boundingRect.left + boundingRect.width <= pointBR.x &&\r\n        boundingRect.top >= pointTL.y &&\r\n        boundingRect.top + boundingRect.height <= pointBR.y\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Checks if point is inside the object\r\n     * @param {fabric.Point} point Point to check against\r\n     * @return {Boolean} true if point is inside the object\r\n     */\r\n    containsPoint: function(point) {\r\n      var lines = this._getImageLines(this.oCoords),\r\n          xPoints = this._findCrossPoints(point, lines);\r\n\r\n      // if xPoints is odd then point is inside the object\r\n      return (xPoints !== 0 && xPoints % 2 === 1);\r\n    },\r\n\r\n    /**\r\n     * Method that returns an object with the object edges in it, given the coordinates of the corners\r\n     * @private\r\n     * @param {Object} oCoords Coordinates of the object corners\r\n     */\r\n    _getImageLines: function(oCoords) {\r\n      return {\r\n        topline: {\r\n          o: oCoords.tl,\r\n          d: oCoords.tr\r\n        },\r\n        rightline: {\r\n          o: oCoords.tr,\r\n          d: oCoords.br\r\n        },\r\n        bottomline: {\r\n          o: oCoords.br,\r\n          d: oCoords.bl\r\n        },\r\n        leftline: {\r\n          o: oCoords.bl,\r\n          d: oCoords.tl\r\n        }\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Helper method to determine how many cross points are between the 4 object edges\r\n     * and the horizontal line determined by a point on canvas\r\n     * @private\r\n     * @param {fabric.Point} point Point to check\r\n     * @param {Object} oCoords Coordinates of the object being evaluated\r\n     */\r\n    _findCrossPoints: function(point, oCoords) {\r\n      var b1, b2, a1, a2, xi, yi,\r\n          xcount = 0,\r\n          iLine;\r\n\r\n      for (var lineKey in oCoords) {\r\n        iLine = oCoords[lineKey];\r\n        // optimisation 1: line below point. no cross\r\n        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {\r\n          continue;\r\n        }\r\n        // optimisation 2: line above point. no cross\r\n        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {\r\n          continue;\r\n        }\r\n        // optimisation 3: vertical line case\r\n        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {\r\n          xi = iLine.o.x;\r\n          yi = point.y;\r\n        }\r\n        // calculate the intersection point\r\n        else {\r\n          b1 = 0;\r\n          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);\r\n          a1 = point.y - b1 * point.x;\r\n          a2 = iLine.o.y - b2 * iLine.o.x;\r\n\r\n          xi = - (a1 - a2) / (b1 - b2);\r\n          yi = a1 + b1 * xi;\r\n        }\r\n        // dont count xi < point.x cases\r\n        if (xi >= point.x) {\r\n          xcount += 1;\r\n        }\r\n        // optimisation 4: specific for square images\r\n        if (xcount === 2) {\r\n          break;\r\n        }\r\n      }\r\n      return xcount;\r\n    },\r\n\r\n    /**\r\n     * Returns width of an object's bounding rectangle\r\n     * @deprecated since 1.0.4\r\n     * @return {Number} width value\r\n     */\r\n    getBoundingRectWidth: function() {\r\n      return this.getBoundingRect().width;\r\n    },\r\n\r\n    /**\r\n     * Returns height of an object's bounding rectangle\r\n     * @deprecated since 1.0.4\r\n     * @return {Number} height value\r\n     */\r\n    getBoundingRectHeight: function() {\r\n      return this.getBoundingRect().height;\r\n    },\r\n\r\n    /**\r\n     * Returns coordinates of object's bounding rectangle (left, top, width, height)\r\n     * @return {Object} Object with left, top, width, height properties\r\n     */\r\n    getBoundingRect: function() {\r\n      this.oCoords || this.setCoords();\r\n\r\n      var xCoords = [this.oCoords.tl.x, this.oCoords.tr.x, this.oCoords.br.x, this.oCoords.bl.x],\r\n          minX = fabric.util.array.min(xCoords),\r\n          maxX = fabric.util.array.max(xCoords),\r\n          width = Math.abs(minX - maxX),\r\n\r\n          yCoords = [this.oCoords.tl.y, this.oCoords.tr.y, this.oCoords.br.y, this.oCoords.bl.y],\r\n          minY = fabric.util.array.min(yCoords),\r\n          maxY = fabric.util.array.max(yCoords),\r\n          height = Math.abs(minY - maxY);\r\n\r\n      return {\r\n        left: minX,\r\n        top: minY,\r\n        width: width,\r\n        height: height\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Returns width of an object\r\n     * @return {Number} width value\r\n     */\r\n    getWidth: function() {\r\n      //needs to be changed\r\n      return this.width * this.scaleX;\r\n    },\r\n\r\n    /**\r\n     * Returns height of an object\r\n     * @return {Number} height value\r\n     */\r\n    getHeight: function() {\r\n      //needs to be changed\r\n      return this.height * this.scaleY;\r\n    },\r\n\r\n    /**\r\n     * Makes sure the scale is valid and modifies it if necessary\r\n     * @private\r\n     * @param {Number} value\r\n     * @return {Number}\r\n     */\r\n    _constrainScale: function(value) {\r\n      if (Math.abs(value) < this.minScaleLimit) {\r\n        if (value < 0) {\r\n          return -this.minScaleLimit;\r\n        }\r\n        else {\r\n          return this.minScaleLimit;\r\n        }\r\n      }\r\n      return value;\r\n    },\r\n\r\n    /**\r\n     * Scales an object (equally by x and y)\r\n     * @param {Number} value Scale factor\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    scale: function(value) {\r\n      value = this._constrainScale(value);\r\n\r\n      if (value < 0) {\r\n        this.flipX = !this.flipX;\r\n        this.flipY = !this.flipY;\r\n        value *= -1;\r\n      }\r\n\r\n      this.scaleX = value;\r\n      this.scaleY = value;\r\n      this.setCoords();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)\r\n     * @param {Number} value New width value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    scaleToWidth: function(value) {\r\n      // adjust to bounding rect factor so that rotated shapes would fit as well\r\n      var boundingRectFactor = this.getBoundingRect().width / this.getWidth();\r\n      return this.scale(value / this.width / boundingRectFactor);\r\n    },\r\n\r\n    /**\r\n     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)\r\n     * @param {Number} value New height value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    scaleToHeight: function(value) {\r\n      // adjust to bounding rect factor so that rotated shapes would fit as well\r\n      var boundingRectFactor = this.getBoundingRect().height / this.getHeight();\r\n      return this.scale(value / this.height / boundingRectFactor);\r\n    },\r\n\r\n    /**\r\n     * Sets corner position coordinates based on current angle, width and height\r\n     * See https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    setCoords: function() {\r\n      var theta = degreesToRadians(this.angle),\r\n          vpt = this.getViewportTransform(),\r\n          dim = this._calculateCurrentDimensions(),\r\n          currentWidth = dim.x, currentHeight = dim.y;\r\n\r\n      // If width is negative, make postive. Fixes path selection issue\r\n      if (currentWidth < 0) {\r\n        currentWidth = Math.abs(currentWidth);\r\n      }\r\n\r\n      var sinTh = Math.sin(theta),\r\n          cosTh = Math.cos(theta),\r\n          _angle = currentWidth > 0 ? Math.atan(currentHeight / currentWidth) : 0,\r\n          _hypotenuse = (currentWidth / Math.cos(_angle)) / 2,\r\n          offsetX = Math.cos(_angle + theta) * _hypotenuse,\r\n          offsetY = Math.sin(_angle + theta) * _hypotenuse,\r\n\r\n          // offset added for rotate and scale actions\r\n          coords = fabric.util.transformPoint(this.getCenterPoint(), vpt),\r\n          tl  = new fabric.Point(coords.x - offsetX, coords.y - offsetY),\r\n          tr  = new fabric.Point(tl.x + (currentWidth * cosTh), tl.y + (currentWidth * sinTh)),\r\n          bl  = new fabric.Point(tl.x - (currentHeight * sinTh), tl.y + (currentHeight * cosTh)),\r\n          br  = new fabric.Point(coords.x + offsetX, coords.y + offsetY),\r\n          ml  = new fabric.Point((tl.x + bl.x)/2, (tl.y + bl.y)/2),\r\n          mt  = new fabric.Point((tr.x + tl.x)/2, (tr.y + tl.y)/2),\r\n          mr  = new fabric.Point((br.x + tr.x)/2, (br.y + tr.y)/2),\r\n          mb  = new fabric.Point((br.x + bl.x)/2, (br.y + bl.y)/2),\r\n          mtr = new fabric.Point(mt.x + sinTh * this.rotatingPointOffset, mt.y - cosTh * this.rotatingPointOffset);\r\n      // debugging\r\n\r\n      /* setTimeout(function() {\r\n         canvas.contextTop.fillStyle = 'green';\r\n         canvas.contextTop.fillRect(mb.x, mb.y, 3, 3);\r\n         canvas.contextTop.fillRect(bl.x, bl.y, 3, 3);\r\n         canvas.contextTop.fillRect(br.x, br.y, 3, 3);\r\n         canvas.contextTop.fillRect(tl.x, tl.y, 3, 3);\r\n         canvas.contextTop.fillRect(tr.x, tr.y, 3, 3);\r\n         canvas.contextTop.fillRect(ml.x, ml.y, 3, 3);\r\n         canvas.contextTop.fillRect(mr.x, mr.y, 3, 3);\r\n         canvas.contextTop.fillRect(mt.x, mt.y, 3, 3);\r\n         canvas.contextTop.fillRect(mtr.x, mtr.y, 3, 3);\r\n       }, 50); */\r\n\r\n      this.oCoords = {\r\n        // corners\r\n        tl: tl, tr: tr, br: br, bl: bl,\r\n        // middle\r\n        ml: ml, mt: mt, mr: mr, mb: mb,\r\n        // rotating point\r\n        mtr: mtr\r\n      };\r\n\r\n      // set coordinates of the draggable boxes in the corners used to scale/rotate the image\r\n      this._setCornerCoords && this._setCornerCoords();\r\n\r\n      return this;\r\n    },\r\n\r\n    _calcDimensionsTransformMatrix: function() {\r\n      // introduce skew matrix here later\r\n      return [this.scaleX, 0, 0, this.scaleY, 0, 0];\r\n    }\r\n  });\r\n})();\r\n\r\n\r\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n  /**\r\n   * Moves an object to the bottom of the stack of drawn objects\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  sendToBack: function() {\r\n    if (this.group) {\r\n      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);\r\n    }\r\n    else {\r\n      this.canvas.sendToBack(this);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Moves an object to the top of the stack of drawn objects\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  bringToFront: function() {\r\n    if (this.group) {\r\n      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);\r\n    }\r\n    else {\r\n      this.canvas.bringToFront(this);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Moves an object down in stack of drawn objects\r\n   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  sendBackwards: function(intersecting) {\r\n    if (this.group) {\r\n      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);\r\n    }\r\n    else {\r\n      this.canvas.sendBackwards(this, intersecting);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Moves an object up in stack of drawn objects\r\n   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  bringForward: function(intersecting) {\r\n    if (this.group) {\r\n      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);\r\n    }\r\n    else {\r\n      this.canvas.bringForward(this, intersecting);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Moves an object to specified level in stack of drawn objects\r\n   * @param {Number} index New position of object\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  moveTo: function(index) {\r\n    if (this.group) {\r\n      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);\r\n    }\r\n    else {\r\n      this.canvas.moveTo(this, index);\r\n    }\r\n    return this;\r\n  }\r\n});\r\n\r\n\r\n/* _TO_SVG_START_ */\r\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n  /**\r\n   * Returns styles-string for svg-export\r\n   * @return {String}\r\n   */\r\n  getSvgStyles: function() {\r\n\r\n    var fill = this.fill\r\n          ? (this.fill.toLive ? 'url(#SVGID_' + this.fill.id + ')' : this.fill)\r\n          : 'none',\r\n        fillRule = this.fillRule,\r\n        stroke = this.stroke\r\n          ? (this.stroke.toLive ? 'url(#SVGID_' + this.stroke.id + ')' : this.stroke)\r\n          : 'none',\r\n\r\n        strokeWidth = this.strokeWidth ? this.strokeWidth : '0',\r\n        strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',\r\n        strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',\r\n        strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',\r\n        strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',\r\n        opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',\r\n\r\n        visibility = this.visible ? '' : ' visibility: hidden;',\r\n        filter = this.getSvgFilter();\r\n\r\n    return [\r\n      'stroke: ', stroke, '; ',\r\n      'stroke-width: ', strokeWidth, '; ',\r\n      'stroke-dasharray: ', strokeDashArray, '; ',\r\n      'stroke-linecap: ', strokeLineCap, '; ',\r\n      'stroke-linejoin: ', strokeLineJoin, '; ',\r\n      'stroke-miterlimit: ', strokeMiterLimit, '; ',\r\n      'fill: ', fill, '; ',\r\n      'fill-rule: ', fillRule, '; ',\r\n      'opacity: ', opacity, ';',\r\n      filter,\r\n      visibility\r\n    ].join('');\r\n  },\r\n\r\n  /**\r\n   * Returns filter for svg shadow\r\n   * @return {String}\r\n   */\r\n  getSvgFilter: function() {\r\n    return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';\r\n  },\r\n\r\n  /**\r\n   * Returns transform-string for svg-export\r\n   * @return {String}\r\n   */\r\n  getSvgTransform: function() {\r\n    if (this.group && this.group.type === 'path-group') {\r\n      return '';\r\n    }\r\n    var toFixed = fabric.util.toFixed,\r\n        angle = this.getAngle(),\r\n        vpt = !this.canvas || this.canvas.svgViewportTransformation ? this.getViewportTransform() : [1, 0, 0, 1, 0, 0],\r\n        center = fabric.util.transformPoint(this.getCenterPoint(), vpt),\r\n\r\n        NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,\r\n\r\n        translatePart = this.type === 'path-group' ? '' : 'translate(' +\r\n                          toFixed(center.x, NUM_FRACTION_DIGITS) +\r\n                          ' ' +\r\n                          toFixed(center.y, NUM_FRACTION_DIGITS) +\r\n                        ')',\r\n\r\n        anglePart = angle !== 0\r\n          ? (' rotate(' + toFixed(angle, NUM_FRACTION_DIGITS) + ')')\r\n          : '',\r\n\r\n        scalePart = (this.scaleX === 1 && this.scaleY === 1 && vpt[0] === 1 && vpt[3] === 1)\r\n          ? '' :\r\n          (' scale(' +\r\n            toFixed(this.scaleX * vpt[0], NUM_FRACTION_DIGITS) +\r\n            ' ' +\r\n            toFixed(this.scaleY * vpt[3], NUM_FRACTION_DIGITS) +\r\n          ')'),\r\n\r\n        addTranslateX = this.type === 'path-group' ? this.width * vpt[0] : 0,\r\n\r\n        flipXPart = this.flipX ? ' matrix(-1 0 0 1 ' + addTranslateX + ' 0) ' : '',\r\n\r\n        addTranslateY = this.type === 'path-group' ? this.height * vpt[3] : 0,\r\n\r\n        flipYPart = this.flipY ? ' matrix(1 0 0 -1 0 ' + addTranslateY + ')' : '';\r\n\r\n    return [\r\n      translatePart, anglePart, scalePart, flipXPart, flipYPart\r\n    ].join('');\r\n  },\r\n\r\n  /**\r\n   * Returns transform-string for svg-export from the transform matrix of single elements\r\n   * @return {String}\r\n   */\r\n  getSvgTransformMatrix: function() {\r\n    return this.transformMatrix ? ' matrix(' + this.transformMatrix.join(' ') + ') ' : '';\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _createBaseSVGMarkup: function() {\r\n    var markup = [ ];\r\n\r\n    if (this.fill && this.fill.toLive) {\r\n      markup.push(this.fill.toSVG(this, false));\r\n    }\r\n    if (this.stroke && this.stroke.toLive) {\r\n      markup.push(this.stroke.toSVG(this, false));\r\n    }\r\n    if (this.shadow) {\r\n      markup.push(this.shadow.toSVG(this));\r\n    }\r\n    return markup;\r\n  }\r\n});\r\n/* _TO_SVG_END_ */\r\n\r\n\r\n/*\r\n  Depends on `stateProperties`\r\n*/\r\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n  /**\r\n   * Returns true if object state (one of its state properties) was changed\r\n   * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called\r\n   */\r\n  hasStateChanged: function() {\r\n    return this.stateProperties.some(function(prop) {\r\n      return this.get(prop) !== this.originalState[prop];\r\n    }, this);\r\n  },\r\n\r\n  /**\r\n   * Saves state of an object\r\n   * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\r\n   * @return {fabric.Object} thisArg\r\n   */\r\n  saveState: function(options) {\r\n    this.stateProperties.forEach(function(prop) {\r\n      this.originalState[prop] = this.get(prop);\r\n    }, this);\r\n\r\n    if (options && options.stateProperties) {\r\n      options.stateProperties.forEach(function(prop) {\r\n        this.originalState[prop] = this.get(prop);\r\n      }, this);\r\n    }\r\n\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Setups state of an object\r\n   * @return {fabric.Object} thisArg\r\n   */\r\n  setupState: function() {\r\n    this.originalState = { };\r\n    this.saveState();\r\n\r\n    return this;\r\n  }\r\n});\r\n\r\n\r\n(function() {\r\n\r\n  var degreesToRadians = fabric.util.degreesToRadians,\r\n      //jscs:disable requireCamelCaseOrUpperCaseIdentifiers\r\n      isVML = function() { return typeof G_vmlCanvasManager !== 'undefined'; };\r\n  //jscs:enable requireCamelCaseOrUpperCaseIdentifiers\r\n\r\n  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n    /**\r\n     * The object interactivity controls.\r\n     * @private\r\n     */\r\n    _controlsVisibility: null,\r\n\r\n    /**\r\n     * Determines which corner has been clicked\r\n     * @private\r\n     * @param {Object} pointer The pointer indicating the mouse position\r\n     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found\r\n     */\r\n    _findTargetCorner: function(pointer) {\r\n      if (!this.hasControls || !this.active) {\r\n        return false;\r\n      }\r\n\r\n      var ex = pointer.x,\r\n          ey = pointer.y,\r\n          xPoints,\r\n          lines;\r\n      this.__corner = 0;\r\n      for (var i in this.oCoords) {\r\n\r\n        if (!this.isControlVisible(i)) {\r\n          continue;\r\n        }\r\n\r\n        if (i === 'mtr' && !this.hasRotatingPoint) {\r\n          continue;\r\n        }\r\n\r\n        if (this.get('lockUniScaling') &&\r\n           (i === 'mt' || i === 'mr' || i === 'mb' || i === 'ml')) {\r\n          continue;\r\n        }\r\n\r\n        lines = this._getImageLines(this.oCoords[i].corner);\r\n\r\n        // debugging\r\n\r\n        // canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\r\n        // canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\r\n\r\n        // canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\r\n        // canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\r\n\r\n        // canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\r\n        // canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\r\n\r\n        // canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\r\n        // canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\r\n\r\n        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);\r\n        if (xPoints !== 0 && xPoints % 2 === 1) {\r\n          this.__corner = i;\r\n          return i;\r\n        }\r\n      }\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Sets the coordinates of the draggable boxes in the corners of\r\n     * the image used to scale/rotate it.\r\n     * @private\r\n     */\r\n    _setCornerCoords: function() {\r\n      var coords = this.oCoords,\r\n          newTheta = degreesToRadians(45 - this.angle),\r\n          /* Math.sqrt(2 * Math.pow(this.cornerSize, 2)) / 2, */\r\n          /* 0.707106 stands for sqrt(2)/2 */\r\n          cornerHypotenuse = this.cornerSize * 0.707106,\r\n          cosHalfOffset = cornerHypotenuse * Math.cos(newTheta),\r\n          sinHalfOffset = cornerHypotenuse * Math.sin(newTheta),\r\n          x, y;\r\n\r\n      for (var point in coords) {\r\n        x = coords[point].x;\r\n        y = coords[point].y;\r\n        coords[point].corner = {\r\n          tl: {\r\n            x: x - sinHalfOffset,\r\n            y: y - cosHalfOffset\r\n          },\r\n          tr: {\r\n            x: x + cosHalfOffset,\r\n            y: y - sinHalfOffset\r\n          },\r\n          bl: {\r\n            x: x - cosHalfOffset,\r\n            y: y + sinHalfOffset\r\n          },\r\n          br: {\r\n            x: x + sinHalfOffset,\r\n            y: y + cosHalfOffset\r\n          }\r\n        };\r\n      }\r\n    },\r\n\r\n    /*\r\n     * Calculate object dimensions from its properties\r\n     * @private\r\n     */\r\n    _getNonTransformedDimensions: function() {\r\n      var strokeWidth = this.strokeWidth,\r\n          w = this.width,\r\n          h = this.height,\r\n          addStrokeToW = true,\r\n          addStrokeToH = true;\r\n\r\n      if (this.type === 'line' && this.strokeLineCap === 'butt') {\r\n        addStrokeToH = w;\r\n        addStrokeToW = h;\r\n      }\r\n\r\n      if (addStrokeToH) {\r\n        h += h < 0 ? -strokeWidth : strokeWidth;\r\n      }\r\n\r\n      if (addStrokeToW) {\r\n        w += w < 0 ? -strokeWidth : strokeWidth;\r\n      }\r\n\r\n      return { x: w, y: h };\r\n    },\r\n\r\n    /*\r\n     * @private\r\n     */\r\n    _getTransformedDimensions: function(dimensions) {\r\n      if (!dimensions) {\r\n        dimensions = this._getNonTransformedDimensions();\r\n      }\r\n      var transformMatrix = this._calcDimensionsTransformMatrix();\r\n      return fabric.util.transformPoint(dimensions, transformMatrix, true);\r\n    },\r\n\r\n    /*\r\n     * private\r\n     */\r\n    _calculateCurrentDimensions: function()  {\r\n      var vpt = this.getViewportTransform(),\r\n          dim = this._getTransformedDimensions(),\r\n          w = dim.x, h = dim.y;\r\n\r\n      w += 2 * this.padding;\r\n      h += 2 * this.padding;\r\n\r\n      return fabric.util.transformPoint(new fabric.Point(w, h), vpt, true);\r\n    },\r\n\r\n    /**\r\n     * Draws borders of an object's bounding box.\r\n     * Requires public properties: width, height\r\n     * Requires public options: padding, borderColor\r\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    drawBorders: function(ctx) {\r\n      if (!this.hasBorders) {\r\n        return this;\r\n      }\r\n\r\n      ctx.save();\r\n\r\n      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\r\n      ctx.strokeStyle = this.borderColor;\r\n      ctx.lineWidth = 1 / this.borderScaleFactor;\r\n\r\n      var wh = this._calculateCurrentDimensions(),\r\n          width = wh.x,\r\n          height = wh.y;\r\n      if (this.group) {\r\n        width = width * this.group.scaleX;\r\n        height = height * this.group.scaleY;\r\n      }\r\n\r\n      ctx.strokeRect(\r\n        ~~(-(width / 2)) - 0.5, // offset needed to make lines look sharper\r\n        ~~(-(height / 2)) - 0.5,\r\n        ~~(width) + 1, // double offset needed to make lines look sharper\r\n        ~~(height) + 1\r\n      );\r\n\r\n      if (this.hasRotatingPoint && this.isControlVisible('mtr') && !this.get('lockRotation') && this.hasControls) {\r\n\r\n        var rotateHeight = -height / 2;\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, rotateHeight);\r\n        ctx.lineTo(0, rotateHeight - this.rotatingPointOffset);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n      }\r\n\r\n      ctx.restore();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Draws corners of an object's bounding box.\r\n     * Requires public properties: width, height\r\n     * Requires public options: cornerSize, padding\r\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    drawControls: function(ctx) {\r\n      if (!this.hasControls) {\r\n        return this;\r\n      }\r\n\r\n      var wh = this._calculateCurrentDimensions(),\r\n          width = wh.x,\r\n          height = wh.y,\r\n          scaleOffset = this.cornerSize / 2,\r\n          left = -(width / 2) - scaleOffset,\r\n          top = -(height / 2) - scaleOffset,\r\n          methodName = this.transparentCorners ? 'strokeRect' : 'fillRect';\r\n\r\n      ctx.save();\r\n\r\n      ctx.lineWidth = 1;\r\n\r\n      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\r\n      ctx.strokeStyle = ctx.fillStyle = this.cornerColor;\r\n\r\n      // top-left\r\n      this._drawControl('tl', ctx, methodName,\r\n        left,\r\n        top);\r\n\r\n      // top-right\r\n      this._drawControl('tr', ctx, methodName,\r\n        left + width,\r\n        top);\r\n\r\n      // bottom-left\r\n      this._drawControl('bl', ctx, methodName,\r\n        left,\r\n        top + height);\r\n\r\n      // bottom-right\r\n      this._drawControl('br', ctx, methodName,\r\n        left + width,\r\n        top + height);\r\n\r\n      if (!this.get('lockUniScaling')) {\r\n\r\n        // middle-top\r\n        this._drawControl('mt', ctx, methodName,\r\n          left + width/2,\r\n          top);\r\n\r\n        // middle-bottom\r\n        this._drawControl('mb', ctx, methodName,\r\n          left + width/2,\r\n          top + height);\r\n\r\n        // middle-right\r\n        this._drawControl('mr', ctx, methodName,\r\n          left + width,\r\n          top + height/2);\r\n\r\n        // middle-left\r\n        this._drawControl('ml', ctx, methodName,\r\n          left,\r\n          top + height/2);\r\n      }\r\n\r\n      // middle-top-rotate\r\n      if (this.hasRotatingPoint) {\r\n        this._drawControl('mtr', ctx, methodName,\r\n          left + width/2 ,\r\n          top - this.rotatingPointOffset);\r\n      }\r\n\r\n      ctx.restore();\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _drawControl: function(control, ctx, methodName, left, top) {\r\n      if (!this.isControlVisible(control)) {\r\n        return;\r\n      }\r\n      var size = this.cornerSize;\r\n      isVML() || this.transparentCorners || ctx.clearRect(left, top, size, size);\r\n      ctx[methodName](left, top, size, size);\r\n    },\r\n\r\n    /**\r\n     * Returns true if the specified control is visible, false otherwise.\r\n     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\r\n     * @returns {Boolean} true if the specified control is visible, false otherwise\r\n     */\r\n    isControlVisible: function(controlName) {\r\n      return this._getControlsVisibility()[controlName];\r\n    },\r\n\r\n    /**\r\n     * Sets the visibility of the specified control.\r\n     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\r\n     * @param {Boolean} visible true to set the specified control visible, false otherwise\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    setControlVisible: function(controlName, visible) {\r\n      this._getControlsVisibility()[controlName] = visible;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the visibility state of object controls.\r\n     * @param {Object} [options] Options object\r\n     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it\r\n     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it\r\n     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it\r\n     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it\r\n     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it\r\n     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it\r\n     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it\r\n     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it\r\n     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    setControlsVisibility: function(options) {\r\n      options || (options = { });\r\n\r\n      for (var p in options) {\r\n        this.setControlVisible(p, options[p]);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the instance of the control visibility set for this object.\r\n     * @private\r\n     * @returns {Object}\r\n     */\r\n    _getControlsVisibility: function() {\r\n      if (!this._controlsVisibility) {\r\n        this._controlsVisibility = {\r\n          tl: true,\r\n          tr: true,\r\n          br: true,\r\n          bl: true,\r\n          ml: true,\r\n          mt: true,\r\n          mr: true,\r\n          mb: true,\r\n          mtr: true\r\n        };\r\n      }\r\n      return this._controlsVisibility;\r\n    }\r\n  });\r\n})();\r\n\r\n\r\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\r\n\r\n  /**\r\n   * Animation duration (in ms) for fx* methods\r\n   * @type Number\r\n   * @default\r\n   */\r\n  FX_DURATION: 500,\r\n\r\n  /**\r\n   * Centers object horizontally with animation.\r\n   * @param {fabric.Object} object Object to center\r\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\r\n   * @param {Function} [callbacks.onComplete] Invoked on completion\r\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\r\n   * @return {fabric.Canvas} thisArg\r\n   * @chainable\r\n   */\r\n  fxCenterObjectH: function (object, callbacks) {\r\n    callbacks = callbacks || { };\r\n\r\n    var empty = function() { },\r\n        onComplete = callbacks.onComplete || empty,\r\n        onChange = callbacks.onChange || empty,\r\n        _this = this;\r\n\r\n    fabric.util.animate({\r\n      startValue: object.get('left'),\r\n      endValue: this.getCenter().left,\r\n      duration: this.FX_DURATION,\r\n      onChange: function(value) {\r\n        object.set('left', value);\r\n        _this.renderAll();\r\n        onChange();\r\n      },\r\n      onComplete: function() {\r\n        object.setCoords();\r\n        onComplete();\r\n      }\r\n    });\r\n\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Centers object vertically with animation.\r\n   * @param {fabric.Object} object Object to center\r\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\r\n   * @param {Function} [callbacks.onComplete] Invoked on completion\r\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\r\n   * @return {fabric.Canvas} thisArg\r\n   * @chainable\r\n   */\r\n  fxCenterObjectV: function (object, callbacks) {\r\n    callbacks = callbacks || { };\r\n\r\n    var empty = function() { },\r\n        onComplete = callbacks.onComplete || empty,\r\n        onChange = callbacks.onChange || empty,\r\n        _this = this;\r\n\r\n    fabric.util.animate({\r\n      startValue: object.get('top'),\r\n      endValue: this.getCenter().top,\r\n      duration: this.FX_DURATION,\r\n      onChange: function(value) {\r\n        object.set('top', value);\r\n        _this.renderAll();\r\n        onChange();\r\n      },\r\n      onComplete: function() {\r\n        object.setCoords();\r\n        onComplete();\r\n      }\r\n    });\r\n\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Same as `fabric.Canvas#remove` but animated\r\n   * @param {fabric.Object} object Object to remove\r\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\r\n   * @param {Function} [callbacks.onComplete] Invoked on completion\r\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\r\n   * @return {fabric.Canvas} thisArg\r\n   * @chainable\r\n   */\r\n  fxRemove: function (object, callbacks) {\r\n    callbacks = callbacks || { };\r\n\r\n    var empty = function() { },\r\n        onComplete = callbacks.onComplete || empty,\r\n        onChange = callbacks.onChange || empty,\r\n        _this = this;\r\n\r\n    fabric.util.animate({\r\n      startValue: object.get('opacity'),\r\n      endValue: 0,\r\n      duration: this.FX_DURATION,\r\n      onStart: function() {\r\n        object.set('active', false);\r\n      },\r\n      onChange: function(value) {\r\n        object.set('opacity', value);\r\n        _this.renderAll();\r\n        onChange();\r\n      },\r\n      onComplete: function () {\r\n        _this.remove(object);\r\n        onComplete();\r\n      }\r\n    });\r\n\r\n    return this;\r\n  }\r\n});\r\n\r\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n  /**\r\n   * Animates object's properties\r\n   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)\r\n   * @param {Number|Object} value Value to animate property to (if string was given first) or options object\r\n   * @return {fabric.Object} thisArg\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#animation}\r\n   * @chainable\r\n   *\r\n   * As object \u00e2\u0080\u0094 multiple properties\r\n   *\r\n   * object.animate({ left: ..., top: ... });\r\n   * object.animate({ left: ..., top: ... }, { duration: ... });\r\n   *\r\n   * As string \u00e2\u0080\u0094 one property\r\n   *\r\n   * object.animate('left', ...);\r\n   * object.animate('left', { duration: ... });\r\n   *\r\n   */\r\n  animate: function() {\r\n    if (arguments[0] && typeof arguments[0] === 'object') {\r\n      var propsToAnimate = [ ], prop, skipCallbacks;\r\n      for (prop in arguments[0]) {\r\n        propsToAnimate.push(prop);\r\n      }\r\n      for (var i = 0, len = propsToAnimate.length; i < len; i++) {\r\n        prop = propsToAnimate[i];\r\n        skipCallbacks = i !== len - 1;\r\n        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);\r\n      }\r\n    }\r\n    else {\r\n      this._animate.apply(this, arguments);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {String} property Property to animate\r\n   * @param {String} to Value to animate to\r\n   * @param {Object} [options] Options object\r\n   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked\r\n   */\r\n  _animate: function(property, to, options, skipCallbacks) {\r\n    var _this = this, propPair;\r\n\r\n    to = to.toString();\r\n\r\n    if (!options) {\r\n      options = { };\r\n    }\r\n    else {\r\n      options = fabric.util.object.clone(options);\r\n    }\r\n\r\n    if (~property.indexOf('.')) {\r\n      propPair = property.split('.');\r\n    }\r\n\r\n    var currentValue = propPair\r\n      ? this.get(propPair[0])[propPair[1]]\r\n      : this.get(property);\r\n\r\n    if (!('from' in options)) {\r\n      options.from = currentValue;\r\n    }\r\n\r\n    if (~to.indexOf('=')) {\r\n      to = currentValue + parseFloat(to.replace('=', ''));\r\n    }\r\n    else {\r\n      to = parseFloat(to);\r\n    }\r\n\r\n    fabric.util.animate({\r\n      startValue: options.from,\r\n      endValue: to,\r\n      byValue: options.by,\r\n      easing: options.easing,\r\n      duration: options.duration,\r\n      abort: options.abort && function() {\r\n        return options.abort.call(_this);\r\n      },\r\n      onChange: function(value) {\r\n        if (propPair) {\r\n          _this[propPair[0]][propPair[1]] = value;\r\n        }\r\n        else {\r\n          _this.set(property, value);\r\n        }\r\n        if (skipCallbacks) {\r\n          return;\r\n        }\r\n        options.onChange && options.onChange();\r\n      },\r\n      onComplete: function() {\r\n        if (skipCallbacks) {\r\n          return;\r\n        }\r\n\r\n        _this.setCoords();\r\n        options.onComplete && options.onComplete();\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },\r\n      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');\r\n\r\n  if (fabric.Line) {\r\n    fabric.warn('fabric.Line is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Line class\r\n   * @class fabric.Line\r\n   * @extends fabric.Object\r\n   * @see {@link fabric.Line#initialize} for constructor definition\r\n   */\r\n  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'line',\r\n\r\n    /**\r\n     * x value or first line edge\r\n     * @type Number\r\n     * @default\r\n     */\r\n    x1: 0,\r\n\r\n    /**\r\n     * y value or first line edge\r\n     * @type Number\r\n     * @default\r\n     */\r\n    y1: 0,\r\n\r\n    /**\r\n     * x value or second line edge\r\n     * @type Number\r\n     * @default\r\n     */\r\n    x2: 0,\r\n\r\n    /**\r\n     * y value or second line edge\r\n     * @type Number\r\n     * @default\r\n     */\r\n    y2: 0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Array} [points] Array of points\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Line} thisArg\r\n     */\r\n    initialize: function(points, options) {\r\n      options = options || { };\r\n\r\n      if (!points) {\r\n        points = [0, 0, 0, 0];\r\n      }\r\n\r\n      this.callSuper('initialize', options);\r\n\r\n      this.set('x1', points[0]);\r\n      this.set('y1', points[1]);\r\n      this.set('x2', points[2]);\r\n      this.set('y2', points[3]);\r\n\r\n      this._setWidthHeight(options);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Options\r\n     */\r\n    _setWidthHeight: function(options) {\r\n      options || (options = { });\r\n\r\n      this.width = Math.abs(this.x2 - this.x1);\r\n      this.height = Math.abs(this.y2 - this.y1);\r\n\r\n      this.left = 'left' in options\r\n        ? options.left\r\n        : this._getLeftToOriginX();\r\n\r\n      this.top = 'top' in options\r\n        ? options.top\r\n        : this._getTopToOriginY();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} key\r\n     * @param {Any} value\r\n     */\r\n    _set: function(key, value) {\r\n      this.callSuper('_set', key, value);\r\n      if (typeof coordProps[key] !== 'undefined') {\r\n        this._setWidthHeight();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.\r\n     */\r\n    _getLeftToOriginX: makeEdgeToOriginGetter(\r\n      { // property names\r\n        origin: 'originX',\r\n        axis1: 'x1',\r\n        axis2: 'x2',\r\n        dimension: 'width'\r\n      },\r\n      { // possible values of origin\r\n        nearest: 'left',\r\n        center: 'center',\r\n        farthest: 'right'\r\n      }\r\n    ),\r\n\r\n    /**\r\n     * @private\r\n     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.\r\n     */\r\n    _getTopToOriginY: makeEdgeToOriginGetter(\r\n      { // property names\r\n        origin: 'originY',\r\n        axis1: 'y1',\r\n        axis2: 'y2',\r\n        dimension: 'height'\r\n      },\r\n      { // possible values of origin\r\n        nearest: 'top',\r\n        center: 'center',\r\n        farthest: 'bottom'\r\n      }\r\n    ),\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx, noTransform) {\r\n      ctx.beginPath();\r\n\r\n      if (noTransform) {\r\n        //  Line coords are distances from left-top of canvas to origin of line.\r\n        //  To render line in a path-group, we need to translate them to\r\n        //  distances from center of path-group to center of line.\r\n        var cp = this.getCenterPoint();\r\n        ctx.translate(\r\n          cp.x - this.strokeWidth / 2,\r\n          cp.y - this.strokeWidth / 2\r\n        );\r\n      }\r\n\r\n      if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {\r\n        // move from center (of virtual box) to its left/top corner\r\n        // we can't assume x1, y1 is top left and x2, y2 is bottom right\r\n        var p = this.calcLinePoints();\r\n        ctx.moveTo(p.x1, p.y1);\r\n        ctx.lineTo(p.x2, p.y2);\r\n      }\r\n\r\n      ctx.lineWidth = this.strokeWidth;\r\n\r\n      // TODO: test this\r\n      // make sure setting \"fill\" changes color of a line\r\n      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)\r\n      var origStrokeStyle = ctx.strokeStyle;\r\n      ctx.strokeStyle = this.stroke || ctx.fillStyle;\r\n      this.stroke && this._renderStroke(ctx);\r\n      ctx.strokeStyle = origStrokeStyle;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderDashedStroke: function(ctx) {\r\n      var p = this.calcLinePoints();\r\n\r\n      ctx.beginPath();\r\n      fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);\r\n      ctx.closePath();\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @methd toObject\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());\r\n    },\r\n\r\n    /**\r\n     * Recalculates line points given width and height\r\n     * @private\r\n     */\r\n    calcLinePoints: function() {\r\n      var xMult = this.x1 <= this.x2 ? -1 : 1,\r\n          yMult = this.y1 <= this.y2 ? -1 : 1,\r\n          x1 = (xMult * this.width * 0.5),\r\n          y1 = (yMult * this.height * 0.5),\r\n          x2 = (xMult * this.width * -0.5),\r\n          y2 = (yMult * this.height * -0.5);\r\n\r\n      return {\r\n        x1: x1,\r\n        x2: x2,\r\n        y1: y1,\r\n        y2: y2\r\n      };\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(),\r\n          p = { x1: this.x1, x2: this.x2, y1: this.y1, y2: this.y2 };\r\n\r\n      if (!(this.group && this.group.type === 'path-group')) {\r\n        p = this.calcLinePoints();\r\n      }\r\n      markup.push(\r\n        '<line ',\r\n          'x1=\"', p.x1,\r\n          '\" y1=\"', p.y1,\r\n          '\" x2=\"', p.x2,\r\n          '\" y2=\"', p.y2,\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(),\r\n          this.getSvgTransformMatrix(),\r\n        '\"/>\\n'\r\n      );\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})\r\n   * @static\r\n   * @memberOf fabric.Line\r\n   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement\r\n   */\r\n  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));\r\n\r\n  /**\r\n   * Returns fabric.Line instance from an SVG element\r\n   * @static\r\n   * @memberOf fabric.Line\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Line} instance of fabric.Line\r\n   */\r\n  fabric.Line.fromElement = function(element, options) {\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),\r\n        points = [\r\n          parsedAttributes.x1 || 0,\r\n          parsedAttributes.y1 || 0,\r\n          parsedAttributes.x2 || 0,\r\n          parsedAttributes.y2 || 0\r\n        ];\r\n    return new fabric.Line(points, extend(parsedAttributes, options));\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns fabric.Line instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Line\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Line} instance of fabric.Line\r\n   */\r\n  fabric.Line.fromObject = function(object) {\r\n    var points = [object.x1, object.y1, object.x2, object.y2];\r\n    return new fabric.Line(points, object);\r\n  };\r\n\r\n  /**\r\n   * Produces a function that calculates distance from canvas edge to Line origin.\r\n   */\r\n  function makeEdgeToOriginGetter(propertyNames, originValues) {\r\n    var origin = propertyNames.origin,\r\n        axis1 = propertyNames.axis1,\r\n        axis2 = propertyNames.axis2,\r\n        dimension = propertyNames.dimension,\r\n        nearest = originValues.nearest,\r\n        center = originValues.center,\r\n        farthest = originValues.farthest;\r\n\r\n    return function() {\r\n      switch (this.get(origin)) {\r\n      case nearest:\r\n        return Math.min(this.get(axis1), this.get(axis2));\r\n      case center:\r\n        return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));\r\n      case farthest:\r\n        return Math.max(this.get(axis1), this.get(axis2));\r\n      }\r\n    };\r\n\r\n  }\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      pi = Math.PI,\r\n      extend = fabric.util.object.extend;\r\n\r\n  if (fabric.Circle) {\r\n    fabric.warn('fabric.Circle is already defined.');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Circle class\r\n   * @class fabric.Circle\r\n   * @extends fabric.Object\r\n   * @see {@link fabric.Circle#initialize} for constructor definition\r\n   */\r\n  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'circle',\r\n\r\n    /**\r\n     * Radius of this circle\r\n     * @type Number\r\n     * @default\r\n     */\r\n    radius: 0,\r\n\r\n    /**\r\n     * Start angle of the circle, moving clockwise\r\n     * @type Number\r\n     * @default 0\r\n     */\r\n    startAngle: 0,\r\n\r\n    /**\r\n     * End angle of the circle\r\n     * @type Number\r\n     * @default 2Pi\r\n     */\r\n    endAngle: pi * 2,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Circle} thisArg\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.callSuper('initialize', options);\r\n      this.set('radius', options.radius || 0);\r\n\r\n      this.startAngle = options.startAngle || this.startAngle;\r\n      this.endAngle = options.endAngle || this.endAngle;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} key\r\n     * @param {Any} value\r\n     * @return {fabric.Circle} thisArg\r\n     */\r\n    _set: function(key, value) {\r\n      this.callSuper('_set', key, value);\r\n\r\n      if (key === 'radius') {\r\n        this.setRadius(value);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return extend(this.callSuper('toObject', propertiesToInclude), {\r\n        radius: this.get('radius'),\r\n        startAngle: this.startAngle,\r\n        endAngle: this.endAngle\r\n      });\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(), x = 0, y = 0,\r\n      angle = (this.endAngle - this.startAngle) % ( 2 * pi);\r\n\r\n      if (angle === 0) {\r\n        if (this.group && this.group.type === 'path-group') {\r\n          x = this.left + this.radius;\r\n          y = this.top + this.radius;\r\n        }\r\n        markup.push(\r\n          '<circle ',\r\n            'cx=\"' + x + '\" cy=\"' + y + '\" ',\r\n            'r=\"', this.radius,\r\n            '\" style=\"', this.getSvgStyles(),\r\n            '\" transform=\"', this.getSvgTransform(),\r\n            ' ', this.getSvgTransformMatrix(),\r\n          '\"/>\\n'\r\n        );\r\n      }\r\n      else {\r\n        var startX = Math.cos(this.startAngle) * this.radius,\r\n            startY = Math.sin(this.startAngle) * this.radius,\r\n            endX = Math.cos(this.endAngle) * this.radius,\r\n            endY = Math.sin(this.endAngle) * this.radius,\r\n            largeFlag = angle > pi ? '1' : '0';\r\n\r\n        markup.push(\r\n          '<path d=\"M ' + startX + ' ' + startY,\r\n          ' A ' + this.radius + ' ' + this.radius,\r\n          ' 0 ', + largeFlag + ' 1', ' ' + endX + ' ' + endY,\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(),\r\n          ' ', this.getSvgTransformMatrix(),\r\n          '\"/>\\n'\r\n        );\r\n      }\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx context to render on\r\n     * @param {Boolean} [noTransform] When true, context is not transformed\r\n     */\r\n    _render: function(ctx, noTransform) {\r\n      ctx.beginPath();\r\n      ctx.arc(noTransform ? this.left + this.radius : 0,\r\n              noTransform ? this.top + this.radius : 0,\r\n              this.radius,\r\n              this.startAngle,\r\n              this.endAngle, false);\r\n      this._renderFill(ctx);\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * Returns horizontal radius of an object (according to how an object is scaled)\r\n     * @return {Number}\r\n     */\r\n    getRadiusX: function() {\r\n      return this.get('radius') * this.get('scaleX');\r\n    },\r\n\r\n    /**\r\n     * Returns vertical radius of an object (according to how an object is scaled)\r\n     * @return {Number}\r\n     */\r\n    getRadiusY: function() {\r\n      return this.get('radius') * this.get('scaleY');\r\n    },\r\n\r\n    /**\r\n     * Sets radius of an object (and updates width accordingly)\r\n     * @return {fabric.Circle} thisArg\r\n     */\r\n    setRadius: function(value) {\r\n      this.radius = value;\r\n      return this.set('width', value * 2).set('height', value * 2);\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})\r\n   * @static\r\n   * @memberOf fabric.Circle\r\n   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement\r\n   */\r\n  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));\r\n\r\n  /**\r\n   * Returns {@link fabric.Circle} instance from an SVG element\r\n   * @static\r\n   * @memberOf fabric.Circle\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @throws {Error} If value of `r` attribute is missing or invalid\r\n   * @return {fabric.Circle} Instance of fabric.Circle\r\n   */\r\n  fabric.Circle.fromElement = function(element, options) {\r\n    options || (options = { });\r\n\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);\r\n\r\n    if (!isValidRadius(parsedAttributes)) {\r\n      throw new Error('value of `r` attribute is required and can not be negative');\r\n    }\r\n\r\n    parsedAttributes.left = parsedAttributes.left || 0;\r\n    parsedAttributes.top = parsedAttributes.top || 0;\r\n\r\n    var obj = new fabric.Circle(extend(parsedAttributes, options));\r\n\r\n    obj.left -= obj.radius;\r\n    obj.top -= obj.radius;\r\n    return obj;\r\n  };\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function isValidRadius(attributes) {\r\n    return (('radius' in attributes) && (attributes.radius >= 0));\r\n  }\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns {@link fabric.Circle} instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Circle\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {Object} Instance of fabric.Circle\r\n   */\r\n  fabric.Circle.fromObject = function(object) {\r\n    return new fabric.Circle(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { });\r\n\r\n  if (fabric.Triangle) {\r\n    fabric.warn('fabric.Triangle is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Triangle class\r\n   * @class fabric.Triangle\r\n   * @extends fabric.Object\r\n   * @return {fabric.Triangle} thisArg\r\n   * @see {@link fabric.Triangle#initialize} for constructor definition\r\n   */\r\n  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'triangle',\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} [options] Options object\r\n     * @return {Object} thisArg\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.callSuper('initialize', options);\r\n\r\n      this.set('width', options.width || 100)\r\n          .set('height', options.height || 100);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx) {\r\n      var widthBy2 = this.width / 2,\r\n          heightBy2 = this.height / 2;\r\n\r\n      ctx.beginPath();\r\n      ctx.moveTo(-widthBy2, heightBy2);\r\n      ctx.lineTo(0, -heightBy2);\r\n      ctx.lineTo(widthBy2, heightBy2);\r\n      ctx.closePath();\r\n\r\n      this._renderFill(ctx);\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderDashedStroke: function(ctx) {\r\n      var widthBy2 = this.width / 2,\r\n          heightBy2 = this.height / 2;\r\n\r\n      ctx.beginPath();\r\n      fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);\r\n      ctx.closePath();\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(),\r\n          widthBy2 = this.width / 2,\r\n          heightBy2 = this.height / 2,\r\n          points = [\r\n            -widthBy2 + ' ' + heightBy2,\r\n            '0 ' + -heightBy2,\r\n            widthBy2 + ' ' + heightBy2\r\n          ]\r\n          .join(',');\r\n\r\n      markup.push(\r\n        '<polygon ',\r\n          'points=\"', points,\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(),\r\n        '\"/>'\r\n      );\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns fabric.Triangle instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Triangle\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {Object} instance of Canvas.Triangle\r\n   */\r\n  fabric.Triangle.fromObject = function(object) {\r\n    return new fabric.Triangle(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      piBy2   = Math.PI * 2,\r\n      extend = fabric.util.object.extend;\r\n\r\n  if (fabric.Ellipse) {\r\n    fabric.warn('fabric.Ellipse is already defined.');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Ellipse class\r\n   * @class fabric.Ellipse\r\n   * @extends fabric.Object\r\n   * @return {fabric.Ellipse} thisArg\r\n   * @see {@link fabric.Ellipse#initialize} for constructor definition\r\n   */\r\n  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'ellipse',\r\n\r\n    /**\r\n     * Horizontal radius\r\n     * @type Number\r\n     * @default\r\n     */\r\n    rx:   0,\r\n\r\n    /**\r\n     * Vertical radius\r\n     * @type Number\r\n     * @default\r\n     */\r\n    ry:   0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Ellipse} thisArg\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.callSuper('initialize', options);\r\n\r\n      this.set('rx', options.rx || 0);\r\n      this.set('ry', options.ry || 0);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} key\r\n     * @param {Any} value\r\n     * @return {fabric.Ellipse} thisArg\r\n     */\r\n    _set: function(key, value) {\r\n      this.callSuper('_set', key, value);\r\n      switch (key) {\r\n\r\n        case 'rx':\r\n          this.rx = value;\r\n          this.set('width', value * 2);\r\n          break;\r\n\r\n        case 'ry':\r\n          this.ry = value;\r\n          this.set('height', value * 2);\r\n          break;\r\n\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns horizontal radius of an object (according to how an object is scaled)\r\n     * @return {Number}\r\n     */\r\n    getRx: function() {\r\n      return this.get('rx') * this.get('scaleX');\r\n    },\r\n\r\n    /**\r\n     * Returns Vertical radius of an object (according to how an object is scaled)\r\n     * @return {Number}\r\n     */\r\n    getRy: function() {\r\n      return this.get('ry') * this.get('scaleY');\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return extend(this.callSuper('toObject', propertiesToInclude), {\r\n        rx: this.get('rx'),\r\n        ry: this.get('ry')\r\n      });\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(), x = 0, y = 0;\r\n      if (this.group && this.group.type === 'path-group') {\r\n        x = this.left + this.rx;\r\n        y = this.top + this.ry;\r\n      }\r\n      markup.push(\r\n        '<ellipse ',\r\n          'cx=\"', x, '\" cy=\"', y, '\" ',\r\n          'rx=\"', this.rx,\r\n          '\" ry=\"', this.ry,\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(),\r\n          this.getSvgTransformMatrix(),\r\n        '\"/>\\n'\r\n      );\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx context to render on\r\n     * @param {Boolean} [noTransform] When true, context is not transformed\r\n     */\r\n    _render: function(ctx, noTransform) {\r\n      ctx.beginPath();\r\n      ctx.save();\r\n      ctx.transform(1, 0, 0, this.ry/this.rx, 0, 0);\r\n      ctx.arc(\r\n        noTransform ? this.left + this.rx : 0,\r\n        noTransform ? (this.top + this.ry) * this.rx/this.ry : 0,\r\n        this.rx,\r\n        0,\r\n        piBy2,\r\n        false);\r\n      ctx.restore();\r\n      this._renderFill(ctx);\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})\r\n   * @static\r\n   * @memberOf fabric.Ellipse\r\n   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement\r\n   */\r\n  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));\r\n\r\n  /**\r\n   * Returns {@link fabric.Ellipse} instance from an SVG element\r\n   * @static\r\n   * @memberOf fabric.Ellipse\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Ellipse}\r\n   */\r\n  fabric.Ellipse.fromElement = function(element, options) {\r\n    options || (options = { });\r\n\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);\r\n\r\n    parsedAttributes.left = parsedAttributes.left || 0;\r\n    parsedAttributes.top = parsedAttributes.top || 0;\r\n\r\n    var ellipse = new fabric.Ellipse(extend(parsedAttributes, options));\r\n\r\n    ellipse.top -= ellipse.ry;\r\n    ellipse.left -= ellipse.rx;\r\n    return ellipse;\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns {@link fabric.Ellipse} instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Ellipse\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Ellipse}\r\n   */\r\n  fabric.Ellipse.fromObject = function(object) {\r\n    return new fabric.Ellipse(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  if (fabric.Rect) {\r\n    fabric.warn('fabric.Rect is already defined');\r\n    return;\r\n  }\r\n\r\n  var stateProperties = fabric.Object.prototype.stateProperties.concat();\r\n  stateProperties.push('rx', 'ry', 'x', 'y');\r\n\r\n  /**\r\n   * Rectangle class\r\n   * @class fabric.Rect\r\n   * @extends fabric.Object\r\n   * @return {fabric.Rect} thisArg\r\n   * @see {@link fabric.Rect#initialize} for constructor definition\r\n   */\r\n  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {\r\n\r\n    /**\r\n     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})\r\n     * as well as for history (undo/redo) purposes\r\n     * @type Array\r\n     */\r\n    stateProperties: stateProperties,\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'rect',\r\n\r\n    /**\r\n     * Horizontal border radius\r\n     * @type Number\r\n     * @default\r\n     */\r\n    rx:   0,\r\n\r\n    /**\r\n     * Vertical border radius\r\n     * @type Number\r\n     * @default\r\n     */\r\n    ry:   0,\r\n\r\n    /**\r\n     * Used to specify dash pattern for stroke on this object\r\n     * @type Array\r\n     */\r\n    strokeDashArray: null,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} [options] Options object\r\n     * @return {Object} thisArg\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.callSuper('initialize', options);\r\n      this._initRxRy();\r\n\r\n    },\r\n\r\n    /**\r\n     * Initializes rx/ry attributes\r\n     * @private\r\n     */\r\n    _initRxRy: function() {\r\n      if (this.rx && !this.ry) {\r\n        this.ry = this.rx;\r\n      }\r\n      else if (this.ry && !this.rx) {\r\n        this.rx = this.ry;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx, noTransform) {\r\n\r\n      // optimize 1x1 case (used in spray brush)\r\n      if (this.width === 1 && this.height === 1) {\r\n        ctx.fillRect(0, 0, 1, 1);\r\n        return;\r\n      }\r\n\r\n      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,\r\n          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,\r\n          w = this.width,\r\n          h = this.height,\r\n          x = noTransform ? this.left : -this.width / 2,\r\n          y = noTransform ? this.top : -this.height / 2,\r\n          isRounded = rx !== 0 || ry !== 0,\r\n          k = 1 - 0.5522847498 /* \"magic number\" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */;\r\n\r\n      ctx.beginPath();\r\n\r\n      ctx.moveTo(x + rx, y);\r\n\r\n      ctx.lineTo(x + w - rx, y);\r\n      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);\r\n\r\n      ctx.lineTo(x + w, y + h - ry);\r\n      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);\r\n\r\n      ctx.lineTo(x + rx, y + h);\r\n      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);\r\n\r\n      ctx.lineTo(x, y + ry);\r\n      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);\r\n\r\n      ctx.closePath();\r\n\r\n      this._renderFill(ctx);\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderDashedStroke: function(ctx) {\r\n      var x = -this.width / 2,\r\n          y = -this.height / 2,\r\n          w = this.width,\r\n          h = this.height;\r\n\r\n      ctx.beginPath();\r\n      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);\r\n      ctx.closePath();\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var object = extend(this.callSuper('toObject', propertiesToInclude), {\r\n        rx: this.get('rx') || 0,\r\n        ry: this.get('ry') || 0\r\n      });\r\n      if (!this.includeDefaultValues) {\r\n        this._removeDefaultValues(object);\r\n      }\r\n      return object;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(), x = this.left, y = this.top;\r\n      if (!(this.group && this.group.type === 'path-group')) {\r\n        x = -this.width / 2;\r\n        y = -this.height / 2;\r\n      }\r\n      markup.push(\r\n        '<rect ',\r\n          'x=\"', x, '\" y=\"', y,\r\n          '\" rx=\"', this.get('rx'), '\" ry=\"', this.get('ry'),\r\n          '\" width=\"', this.width, '\" height=\"', this.height,\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(),\r\n          this.getSvgTransformMatrix(),\r\n        '\"/>\\n');\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)\r\n   * @static\r\n   * @memberOf fabric.Rect\r\n   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement\r\n   */\r\n  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));\r\n\r\n  /**\r\n   * Returns {@link fabric.Rect} instance from an SVG element\r\n   * @static\r\n   * @memberOf fabric.Rect\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Rect} Instance of fabric.Rect\r\n   */\r\n  fabric.Rect.fromElement = function(element, options) {\r\n    if (!element) {\r\n      return null;\r\n    }\r\n    options = options || { };\r\n\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);\r\n\r\n    parsedAttributes.left = parsedAttributes.left || 0;\r\n    parsedAttributes.top  = parsedAttributes.top  || 0;\r\n    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));\r\n    rect.visible = rect.width > 0 && rect.height > 0;\r\n    return rect;\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns {@link fabric.Rect} instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Rect\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {Object} instance of fabric.Rect\r\n   */\r\n  fabric.Rect.fromObject = function(object) {\r\n    return new fabric.Rect(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { });\r\n\r\n  if (fabric.Polyline) {\r\n    fabric.warn('fabric.Polyline is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Polyline class\r\n   * @class fabric.Polyline\r\n   * @extends fabric.Object\r\n   * @see {@link fabric.Polyline#initialize} for constructor definition\r\n   */\r\n  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'polyline',\r\n\r\n    /**\r\n     * Points array\r\n     * @type Array\r\n     * @default\r\n     */\r\n    points: null,\r\n\r\n    /**\r\n     * Minimum X from points values, necessary to offset points\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minX: 0,\r\n\r\n    /**\r\n     * Minimum Y from points values, necessary to offset points\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minY: 0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Array} points Array of points (where each point is an object with x and y)\r\n     * @param {Object} [options] Options object\r\n     * @param {Boolean} [skipOffset] Whether points offsetting should be skipped\r\n     * @return {fabric.Polyline} thisArg\r\n     * @example\r\n     * var poly = new fabric.Polyline([\r\n     *     { x: 10, y: 10 },\r\n     *     { x: 50, y: 30 },\r\n     *     { x: 40, y: 70 },\r\n     *     { x: 60, y: 50 },\r\n     *     { x: 100, y: 150 },\r\n     *     { x: 40, y: 100 }\r\n     *   ], {\r\n     *   stroke: 'red',\r\n     *   left: 100,\r\n     *   top: 100\r\n     * });\r\n     */\r\n    initialize: function(points, options) {\r\n      return fabric.Polygon.prototype.initialize.call(this, points, options);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _calcDimensions: function() {\r\n      return fabric.Polygon.prototype._calcDimensions.call(this);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _applyPointOffset: function() {\r\n      return fabric.Polygon.prototype._applyPointOffset.call(this);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return fabric.Polygon.prototype.toObject.call(this, propertiesToInclude);\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      return fabric.Polygon.prototype.toSVG.call(this, reviver);\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx) {\r\n      if (!fabric.Polygon.prototype.commonRender.call(this, ctx)) {\r\n        return;\r\n      }\r\n      this._renderFill(ctx);\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderDashedStroke: function(ctx) {\r\n      var p1, p2;\r\n\r\n      ctx.beginPath();\r\n      for (var i = 0, len = this.points.length; i < len; i++) {\r\n        p1 = this.points[i];\r\n        p2 = this.points[i + 1] || p1;\r\n        fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return this.get('points').length;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})\r\n   * @static\r\n   * @memberOf fabric.Polyline\r\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement\r\n   */\r\n  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\r\n\r\n  /**\r\n   * Returns fabric.Polyline instance from an SVG element\r\n   * @static\r\n   * @memberOf fabric.Polyline\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Polyline} Instance of fabric.Polyline\r\n   */\r\n  fabric.Polyline.fromElement = function(element, options) {\r\n    if (!element) {\r\n      return null;\r\n    }\r\n    options || (options = { });\r\n\r\n    var points = fabric.parsePointsAttribute(element.getAttribute('points')),\r\n        parsedAttributes = fabric.parseAttributes(element, fabric.Polyline.ATTRIBUTE_NAMES);\r\n\r\n    return new fabric.Polyline(points, fabric.util.object.extend(parsedAttributes, options));\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns fabric.Polyline instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Polyline\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Polyline} Instance of fabric.Polyline\r\n   */\r\n  fabric.Polyline.fromObject = function(object) {\r\n    var points = object.points;\r\n    return new fabric.Polyline(points, object, true);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      min = fabric.util.array.min,\r\n      max = fabric.util.array.max,\r\n      toFixed = fabric.util.toFixed;\r\n\r\n  if (fabric.Polygon) {\r\n    fabric.warn('fabric.Polygon is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Polygon class\r\n   * @class fabric.Polygon\r\n   * @extends fabric.Object\r\n   * @see {@link fabric.Polygon#initialize} for constructor definition\r\n   */\r\n  fabric.Polygon = fabric.util.createClass(fabric.Object, /** @lends fabric.Polygon.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'polygon',\r\n\r\n    /**\r\n     * Points array\r\n     * @type Array\r\n     * @default\r\n     */\r\n    points: null,\r\n\r\n    /**\r\n     * Minimum X from points values, necessary to offset points\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minX: 0,\r\n\r\n    /**\r\n     * Minimum Y from points values, necessary to offset points\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minY: 0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Array} points Array of points\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Polygon} thisArg\r\n     */\r\n    initialize: function(points, options) {\r\n      options = options || { };\r\n      this.points = points || [ ];\r\n      this.callSuper('initialize', options);\r\n      this._calcDimensions();\r\n      if (!('top' in options)) {\r\n        this.top = this.minY;\r\n      }\r\n      if (!('left' in options)) {\r\n        this.left = this.minX;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _calcDimensions: function() {\r\n\r\n      var points = this.points,\r\n          minX = min(points, 'x'),\r\n          minY = min(points, 'y'),\r\n          maxX = max(points, 'x'),\r\n          maxY = max(points, 'y');\r\n\r\n      this.width = (maxX - minX) || 0;\r\n      this.height = (maxY - minY) || 0;\r\n\r\n      this.minX = minX || 0,\r\n      this.minY = minY || 0;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _applyPointOffset: function() {\r\n      // change points to offset polygon into a bounding box\r\n      // executed one time\r\n      this.points.forEach(function(p) {\r\n        p.x -= (this.minX + this.width / 2);\r\n        p.y -= (this.minY + this.height / 2);\r\n      }, this);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return extend(this.callSuper('toObject', propertiesToInclude), {\r\n        points: this.points.concat()\r\n      });\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var points = [],\r\n          markup = this._createBaseSVGMarkup();\r\n\r\n      for (var i = 0, len = this.points.length; i < len; i++) {\r\n        points.push(toFixed(this.points[i].x, 2), ',', toFixed(this.points[i].y, 2), ' ');\r\n      }\r\n\r\n      markup.push(\r\n        '<', this.type, ' ',\r\n          'points=\"', points.join(''),\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(),\r\n          ' ', this.getSvgTransformMatrix(),\r\n        '\"/>\\n'\r\n      );\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx) {\r\n      if (!this.commonRender(ctx)) {\r\n        return;\r\n      }\r\n      this._renderFill(ctx);\r\n      if (this.stroke || this.strokeDashArray) {\r\n        ctx.closePath();\r\n        this._renderStroke(ctx);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    commonRender: function(ctx) {\r\n      var point, len = this.points.length;\r\n\r\n      if (!len || isNaN(this.points[len - 1].y)) {\r\n        // do not draw if no points or odd points\r\n        // NaN comes from parseFloat of a empty string in parser\r\n        return false;\r\n      }\r\n\r\n      ctx.beginPath();\r\n\r\n      if (this._applyPointOffset) {\r\n        if (!(this.group && this.group.type === 'path-group')) {\r\n          this._applyPointOffset();\r\n        }\r\n        this._applyPointOffset = null;\r\n      }\r\n\r\n      ctx.moveTo(this.points[0].x, this.points[0].y);\r\n      for (var i = 0; i < len; i++) {\r\n        point = this.points[i];\r\n        ctx.lineTo(point.x, point.y);\r\n      }\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderDashedStroke: function(ctx) {\r\n      fabric.Polyline.prototype._renderDashedStroke.call(this, ctx);\r\n      ctx.closePath();\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return this.points.length;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)\r\n   * @static\r\n   * @memberOf fabric.Polygon\r\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement\r\n   */\r\n  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\r\n\r\n  /**\r\n   * Returns {@link fabric.Polygon} instance from an SVG element\r\n   * @static\r\n   * @memberOf fabric.Polygon\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Polygon} Instance of fabric.Polygon\r\n   */\r\n  fabric.Polygon.fromElement = function(element, options) {\r\n    if (!element) {\r\n      return null;\r\n    }\r\n\r\n    options || (options = { });\r\n\r\n    var points = fabric.parsePointsAttribute(element.getAttribute('points')),\r\n        parsedAttributes = fabric.parseAttributes(element, fabric.Polygon.ATTRIBUTE_NAMES);\r\n\r\n    return new fabric.Polygon(points, extend(parsedAttributes, options));\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns fabric.Polygon instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Polygon\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Polygon} Instance of fabric.Polygon\r\n   */\r\n  fabric.Polygon.fromObject = function(object) {\r\n    return new fabric.Polygon(object.points, object, true);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      min = fabric.util.array.min,\r\n      max = fabric.util.array.max,\r\n      extend = fabric.util.object.extend,\r\n      _toString = Object.prototype.toString,\r\n      drawArc = fabric.util.drawArc,\r\n      commandLengths = {\r\n        m: 2,\r\n        l: 2,\r\n        h: 1,\r\n        v: 1,\r\n        c: 6,\r\n        s: 4,\r\n        q: 4,\r\n        t: 2,\r\n        a: 7\r\n      },\r\n      repeatedCommands = {\r\n        m: 'l',\r\n        M: 'L'\r\n      };\r\n\r\n  if (fabric.Path) {\r\n    fabric.warn('fabric.Path is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Path class\r\n   * @class fabric.Path\r\n   * @extends fabric.Object\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#path_and_pathgroup}\r\n   * @see {@link fabric.Path#initialize} for constructor definition\r\n   */\r\n  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'path',\r\n\r\n    /**\r\n     * Array of path points\r\n     * @type Array\r\n     * @default\r\n     */\r\n    path: null,\r\n\r\n    /**\r\n     * Minimum X from points values, necessary to offset points\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minX: 0,\r\n\r\n    /**\r\n     * Minimum Y from points values, necessary to offset points\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minY: 0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Path} thisArg\r\n     */\r\n    initialize: function(path, options) {\r\n      options = options || { };\r\n\r\n      this.setOptions(options);\r\n\r\n      if (!path) {\r\n        path = [ ];\r\n      }\r\n\r\n      var fromArray = _toString.call(path) === '[object Array]';\r\n\r\n      this.path = fromArray\r\n        ? path\r\n        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)\r\n        : path.match && path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);\r\n\r\n      if (!this.path) {\r\n        return;\r\n      }\r\n\r\n      if (!fromArray) {\r\n        this.path = this._parsePath();\r\n      }\r\n\r\n      this._setPositionDimensions(options);\r\n\r\n      if (options.sourcePath) {\r\n        this.setSourcePath(options.sourcePath);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} options Options object\r\n     */\r\n    _setPositionDimensions: function(options) {\r\n      var calcDim = this._parseDimensions();\r\n\r\n      this.minX = calcDim.left;\r\n      this.minY = calcDim.top;\r\n      this.width = calcDim.width;\r\n      this.height = calcDim.height;\r\n\r\n      if (typeof options.left === 'undefined') {\r\n        this.left = calcDim.left + (this.originX === 'center'\r\n          ? this.width / 2\r\n          : this.originX === 'right'\r\n            ? this.width\r\n            : 0);\r\n      }\r\n\r\n      if (typeof options.top === 'undefined') {\r\n        this.top = calcDim.top + (this.originY === 'center'\r\n          ? this.height / 2\r\n          : this.originY === 'bottom'\r\n            ? this.height\r\n            : 0);\r\n      }\r\n\r\n      this.pathOffset = this.pathOffset || {\r\n        x: this.minX + this.width / 2,\r\n        y: this.minY + this.height / 2\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx context to render path on\r\n     */\r\n    _render: function(ctx) {\r\n      var current, // current instruction\r\n          previous = null,\r\n          subpathStartX = 0,\r\n          subpathStartY = 0,\r\n          x = 0, // current x\r\n          y = 0, // current y\r\n          controlX = 0, // current control point x\r\n          controlY = 0, // current control point y\r\n          tempX,\r\n          tempY,\r\n          l = -this.pathOffset.x,\r\n          t = -this.pathOffset.y;\r\n\r\n      if (this.group && this.group.type === 'path-group') {\r\n        l = 0;\r\n        t = 0;\r\n      }\r\n\r\n      ctx.beginPath();\r\n\r\n      for (var i = 0, len = this.path.length; i < len; ++i) {\r\n\r\n        current = this.path[i];\r\n\r\n        switch (current[0]) { // first letter\r\n\r\n          case 'l': // lineto, relative\r\n            x += current[1];\r\n            y += current[2];\r\n            ctx.lineTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'L': // lineto, absolute\r\n            x = current[1];\r\n            y = current[2];\r\n            ctx.lineTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'h': // horizontal lineto, relative\r\n            x += current[1];\r\n            ctx.lineTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'H': // horizontal lineto, absolute\r\n            x = current[1];\r\n            ctx.lineTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'v': // vertical lineto, relative\r\n            y += current[1];\r\n            ctx.lineTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'V': // verical lineto, absolute\r\n            y = current[1];\r\n            ctx.lineTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'm': // moveTo, relative\r\n            x += current[1];\r\n            y += current[2];\r\n            subpathStartX = x;\r\n            subpathStartY = y;\r\n            ctx.moveTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'M': // moveTo, absolute\r\n            x = current[1];\r\n            y = current[2];\r\n            subpathStartX = x;\r\n            subpathStartY = y;\r\n            ctx.moveTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'c': // bezierCurveTo, relative\r\n            tempX = x + current[5];\r\n            tempY = y + current[6];\r\n            controlX = x + current[3];\r\n            controlY = y + current[4];\r\n            ctx.bezierCurveTo(\r\n              x + current[1] + l, // x1\r\n              y + current[2] + t, // y1\r\n              controlX + l, // x2\r\n              controlY + t, // y2\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'C': // bezierCurveTo, absolute\r\n            x = current[5];\r\n            y = current[6];\r\n            controlX = current[3];\r\n            controlY = current[4];\r\n            ctx.bezierCurveTo(\r\n              current[1] + l,\r\n              current[2] + t,\r\n              controlX + l,\r\n              controlY + t,\r\n              x + l,\r\n              y + t\r\n            );\r\n            break;\r\n\r\n          case 's': // shorthand cubic bezierCurveTo, relative\r\n\r\n            // transform to absolute x,y\r\n            tempX = x + current[3];\r\n            tempY = y + current[4];\r\n\r\n            if (previous[0].match(/[CcSs]/) === null) {\r\n              // If there is no previous command or if the previous command was not a C, c, S, or s,\r\n              // the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control points\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n\r\n            ctx.bezierCurveTo(\r\n              controlX + l,\r\n              controlY + t,\r\n              x + current[1] + l,\r\n              y + current[2] + t,\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            // set control point to 2nd one of this command\r\n            // \"... the first control point is assumed to be\r\n            // the reflection of the second control point on\r\n            // the previous command relative to the current point.\"\r\n            controlX = x + current[1];\r\n            controlY = y + current[2];\r\n\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'S': // shorthand cubic bezierCurveTo, absolute\r\n            tempX = current[3];\r\n            tempY = current[4];\r\n            if (previous[0].match(/[CcSs]/) === null) {\r\n              // If there is no previous command or if the previous command was not a C, c, S, or s,\r\n              // the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control points\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n            ctx.bezierCurveTo(\r\n              controlX + l,\r\n              controlY + t,\r\n              current[1] + l,\r\n              current[2] + t,\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n\r\n            // set control point to 2nd one of this command\r\n            // \"... the first control point is assumed to be\r\n            // the reflection of the second control point on\r\n            // the previous command relative to the current point.\"\r\n            controlX = current[1];\r\n            controlY = current[2];\r\n\r\n            break;\r\n\r\n          case 'q': // quadraticCurveTo, relative\r\n            // transform to absolute x,y\r\n            tempX = x + current[3];\r\n            tempY = y + current[4];\r\n\r\n            controlX = x + current[1];\r\n            controlY = y + current[2];\r\n\r\n            ctx.quadraticCurveTo(\r\n              controlX + l,\r\n              controlY + t,\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'Q': // quadraticCurveTo, absolute\r\n            tempX = current[3];\r\n            tempY = current[4];\r\n\r\n            ctx.quadraticCurveTo(\r\n              current[1] + l,\r\n              current[2] + t,\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            controlX = current[1];\r\n            controlY = current[2];\r\n            break;\r\n\r\n          case 't': // shorthand quadraticCurveTo, relative\r\n\r\n            // transform to absolute x,y\r\n            tempX = x + current[1];\r\n            tempY = y + current[2];\r\n\r\n            if (previous[0].match(/[QqTt]/) === null) {\r\n              // If there is no previous command or if the previous command was not a Q, q, T or t,\r\n              // assume the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control point\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n\r\n            ctx.quadraticCurveTo(\r\n              controlX + l,\r\n              controlY + t,\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n\r\n            break;\r\n\r\n          case 'T':\r\n            tempX = current[1];\r\n            tempY = current[2];\r\n\r\n            if (previous[0].match(/[QqTt]/) === null) {\r\n              // If there is no previous command or if the previous command was not a Q, q, T or t,\r\n              // assume the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control point\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n            ctx.quadraticCurveTo(\r\n              controlX + l,\r\n              controlY + t,\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'a':\r\n            // TODO: optimize this\r\n            drawArc(ctx, x + l, y + t, [\r\n              current[1],\r\n              current[2],\r\n              current[3],\r\n              current[4],\r\n              current[5],\r\n              current[6] + x + l,\r\n              current[7] + y + t\r\n            ]);\r\n            x += current[6];\r\n            y += current[7];\r\n            break;\r\n\r\n          case 'A':\r\n            // TODO: optimize this\r\n            drawArc(ctx, x + l, y + t, [\r\n              current[1],\r\n              current[2],\r\n              current[3],\r\n              current[4],\r\n              current[5],\r\n              current[6] + l,\r\n              current[7] + t\r\n            ]);\r\n            x = current[6];\r\n            y = current[7];\r\n            break;\r\n\r\n          case 'z':\r\n          case 'Z':\r\n            x = subpathStartX;\r\n            y = subpathStartY;\r\n            ctx.closePath();\r\n            break;\r\n        }\r\n        previous = current;\r\n      }\r\n      this._renderFill(ctx);\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * Returns string representation of an instance\r\n     * @return {String} string representation of an instance\r\n     */\r\n    toString: function() {\r\n      return '#<fabric.Path (' + this.complexity() +\r\n        '): { \"top\": ' + this.top + ', \"left\": ' + this.left + ' }>';\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var o = extend(this.callSuper('toObject', propertiesToInclude), {\r\n        path: this.path.map(function(item) { return item.slice() }),\r\n        pathOffset: this.pathOffset\r\n      });\r\n      if (this.sourcePath) {\r\n        o.sourcePath = this.sourcePath;\r\n      }\r\n      if (this.transformMatrix) {\r\n        o.transformMatrix = this.transformMatrix;\r\n      }\r\n      return o;\r\n    },\r\n\r\n    /**\r\n     * Returns dataless object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toDatalessObject: function(propertiesToInclude) {\r\n      var o = this.toObject(propertiesToInclude);\r\n      if (this.sourcePath) {\r\n        o.path = this.sourcePath;\r\n      }\r\n      delete o.sourcePath;\r\n      return o;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var chunks = [],\r\n          markup = this._createBaseSVGMarkup(), addTransform = '';\r\n\r\n      for (var i = 0, len = this.path.length; i < len; i++) {\r\n        chunks.push(this.path[i].join(' '));\r\n      }\r\n      var path = chunks.join(' ');\r\n      if (!(this.group && this.group.type === 'path-group')) {\r\n        addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';\r\n      }\r\n      markup.push(\r\n        //jscs:disable validateIndentation\r\n        '<path ',\r\n          'd=\"', path,\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(), addTransform,\r\n          this.getSvgTransformMatrix(), '\" stroke-linecap=\"round\" ',\r\n        '/>\\n'\r\n        //jscs:enable validateIndentation\r\n      );\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns number representation of an instance complexity\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return this.path.length;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _parsePath: function() {\r\n      var result = [ ],\r\n          coords = [ ],\r\n          currentPath,\r\n          parsed,\r\n          re = /([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:e[-+]?\\d+)?)/ig,\r\n          match,\r\n          coordsStr;\r\n\r\n      for (var i = 0, coordsParsed, len = this.path.length; i < len; i++) {\r\n        currentPath = this.path[i];\r\n\r\n        coordsStr = currentPath.slice(1).trim();\r\n        coords.length = 0;\r\n\r\n        while ((match = re.exec(coordsStr))) {\r\n          coords.push(match[0]);\r\n        }\r\n\r\n        coordsParsed = [ currentPath.charAt(0) ];\r\n\r\n        for (var j = 0, jlen = coords.length; j < jlen; j++) {\r\n          parsed = parseFloat(coords[j]);\r\n          if (!isNaN(parsed)) {\r\n            coordsParsed.push(parsed);\r\n          }\r\n        }\r\n\r\n        var command = coordsParsed[0],\r\n            commandLength = commandLengths[command.toLowerCase()],\r\n            repeatedCommand = repeatedCommands[command] || command;\r\n\r\n        if (coordsParsed.length - 1 > commandLength) {\r\n          for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {\r\n            result.push([ command ].concat(coordsParsed.slice(k, k + commandLength)));\r\n            command = repeatedCommand;\r\n          }\r\n        }\r\n        else {\r\n          result.push(coordsParsed);\r\n        }\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _parseDimensions: function() {\r\n\r\n      var aX = [],\r\n          aY = [],\r\n          current, // current instruction\r\n          previous = null,\r\n          subpathStartX = 0,\r\n          subpathStartY = 0,\r\n          x = 0, // current x\r\n          y = 0, // current y\r\n          controlX = 0, // current control point x\r\n          controlY = 0, // current control point y\r\n          tempX,\r\n          tempY,\r\n          bounds;\r\n\r\n      for (var i = 0, len = this.path.length; i < len; ++i) {\r\n\r\n        current = this.path[i];\r\n\r\n        switch (current[0]) { // first letter\r\n\r\n          case 'l': // lineto, relative\r\n            x += current[1];\r\n            y += current[2];\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'L': // lineto, absolute\r\n            x = current[1];\r\n            y = current[2];\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'h': // horizontal lineto, relative\r\n            x += current[1];\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'H': // horizontal lineto, absolute\r\n            x = current[1];\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'v': // vertical lineto, relative\r\n            y += current[1];\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'V': // verical lineto, absolute\r\n            y = current[1];\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'm': // moveTo, relative\r\n            x += current[1];\r\n            y += current[2];\r\n            subpathStartX = x;\r\n            subpathStartY = y;\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'M': // moveTo, absolute\r\n            x = current[1];\r\n            y = current[2];\r\n            subpathStartX = x;\r\n            subpathStartY = y;\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'c': // bezierCurveTo, relative\r\n            tempX = x + current[5];\r\n            tempY = y + current[6];\r\n            controlX = x + current[3];\r\n            controlY = y + current[4];\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              x + current[1], // x1\r\n              y + current[2], // y1\r\n              controlX, // x2\r\n              controlY, // y2\r\n              tempX,\r\n              tempY\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'C': // bezierCurveTo, absolute\r\n            x = current[5];\r\n            y = current[6];\r\n            controlX = current[3];\r\n            controlY = current[4];\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              current[1],\r\n              current[2],\r\n              controlX,\r\n              controlY,\r\n              x,\r\n              y\r\n            );\r\n            break;\r\n\r\n          case 's': // shorthand cubic bezierCurveTo, relative\r\n\r\n            // transform to absolute x,y\r\n            tempX = x + current[3];\r\n            tempY = y + current[4];\r\n\r\n            if (previous[0].match(/[CcSs]/) === null) {\r\n              // If there is no previous command or if the previous command was not a C, c, S, or s,\r\n              // the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control points\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              controlX,\r\n              controlY,\r\n              x + current[1],\r\n              y + current[2],\r\n              tempX,\r\n              tempY\r\n            );\r\n            // set control point to 2nd one of this command\r\n            // \"... the first control point is assumed to be\r\n            // the reflection of the second control point on\r\n            // the previous command relative to the current point.\"\r\n            controlX = x + current[1];\r\n            controlY = y + current[2];\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'S': // shorthand cubic bezierCurveTo, absolute\r\n            tempX = current[3];\r\n            tempY = current[4];\r\n            if (previous[0].match(/[CcSs]/) === null) {\r\n              // If there is no previous command or if the previous command was not a C, c, S, or s,\r\n              // the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control points\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              controlX,\r\n              controlY,\r\n              current[1],\r\n              current[2],\r\n              tempX,\r\n              tempY\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            // set control point to 2nd one of this command\r\n            // \"... the first control point is assumed to be\r\n            // the reflection of the second control point on\r\n            // the previous command relative to the current point.\"\r\n            controlX = current[1];\r\n            controlY = current[2];\r\n            break;\r\n\r\n          case 'q': // quadraticCurveTo, relative\r\n            // transform to absolute x,y\r\n            tempX = x + current[3];\r\n            tempY = y + current[4];\r\n            controlX = x + current[1];\r\n            controlY = y + current[2];\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              controlX,\r\n              controlY,\r\n              controlX,\r\n              controlY,\r\n              tempX,\r\n              tempY\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'Q': // quadraticCurveTo, absolute\r\n            controlX = current[1];\r\n            controlY = current[2];\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              controlX,\r\n              controlY,\r\n              controlX,\r\n              controlY,\r\n              current[3],\r\n              current[4]\r\n            );\r\n            x = current[3];\r\n            y = current[4];\r\n            break;\r\n\r\n          case 't': // shorthand quadraticCurveTo, relative\r\n            // transform to absolute x,y\r\n            tempX = x + current[1];\r\n            tempY = y + current[2];\r\n            if (previous[0].match(/[QqTt]/) === null) {\r\n              // If there is no previous command or if the previous command was not a Q, q, T or t,\r\n              // assume the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control point\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              controlX,\r\n              controlY,\r\n              controlX,\r\n              controlY,\r\n              tempX,\r\n              tempY\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n\r\n            break;\r\n\r\n          case 'T':\r\n            tempX = current[1];\r\n            tempY = current[2];\r\n\r\n            if (previous[0].match(/[QqTt]/) === null) {\r\n              // If there is no previous command or if the previous command was not a Q, q, T or t,\r\n              // assume the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control point\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              controlX,\r\n              controlY,\r\n              controlX,\r\n              controlY,\r\n              tempX,\r\n              tempY\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'a':\r\n            // TODO: optimize this\r\n            bounds = fabric.util.getBoundsOfArc(x, y,\r\n              current[1],\r\n              current[2],\r\n              current[3],\r\n              current[4],\r\n              current[5],\r\n              current[6] + x,\r\n              current[7] + y\r\n            );\r\n            x += current[6];\r\n            y += current[7];\r\n            break;\r\n\r\n          case 'A':\r\n            // TODO: optimize this\r\n            bounds = fabric.util.getBoundsOfArc(x, y,\r\n              current[1],\r\n              current[2],\r\n              current[3],\r\n              current[4],\r\n              current[5],\r\n              current[6],\r\n              current[7]\r\n            );\r\n            x = current[6];\r\n            y = current[7];\r\n            break;\r\n\r\n          case 'z':\r\n          case 'Z':\r\n            x = subpathStartX;\r\n            y = subpathStartY;\r\n            break;\r\n        }\r\n        previous = current;\r\n        bounds.forEach(function (point) {\r\n          aX.push(point.x);\r\n          aY.push(point.y);\r\n        });\r\n        aX.push(x);\r\n        aY.push(y);\r\n      }\r\n\r\n      var minX = min(aX) || 0,\r\n          minY = min(aY) || 0,\r\n          maxX = max(aX) || 0,\r\n          maxY = max(aY) || 0,\r\n          deltaX = maxX - minX,\r\n          deltaY = maxY - minY,\r\n\r\n          o = {\r\n            left: minX,\r\n            top: minY,\r\n            width: deltaX,\r\n            height: deltaY\r\n          };\r\n\r\n      return o;\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Creates an instance of fabric.Path from an object\r\n   * @static\r\n   * @memberOf fabric.Path\r\n   * @param {Object} object\r\n   * @param {Function} callback Callback to invoke when an fabric.Path instance is created\r\n   */\r\n  fabric.Path.fromObject = function(object, callback) {\r\n    if (typeof object.path === 'string') {\r\n      fabric.loadSVGFromURL(object.path, function (elements) {\r\n        var path = elements[0],\r\n            pathUrl = object.path;\r\n\r\n        delete object.path;\r\n\r\n        fabric.util.object.extend(path, object);\r\n        path.setSourcePath(pathUrl);\r\n\r\n        callback(path);\r\n      });\r\n    }\r\n    else {\r\n      callback(new fabric.Path(object.path, object));\r\n    }\r\n  };\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)\r\n   * @static\r\n   * @memberOf fabric.Path\r\n   * @see http://www.w3.org/TR/SVG/paths.html#PathElement\r\n   */\r\n  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);\r\n\r\n  /**\r\n   * Creates an instance of fabric.Path from an SVG <path> element\r\n   * @static\r\n   * @memberOf fabric.Path\r\n   * @param {SVGElement} element to parse\r\n   * @param {Function} callback Callback to invoke when an fabric.Path instance is created\r\n   * @param {Object} [options] Options object\r\n   */\r\n  fabric.Path.fromElement = function(element, callback, options) {\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);\r\n    callback && callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Indicates that instances of this type are async\r\n   * @static\r\n   * @memberOf fabric.Path\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  fabric.Path.async = true;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      invoke = fabric.util.array.invoke,\r\n      parentToObject = fabric.Object.prototype.toObject;\r\n\r\n  if (fabric.PathGroup) {\r\n    fabric.warn('fabric.PathGroup is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Path group class\r\n   * @class fabric.PathGroup\r\n   * @extends fabric.Path\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#path_and_pathgroup}\r\n   * @see {@link fabric.PathGroup#initialize} for constructor definition\r\n   */\r\n  fabric.PathGroup = fabric.util.createClass(fabric.Path, /** @lends fabric.PathGroup.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'path-group',\r\n\r\n    /**\r\n     * Fill value\r\n     * @type String\r\n     * @default\r\n     */\r\n    fill: '',\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Array} paths\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.PathGroup} thisArg\r\n     */\r\n    initialize: function(paths, options) {\r\n\r\n      options = options || { };\r\n      this.paths = paths || [ ];\r\n\r\n      for (var i = this.paths.length; i--;) {\r\n        this.paths[i].group = this;\r\n      }\r\n\r\n      if (options.toBeParsed) {\r\n        this.parseDimensionsFromPaths(options);\r\n        delete options.toBeParsed;\r\n      }\r\n      this.setOptions(options);\r\n      this.setCoords();\r\n\r\n      if (options.sourcePath) {\r\n        this.setSourcePath(options.sourcePath);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Calculate width and height based on paths contained\r\n     */\r\n    parseDimensionsFromPaths: function(options) {\r\n      var points, p, xC = [ ], yC = [ ], path, height, width,\r\n          m;\r\n      for (var j = this.paths.length; j--;) {\r\n        path = this.paths[j];\r\n        height = path.height + path.strokeWidth;\r\n        width = path.width + path.strokeWidth;\r\n        points = [\r\n          { x: path.left, y: path.top },\r\n          { x: path.left + width, y: path.top },\r\n          { x: path.left, y: path.top + height },\r\n          { x: path.left + width, y: path.top + height }\r\n        ];\r\n        m = this.paths[j].transformMatrix;\r\n        for (var i = 0; i < points.length; i++) {\r\n          p = points[i];\r\n          if (m) {\r\n            p = fabric.util.transformPoint(p, m, false);\r\n          }\r\n          xC.push(p.x);\r\n          yC.push(p.y);\r\n        }\r\n      }\r\n      options.width = Math.max.apply(null, xC);\r\n      options.height = Math.max.apply(null, yC);\r\n    },\r\n\r\n    /**\r\n     * Renders this group on a specified context\r\n     * @param {CanvasRenderingContext2D} ctx Context to render this instance on\r\n     */\r\n    render: function(ctx) {\r\n      // do not render if object is not visible\r\n      if (!this.visible) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n\r\n      if (this.transformMatrix) {\r\n        ctx.transform.apply(ctx, this.transformMatrix);\r\n      }\r\n      this.transform(ctx);\r\n\r\n      this._setShadow(ctx);\r\n      this.clipTo && fabric.util.clipContext(this, ctx);\r\n      ctx.translate(-this.width/2, -this.height/2);\r\n      for (var i = 0, l = this.paths.length; i < l; ++i) {\r\n        this.paths[i].render(ctx, true);\r\n      }\r\n      this.clipTo && ctx.restore();\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Sets certain property to a certain value\r\n     * @param {String} prop\r\n     * @param {Any} value\r\n     * @return {fabric.PathGroup} thisArg\r\n     */\r\n    _set: function(prop, value) {\r\n\r\n      if (prop === 'fill' && value && this.isSameColor()) {\r\n        var i = this.paths.length;\r\n        while (i--) {\r\n          this.paths[i]._set(prop, value);\r\n        }\r\n      }\r\n\r\n      return this.callSuper('_set', prop, value);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of this path group\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var o = extend(parentToObject.call(this, propertiesToInclude), {\r\n        paths: invoke(this.getObjects(), 'toObject', propertiesToInclude)\r\n      });\r\n      if (this.sourcePath) {\r\n        o.sourcePath = this.sourcePath;\r\n      }\r\n      return o;\r\n    },\r\n\r\n    /**\r\n     * Returns dataless object representation of this path group\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} dataless object representation of an instance\r\n     */\r\n    toDatalessObject: function(propertiesToInclude) {\r\n      var o = this.toObject(propertiesToInclude);\r\n      if (this.sourcePath) {\r\n        o.paths = this.sourcePath;\r\n      }\r\n      return o;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var objects = this.getObjects(),\r\n          p = this.getPointByOrigin('left', 'top'),\r\n          translatePart = 'translate(' + p.x + ' ' + p.y + ')',\r\n          markup = this._createBaseSVGMarkup();\r\n      markup.push(\r\n        '<g ',\r\n        'style=\"', this.getSvgStyles(), '\" ',\r\n        'transform=\"', this.getSvgTransformMatrix(), translatePart, this.getSvgTransform(), '\" ',\r\n        '>\\n'\r\n      );\r\n\r\n      for (var i = 0, len = objects.length; i < len; i++) {\r\n        markup.push('\\t', objects[i].toSVG(reviver));\r\n      }\r\n      markup.push('</g>\\n');\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns a string representation of this path group\r\n     * @return {String} string representation of an object\r\n     */\r\n    toString: function() {\r\n      return '#<fabric.PathGroup (' + this.complexity() +\r\n        '): { top: ' + this.top + ', left: ' + this.left + ' }>';\r\n    },\r\n\r\n    /**\r\n     * Returns true if all paths in this group are of same color\r\n     * @return {Boolean} true if all paths are of the same color (`fill`)\r\n     */\r\n    isSameColor: function() {\r\n      var firstPathFill = this.getObjects()[0].get('fill') || '';\r\n      if (typeof firstPathFill !== 'string') {\r\n        return false;\r\n      }\r\n      firstPathFill = firstPathFill.toLowerCase();\r\n      return this.getObjects().every(function(path) {\r\n        var pathFill = path.get('fill') || '';\r\n        return typeof pathFill === 'string' && (pathFill).toLowerCase() === firstPathFill;\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Returns number representation of object's complexity\r\n     * @return {Number} complexity\r\n     */\r\n    complexity: function() {\r\n      return this.paths.reduce(function(total, path) {\r\n        return total + ((path && path.complexity) ? path.complexity() : 0);\r\n      }, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns all paths in this path group\r\n     * @return {Array} array of path objects included in this path group\r\n     */\r\n    getObjects: function() {\r\n      return this.paths;\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Creates fabric.PathGroup instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.PathGroup\r\n   * @param {Object} object Object to create an instance from\r\n   * @param {Function} callback Callback to invoke when an fabric.PathGroup instance is created\r\n   */\r\n  fabric.PathGroup.fromObject = function(object, callback) {\r\n    if (typeof object.paths === 'string') {\r\n      fabric.loadSVGFromURL(object.paths, function (elements) {\r\n\r\n        var pathUrl = object.paths;\r\n        delete object.paths;\r\n\r\n        var pathGroup = fabric.util.groupSVGElements(elements, object, pathUrl);\r\n\r\n        callback(pathGroup);\r\n      });\r\n    }\r\n    else {\r\n      fabric.util.enlivenObjects(object.paths, function(enlivenedObjects) {\r\n        delete object.paths;\r\n        callback(new fabric.PathGroup(enlivenedObjects, object));\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Indicates that instances of this type are async\r\n   * @static\r\n   * @memberOf fabric.PathGroup\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  fabric.PathGroup.async = true;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      min = fabric.util.array.min,\r\n      max = fabric.util.array.max,\r\n      invoke = fabric.util.array.invoke;\r\n\r\n  if (fabric.Group) {\r\n    return;\r\n  }\r\n\r\n  // lock-related properties, for use in fabric.Group#get\r\n  // to enable locking behavior on group\r\n  // when one of its objects has lock-related properties set\r\n  var _lockProperties = {\r\n    lockMovementX:  true,\r\n    lockMovementY:  true,\r\n    lockRotation:   true,\r\n    lockScalingX:   true,\r\n    lockScalingY:   true,\r\n    lockUniScaling: true\r\n  };\r\n\r\n  /**\r\n   * Group class\r\n   * @class fabric.Group\r\n   * @extends fabric.Object\r\n   * @mixes fabric.Collection\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#groups}\r\n   * @see {@link fabric.Group#initialize} for constructor definition\r\n   */\r\n  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'group',\r\n\r\n    /**\r\n     * Width of stroke\r\n     * @type Number\r\n     * @default\r\n     */\r\n    strokeWidth: 0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} objects Group objects\r\n     * @param {Object} [options] Options object\r\n     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.\r\n     * @return {Object} thisArg\r\n     */\r\n    initialize: function(objects, options, isAlreadyGrouped) {\r\n      options = options || { };\r\n\r\n      this._objects = [];\r\n      // if objects enclosed in a group have been grouped already,\r\n      // we cannot change properties of objects.\r\n      // Thus we need to set options to group without objects,\r\n      // because delegatedProperties propagate to objects.\r\n      isAlreadyGrouped && this.callSuper('initialize', options);\r\n\r\n      this._objects = objects || [];\r\n      for (var i = this._objects.length; i--; ) {\r\n        this._objects[i].group = this;\r\n      }\r\n\r\n      this.originalState = { };\r\n\r\n      if (options.originX) {\r\n        this.originX = options.originX;\r\n      }\r\n      if (options.originY) {\r\n        this.originY = options.originY;\r\n      }\r\n\r\n      if (isAlreadyGrouped) {\r\n        // do not change coordinate of objects enclosed in a group,\r\n        // because objects coordinate system have been group coodinate system already.\r\n        this._updateObjectsCoords(true);\r\n      }\r\n      else {\r\n        this._calcBounds();\r\n        this._updateObjectsCoords();\r\n        this.callSuper('initialize', options);\r\n      }\r\n\r\n      this.setCoords();\r\n      this.saveCoords();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change\r\n     */\r\n    _updateObjectsCoords: function(skipCoordsChange) {\r\n      for (var i = this._objects.length; i--; ){\r\n        this._updateObjectCoords(this._objects[i], skipCoordsChange);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} object\r\n     * @param {Boolean} [skipCoordsChange] if true, coordinates of object dose not change\r\n     */\r\n    _updateObjectCoords: function(object, skipCoordsChange) {\r\n      // do not display corners of objects enclosed in a group\r\n      object.__origHasControls = object.hasControls;\r\n      object.hasControls = false;\r\n\r\n      if (skipCoordsChange) {\r\n        return;\r\n      }\r\n\r\n      var objectLeft = object.getLeft(),\r\n          objectTop = object.getTop(),\r\n          center = this.getCenterPoint();\r\n\r\n      object.set({\r\n        originalLeft: objectLeft,\r\n        originalTop: objectTop,\r\n        left: objectLeft - center.x,\r\n        top: objectTop - center.y\r\n      });\r\n      object.setCoords();\r\n    },\r\n\r\n    /**\r\n     * Returns string represenation of a group\r\n     * @return {String}\r\n     */\r\n    toString: function() {\r\n      return '#<fabric.Group: (' + this.complexity() + ')>';\r\n    },\r\n\r\n    /**\r\n     * Adds an object to a group; Then recalculates group's dimension, position.\r\n     * @param {Object} object\r\n     * @return {fabric.Group} thisArg\r\n     * @chainable\r\n     */\r\n    addWithUpdate: function(object) {\r\n      this._restoreObjectsState();\r\n      if (object) {\r\n        this._objects.push(object);\r\n        object.group = this;\r\n        object._set('canvas', this.canvas);\r\n      }\r\n      // since _restoreObjectsState set objects inactive\r\n      this.forEachObject(this._setObjectActive, this);\r\n      this._calcBounds();\r\n      this._updateObjectsCoords();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setObjectActive: function(object) {\r\n      object.set('active', true);\r\n      object.group = this;\r\n    },\r\n\r\n    /**\r\n     * Removes an object from a group; Then recalculates group's dimension, position.\r\n     * @param {Object} object\r\n     * @return {fabric.Group} thisArg\r\n     * @chainable\r\n     */\r\n    removeWithUpdate: function(object) {\r\n      this._moveFlippedObject(object);\r\n      this._restoreObjectsState();\r\n\r\n      // since _restoreObjectsState set objects inactive\r\n      this.forEachObject(this._setObjectActive, this);\r\n\r\n      this.remove(object);\r\n      this._calcBounds();\r\n      this._updateObjectsCoords();\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _onObjectAdded: function(object) {\r\n      object.group = this;\r\n      object._set('canvas', this.canvas);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _onObjectRemoved: function(object) {\r\n      delete object.group;\r\n      object.set('active', false);\r\n    },\r\n\r\n    /**\r\n     * Properties that are delegated to group objects when reading/writing\r\n     * @param {Object} delegatedProperties\r\n     */\r\n    delegatedProperties: {\r\n      fill:             true,\r\n      opacity:          true,\r\n      fontFamily:       true,\r\n      fontWeight:       true,\r\n      fontSize:         true,\r\n      fontStyle:        true,\r\n      lineHeight:       true,\r\n      textDecoration:   true,\r\n      textAlign:        true,\r\n      backgroundColor:  true\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _set: function(key, value) {\r\n      var i = this._objects.length;\r\n\r\n      if (this.delegatedProperties[key] || key === 'canvas') {\r\n        while (i--) {\r\n          this._objects[i].set(key, value);\r\n        }\r\n      }\r\n      else {\r\n        while (i--) {\r\n          this._objects[i].setOnGroup(key, value);\r\n        }\r\n      }\r\n\r\n      this.callSuper('_set', key, value);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return extend(this.callSuper('toObject', propertiesToInclude), {\r\n        objects: invoke(this._objects, 'toObject', propertiesToInclude)\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Renders instance on a given context\r\n     * @param {CanvasRenderingContext2D} ctx context to render instance on\r\n     */\r\n    render: function(ctx) {\r\n      // do not render if object is not visible\r\n      if (!this.visible) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n      if (this.transformMatrix) {\r\n        ctx.transform.apply(ctx, this.transformMatrix);\r\n      }\r\n      this.transform(ctx);\r\n      this._setShadow(ctx);\r\n      this.clipTo && fabric.util.clipContext(this, ctx);\r\n      // the array is now sorted in order of highest first, so start from end\r\n      for (var i = 0, len = this._objects.length; i < len; i++) {\r\n        this._renderObject(this._objects[i], ctx);\r\n      }\r\n\r\n      this.clipTo && ctx.restore();\r\n\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Renders controls and borders for the object\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Boolean} [noTransform] When true, context is not transformed\r\n     */\r\n    _renderControls: function(ctx, noTransform) {\r\n      this.callSuper('_renderControls', ctx, noTransform);\r\n      for (var i = 0, len = this._objects.length; i < len; i++) {\r\n        this._objects[i]._renderControls(ctx);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _renderObject: function(object, ctx) {\r\n      // do not render if object is not visible\r\n      if (!object.visible) {\r\n        return;\r\n      }\r\n\r\n      var originalHasRotatingPoint = object.hasRotatingPoint;\r\n      object.hasRotatingPoint = false;\r\n      object.render(ctx);\r\n      object.hasRotatingPoint = originalHasRotatingPoint;\r\n    },\r\n\r\n    /**\r\n     * Retores original state of each of group objects (original state is that which was before group was created).\r\n     * @private\r\n     * @return {fabric.Group} thisArg\r\n     * @chainable\r\n     */\r\n    _restoreObjectsState: function() {\r\n      this._objects.forEach(this._restoreObjectState, this);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Realises the transform from this group onto the supplied object\r\n     * i.e. it tells you what would happen if the supplied object was in\r\n     * the group, and then the group was destroyed. It mutates the supplied\r\n     * object.\r\n     * @param {fabric.Object} object\r\n     * @return {fabric.Object} transformedObject\r\n     */\r\n    realizeTransform: function(object) {\r\n      this._moveFlippedObject(object);\r\n      this._setObjectPosition(object);\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Moves a flipped object to the position where it's displayed\r\n     * @private\r\n     * @param {fabric.Object} object\r\n     * @return {fabric.Group} thisArg\r\n     */\r\n    _moveFlippedObject: function(object) {\r\n      var oldOriginX = object.get('originX'),\r\n          oldOriginY = object.get('originY'),\r\n          center = object.getCenterPoint();\r\n\r\n      object.set({\r\n        originX: 'center',\r\n        originY: 'center',\r\n        left: center.x,\r\n        top: center.y\r\n      });\r\n\r\n      this._toggleFlipping(object);\r\n\r\n      var newOrigin = object.getPointByOrigin(oldOriginX, oldOriginY);\r\n\r\n      object.set({\r\n        originX: oldOriginX,\r\n        originY: oldOriginY,\r\n        left: newOrigin.x,\r\n        top: newOrigin.y\r\n      });\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _toggleFlipping: function(object) {\r\n      if (this.flipX) {\r\n        object.toggle('flipX');\r\n        object.set('left', -object.get('left'));\r\n        object.setAngle(-object.getAngle());\r\n      }\r\n      if (this.flipY) {\r\n        object.toggle('flipY');\r\n        object.set('top', -object.get('top'));\r\n        object.setAngle(-object.getAngle());\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Restores original state of a specified object in group\r\n     * @private\r\n     * @param {fabric.Object} object\r\n     * @return {fabric.Group} thisArg\r\n     */\r\n    _restoreObjectState: function(object) {\r\n      this._setObjectPosition(object);\r\n\r\n      object.setCoords();\r\n      object.hasControls = object.__origHasControls;\r\n      delete object.__origHasControls;\r\n      object.set('active', false);\r\n      object.setCoords();\r\n      delete object.group;\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setObjectPosition: function(object) {\r\n      var center = this.getCenterPoint(),\r\n          rotated = this._getRotatedLeftTop(object);\r\n\r\n      object.set({\r\n        angle: object.getAngle() + this.getAngle(),\r\n        left: center.x + rotated.left,\r\n        top: center.y + rotated.top,\r\n        scaleX: object.get('scaleX') * this.get('scaleX'),\r\n        scaleY: object.get('scaleY') * this.get('scaleY')\r\n      });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getRotatedLeftTop: function(object) {\r\n      var groupAngle = this.getAngle() * (Math.PI / 180);\r\n      return {\r\n        left: (-Math.sin(groupAngle) * object.getTop() * this.get('scaleY') +\r\n                Math.cos(groupAngle) * object.getLeft() * this.get('scaleX')),\r\n\r\n        top:  (Math.cos(groupAngle) * object.getTop() * this.get('scaleY') +\r\n               Math.sin(groupAngle) * object.getLeft() * this.get('scaleX'))\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Destroys a group (restoring state of its objects)\r\n     * @return {fabric.Group} thisArg\r\n     * @chainable\r\n     */\r\n    destroy: function() {\r\n      this._objects.forEach(this._moveFlippedObject, this);\r\n      return this._restoreObjectsState();\r\n    },\r\n\r\n    /**\r\n     * Saves coordinates of this instance (to be used together with `hasMoved`)\r\n     * @saveCoords\r\n     * @return {fabric.Group} thisArg\r\n     * @chainable\r\n     */\r\n    saveCoords: function() {\r\n      this._originalLeft = this.get('left');\r\n      this._originalTop = this.get('top');\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Checks whether this group was moved (since `saveCoords` was called last)\r\n     * @return {Boolean} true if an object was moved (since fabric.Group#saveCoords was called)\r\n     */\r\n    hasMoved: function() {\r\n      return this._originalLeft !== this.get('left') ||\r\n             this._originalTop !== this.get('top');\r\n    },\r\n\r\n    /**\r\n     * Sets coordinates of all group objects\r\n     * @return {fabric.Group} thisArg\r\n     * @chainable\r\n     */\r\n    setObjectsCoords: function() {\r\n      this.forEachObject(function(object) {\r\n        object.setCoords();\r\n      });\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _calcBounds: function(onlyWidthHeight) {\r\n      var aX = [],\r\n          aY = [],\r\n          o, prop,\r\n          props = ['tr', 'br', 'bl', 'tl'],\r\n          i = 0, iLen = this._objects.length,\r\n          j, jLen = props.length;\r\n\r\n      for ( ; i < iLen; ++i) {\r\n        o = this._objects[i];\r\n        o.setCoords();\r\n        for (j = 0; j < jLen; j++) {\r\n          prop = props[j];\r\n          aX.push(o.oCoords[prop].x);\r\n          aY.push(o.oCoords[prop].y);\r\n        }\r\n      }\r\n\r\n      this.set(this._getBounds(aX, aY, onlyWidthHeight));\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getBounds: function(aX, aY, onlyWidthHeight) {\r\n      var ivt = fabric.util.invertTransform(this.getViewportTransform()),\r\n          minXY = fabric.util.transformPoint(new fabric.Point(min(aX), min(aY)), ivt),\r\n          maxXY = fabric.util.transformPoint(new fabric.Point(max(aX), max(aY)), ivt),\r\n          obj = {\r\n            width: (maxXY.x - minXY.x) || 0,\r\n            height: (maxXY.y - minXY.y) || 0\r\n          };\r\n\r\n      if (!onlyWidthHeight) {\r\n        obj.left = minXY.x || 0;\r\n        obj.top = minXY.y || 0;\r\n        if (this.originX === 'center') {\r\n          obj.left += obj.width / 2;\r\n        }\r\n        if (this.originX === 'right') {\r\n          obj.left += obj.width;\r\n        }\r\n        if (this.originY === 'center') {\r\n          obj.top += obj.height / 2;\r\n        }\r\n        if (this.originY === 'bottom') {\r\n          obj.top += obj.height;\r\n        }\r\n      }\r\n      return obj;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup();\r\n      markup.push(\r\n        '<g transform=\"',\r\n        /* avoiding styles intentionally */\r\n        this.getSvgTransform(),\r\n        this.getSvgTransformMatrix(),\r\n        '\" style=\"',\r\n        this.getSvgFilter(),\r\n        '\">\\n'\r\n      );\r\n\r\n      for (var i = 0, len = this._objects.length; i < len; i++) {\r\n        markup.push('\\t', this._objects[i].toSVG(reviver));\r\n      }\r\n\r\n      markup.push('</g>\\n');\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns requested property\r\n     * @param {String} prop Property to get\r\n     * @return {Any}\r\n     */\r\n    get: function(prop) {\r\n      if (prop in _lockProperties) {\r\n        if (this[prop]) {\r\n          return this[prop];\r\n        }\r\n        else {\r\n          for (var i = 0, len = this._objects.length; i < len; i++) {\r\n            if (this._objects[i][prop]) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n      else {\r\n        if (prop in this.delegatedProperties) {\r\n          return this._objects[0] && this._objects[0].get(prop);\r\n        }\r\n        return this[prop];\r\n      }\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns {@link fabric.Group} instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Group\r\n   * @param {Object} object Object to create a group from\r\n   * @param {Function} [callback] Callback to invoke when an group instance is created\r\n   * @return {fabric.Group} An instance of fabric.Group\r\n   */\r\n  fabric.Group.fromObject = function(object, callback) {\r\n    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {\r\n      delete object.objects;\r\n      callback && callback(new fabric.Group(enlivenedObjects, object, true));\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Indicates that instances of this type are async\r\n   * @static\r\n   * @memberOf fabric.Group\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  fabric.Group.async = true;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var extend = fabric.util.object.extend;\r\n\r\n  if (!global.fabric) {\r\n    global.fabric = { };\r\n  }\r\n\r\n  if (global.fabric.Image) {\r\n    fabric.warn('fabric.Image is already defined.');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Image class\r\n   * @class fabric.Image\r\n   * @extends fabric.Object\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#images}\r\n   * @see {@link fabric.Image#initialize} for constructor definition\r\n   */\r\n  fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'image',\r\n\r\n    /**\r\n     * crossOrigin value (one of \"\", \"anonymous\", \"allow-credentials\")\r\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\r\n     * @type String\r\n     * @default\r\n     */\r\n    crossOrigin: '',\r\n\r\n    /**\r\n     * AlignX value, part of preserveAspectRatio (one of \"none\", \"mid\", \"min\", \"max\")\r\n     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\r\n     * This parameter defines how the picture is aligned to its viewport when image element width differs from image width.\r\n     * @type String\r\n     * @default\r\n     */\r\n    alignX: 'none',\r\n\r\n    /**\r\n     * AlignY value, part of preserveAspectRatio (one of \"none\", \"mid\", \"min\", \"max\")\r\n     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\r\n     * This parameter defines how the picture is aligned to its viewport when image element height differs from image height.\r\n     * @type String\r\n     * @default\r\n     */\r\n    alignY: 'none',\r\n\r\n    /**\r\n     * meetOrSlice value, part of preserveAspectRatio  (one of \"meet\", \"slice\").\r\n     * if meet the image is always fully visibile, if slice the viewport is always filled with image.\r\n     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\r\n     * @type String\r\n     * @default\r\n     */\r\n    meetOrSlice: 'meet',\r\n\r\n    /**\r\n     * private\r\n     * contains last value of scaleX to detect\r\n     * if the Image got resized after the last Render\r\n     * @type Number\r\n     */\r\n    _lastScaleX: 1,\r\n\r\n    /**\r\n     * private\r\n     * contains last value of scaleY to detect\r\n     * if the Image got resized after the last Render\r\n     * @type Number\r\n     */\r\n    _lastScaleY: 1,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {HTMLImageElement | String} element Image element\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Image} thisArg\r\n     */\r\n    initialize: function(element, options) {\r\n      options || (options = { });\r\n      this.filters = [ ];\r\n      this.resizeFilters = [ ];\r\n      this.callSuper('initialize', options);\r\n      this._initElement(element, options);\r\n    },\r\n\r\n    /**\r\n     * Returns image element which this instance if based on\r\n     * @return {HTMLImageElement} Image element\r\n     */\r\n    getElement: function() {\r\n      return this._element;\r\n    },\r\n\r\n    /**\r\n     * Sets image element for this instance to a specified one.\r\n     * If filters defined they are applied to new image.\r\n     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.\r\n     * @param {HTMLImageElement} element\r\n     * @param {Function} [callback] Callback is invoked when all filters have been applied and new image is generated\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Image} thisArg\r\n     * @chainable\r\n     */\r\n    setElement: function(element, callback, options) {\r\n      this._element = element;\r\n      this._originalElement = element;\r\n      this._initConfig(options);\r\n\r\n      if (this.filters.length !== 0) {\r\n        this.applyFilters(callback);\r\n      }\r\n      else if (callback) {\r\n        callback();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets crossOrigin value (on an instance and corresponding image element)\r\n     * @return {fabric.Image} thisArg\r\n     * @chainable\r\n     */\r\n    setCrossOrigin: function(value) {\r\n      this.crossOrigin = value;\r\n      this._element.crossOrigin = value;\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns original size of an image\r\n     * @return {Object} Object with \"width\" and \"height\" properties\r\n     */\r\n    getOriginalSize: function() {\r\n      var element = this.getElement();\r\n      return {\r\n        width: element.width,\r\n        height: element.height\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _stroke: function(ctx) {\r\n      ctx.save();\r\n      this._setStrokeStyles(ctx);\r\n      ctx.beginPath();\r\n      ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);\r\n      ctx.closePath();\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderDashedStroke: function(ctx) {\r\n      var x = -this.width / 2,\r\n          y = -this.height / 2,\r\n          w = this.width,\r\n          h = this.height;\r\n\r\n      ctx.save();\r\n      this._setStrokeStyles(ctx);\r\n\r\n      ctx.beginPath();\r\n      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);\r\n      ctx.closePath();\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var filters = [ ];\r\n      this.filters.forEach(function(filterObj) {\r\n        if (filterObj) {\r\n          filters.push(filterObj.toObject());\r\n        }\r\n      });\r\n      var object = extend(this.callSuper('toObject', propertiesToInclude), {\r\n        src: this._originalElement.src || this._originalElement._src,\r\n        filters: filters,\r\n        crossOrigin: this.crossOrigin,\r\n        alignX: this.alignX,\r\n        alignY: this.alignY,\r\n        meetOrSlice: this.meetOrSlice\r\n      });\r\n\r\n      if (this.resizeFilters.length > 0) {\r\n        object.resizeFilters = this.resizeFilters.map(function(filterObj) {\r\n          return filterObj && filterObj.toObject();\r\n        });\r\n      }\r\n\r\n      if (!this.includeDefaultValues) {\r\n        this._removeDefaultValues(object);\r\n      }\r\n\r\n      return object;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2,\r\n          preserveAspectRatio = 'none';\r\n      if (this.group && this.group.type === 'path-group') {\r\n        x = this.left;\r\n        y = this.top;\r\n      }\r\n      if (this.alignX !== 'none' && this.alignY !== 'none') {\r\n        preserveAspectRatio = 'x' + this.alignX + 'Y' + this.alignY + ' ' + this.meetOrSlice;\r\n      }\r\n      markup.push(\r\n        '<g transform=\"', this.getSvgTransform(), this.getSvgTransformMatrix(), '\">\\n',\r\n          '<image xlink:href=\"', this.getSvgSrc(),\r\n            '\" x=\"', x, '\" y=\"', y,\r\n            '\" style=\"', this.getSvgStyles(),\r\n            // we're essentially moving origin of transformation from top/left corner to the center of the shape\r\n            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left\r\n            // so that object's center aligns with container's left/top\r\n            '\" width=\"', this.width,\r\n            '\" height=\"', this.height,\r\n            '\" preserveAspectRatio=\"', preserveAspectRatio, '\"',\r\n          '></image>\\n'\r\n      );\r\n\r\n      if (this.stroke || this.strokeDashArray) {\r\n        var origFill = this.fill;\r\n        this.fill = null;\r\n        markup.push(\r\n          '<rect ',\r\n            'x=\"', x, '\" y=\"', y,\r\n            '\" width=\"', this.width, '\" height=\"', this.height,\r\n            '\" style=\"', this.getSvgStyles(),\r\n          '\"/>\\n'\r\n        );\r\n        this.fill = origFill;\r\n      }\r\n\r\n      markup.push('</g>\\n');\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns source of an image\r\n     * @return {String} Source of an image\r\n     */\r\n    getSrc: function() {\r\n      if (this.getElement()) {\r\n        return this.getElement().src || this.getElement()._src;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets source of an image\r\n     * @param {String} src Source string (URL)\r\n     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Image} thisArg\r\n     * @chainable\r\n     */\r\n    setSrc: function(src, callback, options) {\r\n      fabric.util.loadImage(src, function(img) {\r\n        return this.setElement(img, callback, options);\r\n      }, this, options && options.crossOrigin);\r\n    },\r\n\r\n    /**\r\n     * Returns string representation of an instance\r\n     * @return {String} String representation of an instance\r\n     */\r\n    toString: function() {\r\n      return '#<fabric.Image: { src: \"' + this.getSrc() + '\" }>';\r\n    },\r\n\r\n    /**\r\n     * Returns a clone of an instance\r\n     * @param {Function} callback Callback is invoked with a clone as a first argument\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     */\r\n    clone: function(callback, propertiesToInclude) {\r\n      this.constructor.fromObject(this.toObject(propertiesToInclude), callback);\r\n    },\r\n\r\n    /**\r\n     * Applies filters assigned to this image (from \"filters\" array)\r\n     * @method applyFilters\r\n     * @param {Function} callback Callback is invoked when all filters have been applied and new image is generated\r\n     * @return {fabric.Image} thisArg\r\n     * @chainable\r\n     */\r\n    applyFilters: function(callback, filters, imgElement, forResizing) {\r\n\r\n      filters = filters || this.filters;\r\n      imgElement = imgElement || this._originalElement;\r\n\r\n      if (!imgElement) {\r\n        return;\r\n      }\r\n\r\n      var imgEl = imgElement,\r\n          canvasEl = fabric.util.createCanvasElement(),\r\n          replacement = fabric.util.createImage(),\r\n          _this = this;\r\n\r\n      canvasEl.width = imgEl.width;\r\n      canvasEl.height = imgEl.height;\r\n      canvasEl.getContext('2d').drawImage(imgEl, 0, 0, imgEl.width, imgEl.height);\r\n\r\n      if (filters.length === 0) {\r\n        this._element = imgElement;\r\n        callback && callback();\r\n        return canvasEl;\r\n      }\r\n      filters.forEach(function(filter) {\r\n        filter && filter.applyTo(canvasEl, filter.scaleX || _this.scaleX, filter.scaleY || _this.scaleY);\r\n        if (!forResizing && filter && filter.type === 'Resize') {\r\n          _this.width *= filter.scaleX;\r\n          _this.height *= filter.scaleY;\r\n        }\r\n      });\r\n\r\n      /** @ignore */\r\n      replacement.width = canvasEl.width;\r\n      replacement.height = canvasEl.height;\r\n\r\n      if (fabric.isLikelyNode) {\r\n        replacement.src = canvasEl.toBuffer(undefined, fabric.Image.pngCompression);\r\n        // onload doesn't fire in some node versions, so we invoke callback manually\r\n        _this._element = replacement;\r\n        !forResizing && (_this._filteredEl = replacement);\r\n        callback && callback();\r\n      }\r\n      else {\r\n        replacement.onload = function() {\r\n          _this._element = replacement;\r\n          !forResizing && (_this._filteredEl = replacement);\r\n          callback && callback();\r\n          replacement.onload = canvasEl = imgEl = null;\r\n        };\r\n        replacement.src = canvasEl.toDataURL('image/png');\r\n      }\r\n      return canvasEl;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx, noTransform) {\r\n      var x, y, imageMargins = this._findMargins(), elementToDraw;\r\n\r\n      x = (noTransform ? this.left : -this.width / 2);\r\n      y = (noTransform ? this.top : -this.height / 2);\r\n\r\n      if (this.meetOrSlice === 'slice') {\r\n        ctx.beginPath();\r\n        ctx.rect(x, y, this.width, this.height);\r\n        ctx.clip();\r\n      }\r\n\r\n      if (this.isMoving === false && this.resizeFilters.length && this._needsResize()) {\r\n        this._lastScaleX = this.scaleX;\r\n        this._lastScaleY = this.scaleY;\r\n        elementToDraw = this.applyFilters(null, this.resizeFilters, this._filteredEl || this._originalElement, true);\r\n      }\r\n      else {\r\n        elementToDraw = this._element;\r\n      }\r\n      elementToDraw && ctx.drawImage(elementToDraw,\r\n                                     x + imageMargins.marginX,\r\n                                     y + imageMargins.marginY,\r\n                                     imageMargins.width,\r\n                                     imageMargins.height\r\n                                    );\r\n\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * @private, needed to check if image needs resize\r\n     */\r\n    _needsResize: function() {\r\n      return (this.scaleX !== this._lastScaleX || this.scaleY !== this._lastScaleY);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _findMargins: function() {\r\n      var width = this.width, height = this.height, scales,\r\n          scale, marginX = 0, marginY = 0;\r\n\r\n      if (this.alignX !== 'none' || this.alignY !== 'none') {\r\n        scales = [this.width / this._element.width, this.height / this._element.height];\r\n        scale = this.meetOrSlice === 'meet'\r\n                ? Math.min.apply(null, scales) : Math.max.apply(null, scales);\r\n        width = this._element.width * scale;\r\n        height = this._element.height * scale;\r\n        if (this.alignX === 'Mid') {\r\n          marginX = (this.width - width) / 2;\r\n        }\r\n        if (this.alignX === 'Max') {\r\n          marginX = this.width - width;\r\n        }\r\n        if (this.alignY === 'Mid') {\r\n          marginY = (this.height - height) / 2;\r\n        }\r\n        if (this.alignY === 'Max') {\r\n          marginY = this.height - height;\r\n        }\r\n      }\r\n      return {\r\n        width:  width,\r\n        height: height,\r\n        marginX: marginX,\r\n        marginY: marginY\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _resetWidthHeight: function() {\r\n      var element = this.getElement();\r\n\r\n      this.set('width', element.width);\r\n      this.set('height', element.height);\r\n    },\r\n\r\n    /**\r\n     * The Image class's initialization method. This method is automatically\r\n     * called by the constructor.\r\n     * @private\r\n     * @param {HTMLImageElement|String} element The element representing the image\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initElement: function(element, options) {\r\n      this.setElement(fabric.util.getById(element), null, options);\r\n      fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initConfig: function(options) {\r\n      options || (options = { });\r\n      this.setOptions(options);\r\n      this._setWidthHeight(options);\r\n      if (this._element && this.crossOrigin) {\r\n        this._element.crossOrigin = this.crossOrigin;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Array} filters to be initialized\r\n     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created\r\n     */\r\n    _initFilters: function(filters, callback) {\r\n      if (filters && filters.length) {\r\n        fabric.util.enlivenObjects(filters, function(enlivenedObjects) {\r\n          callback && callback(enlivenedObjects);\r\n        }, 'fabric.Image.filters');\r\n      }\r\n      else {\r\n        callback && callback();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Object with width/height properties\r\n     */\r\n    _setWidthHeight: function(options) {\r\n      this.width = 'width' in options\r\n        ? options.width\r\n        : (this.getElement()\r\n            ? this.getElement().width || 0\r\n            : 0);\r\n\r\n      this.height = 'height' in options\r\n        ? options.height\r\n        : (this.getElement()\r\n            ? this.getElement().height || 0\r\n            : 0);\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Default CSS class name for canvas\r\n   * @static\r\n   * @type String\r\n   * @default\r\n   */\r\n  fabric.Image.CSS_CANVAS = 'canvas-img';\r\n\r\n  /**\r\n   * Alias for getSrc\r\n   * @static\r\n   */\r\n  fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;\r\n\r\n  /**\r\n   * Creates an instance of fabric.Image from its object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @param {Function} [callback] Callback to invoke when an image instance is created\r\n   */\r\n  fabric.Image.fromObject = function(object, callback) {\r\n    fabric.util.loadImage(object.src, function(img) {\r\n      fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {\r\n        object.filters = filters || [ ];\r\n        fabric.Image.prototype._initFilters.call(object, object.resizeFilters, function(resizeFilters) {\r\n          object.resizeFilters = resizeFilters || [ ];\r\n          var instance = new fabric.Image(img, object);\r\n          callback && callback(instance);\r\n        });\r\n      });\r\n    }, null, object.crossOrigin);\r\n  };\r\n\r\n  /**\r\n   * Creates an instance of fabric.Image from an URL string\r\n   * @static\r\n   * @param {String} url URL to create an image from\r\n   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument)\r\n   * @param {Object} [imgOptions] Options object\r\n   */\r\n  fabric.Image.fromURL = function(url, callback, imgOptions) {\r\n    fabric.util.loadImage(url, function(img) {\r\n      callback && callback(new fabric.Image(img, imgOptions));\r\n    }, null, imgOptions && imgOptions.crossOrigin);\r\n  };\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})\r\n   * @static\r\n   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}\r\n   */\r\n  fabric.Image.ATTRIBUTE_NAMES =\r\n    fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href'.split(' '));\r\n\r\n  /**\r\n   * Returns {@link fabric.Image} instance from an SVG element\r\n   * @static\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Function} callback Callback to execute when fabric.Image object is created\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Image} Instance of fabric.Image\r\n   */\r\n  fabric.Image.fromElement = function(element, callback, options) {\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES),\r\n        preserveAR;\r\n\r\n    if (parsedAttributes.preserveAspectRatio) {\r\n      preserveAR = fabric.util.parsePreserveAspectRatioAttribute(parsedAttributes.preserveAspectRatio);\r\n      extend(parsedAttributes, preserveAR);\r\n    }\r\n\r\n    fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,\r\n      extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Indicates that instances of this type are async\r\n   * @static\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  fabric.Image.async = true;\r\n\r\n  /**\r\n   * Indicates compression level used when generating PNG under Node (in applyFilters). Any of 0-9\r\n   * @static\r\n   * @type Number\r\n   * @default\r\n   */\r\n  fabric.Image.pngCompression = 1;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n  /**\r\n   * @private\r\n   * @return {Number} angle value\r\n   */\r\n  _getAngleValueForStraighten: function() {\r\n    var angle = this.getAngle() % 360;\r\n    if (angle > 0) {\r\n      return Math.round((angle - 1) / 90) * 90;\r\n    }\r\n    return Math.round(angle / 90) * 90;\r\n  },\r\n\r\n  /**\r\n   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  straighten: function() {\r\n    this.setAngle(this._getAngleValueForStraighten());\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Same as {@link fabric.Object.prototype.straighten} but with animation\r\n   * @param {Object} callbacks Object with callback functions\r\n   * @param {Function} [callbacks.onComplete] Invoked on completion\r\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  fxStraighten: function(callbacks) {\r\n    callbacks = callbacks || { };\r\n\r\n    var empty = function() { },\r\n        onComplete = callbacks.onComplete || empty,\r\n        onChange = callbacks.onChange || empty,\r\n        _this = this;\r\n\r\n    fabric.util.animate({\r\n      startValue: this.get('angle'),\r\n      endValue: this._getAngleValueForStraighten(),\r\n      duration: this.FX_DURATION,\r\n      onChange: function(value) {\r\n        _this.setAngle(value);\r\n        onChange();\r\n      },\r\n      onComplete: function() {\r\n        _this.setCoords();\r\n        onComplete();\r\n      },\r\n      onStart: function() {\r\n        _this.set('active', false);\r\n      }\r\n    });\r\n\r\n    return this;\r\n  }\r\n});\r\n\r\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\r\n\r\n  /**\r\n   * Straightens object, then rerenders canvas\r\n   * @param {fabric.Object} object Object to straighten\r\n   * @return {fabric.Canvas} thisArg\r\n   * @chainable\r\n   */\r\n  straightenObject: function (object) {\r\n    object.straighten();\r\n    this.renderAll();\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated\r\n   * @param {fabric.Object} object Object to straighten\r\n   * @return {fabric.Canvas} thisArg\r\n   * @chainable\r\n   */\r\n  fxStraightenObject: function (object) {\r\n    object.fxStraighten({\r\n      onChange: this.renderAll.bind(this)\r\n    });\r\n    return this;\r\n  }\r\n});\r\n\r\n\r\n/**\r\n * @namespace fabric.Image.filters\r\n * @memberOf fabric.Image\r\n * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#image_filters}\r\n * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n */\r\nfabric.Image.filters = fabric.Image.filters || { };\r\n\r\n/**\r\n * Root filter class from which all filter classes inherit from\r\n * @class fabric.Image.filters.BaseFilter\r\n * @memberOf fabric.Image.filters\r\n */\r\nfabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {\r\n\r\n  /**\r\n   * Filter type\r\n   * @param {String} type\r\n   * @default\r\n   */\r\n  type: 'BaseFilter',\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {Object} [options] Options object\r\n   */\r\n  initialize: function(options) {\r\n    if (options) {\r\n      this.setOptions(options);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets filter's properties from options\r\n   * @param {Object} [options] Options object\r\n   */\r\n  setOptions: function(options) {\r\n    for (var prop in options) {\r\n      this[prop] = options[prop];\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns object representation of an instance\r\n   * @return {Object} Object representation of an instance\r\n   */\r\n  toObject: function() {\r\n    return { type: this.type };\r\n  },\r\n\r\n  /**\r\n   * Returns a JSON representation of an instance\r\n   * @return {Object} JSON\r\n   */\r\n  toJSON: function() {\r\n    // delegate, not alias\r\n    return this.toObject();\r\n  }\r\n});\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Brightness filter class\r\n   * @class fabric.Image.filters.Brightness\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Brightness({\r\n   *   brightness: 200\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Brightness = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Brightness',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Brightness.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {Number} [options.brightness=0] Value to brighten the image up (0..255)\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n      this.brightness = options.brightness || 0;\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          brightness = this.brightness;\r\n\r\n      for (var i = 0, len = data.length; i < len; i += 4) {\r\n        data[i] += brightness;\r\n        data[i + 1] += brightness;\r\n        data[i + 2] += brightness;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        brightness: this.brightness\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness\r\n   */\r\n  fabric.Image.filters.Brightness.fromObject = function(object) {\r\n    return new fabric.Image.filters.Brightness(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Adapted from <a href=\"http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\">html5rocks article</a>\r\n   * @class fabric.Image.filters.Convolute\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example <caption>Sharpen filter</caption>\r\n   * var filter = new fabric.Image.filters.Convolute({\r\n   *   matrix: [ 0, -1,  0,\r\n   *            -1,  5, -1,\r\n   *             0, -1,  0 ]\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   * @example <caption>Blur filter</caption>\r\n   * var filter = new fabric.Image.filters.Convolute({\r\n   *   matrix: [ 1/9, 1/9, 1/9,\r\n   *             1/9, 1/9, 1/9,\r\n   *             1/9, 1/9, 1/9 ]\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   * @example <caption>Emboss filter</caption>\r\n   * var filter = new fabric.Image.filters.Convolute({\r\n   *   matrix: [ 1,   1,  1,\r\n   *             1, 0.7, -1,\r\n   *            -1,  -1, -1 ]\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   * @example <caption>Emboss filter with opaqueness</caption>\r\n   * var filter = new fabric.Image.filters.Convolute({\r\n   *   opaque: true,\r\n   *   matrix: [ 1,   1,  1,\r\n   *             1, 0.7, -1,\r\n   *            -1,  -1, -1 ]\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Convolute = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Convolute',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Convolute.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {Boolean} [options.opaque=false] Opaque value (true/false)\r\n     * @param {Array} [options.matrix] Filter matrix\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.opaque = options.opaque;\r\n      this.matrix = options.matrix || [\r\n        0, 0, 0,\r\n        0, 1, 0,\r\n        0, 0, 0\r\n      ];\r\n\r\n      var canvasEl = fabric.util.createCanvasElement();\r\n      this.tmpCtx = canvasEl.getContext('2d');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _createImageData: function(w, h) {\r\n      return this.tmpCtx.createImageData(w, h);\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n\r\n      var weights = this.matrix,\r\n          context = canvasEl.getContext('2d'),\r\n          pixels = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n\r\n          side = Math.round(Math.sqrt(weights.length)),\r\n          halfSide = Math.floor(side/2),\r\n          src = pixels.data,\r\n          sw = pixels.width,\r\n          sh = pixels.height,\r\n\r\n          // pad output by the convolution matrix\r\n          w = sw,\r\n          h = sh,\r\n          output = this._createImageData(w, h),\r\n\r\n          dst = output.data,\r\n\r\n          // go through the destination image pixels\r\n          alphaFac = this.opaque ? 1 : 0;\r\n\r\n      for (var y = 0; y < h; y++) {\r\n        for (var x = 0; x < w; x++) {\r\n          var sy = y,\r\n              sx = x,\r\n              dstOff = (y * w + x) * 4,\r\n              // calculate the weighed sum of the source image pixels that\r\n              // fall under the convolution matrix\r\n              r = 0, g = 0, b = 0, a = 0;\r\n\r\n          for (var cy = 0; cy < side; cy++) {\r\n            for (var cx = 0; cx < side; cx++) {\r\n\r\n              var scy = sy + cy - halfSide,\r\n                  scx = sx + cx - halfSide;\r\n\r\n              /* jshint maxdepth:5 */\r\n              if (scy < 0 || scy > sh || scx < 0 || scx > sw) {\r\n                continue;\r\n              }\r\n\r\n              var srcOff = (scy * sw + scx) * 4,\r\n                  wt = weights[cy * side + cx];\r\n\r\n              r += src[srcOff] * wt;\r\n              g += src[srcOff + 1] * wt;\r\n              b += src[srcOff + 2] * wt;\r\n              a += src[srcOff + 3] * wt;\r\n            }\r\n          }\r\n          dst[dstOff] = r;\r\n          dst[dstOff + 1] = g;\r\n          dst[dstOff + 2] = b;\r\n          dst[dstOff + 3] = a + alphaFac * (255 - a);\r\n        }\r\n      }\r\n\r\n      context.putImageData(output, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        opaque: this.opaque,\r\n        matrix: this.matrix\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute\r\n   */\r\n  fabric.Image.filters.Convolute.fromObject = function(object) {\r\n    return new fabric.Image.filters.Convolute(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * GradientTransparency filter class\r\n   * @class fabric.Image.filters.GradientTransparency\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.GradientTransparency#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.GradientTransparency({\r\n   *   threshold: 200\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.GradientTransparency = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.GradientTransparency.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'GradientTransparency',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.GradientTransparency.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {Number} [options.threshold=100] Threshold value\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n      this.threshold = options.threshold || 100;\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          threshold = this.threshold,\r\n          total = data.length;\r\n\r\n      for (var i = 0, len = data.length; i < len; i += 4) {\r\n        data[i + 3] = threshold + 255 * (total - i) / total;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        threshold: this.threshold\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.GradientTransparency} Instance of fabric.Image.filters.GradientTransparency\r\n   */\r\n  fabric.Image.filters.GradientTransparency.fromObject = function(object) {\r\n    return new fabric.Image.filters.GradientTransparency(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { });\r\n\r\n  /**\r\n   * Grayscale image filter class\r\n   * @class fabric.Image.filters.Grayscale\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Grayscale();\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Grayscale = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Grayscale',\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @memberOf fabric.Image.filters.Grayscale.prototype\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          len = imageData.width * imageData.height * 4,\r\n          index = 0,\r\n          average;\r\n\r\n      while (index < len) {\r\n        average = (data[index] + data[index + 1] + data[index + 2]) / 3;\r\n        data[index]     = average;\r\n        data[index + 1] = average;\r\n        data[index + 2] = average;\r\n        index += 4;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale\r\n   */\r\n  fabric.Image.filters.Grayscale.fromObject = function() {\r\n    return new fabric.Image.filters.Grayscale();\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { });\r\n\r\n  /**\r\n   * Invert filter class\r\n   * @class fabric.Image.filters.Invert\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Invert();\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Invert = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Invert',\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @memberOf fabric.Image.filters.Invert.prototype\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          iLen = data.length, i;\r\n\r\n      for (i = 0; i < iLen; i+=4) {\r\n        data[i] = 255 - data[i];\r\n        data[i + 1] = 255 - data[i + 1];\r\n        data[i + 2] = 255 - data[i + 2];\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert\r\n   */\r\n  fabric.Image.filters.Invert.fromObject = function() {\r\n    return new fabric.Image.filters.Invert();\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Mask filter class\r\n   * See http://resources.aleph-1.com/mask/\r\n   * @class fabric.Image.filters.Mask\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.Mask#initialize} for constructor definition\r\n   */\r\n  fabric.Image.filters.Mask = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Mask.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Mask',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Mask.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {fabric.Image} [options.mask] Mask image object\r\n     * @param {Number} [options.channel=0] Rgb channel (0, 1, 2 or 3)\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.mask = options.mask;\r\n      this.channel = [ 0, 1, 2, 3 ].indexOf(options.channel) > -1 ? options.channel : 0;\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      if (!this.mask) {\r\n        return;\r\n      }\r\n\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          maskEl = this.mask.getElement(),\r\n          maskCanvasEl = fabric.util.createCanvasElement(),\r\n          channel = this.channel,\r\n          i,\r\n          iLen = imageData.width * imageData.height * 4;\r\n\r\n      maskCanvasEl.width = maskEl.width;\r\n      maskCanvasEl.height = maskEl.height;\r\n\r\n      maskCanvasEl.getContext('2d').drawImage(maskEl, 0, 0, maskEl.width, maskEl.height);\r\n\r\n      var maskImageData = maskCanvasEl.getContext('2d').getImageData(0, 0, maskEl.width, maskEl.height),\r\n          maskData = maskImageData.data;\r\n\r\n      for (i = 0; i < iLen; i += 4) {\r\n        data[i + 3] = maskData[i + channel];\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        mask: this.mask.toObject(),\r\n        channel: this.channel\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @param {Function} [callback] Callback to invoke when a mask filter instance is created\r\n   */\r\n  fabric.Image.filters.Mask.fromObject = function(object, callback) {\r\n    fabric.util.loadImage(object.mask.src, function(img) {\r\n      object.mask = new fabric.Image(img, object.mask);\r\n      callback && callback(new fabric.Image.filters.Mask(object));\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Indicates that instances of this type are async\r\n   * @static\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  fabric.Image.filters.Mask.async = true;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Noise filter class\r\n   * @class fabric.Image.filters.Noise\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Noise({\r\n   *   noise: 700\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Noise = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Noise',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Noise.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {Number} [options.noise=0] Noise value\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n      this.noise = options.noise || 0;\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          noise = this.noise, rand;\r\n\r\n      for (var i = 0, len = data.length; i < len; i += 4) {\r\n\r\n        rand = (0.5 - Math.random()) * noise;\r\n\r\n        data[i] += rand;\r\n        data[i + 1] += rand;\r\n        data[i + 2] += rand;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        noise: this.noise\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise\r\n   */\r\n  fabric.Image.filters.Noise.fromObject = function(object) {\r\n    return new fabric.Image.filters.Noise(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Pixelate filter class\r\n   * @class fabric.Image.filters.Pixelate\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Pixelate({\r\n   *   blocksize: 8\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Pixelate = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Pixelate',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Pixelate.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {Number} [options.blocksize=4] Blocksize for pixelate\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n      this.blocksize = options.blocksize || 4;\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          iLen = imageData.height,\r\n          jLen = imageData.width,\r\n          index, i, j, r, g, b, a;\r\n\r\n      for (i = 0; i < iLen; i += this.blocksize) {\r\n        for (j = 0; j < jLen; j += this.blocksize) {\r\n\r\n          index = (i * 4) * jLen + (j * 4);\r\n\r\n          r = data[index];\r\n          g = data[index + 1];\r\n          b = data[index + 2];\r\n          a = data[index + 3];\r\n\r\n          /*\r\n           blocksize: 4\r\n\r\n           [1,x,x,x,1]\r\n           [x,x,x,x,1]\r\n           [x,x,x,x,1]\r\n           [x,x,x,x,1]\r\n           [1,1,1,1,1]\r\n           */\r\n\r\n          for (var _i = i, _ilen = i + this.blocksize; _i < _ilen; _i++) {\r\n            for (var _j = j, _jlen = j + this.blocksize; _j < _jlen; _j++) {\r\n              index = (_i * 4) * jLen + (_j * 4);\r\n              data[index] = r;\r\n              data[index + 1] = g;\r\n              data[index + 2] = b;\r\n              data[index + 3] = a;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        blocksize: this.blocksize\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate\r\n   */\r\n  fabric.Image.filters.Pixelate.fromObject = function(object) {\r\n    return new fabric.Image.filters.Pixelate(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Remove white filter class\r\n   * @class fabric.Image.filters.RemoveWhite\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.RemoveWhite#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.RemoveWhite({\r\n   *   threshold: 40,\r\n   *   distance: 140\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.RemoveWhite = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.RemoveWhite.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'RemoveWhite',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.RemoveWhite.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {Number} [options.threshold=30] Threshold value\r\n     * @param {Number} [options.distance=20] Distance value\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n      this.threshold = options.threshold || 30;\r\n      this.distance = options.distance || 20;\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          threshold = this.threshold,\r\n          distance = this.distance,\r\n          limit = 255 - threshold,\r\n          abs = Math.abs,\r\n          r, g, b;\r\n\r\n      for (var i = 0, len = data.length; i < len; i += 4) {\r\n        r = data[i];\r\n        g = data[i + 1];\r\n        b = data[i + 2];\r\n\r\n        if (r > limit &&\r\n            g > limit &&\r\n            b > limit &&\r\n            abs(r - g) < distance &&\r\n            abs(r - b) < distance &&\r\n            abs(g - b) < distance\r\n        ) {\r\n          data[i + 3] = 1;\r\n        }\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        threshold: this.threshold,\r\n        distance: this.distance\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.RemoveWhite} Instance of fabric.Image.filters.RemoveWhite\r\n   */\r\n  fabric.Image.filters.RemoveWhite.fromObject = function(object) {\r\n    return new fabric.Image.filters.RemoveWhite(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { });\r\n\r\n  /**\r\n   * Sepia filter class\r\n   * @class fabric.Image.filters.Sepia\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Sepia();\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Sepia = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Sepia.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Sepia',\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @memberOf fabric.Image.filters.Sepia.prototype\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          iLen = data.length, i, avg;\r\n\r\n      for (i = 0; i < iLen; i+=4) {\r\n        avg = 0.3  * data[i] + 0.59 * data[i + 1] + 0.11 * data[i + 2];\r\n        data[i] = avg + 100;\r\n        data[i + 1] = avg + 50;\r\n        data[i + 2] = avg + 255;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @return {fabric.Image.filters.Sepia} Instance of fabric.Image.filters.Sepia\r\n   */\r\n  fabric.Image.filters.Sepia.fromObject = function() {\r\n    return new fabric.Image.filters.Sepia();\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { });\r\n\r\n  /**\r\n   * Sepia2 filter class\r\n   * @class fabric.Image.filters.Sepia2\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Sepia2();\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Sepia2 = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Sepia2.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Sepia2',\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @memberOf fabric.Image.filters.Sepia.prototype\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          iLen = data.length, i, r, g, b;\r\n\r\n      for (i = 0; i < iLen; i+=4) {\r\n        r = data[i];\r\n        g = data[i + 1];\r\n        b = data[i + 2];\r\n\r\n        data[i] = (r * 0.393 + g * 0.769 + b * 0.189 ) / 1.351;\r\n        data[i + 1] = (r * 0.349 + g * 0.686 + b * 0.168 ) / 1.203;\r\n        data[i + 2] = (r * 0.272 + g * 0.534 + b * 0.131 ) / 2.140;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @return {fabric.Image.filters.Sepia2} Instance of fabric.Image.filters.Sepia2\r\n   */\r\n  fabric.Image.filters.Sepia2.fromObject = function() {\r\n    return new fabric.Image.filters.Sepia2();\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Tint filter class\r\n   * Adapted from <a href=\"https://github.com/mezzoblue/PaintbrushJS\">https://github.com/mezzoblue/PaintbrushJS</a>\r\n   * @class fabric.Image.filters.Tint\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.Tint#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example <caption>Tint filter with hex color and opacity</caption>\r\n   * var filter = new fabric.Image.filters.Tint({\r\n   *   color: '#3513B0',\r\n   *   opacity: 0.5\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   * @example <caption>Tint filter with rgba color</caption>\r\n   * var filter = new fabric.Image.filters.Tint({\r\n   *   color: 'rgba(53, 21, 176, 0.5)'\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Tint = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Tint.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Tint',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Tint.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {String} [options.color=#000000] Color to tint the image with\r\n     * @param {Number} [options.opacity] Opacity value that controls the tint effect's transparency (0..1)\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.color = options.color || '#000000';\r\n      this.opacity = typeof options.opacity !== 'undefined'\r\n                      ? options.opacity\r\n                      : new fabric.Color(this.color).getAlpha();\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          iLen = data.length, i,\r\n          tintR, tintG, tintB,\r\n          r, g, b, alpha1,\r\n          source;\r\n\r\n      source = new fabric.Color(this.color).getSource();\r\n\r\n      tintR = source[0] * this.opacity;\r\n      tintG = source[1] * this.opacity;\r\n      tintB = source[2] * this.opacity;\r\n\r\n      alpha1 = 1 - this.opacity;\r\n\r\n      for (i = 0; i < iLen; i+=4) {\r\n        r = data[i];\r\n        g = data[i + 1];\r\n        b = data[i + 2];\r\n\r\n        // alpha compositing\r\n        data[i] = tintR + r * alpha1;\r\n        data[i + 1] = tintG + g * alpha1;\r\n        data[i + 2] = tintB + b * alpha1;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        color: this.color,\r\n        opacity: this.opacity\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.Tint} Instance of fabric.Image.filters.Tint\r\n   */\r\n  fabric.Image.filters.Tint.fromObject = function(object) {\r\n    return new fabric.Image.filters.Tint(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Multiply filter class\r\n   * Adapted from <a href=\"http://www.laurenscorijn.com/articles/colormath-basics\">http://www.laurenscorijn.com/articles/colormath-basics</a>\r\n   * @class fabric.Image.filters.Multiply\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @example <caption>Multiply filter with hex color</caption>\r\n   * var filter = new fabric.Image.filters.Multiply({\r\n   *   color: '#F0F'\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   * @example <caption>Multiply filter with rgb color</caption>\r\n   * var filter = new fabric.Image.filters.Multiply({\r\n   *   color: 'rgb(53, 21, 176)'\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Multiply = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Multiply.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Multiply',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Multiply.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {String} [options.color=#000000] Color to multiply the image pixels with\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.color = options.color || '#000000';\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          iLen = data.length, i,\r\n          source;\r\n\r\n      source = new fabric.Color(this.color).getSource();\r\n\r\n      for (i = 0; i < iLen; i+=4) {\r\n        data[i] *= source[0] / 255;\r\n        data[i + 1] *= source[1] / 255;\r\n        data[i + 2] *= source[2] / 255;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        color: this.color\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.Multiply} Instance of fabric.Image.filters.Multiply\r\n   */\r\n  fabric.Image.filters.Multiply.fromObject = function(object) {\r\n    return new fabric.Image.filters.Multiply(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n  'use strict';\r\n\r\n  var fabric = global.fabric;\r\n\r\n  /**\r\n   * Color Blend filter class\r\n   * @class fabric.Image.filter.Blend\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Blend({\r\n   *  color: '#000',\r\n   *  mode: 'multiply'\r\n   * });\r\n   *\r\n   * var filter = new fabric.Image.filters.Blend({\r\n   *  image: fabricImageObject,\r\n   *  mode: 'multiply',\r\n   *  alpha: 0.5\r\n   * });\r\n\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Blend = fabric.util.createClass({\r\n    type: 'Blend',\r\n\r\n    initialize: function(options) {\r\n      options = options || {};\r\n      this.color = options.color || '#000';\r\n      this.image = options.image || false;\r\n      this.mode = options.mode || 'multiply';\r\n      this.alpha = options.alpha || 1;\r\n    },\r\n\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          tr, tg, tb,\r\n          r, g, b,\r\n          _r, _g, _b,\r\n          source,\r\n          isImage = false;\r\n\r\n      if (this.image) {\r\n        // Blend images\r\n        isImage = true;\r\n\r\n        var _el = fabric.util.createCanvasElement();\r\n        _el.width = this.image.width;\r\n        _el.height = this.image.height;\r\n\r\n        var tmpCanvas = new fabric.StaticCanvas(_el);\r\n        tmpCanvas.add(this.image);\r\n        var context2 =  tmpCanvas.getContext('2d');\r\n        source = context2.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height).data;\r\n      }\r\n      else {\r\n        // Blend color\r\n        source = new fabric.Color(this.color).getSource();\r\n\r\n        tr = source[0] * this.alpha;\r\n        tg = source[1] * this.alpha;\r\n        tb = source[2] * this.alpha;\r\n      }\r\n\r\n      for (var i = 0, len = data.length; i < len; i += 4) {\r\n\r\n        r = data[i];\r\n        g = data[i + 1];\r\n        b = data[i + 2];\r\n\r\n        if (isImage) {\r\n          tr = source[i] * this.alpha;\r\n          tg = source[i + 1] * this.alpha;\r\n          tb = source[i + 2] * this.alpha;\r\n        }\r\n\r\n        switch (this.mode) {\r\n          case 'multiply':\r\n            data[i] = r * tr / 255;\r\n            data[i + 1] = g * tg / 255;\r\n            data[i + 2] = b * tb / 255;\r\n            break;\r\n          case 'screen':\r\n            data[i] = 1 - (1 - r) * (1 - tr);\r\n            data[i + 1] = 1 - (1 - g) * (1 - tg);\r\n            data[i + 2] = 1 - (1 - b) * (1 - tb);\r\n            break;\r\n          case 'add':\r\n            data[i] = Math.min(255, r + tr);\r\n            data[i + 1] = Math.min(255, g + tg);\r\n            data[i + 2] = Math.min(255, b + tb);\r\n            break;\r\n          case 'diff':\r\n          case 'difference':\r\n            data[i] = Math.abs(r - tr);\r\n            data[i + 1] = Math.abs(g - tg);\r\n            data[i + 2] = Math.abs(b - tb);\r\n            break;\r\n          case 'subtract':\r\n            _r = r - tr;\r\n            _g = g - tg;\r\n            _b = b - tb;\r\n\r\n            data[i] = (_r < 0) ? 0 : _r;\r\n            data[i + 1] = (_g < 0) ? 0 : _g;\r\n            data[i + 2] = (_b < 0) ? 0 : _b;\r\n            break;\r\n          case 'darken':\r\n            data[i] = Math.min(r, tr);\r\n            data[i + 1] = Math.min(g, tg);\r\n            data[i + 2] = Math.min(b, tb);\r\n            break;\r\n          case 'lighten':\r\n            data[i] = Math.max(r, tr);\r\n            data[i + 1] = Math.max(g, tg);\r\n            data[i + 2] = Math.max(b, tb);\r\n            break;\r\n        }\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return {\r\n        color: this.color,\r\n        image: this.image,\r\n        mode: this.mode,\r\n        alpha: this.alpha\r\n      };\r\n    }\r\n  });\r\n\r\n  fabric.Image.filters.Blend.fromObject = function(object) {\r\n    return new fabric.Image.filters.Blend(object);\r\n  };\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,\r\n      sqrt = Math.sqrt, abs = Math.abs, max = Math.max, round = Math.round, sin = Math.sin,\r\n      ceil = Math.ceil;\r\n\r\n  /**\r\n   * Resize image filter class\r\n   * @class fabric.Image.filters.Resize\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Resize();\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Resize = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Resize',\r\n\r\n    /**\r\n     * Resize type\r\n     * @param {String} resizeType\r\n     * @default\r\n     */\r\n    resizeType: 'hermite',\r\n\r\n    /**\r\n     * Scale factor for resizing, x axis\r\n     * @param {Number} scaleX\r\n     * @default\r\n     */\r\n    scaleX: 0,\r\n\r\n    /**\r\n     * Scale factor for resizing, y axis\r\n     * @param {Number} scaleY\r\n     * @default\r\n     */\r\n    scaleY: 0,\r\n\r\n    /**\r\n     * LanczosLobes parameter for lanczos filter\r\n     * @param {Number} lanczosLobes\r\n     * @default\r\n     */\r\n    lanczosLobes: 3,\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @memberOf fabric.Image.filters.Resize.prototype\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl, scaleX, scaleY) {\r\n\r\n      this.rcpScaleX = 1 / scaleX;\r\n      this.rcpScaleY = 1 / scaleY;\r\n\r\n      var oW = canvasEl.width, oH = canvasEl.height,\r\n          dW = round(oW * scaleX), dH = round(oH * scaleY),\r\n          imageData;\r\n\r\n      if (this.resizeType === 'sliceHack') {\r\n        imageData = this.sliceByTwo(canvasEl, oW, oH, dW, dH);\r\n      }\r\n      if (this.resizeType === 'hermite') {\r\n        imageData = this.hermiteFastResize(canvasEl, oW, oH, dW, dH);\r\n      }\r\n      if (this.resizeType === 'bilinear') {\r\n        imageData = this.bilinearFiltering(canvasEl, oW, oH, dW, dH);\r\n      }\r\n      if (this.resizeType === 'lanczos') {\r\n        imageData = this.lanczosResize(canvasEl, oW, oH, dW, dH);\r\n      }\r\n      canvasEl.width = dW;\r\n      canvasEl.height = dH;\r\n      canvasEl.getContext('2d').putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    sliceByTwo: function(canvasEl, width, height, newWidth, newHeight) {\r\n      var context = canvasEl.getContext('2d'), imageData,\r\n          multW = 0.5, multH = 0.5, signW = 1, signH = 1,\r\n          doneW = false, doneH = false, stepW = width, stepH = height,\r\n          tmpCanvas = fabric.util.createCanvasElement(),\r\n          tmpCtx = tmpCanvas.getContext('2d');\r\n      newWidth = floor(newWidth);\r\n      newHeight = floor(newHeight);\r\n      tmpCanvas.width = max(newWidth, width);\r\n      tmpCanvas.height = max(newHeight, height);\r\n\r\n      if (newWidth > width) {\r\n        multW = 2;\r\n        signW = -1;\r\n      }\r\n      if (newHeight > height) {\r\n        multH = 2;\r\n        signH = -1;\r\n      }\r\n      imageData = context.getImageData(0, 0, width, height);\r\n      canvasEl.width = max(newWidth, width);\r\n      canvasEl.height = max(newHeight, height);\r\n      context.putImageData(imageData, 0, 0);\r\n\r\n      while (!doneW || !doneH) {\r\n        width = stepW;\r\n        height = stepH;\r\n        if (newWidth * signW < floor(stepW * multW * signW)) {\r\n          stepW = floor(stepW * multW);\r\n        }\r\n        else {\r\n          stepW = newWidth;\r\n          doneW = true;\r\n        }\r\n        if (newHeight * signH < floor(stepH * multH * signH)) {\r\n          stepH = floor(stepH * multH);\r\n        }\r\n        else {\r\n          stepH = newHeight;\r\n          doneH = true;\r\n        }\r\n        imageData = context.getImageData(0, 0, width, height);\r\n        tmpCtx.putImageData(imageData, 0, 0);\r\n        context.clearRect(0, 0, stepW, stepH);\r\n        context.drawImage(tmpCanvas, 0, 0, width, height, 0, 0, stepW, stepH);\r\n      }\r\n      return context.getImageData(0, 0, newWidth, newHeight);\r\n    },\r\n\r\n    lanczosResize: function(canvasEl, oW, oH, dW, dH) {\r\n\r\n      function lanczosCreate(lobes) {\r\n        return function(x) {\r\n          if (x > lobes) {\r\n            return 0;\r\n          }\r\n          x *= Math.PI;\r\n          if (abs(x) < 1e-16) {\r\n            return 1;\r\n          }\r\n          var xx = x / lobes;\r\n          return sin(x) * sin(xx) / x / xx;\r\n        };\r\n      }\r\n\r\n      function process(u) {\r\n        var v, i, weight, idx, a, red, green,\r\n            blue, alpha, fX, fY;\r\n        center.x = (u + 0.5) * ratioX;\r\n        icenter.x = floor(center.x);\r\n        for (v = 0; v < dH; v++) {\r\n          center.y = (v + 0.5) * ratioY;\r\n          icenter.y = floor(center.y);\r\n          a = 0, red = 0, green = 0, blue = 0, alpha = 0;\r\n          for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {\r\n            if (i < 0 || i >= oW) {\r\n              continue;\r\n            }\r\n            fX = floor(1000 * abs(i - center.x));\r\n            if (!cacheLanc[fX]) {\r\n              cacheLanc[fX] = { };\r\n            }\r\n            for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {\r\n              if (j < 0 || j >= oH) {\r\n                continue;\r\n              }\r\n              fY = floor(1000 * abs(j - center.y));\r\n              if (!cacheLanc[fX][fY]) {\r\n                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);\r\n              }\r\n              weight = cacheLanc[fX][fY];\r\n              if (weight > 0) {\r\n                idx = (j * oW + i) * 4;\r\n                a += weight;\r\n                red += weight * srcData[idx];\r\n                green += weight * srcData[idx + 1];\r\n                blue += weight * srcData[idx + 2];\r\n                alpha += weight * srcData[idx + 3];\r\n              }\r\n            }\r\n          }\r\n          idx = (v * dW + u) * 4;\r\n          destData[idx] = red / a;\r\n          destData[idx + 1] = green / a;\r\n          destData[idx + 2] = blue / a;\r\n          destData[idx + 3] = alpha / a;\r\n        }\r\n\r\n        if (++u < dW) {\r\n          return process(u);\r\n        }\r\n        else {\r\n          return destImg;\r\n        }\r\n      }\r\n\r\n      var context = canvasEl.getContext('2d'),\r\n          srcImg = context.getImageData(0, 0, oW, oH),\r\n          destImg = context.getImageData(0, 0, dW, dH),\r\n          srcData = srcImg.data, destData = destImg.data,\r\n          lanczos = lanczosCreate(this.lanczosLobes),\r\n          ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,\r\n          rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,\r\n          range2X = ceil(ratioX * this.lanczosLobes / 2),\r\n          range2Y = ceil(ratioY * this.lanczosLobes / 2),\r\n          cacheLanc = { }, center = { }, icenter = { };\r\n\r\n      return process(0);\r\n    },\r\n\r\n    bilinearFiltering: function(canvasEl, w, h, w2, h2) {\r\n      var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,\r\n          color, offset = 0, origPix, ratioX = this.rcpScaleX,\r\n          ratioY = this.rcpScaleY, context = canvasEl.getContext('2d'),\r\n          w4 = 4 * (w - 1), img = context.getImageData(0, 0, w, h),\r\n          pixels = img.data, destImage = context.getImageData(0, 0, w2, h2),\r\n          destPixels = destImage.data;\r\n      for (i = 0; i < h2; i++) {\r\n        for (j = 0; j < w2; j++) {\r\n          x = floor(ratioX * j);\r\n          y = floor(ratioY * i);\r\n          xDiff = ratioX * j - x;\r\n          yDiff = ratioY * i - y;\r\n          origPix = 4 * (y * w + x);\r\n\r\n          for (chnl = 0; chnl < 4; chnl++) {\r\n            a = pixels[origPix + chnl];\r\n            b = pixels[origPix + 4 + chnl];\r\n            c = pixels[origPix + w4 + chnl];\r\n            d = pixels[origPix + w4 + 4 + chnl];\r\n            color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +\r\n                    c * yDiff * (1 - xDiff) + d * xDiff * yDiff;\r\n            destPixels[offset++] = color;\r\n          }\r\n        }\r\n      }\r\n      return destImage;\r\n    },\r\n\r\n    hermiteFastResize: function(canvasEl, oW, oH, dW, dH) {\r\n      var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,\r\n          ratioWHalf = ceil(ratioW / 2),\r\n          ratioHHalf = ceil(ratioH / 2),\r\n          context = canvasEl.getContext('2d'),\r\n          img = context.getImageData(0, 0, oW, oH), data = img.data,\r\n          img2 = context.getImageData(0, 0, dW, dH), data2 = img2.data;\r\n      for (var j = 0; j < dH; j++) {\r\n        for (var i = 0; i < dW; i++) {\r\n          var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,\r\n              gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;\r\n          for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {\r\n            var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,\r\n                centerX = (i + 0.5) * ratioW, w0 = dy * dy;\r\n            for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {\r\n              var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,\r\n                  w = sqrt(w0 + dx * dx);\r\n              /*jshint maxdepth:5 */\r\n              if (w > 1 && w < -1) {\r\n                continue;\r\n              }\r\n              //hermite filter\r\n              weight = 2 * w * w * w - 3 * w * w + 1;\r\n              if (weight > 0) {\r\n                dx = 4 * (xx + yy * oW);\r\n                //alpha\r\n                gxA += weight * data[dx + 3];\r\n                weightsAlpha += weight;\r\n                //colors\r\n                /*jshint maxdepth:6 */\r\n                if (data[dx + 3] < 255) {\r\n                  weight = weight * data[dx + 3] / 250;\r\n                }\r\n                /*jshint maxdepth:5 */\r\n                gxR += weight * data[dx];\r\n                gxG += weight * data[dx + 1];\r\n                gxB += weight * data[dx + 2];\r\n                weights += weight;\r\n              }\r\n              /*jshint maxdepth:4 */\r\n            }\r\n          }\r\n          data2[x2] = gxR / weights;\r\n          data2[x2 + 1] = gxG / weights;\r\n          data2[x2 + 2] = gxB / weights;\r\n          data2[x2 + 3] = gxA / weightsAlpha;\r\n        }\r\n      }\r\n      return img2;\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return {\r\n        type: this.type,\r\n        scaleX: this.scaleX,\r\n        scaleY: this.scaleY,\r\n        resizeType: this.resizeType,\r\n        lanczosLobes: this.lanczosLobes\r\n      };\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize\r\n   */\r\n  fabric.Image.filters.Resize.fromObject = function(object) {\r\n    return new fabric.Image.filters.Resize(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      clone = fabric.util.object.clone,\r\n      toFixed = fabric.util.toFixed,\r\n      supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),\r\n      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\r\n\r\n  if (fabric.Text) {\r\n    fabric.warn('fabric.Text is already defined');\r\n    return;\r\n  }\r\n\r\n  var stateProperties = fabric.Object.prototype.stateProperties.concat();\r\n  stateProperties.push(\r\n    'fontFamily',\r\n    'fontWeight',\r\n    'fontSize',\r\n    'text',\r\n    'textDecoration',\r\n    'textAlign',\r\n    'fontStyle',\r\n    'lineHeight',\r\n    'textBackgroundColor'\r\n  );\r\n\r\n  /**\r\n   * Text class\r\n   * @class fabric.Text\r\n   * @extends fabric.Object\r\n   * @return {fabric.Text} thisArg\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#text}\r\n   * @see {@link fabric.Text#initialize} for constructor definition\r\n   */\r\n  fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {\r\n\r\n    /**\r\n     * Properties which when set cause object to change dimensions\r\n     * @type Object\r\n     * @private\r\n     */\r\n    _dimensionAffectingProps: {\r\n      fontSize: true,\r\n      fontWeight: true,\r\n      fontFamily: true,\r\n      fontStyle: true,\r\n      lineHeight: true,\r\n      stroke: true,\r\n      strokeWidth: true,\r\n      text: true,\r\n      textAlign: true\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _reNewline: /\\r?\\n/,\r\n\r\n    /**\r\n     * Use this regular expression to filter for whitespace that is not a new line.\r\n     * Mostly used when text is 'justify' aligned.\r\n     * @private\r\n     */\r\n    _reSpacesAndTabs: /[ \\t\\r]+/g,\r\n\r\n    /**\r\n     * Retrieves object's fontSize\r\n     * @method getFontSize\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} Font size (in pixels)\r\n     */\r\n\r\n    /**\r\n     * Sets object's fontSize\r\n     * @method setFontSize\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {Number} fontSize Font size (in pixels)\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's fontWeight\r\n     * @method getFontWeight\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {(String|Number)} Font weight\r\n     */\r\n\r\n    /**\r\n     * Sets object's fontWeight\r\n     * @method setFontWeight\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {(Number|String)} fontWeight Font weight\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's fontFamily\r\n     * @method getFontFamily\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} Font family\r\n     */\r\n\r\n    /**\r\n     * Sets object's fontFamily\r\n     * @method setFontFamily\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {String} fontFamily Font family\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's text\r\n     * @method getText\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} text\r\n     */\r\n\r\n    /**\r\n     * Sets object's text\r\n     * @method setText\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {String} text Text\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's textDecoration\r\n     * @method getTextDecoration\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} Text decoration\r\n     */\r\n\r\n    /**\r\n     * Sets object's textDecoration\r\n     * @method setTextDecoration\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {String} textDecoration Text decoration\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's fontStyle\r\n     * @method getFontStyle\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} Font style\r\n     */\r\n\r\n    /**\r\n     * Sets object's fontStyle\r\n     * @method setFontStyle\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {String} fontStyle Font style\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's lineHeight\r\n     * @method getLineHeight\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {Number} Line height\r\n     */\r\n\r\n    /**\r\n     * Sets object's lineHeight\r\n     * @method setLineHeight\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {Number} lineHeight Line height\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's textAlign\r\n     * @method getTextAlign\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} Text alignment\r\n     */\r\n\r\n    /**\r\n     * Sets object's textAlign\r\n     * @method setTextAlign\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {String} textAlign Text alignment\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's textBackgroundColor\r\n     * @method getTextBackgroundColor\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} Text background color\r\n     */\r\n\r\n    /**\r\n     * Sets object's textBackgroundColor\r\n     * @method setTextBackgroundColor\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {String} textBackgroundColor Text background color\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type:                 'text',\r\n\r\n    /**\r\n     * Font size (in pixels)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    fontSize:             40,\r\n\r\n    /**\r\n     * Font weight (e.g. bold, normal, 400, 600, 800)\r\n     * @type {(Number|String)}\r\n     * @default\r\n     */\r\n    fontWeight:           'normal',\r\n\r\n    /**\r\n     * Font family\r\n     * @type String\r\n     * @default\r\n     */\r\n    fontFamily:           'Times New Roman',\r\n\r\n    /**\r\n     * Text decoration Possible values: \"\", \"underline\", \"overline\" or \"line-through\".\r\n     * @type String\r\n     * @default\r\n     */\r\n    textDecoration:       '',\r\n\r\n    /**\r\n     * Text alignment. Possible values: \"left\", \"center\", or \"right\".\r\n     * @type String\r\n     * @default\r\n     */\r\n    textAlign:            'left',\r\n\r\n    /**\r\n     * Font style . Possible values: \"\", \"normal\", \"italic\" or \"oblique\".\r\n     * @type String\r\n     * @default\r\n     */\r\n    fontStyle:            '',\r\n\r\n    /**\r\n     * Line height\r\n     * @type Number\r\n     * @default\r\n     */\r\n    lineHeight:           1.16,\r\n\r\n    /**\r\n     * Background color of text lines\r\n     * @type String\r\n     * @default\r\n     */\r\n    textBackgroundColor:  '',\r\n\r\n    /**\r\n     * List of properties to consider when checking if\r\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\r\n     * as well as for history (undo/redo) purposes\r\n     * @type Array\r\n     */\r\n    stateProperties:      stateProperties,\r\n\r\n    /**\r\n     * When defined, an object is rendered via stroke and this property specifies its color.\r\n     * <b>Backwards incompatibility note:</b> This property was named \"strokeStyle\" until v1.1.6\r\n     * @type String\r\n     * @default\r\n     */\r\n    stroke:               null,\r\n\r\n    /**\r\n     * Shadow object representing shadow of this shape.\r\n     * <b>Backwards incompatibility note:</b> This property was named \"textShadow\" (String) until v1.2.11\r\n     * @type fabric.Shadow\r\n     * @default\r\n     */\r\n    shadow:               null,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _fontSizeFraction: 0.25,\r\n\r\n    /**\r\n     * Text Line proportion to font Size (in pixels)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    _fontSizeMult:             1.13,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {String} text Text string\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Text} thisArg\r\n     */\r\n    initialize: function(text, options) {\r\n      options = options || { };\r\n      this.text = text;\r\n      this.__skipDimension = true;\r\n      this.setOptions(options);\r\n      this.__skipDimension = false;\r\n      this._initDimensions();\r\n    },\r\n\r\n    /**\r\n     * Renders text object on offscreen canvas, so that it would get dimensions\r\n     * @private\r\n     */\r\n    _initDimensions: function(ctx) {\r\n      if (this.__skipDimension) {\r\n        return;\r\n      }\r\n      if (!ctx) {\r\n        ctx = fabric.util.createCanvasElement().getContext('2d');\r\n        this._setTextStyles(ctx);\r\n      }\r\n      this._textLines = this._splitTextIntoLines();\r\n      this._clearCache();\r\n      //if textAlign is 'justify' i have to disable caching\r\n      //when calculating width of text and widths of line.\r\n      this._cacheLinesWidth = (this.textAlign !== 'justify');\r\n      this.width = this._getTextWidth(ctx);\r\n      this._cacheLinesWidth = true;\r\n      this.height = this._getTextHeight(ctx);\r\n    },\r\n\r\n    /**\r\n     * Returns string representation of an instance\r\n     * @return {String} String representation of text object\r\n     */\r\n    toString: function() {\r\n      return '#<fabric.Text (' + this.complexity() +\r\n        '): { \"text\": \"' + this.text + '\", \"fontFamily\": \"' + this.fontFamily + '\" }>';\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx) {\r\n      this.clipTo && fabric.util.clipContext(this, ctx);\r\n      this._setOpacity(ctx);\r\n      this._setShadow(ctx);\r\n      this._setupCompositeOperation(ctx);\r\n      this._renderTextBackground(ctx);\r\n      this._setStrokeStyles(ctx);\r\n      this._setFillStyles(ctx);\r\n      this._renderText(ctx);\r\n      this._renderTextDecoration(ctx);\r\n      this.clipTo && ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderText: function(ctx) {\r\n\r\n      this._translateForTextAlign(ctx);\r\n      this._renderTextFill(ctx);\r\n      this._renderTextStroke(ctx);\r\n      this._translateForTextAlign(ctx, true);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Boolean} back Indicates if translate back or forward\r\n     */\r\n    _translateForTextAlign: function(ctx, back) {\r\n      if (this.textAlign !== 'left' && this.textAlign !== 'justify') {\r\n        var sign = back ? -1 : 1;\r\n        ctx.translate(this.textAlign === 'center' ? (sign * this.width / 2) : sign * this.width, 0);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _setTextStyles: function(ctx) {\r\n      ctx.textBaseline = 'alphabetic';\r\n      if (!this.skipTextAlign) {\r\n        ctx.textAlign = this.textAlign;\r\n      }\r\n      ctx.font = this._getFontDeclaration();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @return {Number} Height of fabric.Text object\r\n     */\r\n    _getTextHeight: function() {\r\n      return this._textLines.length * this._getHeightOfLine();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @return {Number} Maximum width of fabric.Text object\r\n     */\r\n    _getTextWidth: function(ctx) {\r\n      var maxWidth = this._getLineWidth(ctx, 0);\r\n\r\n      for (var i = 1, len = this._textLines.length; i < len; i++) {\r\n        var currentLineWidth = this._getLineWidth(ctx, i);\r\n        if (currentLineWidth > maxWidth) {\r\n          maxWidth = currentLineWidth;\r\n        }\r\n      }\r\n      return maxWidth;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {String} chars Chars to render\r\n     * @param {Number} left Left position of text\r\n     * @param {Number} top Top position of text\r\n     */\r\n    _renderChars: function(method, ctx, chars, left, top) {\r\n      // remove Text word from method var\r\n      var shortM = method.slice(0, -4);\r\n      if (this[shortM].toLive) {\r\n        var offsetX = -this.width / 2 + this[shortM].offsetX || 0,\r\n            offsetY = -this.height / 2 + this[shortM].offsetY || 0;\r\n        ctx.save();\r\n        ctx.translate(offsetX, offsetY);\r\n        left -= offsetX;\r\n        top -= offsetY;\r\n      }\r\n      ctx[method](chars, left, top);\r\n      this[shortM].toLive && ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {String} line Text to render\r\n     * @param {Number} left Left position of text\r\n     * @param {Number} top Top position of text\r\n     * @param {Number} lineIndex Index of a line in a text\r\n     */\r\n    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {\r\n      // lift the line by quarter of fontSize\r\n      top -= this.fontSize * this._fontSizeFraction;\r\n\r\n      // short-circuit\r\n      var lineWidth = this._getLineWidth(ctx, lineIndex);\r\n      if (this.textAlign !== 'justify' || this.width < lineWidth) {\r\n        this._renderChars(method, ctx, line, left, top, lineIndex);\r\n        return;\r\n      }\r\n\r\n      // stretch the line\r\n      var words = line.split(/\\s+/),\r\n          wordsWidth = this._getWidthOfWords(ctx, line, lineIndex),\r\n          widthDiff = this.width - wordsWidth,\r\n          numSpaces = words.length - 1,\r\n          spaceWidth = numSpaces > 0 ? widthDiff / numSpaces : 0,\r\n          leftOffset = 0, charOffset = 0, word;\r\n\r\n      for (var i = 0, len = words.length; i < len; i++) {\r\n        while (line[charOffset] === ' ' && charOffset < line.length) {\r\n          charOffset++;\r\n        }\r\n        word = words[i];\r\n        this._renderChars(method, ctx, word, left + leftOffset, top, lineIndex, charOffset);\r\n        leftOffset += ctx.measureText(word).width + spaceWidth;\r\n        charOffset += word.length;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Number} line\r\n     */\r\n    _getWidthOfWords: function (ctx, line) {\r\n      return ctx.measureText(line.replace(/\\s+/g, '')).width;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @return {Number} Left offset\r\n     */\r\n    _getLeftOffset: function() {\r\n      return -this.width / 2;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @return {Number} Top offset\r\n     */\r\n    _getTopOffset: function() {\r\n      return -this.height / 2;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextFill: function(ctx) {\r\n      if (!this.fill && !this._skipFillStrokeCheck) {\r\n        return;\r\n      }\r\n\r\n      var lineHeights = 0;\r\n\r\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n        var heightOfLine = this._getHeightOfLine(ctx, i),\r\n            maxHeight = heightOfLine / this.lineHeight;\r\n\r\n        this._renderTextLine(\r\n          'fillText',\r\n          ctx,\r\n          this._textLines[i],\r\n          this._getLeftOffset(),\r\n          this._getTopOffset() + lineHeights + maxHeight,\r\n          i\r\n        );\r\n        lineHeights += heightOfLine;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextStroke: function(ctx) {\r\n      if ((!this.stroke || this.strokeWidth === 0) && !this._skipFillStrokeCheck) {\r\n        return;\r\n      }\r\n\r\n      var lineHeights = 0;\r\n\r\n      if (this.shadow && !this.shadow.affectStroke) {\r\n        this._removeShadow(ctx);\r\n      }\r\n\r\n      ctx.save();\r\n\r\n      if (this.strokeDashArray) {\r\n        // Spec requires the concatenation of two copies the dash list when the number of elements is odd\r\n        if (1 & this.strokeDashArray.length) {\r\n          this.strokeDashArray.push.apply(this.strokeDashArray, this.strokeDashArray);\r\n        }\r\n        supportsLineDash && ctx.setLineDash(this.strokeDashArray);\r\n      }\r\n\r\n      ctx.beginPath();\r\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n        var heightOfLine = this._getHeightOfLine(ctx, i),\r\n            maxHeight = heightOfLine / this.lineHeight;\r\n\r\n        this._renderTextLine(\r\n          'strokeText',\r\n          ctx,\r\n          this._textLines[i],\r\n          this._getLeftOffset(),\r\n          this._getTopOffset() + lineHeights + maxHeight,\r\n          i\r\n        );\r\n        lineHeights += heightOfLine;\r\n      }\r\n      ctx.closePath();\r\n      ctx.restore();\r\n    },\r\n\r\n    _getHeightOfLine: function() {\r\n      return this.fontSize * this._fontSizeMult * this.lineHeight;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Array} textLines Array of all text lines\r\n     */\r\n    _renderTextBackground: function(ctx) {\r\n      this._renderTextBoxBackground(ctx);\r\n      this._renderTextLinesBackground(ctx);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextBoxBackground: function(ctx) {\r\n      if (!this.backgroundColor) {\r\n        return;\r\n      }\r\n\r\n      ctx.fillStyle = this.backgroundColor;\r\n\r\n      ctx.fillRect(\r\n        this._getLeftOffset(),\r\n        this._getTopOffset(),\r\n        this.width,\r\n        this.height\r\n      );\r\n\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextLinesBackground: function(ctx) {\r\n      if (!this.textBackgroundColor) {\r\n        return;\r\n      }\r\n      var lineTopOffset = 0, heightOfLine = this._getHeightOfLine(),\r\n          lineWidth, lineLeftOffset;\r\n\r\n      ctx.fillStyle = this.textBackgroundColor;\r\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n        if (this._textLines[i] !== '') {\r\n          lineWidth = this._getLineWidth(ctx, i);\r\n          lineLeftOffset = this._getLineLeftOffset(lineWidth);\r\n          ctx.fillRect(\r\n            this._getLeftOffset() + lineLeftOffset,\r\n            this._getTopOffset() + lineTopOffset,\r\n            lineWidth,\r\n            this.fontSize * this._fontSizeMult\r\n          );\r\n        }\r\n        lineTopOffset += heightOfLine;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Number} lineWidth Width of text line\r\n     * @return {Number} Line left offset\r\n     */\r\n    _getLineLeftOffset: function(lineWidth) {\r\n      if (this.textAlign === 'center') {\r\n        return (this.width - lineWidth) / 2;\r\n      }\r\n      if (this.textAlign === 'right') {\r\n        return this.width - lineWidth;\r\n      }\r\n      return 0;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _clearCache: function() {\r\n      this.__lineWidths = [ ];\r\n      this.__lineHeights = [ ];\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _shouldClearCache: function() {\r\n      var shouldClear = false;\r\n      if (this._forceClearCache) {\r\n        this._forceClearCache = false;\r\n        return true;\r\n      }\r\n      for (var prop in this._dimensionAffectingProps) {\r\n        if (this['__' + prop] !== this[prop]) {\r\n          this['__' + prop] = this[prop];\r\n          shouldClear = true;\r\n        }\r\n      }\r\n      return shouldClear;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Number} lineIndex line number\r\n     * @return {Number} Line width\r\n     */\r\n    _getLineWidth: function(ctx, lineIndex) {\r\n      if (this.__lineWidths[lineIndex]) {\r\n        return this.__lineWidths[lineIndex];\r\n      }\r\n      var width, wordCount, line = this._textLines[lineIndex];\r\n      if (line === '') {\r\n        width = 0;\r\n      }\r\n      else if (this.textAlign === 'justify' && this._cacheLinesWidth) {\r\n        wordCount = line.split(' ');\r\n        //consider not justify last line, not for now.\r\n        if (wordCount.length > 1) {\r\n          width = this.width;\r\n        }\r\n        else {\r\n          width = ctx.measureText(line).width;\r\n        }\r\n      }\r\n      else {\r\n        width = ctx.measureText(line).width;\r\n      }\r\n      this._cacheLinesWidth && (this.__lineWidths[lineIndex] = width);\r\n      return width;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextDecoration: function(ctx) {\r\n      if (!this.textDecoration) {\r\n        return;\r\n      }\r\n\r\n      var halfOfVerticalBox = this.height / 2,\r\n          _this = this, offsets = [];\r\n\r\n      /** @ignore */\r\n      function renderLinesAtOffset(offsets) {\r\n        var i, lineHeight = 0, len, j, oLen, lineWidth,\r\n            lineLeftOffset, heightOfLine;\r\n\r\n        for (i = 0, len = _this._textLines.length; i < len; i++) {\r\n\r\n          lineWidth = _this._getLineWidth(ctx, i),\r\n          lineLeftOffset = _this._getLineLeftOffset(lineWidth),\r\n          heightOfLine = _this._getHeightOfLine(ctx, i);\r\n\r\n          for (j = 0, oLen = offsets.length; j < oLen; j++) {\r\n            ctx.fillRect(\r\n              _this._getLeftOffset() + lineLeftOffset,\r\n              lineHeight + (_this._fontSizeMult - 1 + offsets[j] ) * _this.fontSize - halfOfVerticalBox,\r\n              lineWidth,\r\n              _this.fontSize / 15);\r\n          }\r\n          lineHeight += heightOfLine;\r\n        }\r\n      }\r\n\r\n      if (this.textDecoration.indexOf('underline') > -1) {\r\n        offsets.push(0.85); // 1 - 3/16\r\n      }\r\n      if (this.textDecoration.indexOf('line-through') > -1) {\r\n        offsets.push(0.43);\r\n      }\r\n      if (this.textDecoration.indexOf('overline') > -1) {\r\n        offsets.push(-0.12);\r\n      }\r\n      if (offsets.length > 0) {\r\n        renderLinesAtOffset(offsets);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getFontDeclaration: function() {\r\n      return [\r\n        // node-canvas needs \"weight style\", while browsers need \"style weight\"\r\n        (fabric.isLikelyNode ? this.fontWeight : this.fontStyle),\r\n        (fabric.isLikelyNode ? this.fontStyle : this.fontWeight),\r\n        this.fontSize + 'px',\r\n        (fabric.isLikelyNode ? ('\"' + this.fontFamily + '\"') : this.fontFamily)\r\n      ].join(' ');\r\n    },\r\n\r\n    /**\r\n     * Renders text instance on a specified context\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    render: function(ctx, noTransform) {\r\n      // do not render if object is not visible\r\n      if (!this.visible) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n      this._setTextStyles(ctx);\r\n\r\n      if (this._shouldClearCache()) {\r\n        this._initDimensions(ctx);\r\n      }\r\n      if (!noTransform) {\r\n        this.transform(ctx);\r\n      }\r\n      if (this.transformMatrix) {\r\n        ctx.transform.apply(ctx, this.transformMatrix);\r\n      }\r\n      if (this.group && this.group.type === 'path-group') {\r\n        ctx.translate(this.left, this.top);\r\n      }\r\n      this._render(ctx);\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Returns the text as an array of lines.\r\n     * @returns {Array} Lines in the text\r\n     */\r\n    _splitTextIntoLines: function() {\r\n      return this.text.split(this._reNewline);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var object = extend(this.callSuper('toObject', propertiesToInclude), {\r\n        text:                 this.text,\r\n        fontSize:             this.fontSize,\r\n        fontWeight:           this.fontWeight,\r\n        fontFamily:           this.fontFamily,\r\n        fontStyle:            this.fontStyle,\r\n        lineHeight:           this.lineHeight,\r\n        textDecoration:       this.textDecoration,\r\n        textAlign:            this.textAlign,\r\n        textBackgroundColor:  this.textBackgroundColor\r\n      });\r\n      if (!this.includeDefaultValues) {\r\n        this._removeDefaultValues(object);\r\n      }\r\n      return object;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(),\r\n          offsets = this._getSVGLeftTopOffsets(this.ctx),\r\n          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);\r\n      this._wrapSVGTextAndBg(markup, textAndBg);\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getSVGLeftTopOffsets: function(ctx) {\r\n      var lineTop = this._getHeightOfLine(ctx, 0),\r\n          textLeft = -this.width / 2,\r\n          textTop = 0;\r\n\r\n      return {\r\n        textLeft: textLeft + (this.group && this.group.type === 'path-group' ? this.left : 0),\r\n        textTop: textTop + (this.group && this.group.type === 'path-group' ? -this.top : 0),\r\n        lineTop: lineTop\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _wrapSVGTextAndBg: function(markup, textAndBg) {\r\n      markup.push(\r\n        '\\t<g transform=\"', this.getSvgTransform(), this.getSvgTransformMatrix(), '\">\\n',\r\n          textAndBg.textBgRects.join(''),\r\n          '\\t\\t<text ',\r\n            (this.fontFamily ? 'font-family=\"' + this.fontFamily.replace(/\"/g, '\\'') + '\" ': ''),\r\n            (this.fontSize ? 'font-size=\"' + this.fontSize + '\" ': ''),\r\n            (this.fontStyle ? 'font-style=\"' + this.fontStyle + '\" ': ''),\r\n            (this.fontWeight ? 'font-weight=\"' + this.fontWeight + '\" ': ''),\r\n            (this.textDecoration ? 'text-decoration=\"' + this.textDecoration + '\" ': ''),\r\n            'style=\"', this.getSvgStyles(), '\" >',\r\n            textAndBg.textSpans.join(''),\r\n          '</text>\\n',\r\n        '\\t</g>\\n'\r\n      );\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Number} textTopOffset Text top offset\r\n     * @param {Number} textLeftOffset Text left offset\r\n     * @return {Object}\r\n     */\r\n    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {\r\n      var textSpans = [ ],\r\n          textBgRects = [ ],\r\n          height = 0;\r\n      // bounding-box background\r\n      this._setSVGBg(textBgRects);\r\n\r\n      // text and text-background\r\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n        if (this.textBackgroundColor) {\r\n          this._setSVGTextLineBg(textBgRects, i, textLeftOffset, textTopOffset, height);\r\n        }\r\n        this._setSVGTextLineText(i, textSpans, height, textLeftOffset, textTopOffset, textBgRects);\r\n        height += this._getHeightOfLine(this.ctx, i);\r\n      }\r\n\r\n      return {\r\n        textSpans: textSpans,\r\n        textBgRects: textBgRects\r\n      };\r\n    },\r\n\r\n    _setSVGTextLineText: function(i, textSpans, height, textLeftOffset, textTopOffset) {\r\n      var yPos = this.fontSize * (this._fontSizeMult - this._fontSizeFraction)\r\n        - textTopOffset + height - this.height / 2;\r\n      textSpans.push(\r\n        '<tspan x=\"',\r\n          toFixed(textLeftOffset + this._getLineLeftOffset(this._getLineWidth(this.ctx, i)), NUM_FRACTION_DIGITS), '\" ',\r\n          'y=\"',\r\n          toFixed(yPos, NUM_FRACTION_DIGITS),\r\n          '\" ',\r\n          // doing this on <tspan> elements since setting opacity\r\n          // on containing <text> one doesn't work in Illustrator\r\n          this._getFillAttributes(this.fill), '>',\r\n          fabric.util.string.escapeXml(this._textLines[i]),\r\n        '</tspan>'\r\n      );\r\n    },\r\n\r\n    _setSVGTextLineBg: function(textBgRects, i, textLeftOffset, textTopOffset, height) {\r\n      textBgRects.push(\r\n        '\\t\\t<rect ',\r\n          this._getFillAttributes(this.textBackgroundColor),\r\n          ' x=\"',\r\n          toFixed(textLeftOffset + this._getLineLeftOffset(this._getLineWidth(this.ctx, i)), NUM_FRACTION_DIGITS),\r\n          '\" y=\"',\r\n          toFixed(height - this.height / 2, NUM_FRACTION_DIGITS),\r\n          '\" width=\"',\r\n          toFixed(this._getLineWidth(this.ctx, i), NUM_FRACTION_DIGITS),\r\n          '\" height=\"',\r\n          toFixed(this._getHeightOfLine(this.ctx, i) / this.lineHeight, NUM_FRACTION_DIGITS),\r\n        '\"></rect>\\n');\r\n    },\r\n\r\n    _setSVGBg: function(textBgRects) {\r\n      if (this.backgroundColor) {\r\n        textBgRects.push(\r\n          '\\t\\t<rect ',\r\n            this._getFillAttributes(this.backgroundColor),\r\n            ' x=\"',\r\n            toFixed(-this.width / 2, NUM_FRACTION_DIGITS),\r\n            '\" y=\"',\r\n            toFixed(-this.height / 2, NUM_FRACTION_DIGITS),\r\n            '\" width=\"',\r\n            toFixed(this.width, NUM_FRACTION_DIGITS),\r\n            '\" height=\"',\r\n            toFixed(this.height, NUM_FRACTION_DIGITS),\r\n          '\"></rect>\\n');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values\r\n     * we work around it by \"moving\" alpha channel into opacity attribute and setting fill's alpha to 1\r\n     *\r\n     * @private\r\n     * @param {Any} value\r\n     * @return {String}\r\n     */\r\n    _getFillAttributes: function(value) {\r\n      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';\r\n      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {\r\n        return 'fill=\"' + value + '\"';\r\n      }\r\n      return 'opacity=\"' + fillColor.getAlpha() + '\" fill=\"' + fillColor.setAlpha(1).toRgb() + '\"';\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Sets specified property to a specified value\r\n     * @param {String} key\r\n     * @param {Any} value\r\n     * @return {fabric.Text} thisArg\r\n     * @chainable\r\n     */\r\n    _set: function(key, value) {\r\n      this.callSuper('_set', key, value);\r\n\r\n      if (key in this._dimensionAffectingProps) {\r\n        this._initDimensions();\r\n        this.setCoords();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})\r\n   * @static\r\n   * @memberOf fabric.Text\r\n   * @see: http://www.w3.org/TR/SVG/text.html#TextElement\r\n   */\r\n  fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\r\n    'x y dx dy font-family font-style font-weight font-size text-decoration text-anchor'.split(' '));\r\n\r\n  /**\r\n   * Default SVG font size\r\n   * @static\r\n   * @memberOf fabric.Text\r\n   */\r\n  fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;\r\n\r\n  /**\r\n   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)\r\n   * @static\r\n   * @memberOf fabric.Text\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Text} Instance of fabric.Text\r\n   */\r\n  fabric.Text.fromElement = function(element, options) {\r\n    if (!element) {\r\n      return null;\r\n    }\r\n\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES);\r\n    options = fabric.util.object.extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes);\r\n\r\n    options.top = options.top || 0;\r\n    options.left = options.left || 0;\r\n    if ('dx' in parsedAttributes) {\r\n      options.left += parsedAttributes.dx;\r\n    }\r\n    if ('dy' in parsedAttributes) {\r\n      options.top += parsedAttributes.dy;\r\n    }\r\n    if (!('fontSize' in options)) {\r\n      options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\r\n    }\r\n\r\n    if (!options.originX) {\r\n      options.originX = 'left';\r\n    }\r\n    var textContent = element.textContent.replace(/^\\s+|\\s+$|\\n+/g, '').replace(/\\s+/g, ' '),\r\n        text = new fabric.Text(textContent, options),\r\n        /*\r\n          Adjust positioning:\r\n            x/y attributes in SVG correspond to the bottom-left corner of text bounding box\r\n            top/left properties in Fabric correspond to center point of text bounding box\r\n        */\r\n        offX = 0;\r\n\r\n    if (text.originX === 'left') {\r\n      offX = text.getWidth() / 2;\r\n    }\r\n    if (text.originX === 'right') {\r\n      offX = -text.getWidth() / 2;\r\n    }\r\n    text.set({\r\n      left: text.getLeft() + offX,\r\n      top: text.getTop() - text.getHeight() / 2 + text.fontSize * (0.18 + text._fontSizeFraction) /* 0.3 is the old lineHeight */\r\n    });\r\n\r\n    return text;\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns fabric.Text instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Text\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Text} Instance of fabric.Text\r\n   */\r\n  fabric.Text.fromObject = function(object) {\r\n    return new fabric.Text(object.text, clone(object));\r\n  };\r\n\r\n  fabric.util.createAccessors(fabric.Text);\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function() {\r\n\r\n  var clone = fabric.util.object.clone;\r\n\r\n  /**\r\n   * IText class (introduced in <b>v1.4</b>) Events are also fired with \"text:\"\r\n   * prefix when observing canvas.\r\n   * @class fabric.IText\r\n   * @extends fabric.Text\r\n   * @mixes fabric.Observable\r\n   *\r\n   * @fires changed\r\n   * @fires selection:changed\r\n   * @fires editing:entered\r\n   * @fires editing:exited\r\n   *\r\n   * @return {fabric.IText} thisArg\r\n   * @see {@link fabric.IText#initialize} for constructor definition\r\n   *\r\n   * <p>Supported key combinations:</p>\r\n   * <pre>\r\n   *   Move cursor:                    left, right, up, down\r\n   *   Select character:               shift + left, shift + right\r\n   *   Select text vertically:         shift + up, shift + down\r\n   *   Move cursor by word:            alt + left, alt + right\r\n   *   Select words:                   shift + alt + left, shift + alt + right\r\n   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end\r\n   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end\r\n   *   Jump to start/end of text:      cmd + up, cmd + down\r\n   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown\r\n   *   Delete character:               backspace\r\n   *   Delete word:                    alt + backspace\r\n   *   Delete line:                    cmd + backspace\r\n   *   Forward delete:                 delete\r\n   *   Copy text:                      ctrl/cmd + c\r\n   *   Paste text:                     ctrl/cmd + v\r\n   *   Cut text:                       ctrl/cmd + x\r\n   *   Select entire text:             ctrl/cmd + a\r\n   *   Quit editing                    tab or esc\r\n   * </pre>\r\n   *\r\n   * <p>Supported mouse/touch combination</p>\r\n   * <pre>\r\n   *   Position cursor:                click/touch\r\n   *   Create selection:               click/touch & drag\r\n   *   Create selection:               click & shift + click\r\n   *   Select word:                    double click\r\n   *   Select line:                    triple click\r\n   * </pre>\r\n   */\r\n  fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'i-text',\r\n\r\n    /**\r\n     * Index where text selection starts (or where cursor is when there is no selection)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    selectionStart: 0,\r\n\r\n    /**\r\n     * Index where text selection ends\r\n     * @type Number\r\n     * @default\r\n     */\r\n    selectionEnd: 0,\r\n\r\n    /**\r\n     * Color of text selection\r\n     * @type String\r\n     * @default\r\n     */\r\n    selectionColor: 'rgba(17,119,255,0.3)',\r\n\r\n    /**\r\n     * Indicates whether text is in editing mode\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    isEditing: false,\r\n\r\n    /**\r\n     * Indicates whether a text can be edited\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    editable: true,\r\n\r\n    /**\r\n     * Border color of text object while it's in editing mode\r\n     * @type String\r\n     * @default\r\n     */\r\n    editingBorderColor: 'rgba(102,153,255,0.25)',\r\n\r\n    /**\r\n     * Width of cursor (in px)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    cursorWidth: 2,\r\n\r\n    /**\r\n     * Color of default cursor (when not overwritten by character style)\r\n     * @type String\r\n     * @default\r\n     */\r\n    cursorColor: '#333',\r\n\r\n    /**\r\n     * Delay between cursor blink (in ms)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    cursorDelay: 1000,\r\n\r\n    /**\r\n     * Duration of cursor fadein (in ms)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    cursorDuration: 600,\r\n\r\n    /**\r\n     * Object containing character styles\r\n     * (where top-level properties corresponds to line number and 2nd-level properties -- to char number in a line)\r\n     * @type Object\r\n     * @default\r\n     */\r\n    styles: null,\r\n\r\n    /**\r\n     * Indicates whether internal text char widths can be cached\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    caching: true,\r\n\r\n    /**\r\n     * @private\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    _skipFillStrokeCheck: false,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _reSpace: /\\s|\\n/,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _currentCursorOpacity: 0,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _selectionDirection: null,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _abortCursorAnimation: false,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _charWidthsCache: { },\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {String} text Text string\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.IText} thisArg\r\n     */\r\n    initialize: function(text, options) {\r\n      this.styles = options ? (options.styles || { }) : { };\r\n      this.callSuper('initialize', text, options);\r\n      this.initBehavior();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _clearCache: function() {\r\n      this.callSuper('_clearCache');\r\n      this.__maxFontHeights = [ ];\r\n      this.__widthOfSpace = [ ];\r\n    },\r\n\r\n    /**\r\n     * Returns true if object has no styling\r\n     */\r\n    isEmptyStyles: function() {\r\n      if (!this.styles) {\r\n        return true;\r\n      }\r\n      var obj = this.styles;\r\n\r\n      for (var p1 in obj) {\r\n        for (var p2 in obj[p1]) {\r\n          /*jshint unused:false */\r\n          for (var p3 in obj[p1][p2]) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Sets selection start (left boundary of a selection)\r\n     * @param {Number} index Index to set selection start to\r\n     */\r\n    setSelectionStart: function(index) {\r\n      index = Math.max(index, 0);\r\n      if (this.selectionStart !== index) {\r\n        this.fire('selection:changed');\r\n        this.canvas && this.canvas.fire('text:selection:changed', { target: this });\r\n        this.selectionStart = index;\r\n      }\r\n      this._updateTextarea();\r\n    },\r\n\r\n    /**\r\n     * Sets selection end (right boundary of a selection)\r\n     * @param {Number} index Index to set selection end to\r\n     */\r\n    setSelectionEnd: function(index) {\r\n      index = Math.min(index, this.text.length);\r\n      if (this.selectionEnd !== index) {\r\n        this.fire('selection:changed');\r\n        this.canvas && this.canvas.fire('text:selection:changed', { target: this });\r\n        this.selectionEnd = index;\r\n      }\r\n      this._updateTextarea();\r\n    },\r\n\r\n    /**\r\n     * Gets style of a current selection/cursor (at the start position)\r\n     * @param {Number} [startIndex] Start index to get styles at\r\n     * @param {Number} [endIndex] End index to get styles at\r\n     * @return {Object} styles Style object at a specified (or current) index\r\n     */\r\n    getSelectionStyles: function(startIndex, endIndex) {\r\n\r\n      if (arguments.length === 2) {\r\n        var styles = [ ];\r\n        for (var i = startIndex; i < endIndex; i++) {\r\n          styles.push(this.getSelectionStyles(i));\r\n        }\r\n        return styles;\r\n      }\r\n\r\n      var loc = this.get2DCursorLocation(startIndex),\r\n          style = this._getStyleDeclaration(loc.lineIndex, loc.charIndex);\r\n\r\n      return style || {};\r\n    },\r\n\r\n    /**\r\n     * Sets style of a current selection\r\n     * @param {Object} [styles] Styles object\r\n     * @return {fabric.IText} thisArg\r\n     * @chainable\r\n     */\r\n    setSelectionStyles: function(styles) {\r\n      if (this.selectionStart === this.selectionEnd) {\r\n        this._extendStyles(this.selectionStart, styles);\r\n      }\r\n      else {\r\n        for (var i = this.selectionStart; i < this.selectionEnd; i++) {\r\n          this._extendStyles(i, styles);\r\n        }\r\n      }\r\n      /* not included in _extendStyles to avoid clearing cache more than once */\r\n      this._forceClearCache = true;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _extendStyles: function(index, styles) {\r\n      var loc = this.get2DCursorLocation(index);\r\n\r\n      if (!this._getLineStyle(loc.lineIndex)) {\r\n        this._setLineStyle(loc.lineIndex, {});\r\n      }\r\n\r\n      if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {\r\n        this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});\r\n      }\r\n\r\n      fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx) {\r\n      this.callSuper('_render', ctx);\r\n      this.ctx = ctx;\r\n      this.isEditing && this.renderCursorOrSelection();\r\n    },\r\n\r\n    /**\r\n     * Renders cursor or selection (depending on what exists)\r\n     */\r\n    renderCursorOrSelection: function() {\r\n      if (!this.active) {\r\n        return;\r\n      }\r\n\r\n      var chars = this.text.split(''),\r\n          boundaries, ctx;\r\n\r\n      if (this.canvas.contextTop) {\r\n        ctx = this.canvas.contextTop;\r\n        ctx.save();\r\n        ctx.transform.apply(ctx, this.canvas.viewportTransform);\r\n        this.transform(ctx);\r\n        this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);\r\n      }\r\n      else {\r\n        ctx = this.ctx;\r\n        ctx.save();\r\n      }\r\n\r\n      if (this.selectionStart === this.selectionEnd) {\r\n        boundaries = this._getCursorBoundaries(chars, 'cursor');\r\n        this.renderCursor(boundaries, ctx);\r\n      }\r\n      else {\r\n        boundaries = this._getCursorBoundaries(chars, 'selection');\r\n        this.renderSelection(chars, boundaries, ctx);\r\n      }\r\n\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)\r\n     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.\r\n     */\r\n    get2DCursorLocation: function(selectionStart) {\r\n      if (typeof selectionStart === 'undefined') {\r\n        selectionStart = this.selectionStart;\r\n      }\r\n      var len = this._textLines.length;\r\n      for (var i = 0; i < len; i++) {\r\n        if (selectionStart <= this._textLines[i].length) {\r\n          return {\r\n            lineIndex: i,\r\n            charIndex: selectionStart\r\n          };\r\n        }\r\n        selectionStart -= this._textLines[i].length + 1;\r\n      }\r\n      return {\r\n        lineIndex: i - 1,\r\n        charIndex: this._textLines[i - 1].length < selectionStart ? this._textLines[i - 1].length : selectionStart\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Returns complete style of char at the current cursor\r\n     * @param {Number} lineIndex Line index\r\n     * @param {Number} charIndex Char index\r\n     * @return {Object} Character style\r\n     */\r\n    getCurrentCharStyle: function(lineIndex, charIndex) {\r\n      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);\r\n\r\n      return {\r\n        fontSize: style && style.fontSize || this.fontSize,\r\n        fill: style && style.fill || this.fill,\r\n        textBackgroundColor: style && style.textBackgroundColor || this.textBackgroundColor,\r\n        textDecoration: style && style.textDecoration || this.textDecoration,\r\n        fontFamily: style && style.fontFamily || this.fontFamily,\r\n        fontWeight: style && style.fontWeight || this.fontWeight,\r\n        fontStyle: style && style.fontStyle || this.fontStyle,\r\n        stroke: style && style.stroke || this.stroke,\r\n        strokeWidth: style && style.strokeWidth || this.strokeWidth\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Returns fontSize of char at the current cursor\r\n     * @param {Number} lineIndex Line index\r\n     * @param {Number} charIndex Char index\r\n     * @return {Number} Character font size\r\n     */\r\n    getCurrentCharFontSize: function(lineIndex, charIndex) {\r\n      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);\r\n      return style && style.fontSize ? style.fontSize : this.fontSize;\r\n    },\r\n\r\n    /**\r\n     * Returns color (fill) of char at the current cursor\r\n     * @param {Number} lineIndex Line index\r\n     * @param {Number} charIndex Char index\r\n     * @return {String} Character color (fill)\r\n     */\r\n    getCurrentCharColor: function(lineIndex, charIndex) {\r\n      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);\r\n      return style && style.fill ? style.fill : this.cursorColor;\r\n    },\r\n\r\n    /**\r\n     * Returns cursor boundaries (left, top, leftOffset, topOffset)\r\n     * @private\r\n     * @param {Array} chars Array of characters\r\n     * @param {String} typeOfBoundaries\r\n     */\r\n    _getCursorBoundaries: function(chars, typeOfBoundaries) {\r\n\r\n      // left/top are left/top of entire text box\r\n      // leftOffset/topOffset are offset from that left/top point of a text box\r\n\r\n      var left = Math.round(this._getLeftOffset()),\r\n          top = this._getTopOffset(),\r\n\r\n          offsets = this._getCursorBoundariesOffsets(\r\n                      chars, typeOfBoundaries);\r\n\r\n      return {\r\n        left: left,\r\n        top: top,\r\n        leftOffset: offsets.left + offsets.lineLeft,\r\n        topOffset: offsets.top\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getCursorBoundariesOffsets: function(chars, typeOfBoundaries) {\r\n\r\n      var lineLeftOffset = 0,\r\n\r\n          lineIndex = 0,\r\n          charIndex = 0,\r\n          topOffset = 0,\r\n          leftOffset = 0;\r\n\r\n      for (var i = 0; i < this.selectionStart; i++) {\r\n        if (chars[i] === '\\n') {\r\n          leftOffset = 0;\r\n          topOffset += this._getHeightOfLine(this.ctx, lineIndex);\r\n\r\n          lineIndex++;\r\n          charIndex = 0;\r\n        }\r\n        else {\r\n          leftOffset += this._getWidthOfChar(this.ctx, chars[i], lineIndex, charIndex);\r\n          charIndex++;\r\n        }\r\n\r\n        lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex));\r\n      }\r\n      if (typeOfBoundaries === 'cursor') {\r\n        topOffset += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, lineIndex) / this.lineHeight\r\n          - this.getCurrentCharFontSize(lineIndex, charIndex) * (1 - this._fontSizeFraction);\r\n      }\r\n\r\n      return {\r\n        top: topOffset,\r\n        left: leftOffset,\r\n        lineLeft: lineLeftOffset\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Renders cursor\r\n     * @param {Object} boundaries\r\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\r\n     */\r\n    renderCursor: function(boundaries, ctx) {\r\n\r\n      var cursorLocation = this.get2DCursorLocation(),\r\n          lineIndex = cursorLocation.lineIndex,\r\n          charIndex = cursorLocation.charIndex,\r\n          charHeight = this.getCurrentCharFontSize(lineIndex, charIndex),\r\n          leftOffset = (lineIndex === 0 && charIndex === 0)\r\n                    ? this._getLineLeftOffset(this._getLineWidth(ctx, lineIndex))\r\n                    : boundaries.leftOffset;\r\n\r\n      ctx.fillStyle = this.getCurrentCharColor(lineIndex, charIndex);\r\n      ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;\r\n\r\n      ctx.fillRect(\r\n        boundaries.left + leftOffset,\r\n        boundaries.top + boundaries.topOffset,\r\n        this.cursorWidth / this.scaleX,\r\n        charHeight);\r\n\r\n    },\r\n\r\n    /**\r\n     * Renders text selection\r\n     * @param {Array} chars Array of characters\r\n     * @param {Object} boundaries Object with left/top/leftOffset/topOffset\r\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\r\n     */\r\n    renderSelection: function(chars, boundaries, ctx) {\r\n\r\n      ctx.fillStyle = this.selectionColor;\r\n\r\n      var start = this.get2DCursorLocation(this.selectionStart),\r\n          end = this.get2DCursorLocation(this.selectionEnd),\r\n          startLine = start.lineIndex,\r\n          endLine = end.lineIndex;\r\n\r\n      for (var i = startLine; i <= endLine; i++) {\r\n        var lineOffset = this._getLineLeftOffset(this._getLineWidth(ctx, i)) || 0,\r\n            lineHeight = this._getHeightOfLine(this.ctx, i),\r\n            boxWidth = 0, line = this._textLines[i];\r\n\r\n        if (i === startLine) {\r\n          for (var j = 0, len = line.length; j < len; j++) {\r\n            if (j >= start.charIndex && (i !== endLine || j < end.charIndex)) {\r\n              boxWidth += this._getWidthOfChar(ctx, line[j], i, j);\r\n            }\r\n            if (j < start.charIndex) {\r\n              lineOffset += this._getWidthOfChar(ctx, line[j], i, j);\r\n            }\r\n          }\r\n        }\r\n        else if (i > startLine && i < endLine) {\r\n          boxWidth += this._getLineWidth(ctx, i) || 5;\r\n        }\r\n        else if (i === endLine) {\r\n          for (var j2 = 0, j2len = end.charIndex; j2 < j2len; j2++) {\r\n            boxWidth += this._getWidthOfChar(ctx, line[j2], i, j2);\r\n          }\r\n        }\r\n\r\n        ctx.fillRect(\r\n          boundaries.left + lineOffset,\r\n          boundaries.top + boundaries.topOffset,\r\n          boxWidth,\r\n          lineHeight);\r\n\r\n        boundaries.topOffset += lineHeight;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} method\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderChars: function(method, ctx, line, left, top, lineIndex, charOffset) {\r\n\r\n      if (this.isEmptyStyles()) {\r\n        return this._renderCharsFast(method, ctx, line, left, top);\r\n      }\r\n\r\n      charOffset = charOffset || 0;\r\n      this.skipTextAlign = true;\r\n\r\n      // set proper box offset\r\n      left -= this.textAlign === 'center'\r\n        ? (this.width / 2)\r\n        : (this.textAlign === 'right')\r\n          ? this.width\r\n          : 0;\r\n\r\n      // set proper line offset\r\n      var lineHeight = this._getHeightOfLine(ctx, lineIndex),\r\n          lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(ctx, lineIndex)),\r\n          prevStyle,\r\n          thisStyle,\r\n          charsToRender = '';\r\n\r\n      left += lineLeftOffset || 0;\r\n\r\n      ctx.save();\r\n      top -= lineHeight / this.lineHeight * this._fontSizeFraction;\r\n      for (var i = charOffset, len = line.length + charOffset; i <= len; i++) {\r\n        prevStyle = prevStyle || this.getCurrentCharStyle(lineIndex, i);\r\n        thisStyle = this.getCurrentCharStyle(lineIndex, i + 1);\r\n\r\n        if (this._hasStyleChanged(prevStyle, thisStyle) || i === len) {\r\n          this._renderChar(method, ctx, lineIndex, i - 1, charsToRender, left, top, lineHeight);\r\n          charsToRender = '';\r\n          prevStyle = thisStyle;\r\n        }\r\n        charsToRender += line[i - charOffset];\r\n      }\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} method\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {String} line Content of the line\r\n     * @param {Number} left Left coordinate\r\n     * @param {Number} top Top coordinate\r\n     */\r\n    _renderCharsFast: function(method, ctx, line, left, top) {\r\n      this.skipTextAlign = false;\r\n\r\n      if (method === 'fillText' && this.fill) {\r\n        this.callSuper('_renderChars', method, ctx, line, left, top);\r\n      }\r\n      if (method === 'strokeText' && ((this.stroke && this.strokeWidth > 0) || this.skipFillStrokeCheck)) {\r\n        this.callSuper('_renderChars', method, ctx, line, left, top);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} method\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Number} lineIndex\r\n     * @param {Number} i\r\n     * @param {String} _char\r\n     * @param {Number} left Left coordinate\r\n     * @param {Number} top Top coordinate\r\n     * @param {Number} lineHeight Height of the line\r\n     */\r\n    _renderChar: function(method, ctx, lineIndex, i, _char, left, top, lineHeight) {\r\n      var charWidth, charHeight,\r\n          decl = this._getStyleDeclaration(lineIndex, i),\r\n          offset = this._fontSizeFraction * lineHeight / this.lineHeight;\r\n\r\n      if (decl) {\r\n        var shouldStroke = decl.stroke || this.stroke,\r\n            shouldFill = decl.fill || this.fill;\r\n\r\n        ctx.save();\r\n        charWidth = this._applyCharStylesGetWidth(ctx, _char, lineIndex, i, decl);\r\n        charHeight = this._getHeightOfChar(ctx, _char, lineIndex, i);\r\n\r\n        if (shouldFill) {\r\n          ctx.fillText(_char, left, top);\r\n        }\r\n        if (shouldStroke) {\r\n          ctx.strokeText(_char, left, top);\r\n        }\r\n\r\n        this._renderCharDecoration(ctx, decl, left, top, offset, charWidth, charHeight);\r\n        ctx.restore();\r\n      }\r\n      else {\r\n        if (method === 'strokeText' && this.stroke) {\r\n          ctx[method](_char, left, top);\r\n        }\r\n        if (method === 'fillText' && this.fill) {\r\n          ctx[method](_char, left, top);\r\n        }\r\n        charWidth = this._applyCharStylesGetWidth(ctx, _char, lineIndex, i);\r\n        this._renderCharDecoration(ctx, null, left, top, offset, charWidth, this.fontSize);\r\n      }\r\n      ctx.translate(charWidth, 0);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} prevStyle\r\n     * @param {Object} thisStyle\r\n     */\r\n    _hasStyleChanged: function(prevStyle, thisStyle) {\r\n      return (prevStyle.fill !== thisStyle.fill ||\r\n              prevStyle.fontSize !== thisStyle.fontSize ||\r\n              prevStyle.textBackgroundColor !== thisStyle.textBackgroundColor ||\r\n              prevStyle.textDecoration !== thisStyle.textDecoration ||\r\n              prevStyle.fontFamily !== thisStyle.fontFamily ||\r\n              prevStyle.fontWeight !== thisStyle.fontWeight ||\r\n              prevStyle.fontStyle !== thisStyle.fontStyle ||\r\n              prevStyle.stroke !== thisStyle.stroke ||\r\n              prevStyle.strokeWidth !== thisStyle.strokeWidth\r\n      );\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderCharDecoration: function(ctx, styleDeclaration, left, top, offset, charWidth, charHeight) {\r\n\r\n      var textDecoration = styleDeclaration\r\n            ? (styleDeclaration.textDecoration || this.textDecoration)\r\n            : this.textDecoration;\r\n\r\n      if (!textDecoration) {\r\n        return;\r\n      }\r\n\r\n      if (textDecoration.indexOf('underline') > -1) {\r\n        ctx.fillRect(\r\n          left,\r\n          top + charHeight / 10,\r\n          charWidth ,\r\n          charHeight / 15\r\n        );\r\n      }\r\n      if (textDecoration.indexOf('line-through') > -1) {\r\n        ctx.fillRect(\r\n          left,\r\n          top - charHeight * (this._fontSizeFraction + this._fontSizeMult - 1) + charHeight / 15,\r\n          charWidth,\r\n          charHeight / 15\r\n        );\r\n      }\r\n      if (textDecoration.indexOf('overline') > -1) {\r\n        ctx.fillRect(\r\n          left,\r\n          top - (this._fontSizeMult - this._fontSizeFraction) * charHeight,\r\n          charWidth,\r\n          charHeight / 15\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} method\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {String} line\r\n     */\r\n    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {\r\n      // to \"cancel\" this.fontSize subtraction in fabric.Text#_renderTextLine\r\n      // the adding 0.03 is just to align text with itext by overlap test\r\n      if (!this.isEmptyStyles()) {\r\n        top += this.fontSize * (this._fontSizeFraction + 0.03);\r\n      }\r\n      this.callSuper('_renderTextLine', method, ctx, line, left, top, lineIndex);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextDecoration: function(ctx) {\r\n      if (this.isEmptyStyles()) {\r\n        return this.callSuper('_renderTextDecoration', ctx);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextLinesBackground: function(ctx) {\r\n      if (!this.textBackgroundColor && !this.styles) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n\r\n      if (this.textBackgroundColor) {\r\n        ctx.fillStyle = this.textBackgroundColor;\r\n      }\r\n\r\n      var lineHeights = 0;\r\n\r\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n\r\n        var heightOfLine = this._getHeightOfLine(ctx, i);\r\n        if (this._textLines[i] === '') {\r\n          lineHeights += heightOfLine;\r\n          continue;\r\n        }\r\n\r\n        var lineWidth = this._getLineWidth(ctx, i),\r\n            lineLeftOffset = this._getLineLeftOffset(lineWidth);\r\n\r\n        if (this.textBackgroundColor) {\r\n          ctx.fillStyle = this.textBackgroundColor;\r\n\r\n          ctx.fillRect(\r\n            this._getLeftOffset() + lineLeftOffset,\r\n            this._getTopOffset() + lineHeights,\r\n            lineWidth,\r\n            heightOfLine / this.lineHeight\r\n          );\r\n        }\r\n        if (this._getLineStyle(i)) {\r\n          for (var j = 0, jlen = this._textLines[i].length; j < jlen; j++) {\r\n            var style = this._getStyleDeclaration(i, j);\r\n            if (style && style.textBackgroundColor) {\r\n\r\n              var _char = this._textLines[i][j];\r\n\r\n              ctx.fillStyle = style.textBackgroundColor;\r\n\r\n              ctx.fillRect(\r\n                this._getLeftOffset() + lineLeftOffset + this._getWidthOfCharsAt(ctx, i, j),\r\n                this._getTopOffset() + lineHeights,\r\n                this._getWidthOfChar(ctx, _char, i, j) + 1,\r\n                heightOfLine / this.lineHeight\r\n              );\r\n            }\r\n          }\r\n        }\r\n        lineHeights += heightOfLine;\r\n      }\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getCacheProp: function(_char, styleDeclaration) {\r\n      return _char +\r\n             styleDeclaration.fontFamily +\r\n             styleDeclaration.fontSize +\r\n             styleDeclaration.fontWeight +\r\n             styleDeclaration.fontStyle +\r\n             styleDeclaration.shadow;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {String} _char\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @param {Object} [decl]\r\n     */\r\n    _applyCharStylesGetWidth: function(ctx, _char, lineIndex, charIndex, decl) {\r\n      var styleDeclaration = decl || this._getStyleDeclaration(lineIndex, charIndex, true);\r\n\r\n      this._applyFontStyles(styleDeclaration);\r\n\r\n      var cacheProp = this._getCacheProp(_char, styleDeclaration);\r\n\r\n      // short-circuit if no styles\r\n      if (this.isEmptyStyles() && this._charWidthsCache[cacheProp] && this.caching) {\r\n        return this._charWidthsCache[cacheProp];\r\n      }\r\n\r\n      if (typeof styleDeclaration.shadow === 'string') {\r\n        styleDeclaration.shadow = new fabric.Shadow(styleDeclaration.shadow);\r\n      }\r\n\r\n      var fill = styleDeclaration.fill || this.fill;\r\n      ctx.fillStyle = fill.toLive\r\n        ? fill.toLive(ctx, this)\r\n        : fill;\r\n\r\n      if (styleDeclaration.stroke) {\r\n        ctx.strokeStyle = (styleDeclaration.stroke && styleDeclaration.stroke.toLive)\r\n          ? styleDeclaration.stroke.toLive(ctx, this)\r\n          : styleDeclaration.stroke;\r\n      }\r\n\r\n      ctx.lineWidth = styleDeclaration.strokeWidth || this.strokeWidth;\r\n      ctx.font = this._getFontDeclaration.call(styleDeclaration);\r\n      this._setShadow.call(styleDeclaration, ctx);\r\n\r\n      if (!this.caching) {\r\n        return ctx.measureText(_char).width;\r\n      }\r\n\r\n      if (!this._charWidthsCache[cacheProp]) {\r\n        this._charWidthsCache[cacheProp] = ctx.measureText(_char).width;\r\n      }\r\n\r\n      return this._charWidthsCache[cacheProp];\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} styleDeclaration\r\n     */\r\n    _applyFontStyles: function(styleDeclaration) {\r\n      if (!styleDeclaration.fontFamily) {\r\n        styleDeclaration.fontFamily = this.fontFamily;\r\n      }\r\n      if (!styleDeclaration.fontSize) {\r\n        styleDeclaration.fontSize = this.fontSize;\r\n      }\r\n      if (!styleDeclaration.fontWeight) {\r\n        styleDeclaration.fontWeight = this.fontWeight;\r\n      }\r\n      if (!styleDeclaration.fontStyle) {\r\n        styleDeclaration.fontStyle = this.fontStyle;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @param {Boolean} [returnCloneOrEmpty=false]\r\n     * @private\r\n     */\r\n    _getStyleDeclaration: function(lineIndex, charIndex, returnCloneOrEmpty) {\r\n      if (returnCloneOrEmpty) {\r\n        return (this.styles[lineIndex] && this.styles[lineIndex][charIndex])\r\n          ? clone(this.styles[lineIndex][charIndex])\r\n          : { };\r\n      }\r\n\r\n      return this.styles[lineIndex] && this.styles[lineIndex][charIndex] ? this.styles[lineIndex][charIndex] : null;\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @param {Object} style\r\n     * @private\r\n     */\r\n    _setStyleDeclaration: function(lineIndex, charIndex, style) {\r\n      this.styles[lineIndex][charIndex] = style;\r\n    },\r\n\r\n    /**\r\n     *\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @private\r\n     */\r\n    _deleteStyleDeclaration: function(lineIndex, charIndex) {\r\n      delete this.styles[lineIndex][charIndex];\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @private\r\n     */\r\n    _getLineStyle: function(lineIndex) {\r\n      return this.styles[lineIndex];\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Object} style\r\n     * @private\r\n     */\r\n    _setLineStyle: function(lineIndex, style) {\r\n      this.styles[lineIndex] = style;\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @private\r\n     */\r\n    _deleteLineStyle: function(lineIndex) {\r\n      delete this.styles[lineIndex];\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getWidthOfChar: function(ctx, _char, lineIndex, charIndex) {\r\n      if (this.textAlign === 'justify' && this._reSpacesAndTabs.test(_char)) {\r\n        return this._getWidthOfSpace(ctx, lineIndex);\r\n      }\r\n\r\n      var styleDeclaration = this._getStyleDeclaration(lineIndex, charIndex, true);\r\n      this._applyFontStyles(styleDeclaration);\r\n      var cacheProp = this._getCacheProp(_char, styleDeclaration);\r\n\r\n      if (this._charWidthsCache[cacheProp] && this.caching) {\r\n        return this._charWidthsCache[cacheProp];\r\n      }\r\n      else if (ctx) {\r\n        ctx.save();\r\n        var width = this._applyCharStylesGetWidth(ctx, _char, lineIndex, charIndex);\r\n        ctx.restore();\r\n        return width;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getHeightOfChar: function(ctx, _char, lineIndex, charIndex) {\r\n      var style = this._getStyleDeclaration(lineIndex, charIndex);\r\n      return style && style.fontSize ? style.fontSize : this.fontSize;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getHeightOfCharAt: function(ctx, lineIndex, charIndex) {\r\n      var _char = this._textLines[lineIndex][charIndex];\r\n      return this._getHeightOfChar(ctx, _char, lineIndex, charIndex);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getWidthOfCharsAt: function(ctx, lineIndex, charIndex) {\r\n      var width = 0, i, _char;\r\n      for (i = 0; i < charIndex; i++) {\r\n        _char = this._textLines[lineIndex][i];\r\n        width += this._getWidthOfChar(ctx, _char, lineIndex, i);\r\n      }\r\n      return width;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getLineWidth: function(ctx, lineIndex) {\r\n      if (this.__lineWidths[lineIndex]) {\r\n        return this.__lineWidths[lineIndex];\r\n      }\r\n      this.__lineWidths[lineIndex] = this._getWidthOfCharsAt(ctx, lineIndex, this._textLines[lineIndex].length);\r\n      return this.__lineWidths[lineIndex];\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Number} lineIndex\r\n     */\r\n    _getWidthOfSpace: function (ctx, lineIndex) {\r\n      if (this.__widthOfSpace[lineIndex]) {\r\n        return this.__widthOfSpace[lineIndex];\r\n      }\r\n      var line = this._textLines[lineIndex],\r\n          wordsWidth = this._getWidthOfWords(ctx, line, lineIndex),\r\n          widthDiff = this.width - wordsWidth,\r\n          numSpaces = line.length - line.replace(this._reSpacesAndTabs, '').length,\r\n          width = widthDiff / numSpaces;\r\n      this.__widthOfSpace[lineIndex] = width;\r\n      return width;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Number} line\r\n     * @param {Number} lineIndex\r\n     */\r\n    _getWidthOfWords: function (ctx, line, lineIndex) {\r\n      var width = 0;\r\n\r\n      for (var charIndex = 0; charIndex < line.length; charIndex++) {\r\n        var _char = line[charIndex];\r\n\r\n        if (!_char.match(/\\s/)) {\r\n          width += this._getWidthOfChar(ctx, _char, lineIndex, charIndex);\r\n        }\r\n      }\r\n\r\n      return width;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getHeightOfLine: function(ctx, lineIndex) {\r\n      if (this.__lineHeights[lineIndex]) {\r\n        return this.__lineHeights[lineIndex];\r\n      }\r\n\r\n      var line = this._textLines[lineIndex],\r\n          maxHeight = this._getHeightOfChar(ctx, line[0], lineIndex, 0);\r\n\r\n      for (var i = 1, len = line.length; i < len; i++) {\r\n        var currentCharHeight = this._getHeightOfChar(ctx, line[i], lineIndex, i);\r\n        if (currentCharHeight > maxHeight) {\r\n          maxHeight = currentCharHeight;\r\n        }\r\n      }\r\n      this.__maxFontHeights[lineIndex] = maxHeight;\r\n      this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;\r\n      return this.__lineHeights[lineIndex];\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getTextHeight: function(ctx) {\r\n      var height = 0;\r\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n        height += this._getHeightOfLine(ctx, i);\r\n      }\r\n      return height;\r\n    },\r\n\r\n    /**\r\n     * This method is overwritten to account for different top offset\r\n     * @private\r\n     */\r\n    _renderTextBoxBackground: function(ctx) {\r\n      if (!this.backgroundColor) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n      ctx.fillStyle = this.backgroundColor;\r\n\r\n      ctx.fillRect(\r\n        this._getLeftOffset(),\r\n        this._getTopOffset(),\r\n        this.width,\r\n        this.height\r\n      );\r\n\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @method toObject\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var clonedStyles = { }, i, j, row;\r\n      for (i in this.styles) {\r\n        row = this.styles[i];\r\n        clonedStyles[i] = { };\r\n        for (j in row) {\r\n          clonedStyles[i][j] = clone(row[j]);\r\n        }\r\n      }\r\n      return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {\r\n        styles: clonedStyles\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns fabric.IText instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.IText\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.IText} instance of fabric.IText\r\n   */\r\n  fabric.IText.fromObject = function(object) {\r\n    return new fabric.IText(object.text, clone(object));\r\n  };\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  var clone = fabric.util.object.clone;\r\n\r\n  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\r\n\r\n    /**\r\n     * Initializes all the interactive behavior of IText\r\n     */\r\n    initBehavior: function() {\r\n      this.initAddedHandler();\r\n      this.initRemovedHandler();\r\n      this.initCursorSelectionHandlers();\r\n      this.initDoubleClickSimulation();\r\n    },\r\n\r\n    /**\r\n     * Initializes \"selected\" event handler\r\n     */\r\n    initSelectedHandler: function() {\r\n      this.on('selected', function() {\r\n\r\n        var _this = this;\r\n        setTimeout(function() {\r\n          _this.selected = true;\r\n        }, 100);\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Initializes \"added\" event handler\r\n     */\r\n    initAddedHandler: function() {\r\n      var _this = this;\r\n      this.on('added', function() {\r\n        if (this.canvas && !this.canvas._hasITextHandlers) {\r\n          this.canvas._hasITextHandlers = true;\r\n          this._initCanvasHandlers();\r\n        }\r\n\r\n        // Track IText instances per-canvas. Only register in this array once added\r\n        // to a canvas; we don't want to leak a reference to the instance forever\r\n        // simply because it existed at some point.\r\n        // (Might be added to a collection, but not on a canvas.)\r\n        if (_this.canvas) {\r\n          _this.canvas._iTextInstances = _this.canvas._iTextInstances || [];\r\n          _this.canvas._iTextInstances.push(_this);\r\n        }\r\n      });\r\n    },\r\n\r\n    initRemovedHandler: function() {\r\n      var _this = this;\r\n      this.on('removed', function() {\r\n        // (Might be removed from a collection, but not on a canvas.)\r\n        if (_this.canvas) {\r\n          _this.canvas._iTextInstances = _this.canvas._iTextInstances || [];\r\n          fabric.util.removeFromArray(_this.canvas._iTextInstances, _this);\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _initCanvasHandlers: function() {\r\n      var _this = this;\r\n\r\n      this.canvas.on('selection:cleared', function() {\r\n        fabric.IText.prototype.exitEditingOnOthers(_this.canvas);\r\n      });\r\n\r\n      this.canvas.on('mouse:up', function() {\r\n        if (_this.canvas._iTextInstances) {\r\n          _this.canvas._iTextInstances.forEach(function(obj) {\r\n            obj.__isMousedown = false;\r\n          });\r\n        }\r\n      });\r\n\r\n      this.canvas.on('object:selected', function() {\r\n        fabric.IText.prototype.exitEditingOnOthers(_this.canvas);\r\n      });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _tick: function() {\r\n      this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _animateCursor: function(obj, targetOpacity, duration, completeMethod) {\r\n\r\n      var tickState;\r\n\r\n      tickState = {\r\n        isAborted: false,\r\n        abort: function() {\r\n          this.isAborted = true;\r\n        },\r\n      };\r\n\r\n      obj.animate('_currentCursorOpacity', targetOpacity, {\r\n        duration: duration,\r\n        onComplete: function() {\r\n          if (!tickState.isAborted) {\r\n            obj[completeMethod]();\r\n          }\r\n        },\r\n        onChange: function() {\r\n          if (obj.canvas) {\r\n            obj.canvas.clearContext(obj.canvas.contextTop || obj.ctx);\r\n            obj.renderCursorOrSelection();\r\n          }\r\n        },\r\n        abort: function() {\r\n          return tickState.isAborted;\r\n        }\r\n      });\r\n      return tickState;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _onTickComplete: function() {\r\n\r\n      var _this = this;\r\n\r\n      if (this._cursorTimeout1) {\r\n        clearTimeout(this._cursorTimeout1);\r\n      }\r\n      this._cursorTimeout1 = setTimeout(function() {\r\n        _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');\r\n      }, 100);\r\n    },\r\n\r\n    /**\r\n     * Initializes delayed cursor\r\n     */\r\n    initDelayedCursor: function(restart) {\r\n      var _this = this,\r\n          delay = restart ? 0 : this.cursorDelay;\r\n\r\n      this._currentTickState && this._currentTickState.abort();\r\n      this._currentTickCompleteState && this._currentTickCompleteState.abort();\r\n      clearTimeout(this._cursorTimeout1);\r\n      this._currentCursorOpacity = 1;\r\n      if (this.canvas) {\r\n        this.canvas.clearContext(this.canvas.contextTop || this.ctx);\r\n        this.renderCursorOrSelection();\r\n      }\r\n      if (this._cursorTimeout2) {\r\n        clearTimeout(this._cursorTimeout2);\r\n      }\r\n      this._cursorTimeout2 = setTimeout(function() {\r\n        _this._tick();\r\n      }, delay);\r\n    },\r\n\r\n    /**\r\n     * Aborts cursor animation and clears all timeouts\r\n     */\r\n    abortCursorAnimation: function() {\r\n      this._currentTickState && this._currentTickState.abort();\r\n      this._currentTickCompleteState && this._currentTickCompleteState.abort();\r\n\r\n      clearTimeout(this._cursorTimeout1);\r\n      clearTimeout(this._cursorTimeout2);\r\n\r\n      this._currentCursorOpacity = 0;\r\n      this.canvas && this.canvas.clearContext(this.canvas.contextTop || this.ctx);\r\n    },\r\n\r\n    /**\r\n     * Selects entire text\r\n     */\r\n    selectAll: function() {\r\n      this.setSelectionStart(0);\r\n      this.setSelectionEnd(this.text.length);\r\n    },\r\n\r\n    /**\r\n     * Returns selected text\r\n     * @return {String}\r\n     */\r\n    getSelectedText: function() {\r\n      return this.text.slice(this.selectionStart, this.selectionEnd);\r\n    },\r\n\r\n    /**\r\n     * Find new selection index representing start of current word according to current selection index\r\n     * @param {Number} startFrom Surrent selection index\r\n     * @return {Number} New selection index\r\n     */\r\n    findWordBoundaryLeft: function(startFrom) {\r\n      var offset = 0, index = startFrom - 1;\r\n\r\n      // remove space before cursor first\r\n      if (this._reSpace.test(this.text.charAt(index))) {\r\n        while (this._reSpace.test(this.text.charAt(index))) {\r\n          offset++;\r\n          index--;\r\n        }\r\n      }\r\n      while (/\\S/.test(this.text.charAt(index)) && index > -1) {\r\n        offset++;\r\n        index--;\r\n      }\r\n\r\n      return startFrom - offset;\r\n    },\r\n\r\n    /**\r\n     * Find new selection index representing end of current word according to current selection index\r\n     * @param {Number} startFrom Current selection index\r\n     * @return {Number} New selection index\r\n     */\r\n    findWordBoundaryRight: function(startFrom) {\r\n      var offset = 0, index = startFrom;\r\n\r\n      // remove space after cursor first\r\n      if (this._reSpace.test(this.text.charAt(index))) {\r\n        while (this._reSpace.test(this.text.charAt(index))) {\r\n          offset++;\r\n          index++;\r\n        }\r\n      }\r\n      while (/\\S/.test(this.text.charAt(index)) && index < this.text.length) {\r\n        offset++;\r\n        index++;\r\n      }\r\n\r\n      return startFrom + offset;\r\n    },\r\n\r\n    /**\r\n     * Find new selection index representing start of current line according to current selection index\r\n     * @param {Number} startFrom Current selection index\r\n     * @return {Number} New selection index\r\n     */\r\n    findLineBoundaryLeft: function(startFrom) {\r\n      var offset = 0, index = startFrom - 1;\r\n\r\n      while (!/\\n/.test(this.text.charAt(index)) && index > -1) {\r\n        offset++;\r\n        index--;\r\n      }\r\n\r\n      return startFrom - offset;\r\n    },\r\n\r\n    /**\r\n     * Find new selection index representing end of current line according to current selection index\r\n     * @param {Number} startFrom Current selection index\r\n     * @return {Number} New selection index\r\n     */\r\n    findLineBoundaryRight: function(startFrom) {\r\n      var offset = 0, index = startFrom;\r\n\r\n      while (!/\\n/.test(this.text.charAt(index)) && index < this.text.length) {\r\n        offset++;\r\n        index++;\r\n      }\r\n\r\n      return startFrom + offset;\r\n    },\r\n\r\n    /**\r\n     * Returns number of newlines in selected text\r\n     * @return {Number} Number of newlines in selected text\r\n     */\r\n    getNumNewLinesInSelectedText: function() {\r\n      var selectedText = this.getSelectedText(),\r\n          numNewLines  = 0;\r\n\r\n      for (var i = 0, len = selectedText.length; i < len; i++) {\r\n        if (selectedText[i] === '\\n') {\r\n          numNewLines++;\r\n        }\r\n      }\r\n      return numNewLines;\r\n    },\r\n\r\n    /**\r\n     * Finds index corresponding to beginning or end of a word\r\n     * @param {Number} selectionStart Index of a character\r\n     * @param {Number} direction 1 or -1\r\n     * @return {Number} Index of the beginning or end of a word\r\n     */\r\n    searchWordBoundary: function(selectionStart, direction) {\r\n      var index     = this._reSpace.test(this.text.charAt(selectionStart)) ? selectionStart - 1 : selectionStart,\r\n          _char     = this.text.charAt(index),\r\n          reNonWord = /[ \\n\\.,;!\\?\\-]/;\r\n\r\n      while (!reNonWord.test(_char) && index > 0 && index < this.text.length) {\r\n        index += direction;\r\n        _char = this.text.charAt(index);\r\n      }\r\n      if (reNonWord.test(_char) && _char !== '\\n') {\r\n        index += direction === 1 ? 0 : 1;\r\n      }\r\n      return index;\r\n    },\r\n\r\n    /**\r\n     * Selects a word based on the index\r\n     * @param {Number} selectionStart Index of a character\r\n     */\r\n    selectWord: function(selectionStart) {\r\n      var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */\r\n          newSelectionEnd   = this.searchWordBoundary(selectionStart, 1);\r\n      /* search forward */\r\n\r\n      this.setSelectionStart(newSelectionStart);\r\n      this.setSelectionEnd(newSelectionEnd);\r\n    },\r\n\r\n    /**\r\n     * Selects a line based on the index\r\n     * @param {Number} selectionStart Index of a character\r\n     */\r\n    selectLine: function(selectionStart) {\r\n      var newSelectionStart = this.findLineBoundaryLeft(selectionStart),\r\n          newSelectionEnd   = this.findLineBoundaryRight(selectionStart);\r\n\r\n      this.setSelectionStart(newSelectionStart);\r\n      this.setSelectionEnd(newSelectionEnd);\r\n    },\r\n\r\n    /**\r\n     * Enters editing state\r\n     * @return {fabric.IText} thisArg\r\n     * @chainable\r\n     */\r\n    enterEditing: function() {\r\n      if (this.isEditing || !this.editable) {\r\n        return;\r\n      }\r\n\r\n      if (this.canvas) {\r\n        this.exitEditingOnOthers(this.canvas);\r\n      }\r\n\r\n      this.isEditing = true;\r\n\r\n      this.initHiddenTextarea();\r\n      this.hiddenTextarea.focus();\r\n      this._updateTextarea();\r\n      this._saveEditingProps();\r\n      this._setEditingProps();\r\n\r\n      this._tick();\r\n      this.fire('editing:entered');\r\n\r\n      if (!this.canvas) {\r\n        return this;\r\n      }\r\n\r\n      this.canvas.renderAll();\r\n      this.canvas.fire('text:editing:entered', { target: this });\r\n      this.initMouseMoveHandler();\r\n      return this;\r\n    },\r\n\r\n    exitEditingOnOthers: function(canvas) {\r\n      if (canvas._iTextInstances) {\r\n        canvas._iTextInstances.forEach(function(obj) {\r\n          obj.selected = false;\r\n          if (obj.isEditing) {\r\n            obj.exitEditing();\r\n          }\r\n        });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Initializes \"mousemove\" event handler\r\n     */\r\n    initMouseMoveHandler: function() {\r\n      var _this = this;\r\n      this.canvas.on('mouse:move', function(options) {\r\n        if (!_this.__isMousedown || !_this.isEditing) {\r\n          return;\r\n        }\r\n\r\n        var newSelectionStart = _this.getSelectionStartFromPointer(options.e);\r\n        if (newSelectionStart >= _this.__selectionStartOnMouseDown) {\r\n          _this.setSelectionStart(_this.__selectionStartOnMouseDown);\r\n          _this.setSelectionEnd(newSelectionStart);\r\n        }\r\n        else {\r\n          _this.setSelectionStart(newSelectionStart);\r\n          _this.setSelectionEnd(_this.__selectionStartOnMouseDown);\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setEditingProps: function() {\r\n      this.hoverCursor = 'text';\r\n\r\n      if (this.canvas) {\r\n        this.canvas.defaultCursor = this.canvas.moveCursor = 'text';\r\n      }\r\n\r\n      this.borderColor = this.editingBorderColor;\r\n\r\n      this.hasControls = this.selectable = false;\r\n      this.lockMovementX = this.lockMovementY = true;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _updateTextarea: function() {\r\n      if (!this.hiddenTextarea) {\r\n        return;\r\n      }\r\n\r\n      this.hiddenTextarea.value = this.text;\r\n      this.hiddenTextarea.selectionStart = this.selectionStart;\r\n      this.hiddenTextarea.selectionEnd = this.selectionEnd;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _saveEditingProps: function() {\r\n      this._savedProps = {\r\n        hasControls: this.hasControls,\r\n        borderColor: this.borderColor,\r\n        lockMovementX: this.lockMovementX,\r\n        lockMovementY: this.lockMovementY,\r\n        hoverCursor: this.hoverCursor,\r\n        defaultCursor: this.canvas && this.canvas.defaultCursor,\r\n        moveCursor: this.canvas && this.canvas.moveCursor\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _restoreEditingProps: function() {\r\n      if (!this._savedProps) {\r\n        return;\r\n      }\r\n\r\n      this.hoverCursor = this._savedProps.overCursor;\r\n      this.hasControls = this._savedProps.hasControls;\r\n      this.borderColor = this._savedProps.borderColor;\r\n      this.lockMovementX = this._savedProps.lockMovementX;\r\n      this.lockMovementY = this._savedProps.lockMovementY;\r\n\r\n      if (this.canvas) {\r\n        this.canvas.defaultCursor = this._savedProps.defaultCursor;\r\n        this.canvas.moveCursor = this._savedProps.moveCursor;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Exits from editing state\r\n     * @return {fabric.IText} thisArg\r\n     * @chainable\r\n     */\r\n    exitEditing: function() {\r\n\r\n      this.selected = false;\r\n      this.isEditing = false;\r\n      this.selectable = true;\r\n\r\n      this.selectionEnd = this.selectionStart;\r\n      this.hiddenTextarea && this.canvas && this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea);\r\n      this.hiddenTextarea = null;\r\n\r\n      this.abortCursorAnimation();\r\n      this._restoreEditingProps();\r\n      this._currentCursorOpacity = 0;\r\n\r\n      this.fire('editing:exited');\r\n      this.canvas && this.canvas.fire('text:editing:exited', { target: this });\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _removeExtraneousStyles: function() {\r\n      for (var prop in this.styles) {\r\n        if (!this._textLines[prop]) {\r\n          delete this.styles[prop];\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _removeCharsFromTo: function(start, end) {\r\n      while (end !== start) {\r\n        this._removeSingleCharAndStyle(start + 1);\r\n        end--;\r\n      }\r\n      this.setSelectionStart(start);\r\n    },\r\n\r\n    _removeSingleCharAndStyle: function(index) {\r\n      var isBeginningOfLine = this.text[index - 1] === '\\n',\r\n          indexStyle        = isBeginningOfLine ? index : index - 1;\r\n      this.removeStyleObject(isBeginningOfLine, indexStyle);\r\n      this.text = this.text.slice(0, index - 1) +\r\n        this.text.slice(index);\r\n\r\n      this._textLines = this._splitTextIntoLines();\r\n    },\r\n\r\n    /**\r\n     * Inserts characters where cursor is (replacing selection if one exists)\r\n     * @param {String} _chars Characters to insert\r\n     * @param {Boolean} useCopiedStyle use fabric.copiedTextStyle\r\n     */\r\n    insertChars: function(_chars, useCopiedStyle) {\r\n      var style;\r\n\r\n      if (this.selectionEnd - this.selectionStart > 1) {\r\n        this._removeCharsFromTo(this.selectionStart, this.selectionEnd);\r\n        this.setSelectionEnd(this.selectionStart);\r\n      }\r\n\r\n      for (var i = 0, len = _chars.length; i < len; i++) {\r\n        if (useCopiedStyle) {\r\n          style = fabric.copiedTextStyle[i];\r\n        }\r\n        this.insertChar(_chars[i], i < len - 1, style);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Inserts a character where cursor is\r\n     * @param {String} _char Characters to insert\r\n     * @param {Boolean} skipUpdate trigger rendering and updates at the end of text insert\r\n     * @param {Object} styleObject Style to be inserted for the new char\r\n     */\r\n    insertChar: function(_char, skipUpdate, styleObject) {\r\n      var isEndOfLine = this.text[this.selectionStart] === '\\n';\r\n      this.text = this.text.slice(0, this.selectionStart) +\r\n        _char + this.text.slice(this.selectionEnd);\r\n      this._textLines = this._splitTextIntoLines();\r\n      this.insertStyleObjects(_char, isEndOfLine, styleObject);\r\n      this.selectionStart += 1;\r\n      this.selectionEnd = this.selectionStart;\r\n      if (skipUpdate) {\r\n        return;\r\n      }\r\n      this._updateTextarea();\r\n      this.canvas && this.canvas.renderAll();\r\n      this.setCoords();\r\n      this.fire('changed');\r\n      this.canvas && this.canvas.fire('text:changed', { target: this });\r\n    },\r\n\r\n    /**\r\n     * Inserts new style object\r\n     * @param {Number} lineIndex Index of a line\r\n     * @param {Number} charIndex Index of a char\r\n     * @param {Boolean} isEndOfLine True if it's end of line\r\n     */\r\n    insertNewlineStyleObject: function(lineIndex, charIndex, isEndOfLine) {\r\n\r\n      this.shiftLineStyles(lineIndex, +1);\r\n\r\n      if (!this.styles[lineIndex + 1]) {\r\n        this.styles[lineIndex + 1] = {};\r\n      }\r\n\r\n      var currentCharStyle = {},\r\n          newLineStyles    = {};\r\n\r\n      if (this.styles[lineIndex] && this.styles[lineIndex][charIndex - 1]) {\r\n        currentCharStyle = this.styles[lineIndex][charIndex - 1];\r\n      }\r\n\r\n      // if there's nothing after cursor,\r\n      // we clone current char style onto the next (otherwise empty) line\r\n      if (isEndOfLine) {\r\n        newLineStyles[0] = clone(currentCharStyle);\r\n        this.styles[lineIndex + 1] = newLineStyles;\r\n      }\r\n      // otherwise we clone styles of all chars\r\n      // after cursor onto the next line, from the beginning\r\n      else {\r\n        for (var index in this.styles[lineIndex]) {\r\n          if (parseInt(index, 10) >= charIndex) {\r\n            newLineStyles[parseInt(index, 10) - charIndex] = this.styles[lineIndex][index];\r\n            // remove lines from the previous line since they're on a new line now\r\n            delete this.styles[lineIndex][index];\r\n          }\r\n        }\r\n        this.styles[lineIndex + 1] = newLineStyles;\r\n      }\r\n      this._forceClearCache = true;\r\n    },\r\n\r\n    /**\r\n     * Inserts style object for a given line/char index\r\n     * @param {Number} lineIndex Index of a line\r\n     * @param {Number} charIndex Index of a char\r\n     * @param {Object} [style] Style object to insert, if given\r\n     */\r\n    insertCharStyleObject: function(lineIndex, charIndex, style) {\r\n\r\n      var currentLineStyles       = this.styles[lineIndex],\r\n          currentLineStylesCloned = clone(currentLineStyles);\r\n\r\n      if (charIndex === 0 && !style) {\r\n        charIndex = 1;\r\n      }\r\n\r\n      // shift all char styles by 1 forward\r\n      // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4\r\n      for (var index in currentLineStylesCloned) {\r\n        var numericIndex = parseInt(index, 10);\r\n\r\n        if (numericIndex >= charIndex) {\r\n          currentLineStyles[numericIndex + 1] = currentLineStylesCloned[numericIndex];\r\n\r\n          // only delete the style if there was nothing moved there\r\n          if (!currentLineStylesCloned[numericIndex - 1]) {\r\n            delete currentLineStyles[numericIndex];\r\n          }\r\n        }\r\n      }\r\n\r\n      this.styles[lineIndex][charIndex] =\r\n        style || clone(currentLineStyles[charIndex - 1]);\r\n      this._forceClearCache = true;\r\n    },\r\n\r\n    /**\r\n     * Inserts style object(s)\r\n     * @param {String} _chars Characters at the location where style is inserted\r\n     * @param {Boolean} isEndOfLine True if it's end of line\r\n     * @param {Object} [styleObject] Style to insert\r\n     */\r\n    insertStyleObjects: function(_chars, isEndOfLine, styleObject) {\r\n      // removed shortcircuit over isEmptyStyles\r\n\r\n      var cursorLocation = this.get2DCursorLocation(),\r\n          lineIndex      = cursorLocation.lineIndex,\r\n          charIndex      = cursorLocation.charIndex;\r\n\r\n      if (!this._getLineStyle(lineIndex)) {\r\n        this._setLineStyle(lineIndex, {});\r\n      }\r\n\r\n      if (_chars === '\\n') {\r\n        this.insertNewlineStyleObject(lineIndex, charIndex, isEndOfLine);\r\n      }\r\n      else {\r\n        this.insertCharStyleObject(lineIndex, charIndex, styleObject);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Shifts line styles up or down\r\n     * @param {Number} lineIndex Index of a line\r\n     * @param {Number} offset Can be -1 or +1\r\n     */\r\n    shiftLineStyles: function(lineIndex, offset) {\r\n      // shift all line styles by 1 upward\r\n      var clonedStyles = clone(this.styles);\r\n      for (var line in this.styles) {\r\n        var numericLine = parseInt(line, 10);\r\n        if (numericLine > lineIndex) {\r\n          this.styles[numericLine + offset] = clonedStyles[numericLine];\r\n          if (!clonedStyles[numericLine - offset]) {\r\n            delete this.styles[numericLine];\r\n          }\r\n        }\r\n      }\r\n      //TODO: evaluate if delete old style lines with offset -1\r\n    },\r\n\r\n    /**\r\n     * Removes style object\r\n     * @param {Boolean} isBeginningOfLine True if cursor is at the beginning of line\r\n     * @param {Number} [index] Optional index. When not given, current selectionStart is used.\r\n     */\r\n    removeStyleObject: function(isBeginningOfLine, index) {\r\n\r\n      var cursorLocation = this.get2DCursorLocation(index),\r\n          lineIndex      = cursorLocation.lineIndex,\r\n          charIndex      = cursorLocation.charIndex;\r\n\r\n      if (isBeginningOfLine) {\r\n\r\n        var textOnPreviousLine     = this._textLines[lineIndex - 1],\r\n            newCharIndexOnPrevLine = textOnPreviousLine\r\n              ? textOnPreviousLine.length\r\n              : 0;\r\n\r\n        if (!this.styles[lineIndex - 1]) {\r\n          this.styles[lineIndex - 1] = {};\r\n        }\r\n\r\n        for (charIndex in this.styles[lineIndex]) {\r\n          this.styles[lineIndex - 1][parseInt(charIndex, 10) + newCharIndexOnPrevLine]\r\n            = this.styles[lineIndex][charIndex];\r\n        }\r\n\r\n        this.shiftLineStyles(lineIndex, -1);\r\n\r\n      }\r\n      else {\r\n        var currentLineStyles = this.styles[lineIndex];\r\n\r\n        if (currentLineStyles) {\r\n          delete currentLineStyles[charIndex];\r\n          //console.log('deleting', lineIndex, charIndex + offset);\r\n        }\r\n\r\n        var currentLineStylesCloned = clone(currentLineStyles);\r\n\r\n        // shift all styles by 1 backwards\r\n        for (var i in currentLineStylesCloned) {\r\n          var numericIndex = parseInt(i, 10);\r\n          if (numericIndex >= charIndex && numericIndex !== 0) {\r\n            currentLineStyles[numericIndex - 1] = currentLineStylesCloned[numericIndex];\r\n            delete currentLineStyles[numericIndex];\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Inserts new line\r\n     */\r\n    insertNewline: function() {\r\n      this.insertChars('\\n');\r\n    }\r\n  });\r\n})();\r\n\r\n\r\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\r\n  /**\r\n   * Initializes \"dbclick\" event handler\r\n   */\r\n  initDoubleClickSimulation: function() {\r\n\r\n    // for double click\r\n    this.__lastClickTime = +new Date();\r\n\r\n    // for triple click\r\n    this.__lastLastClickTime = +new Date();\r\n\r\n    this.__lastPointer = { };\r\n\r\n    this.on('mousedown', this.onMouseDown.bind(this));\r\n  },\r\n\r\n  onMouseDown: function(options) {\r\n\r\n    this.__newClickTime = +new Date();\r\n    var newPointer = this.canvas.getPointer(options.e);\r\n\r\n    if (this.isTripleClick(newPointer)) {\r\n      this.fire('tripleclick', options);\r\n      this._stopEvent(options.e);\r\n    }\r\n    else if (this.isDoubleClick(newPointer)) {\r\n      this.fire('dblclick', options);\r\n      this._stopEvent(options.e);\r\n    }\r\n\r\n    this.__lastLastClickTime = this.__lastClickTime;\r\n    this.__lastClickTime = this.__newClickTime;\r\n    this.__lastPointer = newPointer;\r\n    this.__lastIsEditing = this.isEditing;\r\n    this.__lastSelected = this.selected;\r\n  },\r\n\r\n  isDoubleClick: function(newPointer) {\r\n    return this.__newClickTime - this.__lastClickTime < 500 &&\r\n        this.__lastPointer.x === newPointer.x &&\r\n        this.__lastPointer.y === newPointer.y && this.__lastIsEditing;\r\n  },\r\n\r\n  isTripleClick: function(newPointer) {\r\n    return this.__newClickTime - this.__lastClickTime < 500 &&\r\n        this.__lastClickTime - this.__lastLastClickTime < 500 &&\r\n        this.__lastPointer.x === newPointer.x &&\r\n        this.__lastPointer.y === newPointer.y;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _stopEvent: function(e) {\r\n    e.preventDefault && e.preventDefault();\r\n    e.stopPropagation && e.stopPropagation();\r\n  },\r\n\r\n  /**\r\n   * Initializes event handlers related to cursor or selection\r\n   */\r\n  initCursorSelectionHandlers: function() {\r\n    this.initSelectedHandler();\r\n    this.initMousedownHandler();\r\n    this.initMouseupHandler();\r\n    this.initClicks();\r\n  },\r\n\r\n  /**\r\n   * Initializes double and triple click event handlers\r\n   */\r\n  initClicks: function() {\r\n    this.on('dblclick', function(options) {\r\n      this.selectWord(this.getSelectionStartFromPointer(options.e));\r\n    });\r\n    this.on('tripleclick', function(options) {\r\n      this.selectLine(this.getSelectionStartFromPointer(options.e));\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Initializes \"mousedown\" event handler\r\n   */\r\n  initMousedownHandler: function() {\r\n    this.on('mousedown', function(options) {\r\n\r\n      var pointer = this.canvas.getPointer(options.e);\r\n\r\n      this.__mousedownX = pointer.x;\r\n      this.__mousedownY = pointer.y;\r\n      this.__isMousedown = true;\r\n\r\n      if (this.hiddenTextarea && this.canvas) {\r\n        this.canvas.wrapperEl.appendChild(this.hiddenTextarea);\r\n      }\r\n\r\n      if (this.selected) {\r\n        this.setCursorByClick(options.e);\r\n      }\r\n\r\n      if (this.isEditing) {\r\n        this.__selectionStartOnMouseDown = this.selectionStart;\r\n        this.initDelayedCursor(true);\r\n      }\r\n    });\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _isObjectMoved: function(e) {\r\n    var pointer = this.canvas.getPointer(e);\r\n\r\n    return this.__mousedownX !== pointer.x ||\r\n           this.__mousedownY !== pointer.y;\r\n  },\r\n\r\n  /**\r\n   * Initializes \"mouseup\" event handler\r\n   */\r\n  initMouseupHandler: function() {\r\n    this.on('mouseup', function(options) {\r\n      this.__isMousedown = false;\r\n      if (this._isObjectMoved(options.e)) {\r\n        return;\r\n      }\r\n\r\n      if (this.__lastSelected && !this.__corner) {\r\n        this.enterEditing();\r\n        this.initDelayedCursor(true);\r\n      }\r\n      this.selected = true;\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Changes cursor location in a text depending on passed pointer (x/y) object\r\n   * @param {Event} e Event object\r\n   */\r\n  setCursorByClick: function(e) {\r\n    var newSelectionStart = this.getSelectionStartFromPointer(e);\r\n\r\n    if (e.shiftKey) {\r\n      if (newSelectionStart < this.selectionStart) {\r\n        this.setSelectionEnd(this.selectionStart);\r\n        this.setSelectionStart(newSelectionStart);\r\n      }\r\n      else {\r\n        this.setSelectionEnd(newSelectionStart);\r\n      }\r\n    }\r\n    else {\r\n      this.setSelectionStart(newSelectionStart);\r\n      this.setSelectionEnd(newSelectionStart);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns index of a character corresponding to where an object was clicked\r\n   * @param {Event} e Event object\r\n   * @return {Number} Index of a character\r\n   */\r\n  getSelectionStartFromPointer: function(e) {\r\n    var mouseOffset = this.getLocalPointer(e),\r\n        prevWidth = 0,\r\n        width = 0,\r\n        height = 0,\r\n        charIndex = 0,\r\n        newSelectionStart,\r\n        line;\r\n\r\n    for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n      line = this._textLines[i];\r\n      height += this._getHeightOfLine(this.ctx, i) * this.scaleY;\r\n\r\n      var widthOfLine = this._getLineWidth(this.ctx, i),\r\n          lineLeftOffset = this._getLineLeftOffset(widthOfLine);\r\n\r\n      width = lineLeftOffset * this.scaleX;\r\n\r\n      if (this.flipX) {\r\n        // when oject is horizontally flipped we reverse chars\r\n        // we should reverse also style or do not revers at all.\r\n        this._textLines[i] = line.reverse().join('');\r\n      }\r\n\r\n      for (var j = 0, jlen = line.length; j < jlen; j++) {\r\n\r\n        prevWidth = width;\r\n\r\n        width += this._getWidthOfChar(this.ctx, line[j], i, this.flipX ? jlen - j : j) *\r\n                 this.scaleX;\r\n\r\n        if (height <= mouseOffset.y || width <= mouseOffset.x) {\r\n          charIndex++;\r\n          continue;\r\n        }\r\n\r\n        return this._getNewSelectionStartFromOffset(\r\n          mouseOffset, prevWidth, width, charIndex + i, jlen);\r\n      }\r\n\r\n      if (mouseOffset.y < height) {\r\n        //this happens just on end of lines.\r\n        return this._getNewSelectionStartFromOffset(\r\n          mouseOffset, prevWidth, width, charIndex + i - 1, jlen);\r\n      }\r\n    }\r\n\r\n    // clicked somewhere after all chars, so set at the end\r\n    if (typeof newSelectionStart === 'undefined') {\r\n      return this.text.length;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {\r\n\r\n    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,\r\n        distanceBtwNextCharAndCursor = width - mouseOffset.x,\r\n        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ? 0 : 1,\r\n        newSelectionStart = index + offset;\r\n\r\n    // if object is horizontally flipped, mirror cursor location from the end\r\n    if (this.flipX) {\r\n      newSelectionStart = jlen - newSelectionStart;\r\n    }\r\n\r\n    if (newSelectionStart > this.text.length) {\r\n      newSelectionStart = this.text.length;\r\n    }\r\n\r\n    return newSelectionStart;\r\n  }\r\n});\r\n\r\n\r\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\r\n\r\n  /**\r\n   * Initializes hidden textarea (needed to bring up keyboard in iOS)\r\n   */\r\n  initHiddenTextarea: function() {\r\n    this.hiddenTextarea = fabric.document.createElement('textarea');\r\n\r\n    this.hiddenTextarea.setAttribute('autocapitalize', 'off');\r\n    this.hiddenTextarea.style.cssText = 'position: fixed; bottom: 20px; left: 0px; opacity: 0;'\r\n                                        + ' width: 0px; height: 0px; z-index: -999;';\r\n    fabric.document.body.appendChild(this.hiddenTextarea);\r\n\r\n    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));\r\n    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));\r\n    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));\r\n    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));\r\n\r\n    if (!this._clickHandlerInitialized && this.canvas) {\r\n      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));\r\n      this._clickHandlerInitialized = true;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _keysMap: {\r\n    8:  'removeChars',\r\n    9:  'exitEditing',\r\n    27: 'exitEditing',\r\n    13: 'insertNewline',\r\n    33: 'moveCursorUp',\r\n    34: 'moveCursorDown',\r\n    35: 'moveCursorRight',\r\n    36: 'moveCursorLeft',\r\n    37: 'moveCursorLeft',\r\n    38: 'moveCursorUp',\r\n    39: 'moveCursorRight',\r\n    40: 'moveCursorDown',\r\n    46: 'forwardDelete'\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _ctrlKeysMap: {\r\n    65: 'selectAll',\r\n    88: 'cut'\r\n  },\r\n\r\n  onClick: function() {\r\n    // No need to trigger click event here, focus is enough to have the keyboard appear on Android\r\n    this.hiddenTextarea && this.hiddenTextarea.focus();\r\n  },\r\n\r\n  /**\r\n   * Handles keyup event\r\n   * @param {Event} e Event object\r\n   */\r\n  onKeyDown: function(e) {\r\n    if (!this.isEditing) {\r\n      return;\r\n    }\r\n    if (e.keyCode in this._keysMap) {\r\n      this[this._keysMap[e.keyCode]](e);\r\n    }\r\n    else if ((e.keyCode in this._ctrlKeysMap) && (e.ctrlKey || e.metaKey)) {\r\n      this[this._ctrlKeysMap[e.keyCode]](e);\r\n    }\r\n    else {\r\n      return;\r\n    }\r\n    e.stopImmediatePropagation();\r\n    e.preventDefault();\r\n    this.canvas && this.canvas.renderAll();\r\n  },\r\n\r\n  /**\r\n   * Handles onInput event\r\n   * @param {Event} e Event object\r\n   */\r\n  onInput: function(e) {\r\n    if (!this.isEditing || this._cancelOnInput) {\r\n      this._cancelOnInput = false;\r\n      return;\r\n    }\r\n    var offset = this.selectionStart || 0,\r\n        textLength = this.text.length,\r\n        newTextLength = this.hiddenTextarea.value.length,\r\n        diff = newTextLength - textLength,\r\n        charsToInsert = this.hiddenTextarea.value.slice(offset, offset + diff);\r\n    this.insertChars(charsToInsert);\r\n    e.stopPropagation();\r\n  },\r\n\r\n  /**\r\n   * Forward delete\r\n   */\r\n  forwardDelete: function(e) {\r\n    if (this.selectionStart === this.selectionEnd) {\r\n      if (this.selectionStart === this.text.length) {\r\n        return;\r\n      }\r\n      this.moveCursorRight(e);\r\n    }\r\n    this.removeChars(e);\r\n  },\r\n\r\n  /**\r\n   * Copies selected text\r\n   * @param {Event} e Event object\r\n   */\r\n  copy: function(e) {\r\n    var selectedText = this.getSelectedText(),\r\n        clipboardData = this._getClipboardData(e);\r\n\r\n    // Check for backward compatibility with old browsers\r\n    if (clipboardData) {\r\n      clipboardData.setData('text', selectedText);\r\n    }\r\n\r\n    fabric.copiedText = selectedText;\r\n    fabric.copiedTextStyle = this.getSelectionStyles(\r\n                          this.selectionStart,\r\n                          this.selectionEnd);\r\n  },\r\n\r\n  /**\r\n   * Pastes text\r\n   * @param {Event} e Event object\r\n   */\r\n  paste: function(e) {\r\n    var copiedText = null,\r\n        clipboardData = this._getClipboardData(e),\r\n        useCopiedStyle = true;\r\n\r\n    // Check for backward compatibility with old browsers\r\n    if (clipboardData) {\r\n      copiedText = clipboardData.getData('text').replace(/\\r/g, '');\r\n      if (!fabric.copiedTextStyle || fabric.copiedText !== copiedText) {\r\n        useCopiedStyle = false;\r\n      }\r\n    }\r\n    else {\r\n      copiedText = fabric.copiedText;\r\n    }\r\n\r\n    if (copiedText) {\r\n      this.insertChars(copiedText, useCopiedStyle);\r\n    }\r\n    this._cancelOnInput = true;\r\n  },\r\n\r\n  /**\r\n   * Cuts text\r\n   * @param {Event} e Event object\r\n   */\r\n  cut: function(e) {\r\n    if (this.selectionStart === this.selectionEnd) {\r\n      return;\r\n    }\r\n\r\n    this.copy();\r\n    this.removeChars(e);\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} e Event object\r\n   * @return {Object} Clipboard data object\r\n   */\r\n  _getClipboardData: function(e) {\r\n    return e && (e.clipboardData || fabric.window.clipboardData);\r\n  },\r\n\r\n  /**\r\n   * Gets start offset of a selection\r\n   * @param {Event} e Event object\r\n   * @param {Boolean} isRight\r\n   * @return {Number}\r\n   */\r\n  getDownCursorOffset: function(e, isRight) {\r\n    var selectionProp = isRight ? this.selectionEnd : this.selectionStart,\r\n        cursorLocation = this.get2DCursorLocation(selectionProp),\r\n        _char, lineLeftOffset, lineIndex = cursorLocation.lineIndex,\r\n        textOnSameLineBeforeCursor = this._textLines[lineIndex].slice(0, cursorLocation.charIndex),\r\n        textOnSameLineAfterCursor = this._textLines[lineIndex].slice(cursorLocation.charIndex),\r\n        textOnNextLine = this._textLines[lineIndex + 1] || '';\r\n\r\n    // if on last line, down cursor goes to end of line\r\n    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {\r\n\r\n      // move to the end of a text\r\n      return this.text.length - selectionProp;\r\n    }\r\n\r\n    var widthOfSameLineBeforeCursor = this._getLineWidth(this.ctx, lineIndex);\r\n    lineLeftOffset = this._getLineLeftOffset(widthOfSameLineBeforeCursor);\r\n\r\n    var widthOfCharsOnSameLineBeforeCursor = lineLeftOffset;\r\n\r\n    for (var i = 0, len = textOnSameLineBeforeCursor.length; i < len; i++) {\r\n      _char = textOnSameLineBeforeCursor[i];\r\n      widthOfCharsOnSameLineBeforeCursor += this._getWidthOfChar(this.ctx, _char, lineIndex, i);\r\n    }\r\n\r\n    var indexOnNextLine = this._getIndexOnNextLine(\r\n      cursorLocation, textOnNextLine, widthOfCharsOnSameLineBeforeCursor);\r\n\r\n    return textOnSameLineAfterCursor.length + 1 + indexOnNextLine;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _getIndexOnNextLine: function(cursorLocation, textOnNextLine, widthOfCharsOnSameLineBeforeCursor) {\r\n    var lineIndex = cursorLocation.lineIndex + 1,\r\n        widthOfNextLine = this._getLineWidth(this.ctx, lineIndex),\r\n        lineLeftOffset = this._getLineLeftOffset(widthOfNextLine),\r\n        widthOfCharsOnNextLine = lineLeftOffset,\r\n        indexOnNextLine = 0,\r\n        foundMatch;\r\n\r\n    for (var j = 0, jlen = textOnNextLine.length; j < jlen; j++) {\r\n\r\n      var _char = textOnNextLine[j],\r\n          widthOfChar = this._getWidthOfChar(this.ctx, _char, lineIndex, j);\r\n\r\n      widthOfCharsOnNextLine += widthOfChar;\r\n\r\n      if (widthOfCharsOnNextLine > widthOfCharsOnSameLineBeforeCursor) {\r\n\r\n        foundMatch = true;\r\n\r\n        var leftEdge = widthOfCharsOnNextLine - widthOfChar,\r\n            rightEdge = widthOfCharsOnNextLine,\r\n            offsetFromLeftEdge = Math.abs(leftEdge - widthOfCharsOnSameLineBeforeCursor),\r\n            offsetFromRightEdge = Math.abs(rightEdge - widthOfCharsOnSameLineBeforeCursor);\r\n\r\n        indexOnNextLine = offsetFromRightEdge < offsetFromLeftEdge ? j + 1 : j;\r\n\r\n        break;\r\n      }\r\n    }\r\n\r\n    // reached end\r\n    if (!foundMatch) {\r\n      indexOnNextLine = textOnNextLine.length;\r\n    }\r\n\r\n    return indexOnNextLine;\r\n  },\r\n\r\n  /**\r\n   * Moves cursor down\r\n   * @param {Event} e Event object\r\n   */\r\n  moveCursorDown: function(e) {\r\n    this.abortCursorAnimation();\r\n    this._currentCursorOpacity = 1;\r\n\r\n    var offset = this.getDownCursorOffset(e, this._selectionDirection === 'right');\r\n\r\n    if (e.shiftKey) {\r\n      this.moveCursorDownWithShift(offset);\r\n    }\r\n    else {\r\n      this.moveCursorDownWithoutShift(offset);\r\n    }\r\n\r\n    this.initDelayedCursor();\r\n  },\r\n\r\n  /**\r\n   * Moves cursor down without keeping selection\r\n   * @param {Number} offset\r\n   */\r\n  moveCursorDownWithoutShift: function(offset) {\r\n    this._selectionDirection = 'right';\r\n    this.setSelectionStart(this.selectionStart + offset);\r\n    this.setSelectionEnd(this.selectionStart);\r\n  },\r\n\r\n  /**\r\n   * private\r\n   */\r\n  swapSelectionPoints: function() {\r\n    var swapSel = this.selectionEnd;\r\n    this.setSelectionEnd(this.selectionStart);\r\n    this.setSelectionStart(swapSel);\r\n  },\r\n\r\n  /**\r\n   * Moves cursor down while keeping selection\r\n   * @param {Number} offset\r\n   */\r\n  moveCursorDownWithShift: function(offset) {\r\n    if (this.selectionEnd === this.selectionStart) {\r\n      this._selectionDirection = 'right';\r\n    }\r\n    if (this._selectionDirection === 'right') {\r\n      this.setSelectionEnd(this.selectionEnd + offset);\r\n    }\r\n    else {\r\n      this.setSelectionStart(this.selectionStart + offset);\r\n    }\r\n    if (this.selectionEnd < this.selectionStart  && this._selectionDirection === 'left') {\r\n      this.swapSelectionPoints();\r\n      this._selectionDirection = 'right';\r\n    }\r\n    if (this.selectionEnd > this.text.length) {\r\n      this.setSelectionEnd(this.text.length);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @param {Event} e Event object\r\n   * @param {Boolean} isRight\r\n   * @return {Number}\r\n   */\r\n  getUpCursorOffset: function(e, isRight) {\r\n    var selectionProp = isRight ? this.selectionEnd : this.selectionStart,\r\n        cursorLocation = this.get2DCursorLocation(selectionProp),\r\n        lineIndex = cursorLocation.lineIndex;\r\n    // if on first line, up cursor goes to start of line\r\n    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {\r\n      return selectionProp;\r\n    }\r\n\r\n    var textOnSameLineBeforeCursor = this._textLines[lineIndex].slice(0, cursorLocation.charIndex),\r\n        textOnPreviousLine = this._textLines[lineIndex - 1] || '',\r\n        _char,\r\n        widthOfSameLineBeforeCursor = this._getLineWidth(this.ctx, cursorLocation.lineIndex),\r\n        lineLeftOffset = this._getLineLeftOffset(widthOfSameLineBeforeCursor),\r\n        widthOfCharsOnSameLineBeforeCursor = lineLeftOffset;\r\n\r\n    for (var i = 0, len = textOnSameLineBeforeCursor.length; i < len; i++) {\r\n      _char = textOnSameLineBeforeCursor[i];\r\n      widthOfCharsOnSameLineBeforeCursor += this._getWidthOfChar(this.ctx, _char, lineIndex, i);\r\n    }\r\n\r\n    var indexOnPrevLine = this._getIndexOnPrevLine(\r\n      cursorLocation, textOnPreviousLine, widthOfCharsOnSameLineBeforeCursor);\r\n\r\n    return textOnPreviousLine.length - indexOnPrevLine + textOnSameLineBeforeCursor.length;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _getIndexOnPrevLine: function(cursorLocation, textOnPreviousLine, widthOfCharsOnSameLineBeforeCursor) {\r\n\r\n    var lineIndex = cursorLocation.lineIndex - 1,\r\n        widthOfPreviousLine = this._getLineWidth(this.ctx, lineIndex),\r\n        lineLeftOffset = this._getLineLeftOffset(widthOfPreviousLine),\r\n        widthOfCharsOnPreviousLine = lineLeftOffset,\r\n        indexOnPrevLine = 0,\r\n        foundMatch;\r\n\r\n    for (var j = 0, jlen = textOnPreviousLine.length; j < jlen; j++) {\r\n\r\n      var _char = textOnPreviousLine[j],\r\n          widthOfChar = this._getWidthOfChar(this.ctx, _char, lineIndex, j);\r\n\r\n      widthOfCharsOnPreviousLine += widthOfChar;\r\n\r\n      if (widthOfCharsOnPreviousLine > widthOfCharsOnSameLineBeforeCursor) {\r\n\r\n        foundMatch = true;\r\n\r\n        var leftEdge = widthOfCharsOnPreviousLine - widthOfChar,\r\n            rightEdge = widthOfCharsOnPreviousLine,\r\n            offsetFromLeftEdge = Math.abs(leftEdge - widthOfCharsOnSameLineBeforeCursor),\r\n            offsetFromRightEdge = Math.abs(rightEdge - widthOfCharsOnSameLineBeforeCursor);\r\n\r\n        indexOnPrevLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);\r\n\r\n        break;\r\n      }\r\n    }\r\n\r\n    // reached end\r\n    if (!foundMatch) {\r\n      indexOnPrevLine = textOnPreviousLine.length - 1;\r\n    }\r\n\r\n    return indexOnPrevLine;\r\n  },\r\n\r\n  /**\r\n   * Moves cursor up\r\n   * @param {Event} e Event object\r\n   */\r\n  moveCursorUp: function(e) {\r\n\r\n    this.abortCursorAnimation();\r\n    this._currentCursorOpacity = 1;\r\n\r\n    var offset = this.getUpCursorOffset(e, this._selectionDirection === 'right');\r\n    if (e.shiftKey) {\r\n      this.moveCursorUpWithShift(offset);\r\n    }\r\n    else {\r\n      this.moveCursorUpWithoutShift(offset);\r\n    }\r\n\r\n    this.initDelayedCursor();\r\n  },\r\n\r\n  /**\r\n   * Moves cursor up with shift\r\n   * @param {Number} offset\r\n   */\r\n  moveCursorUpWithShift: function(offset) {\r\n    if (this.selectionEnd === this.selectionStart) {\r\n      this._selectionDirection = 'left';\r\n    }\r\n    if (this._selectionDirection === 'right') {\r\n      this.setSelectionEnd(this.selectionEnd - offset);\r\n    }\r\n    else {\r\n      this.setSelectionStart(this.selectionStart - offset);\r\n    }\r\n    if (this.selectionEnd < this.selectionStart && this._selectionDirection === 'right') {\r\n      this.swapSelectionPoints();\r\n      this._selectionDirection = 'left';\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Moves cursor up without shift\r\n   * @param {Number} offset\r\n   */\r\n  moveCursorUpWithoutShift: function(offset) {\r\n    if (this.selectionStart === this.selectionEnd) {\r\n      this.setSelectionStart(this.selectionStart - offset);\r\n    }\r\n    this.setSelectionEnd(this.selectionStart);\r\n\r\n    this._selectionDirection = 'left';\r\n  },\r\n\r\n  /**\r\n   * Moves cursor left\r\n   * @param {Event} e Event object\r\n   */\r\n  moveCursorLeft: function(e) {\r\n    if (this.selectionStart === 0 && this.selectionEnd === 0) {\r\n      return;\r\n    }\r\n\r\n    this.abortCursorAnimation();\r\n    this._currentCursorOpacity = 1;\r\n\r\n    if (e.shiftKey) {\r\n      this.moveCursorLeftWithShift(e);\r\n    }\r\n    else {\r\n      this.moveCursorLeftWithoutShift(e);\r\n    }\r\n\r\n    this.initDelayedCursor();\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _move: function(e, prop, direction) {\r\n    var propMethod = (prop === 'selectionStart' ? 'setSelectionStart' : 'setSelectionEnd');\r\n    if (e.altKey) {\r\n      this[propMethod](this['findWordBoundary' + direction](this[prop]));\r\n    }\r\n    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {\r\n      this[propMethod](this['findLineBoundary' + direction](this[prop]));\r\n    }\r\n    else {\r\n      this[propMethod](this[prop] + (direction === 'Left' ? -1 : 1));\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _moveLeft: function(e, prop) {\r\n    this._move(e, prop, 'Left');\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _moveRight: function(e, prop) {\r\n    this._move(e, prop, 'Right');\r\n  },\r\n\r\n  /**\r\n   * Moves cursor left without keeping selection\r\n   * @param {Event} e\r\n   */\r\n  moveCursorLeftWithoutShift: function(e) {\r\n    this._selectionDirection = 'left';\r\n\r\n    // only move cursor when there is no selection,\r\n    // otherwise we discard it, and leave cursor on same place\r\n    if (this.selectionEnd === this.selectionStart) {\r\n      this._moveLeft(e, 'selectionStart');\r\n    }\r\n    this.setSelectionEnd(this.selectionStart);\r\n  },\r\n\r\n  /**\r\n   * Moves cursor left while keeping selection\r\n   * @param {Event} e\r\n   */\r\n  moveCursorLeftWithShift: function(e) {\r\n    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {\r\n      this._moveLeft(e, 'selectionEnd');\r\n    }\r\n    else {\r\n      this._selectionDirection = 'left';\r\n      this._moveLeft(e, 'selectionStart');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Moves cursor right\r\n   * @param {Event} e Event object\r\n   */\r\n  moveCursorRight: function(e) {\r\n    if (this.selectionStart >= this.text.length && this.selectionEnd >= this.text.length) {\r\n      return;\r\n    }\r\n\r\n    this.abortCursorAnimation();\r\n    this._currentCursorOpacity = 1;\r\n\r\n    if (e.shiftKey) {\r\n      this.moveCursorRightWithShift(e);\r\n    }\r\n    else {\r\n      this.moveCursorRightWithoutShift(e);\r\n    }\r\n\r\n    this.initDelayedCursor();\r\n  },\r\n\r\n  /**\r\n   * Moves cursor right while keeping selection\r\n   * @param {Event} e\r\n   */\r\n  moveCursorRightWithShift: function(e) {\r\n    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {\r\n      this._moveRight(e, 'selectionStart');\r\n    }\r\n    else {\r\n      this._selectionDirection = 'right';\r\n      this._moveRight(e, 'selectionEnd');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Moves cursor right without keeping selection\r\n   * @param {Event} e Event object\r\n   */\r\n  moveCursorRightWithoutShift: function(e) {\r\n    this._selectionDirection = 'right';\r\n\r\n    if (this.selectionStart === this.selectionEnd) {\r\n      this._moveRight(e, 'selectionStart');\r\n      this.setSelectionEnd(this.selectionStart);\r\n    }\r\n    else {\r\n      this.setSelectionEnd(this.selectionEnd + this.getNumNewLinesInSelectedText());\r\n      this.setSelectionStart(this.selectionEnd);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Removes characters selected by selection\r\n   * @param {Event} e Event object\r\n   */\r\n  removeChars: function(e) {\r\n    if (this.selectionStart === this.selectionEnd) {\r\n      this._removeCharsNearCursor(e);\r\n    }\r\n    else {\r\n      this._removeCharsFromTo(this.selectionStart, this.selectionEnd);\r\n    }\r\n\r\n    this.setSelectionEnd(this.selectionStart);\r\n\r\n    this._removeExtraneousStyles();\r\n\r\n    this.canvas && this.canvas.renderAll();\r\n\r\n    this.setCoords();\r\n    this.fire('changed');\r\n    this.canvas && this.canvas.fire('text:changed', { target: this });\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} e Event object\r\n   */\r\n  _removeCharsNearCursor: function(e) {\r\n    if (this.selectionStart === 0) {\r\n      return;\r\n    }\r\n    if (e.metaKey) {\r\n      // remove all till the start of current line\r\n      var leftLineBoundary = this.findLineBoundaryLeft(this.selectionStart);\r\n\r\n      this._removeCharsFromTo(leftLineBoundary, this.selectionStart);\r\n      this.setSelectionStart(leftLineBoundary);\r\n    }\r\n    else if (e.altKey) {\r\n      // remove all till the start of current word\r\n      var leftWordBoundary = this.findWordBoundaryLeft(this.selectionStart);\r\n\r\n      this._removeCharsFromTo(leftWordBoundary, this.selectionStart);\r\n      this.setSelectionStart(leftWordBoundary);\r\n    }\r\n    else {\r\n      this._removeSingleCharAndStyle(this.selectionStart);\r\n      this.setSelectionStart(this.selectionStart - 1);\r\n    }\r\n  }\r\n});\r\n\r\n\r\n/* _TO_SVG_START_ */\r\n(function() {\r\n  var toFixed = fabric.util.toFixed,\r\n      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\r\n\r\n  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGTextLineText: function(lineIndex, textSpans, height, textLeftOffset, textTopOffset, textBgRects) {\r\n      if (!this.styles[lineIndex]) {\r\n        fabric.Text.prototype._setSVGTextLineText.call(this,\r\n          lineIndex, textSpans, height, textLeftOffset, textTopOffset);\r\n      }\r\n      else {\r\n        this._setSVGTextLineChars(\r\n          lineIndex, textSpans, height, textLeftOffset, textBgRects);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGTextLineChars: function(lineIndex, textSpans, height, textLeftOffset, textBgRects) {\r\n\r\n      var chars = this._textLines[lineIndex],\r\n          charOffset = 0,\r\n          lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex)) - this.width / 2,\r\n          lineOffset = this._getSVGLineTopOffset(lineIndex),\r\n          heightOfLine = this._getHeightOfLine(this.ctx, lineIndex);\r\n\r\n      for (var i = 0, len = chars.length; i < len; i++) {\r\n        var styleDecl = this.styles[lineIndex][i] || { };\r\n\r\n        textSpans.push(\r\n          this._createTextCharSpan(\r\n            chars[i], styleDecl, lineLeftOffset, lineOffset.lineTop + lineOffset.offset, charOffset));\r\n\r\n        var charWidth = this._getWidthOfChar(this.ctx, chars[i], lineIndex, i);\r\n\r\n        if (styleDecl.textBackgroundColor) {\r\n          textBgRects.push(\r\n            this._createTextCharBg(\r\n              styleDecl, lineLeftOffset, lineOffset.lineTop, heightOfLine, charWidth, charOffset));\r\n        }\r\n\r\n        charOffset += charWidth;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getSVGLineTopOffset: function(lineIndex) {\r\n      var lineTopOffset = 0, lastHeight = 0;\r\n      for (var j = 0; j < lineIndex; j++) {\r\n        lineTopOffset += this._getHeightOfLine(this.ctx, j);\r\n      }\r\n      lastHeight = this._getHeightOfLine(this.ctx, j);\r\n      return {\r\n        lineTop: lineTopOffset,\r\n        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _createTextCharBg: function(styleDecl, lineLeftOffset, lineTopOffset, heightOfLine, charWidth, charOffset) {\r\n      return [\r\n        //jscs:disable validateIndentation\r\n        '<rect fill=\"', styleDecl.textBackgroundColor,\r\n        '\" x=\"', toFixed(lineLeftOffset + charOffset, NUM_FRACTION_DIGITS),\r\n        '\" y=\"', toFixed(lineTopOffset - this.height/2, NUM_FRACTION_DIGITS),\r\n        '\" width=\"', toFixed(charWidth, NUM_FRACTION_DIGITS),\r\n        '\" height=\"', toFixed(heightOfLine / this.lineHeight, NUM_FRACTION_DIGITS),\r\n        '\"></rect>'\r\n        //jscs:enable validateIndentation\r\n      ].join('');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _createTextCharSpan: function(_char, styleDecl, lineLeftOffset, lineTopOffset, charOffset) {\r\n\r\n      var fillStyles = this.getSvgStyles.call(fabric.util.object.extend({\r\n        visible: true,\r\n        fill: this.fill,\r\n        stroke: this.stroke,\r\n        type: 'text'\r\n      }, styleDecl));\r\n\r\n      return [\r\n        //jscs:disable validateIndentation\r\n        '<tspan x=\"', toFixed(lineLeftOffset + charOffset, NUM_FRACTION_DIGITS), '\" y=\"',\r\n          toFixed(lineTopOffset - this.height/2, NUM_FRACTION_DIGITS), '\" ',\r\n          (styleDecl.fontFamily ? 'font-family=\"' + styleDecl.fontFamily.replace(/\"/g, '\\'') + '\" ': ''),\r\n          (styleDecl.fontSize ? 'font-size=\"' + styleDecl.fontSize + '\" ': ''),\r\n          (styleDecl.fontStyle ? 'font-style=\"' + styleDecl.fontStyle + '\" ': ''),\r\n          (styleDecl.fontWeight ? 'font-weight=\"' + styleDecl.fontWeight + '\" ': ''),\r\n          (styleDecl.textDecoration ? 'text-decoration=\"' + styleDecl.textDecoration + '\" ': ''),\r\n          'style=\"', fillStyles, '\">',\r\n          fabric.util.string.escapeXml(_char),\r\n        '</tspan>'\r\n        //jscs:enable validateIndentation\r\n      ].join('');\r\n    }\r\n  });\r\n})();\r\n/* _TO_SVG_END_ */\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = {}),\r\n      clone  = fabric.util.object.clone;\r\n\r\n  /**\r\n   * Textbox class, based on IText, allows the user to resize the text rectangle\r\n   * and wraps lines automatically. Textboxes have their Y scaling locked, the\r\n   * user can only change width. Height is adjusted automatically based on the\r\n   * wrapping of lines.\r\n   * @class fabric.Textbox\r\n   * @extends fabric.IText\r\n   * @mixes fabric.Observable\r\n   * @return {fabric.Textbox} thisArg\r\n   * @see {@link fabric.Textbox#initialize} for constructor definition\r\n   */\r\n  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'textbox',\r\n    /**\r\n     * Minimum width of textbox, in pixels.\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minWidth: 20,\r\n    /**\r\n     * Minimum calculated width of a textbox, in pixels.\r\n     * @type Number\r\n     * @default\r\n     */\r\n    dynamicMinWidth: 0,\r\n    /**\r\n     * Cached array of text wrapping.\r\n     * @type Array\r\n     */\r\n    __cachedLines: null,\r\n    /**\r\n     * Constructor. Some scaling related property values are forced. Visibility\r\n     * of controls is also fixed; only the rotation and width controls are\r\n     * made available.\r\n     * @param {String} text Text string\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Textbox} thisArg\r\n     */\r\n    initialize: function(text, options) {\r\n      this.ctx = fabric.util.createCanvasElement().getContext('2d');\r\n\r\n      this.callSuper('initialize', text, options);\r\n      this.set({\r\n        lockUniScaling: false,\r\n        lockScalingY: true,\r\n        lockScalingFlip: true,\r\n        hasBorders: true\r\n      });\r\n      this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility());\r\n\r\n      // add width to this list of props that effect line wrapping.\r\n      this._dimensionAffectingProps.width = true;\r\n    },\r\n\r\n    /**\r\n     * Unlike superclass's version of this function, Textbox does not update\r\n     * its width.\r\n     * @param {CanvasRenderingContext2D} ctx Context to use for measurements\r\n     * @private\r\n     * @override\r\n     */\r\n    _initDimensions: function(ctx) {\r\n      if (this.__skipDimension) {\r\n        return;\r\n      }\r\n\r\n      if (!ctx) {\r\n        ctx = fabric.util.createCanvasElement().getContext('2d');\r\n        this._setTextStyles(ctx);\r\n      }\r\n\r\n      // clear dynamicMinWidth as it will be different after we re-wrap line\r\n      this.dynamicMinWidth = 0;\r\n\r\n      // wrap lines\r\n      this._textLines = this._splitTextIntoLines();\r\n\r\n      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap\r\n      if (this.dynamicMinWidth > this.width) {\r\n        this._set('width', this.dynamicMinWidth);\r\n      }\r\n\r\n      // clear cache and re-calculate height\r\n      this._clearCache();\r\n      this.height = this._getTextHeight(ctx);\r\n    },\r\n\r\n    /**\r\n     * Generate an object that translates the style object so that it is\r\n     * broken up by visual lines (new lines and automatic wrapping).\r\n     * The original text styles object is broken up by actual lines (new lines only),\r\n     * which is only sufficient for Text / IText\r\n     * @private\r\n     */\r\n    _generateStyleMap: function() {\r\n      var realLineCount     = 0,\r\n          realLineCharCount = 0,\r\n          charCount         = 0,\r\n          map               = {};\r\n\r\n      for (var i = 0; i < this._textLines.length; i++) {\r\n        if (this.text[charCount] === '\\n') {\r\n          realLineCharCount = 0;\r\n          charCount++;\r\n          realLineCount++;\r\n        }\r\n        else if (this.text[charCount] === ' ') {\r\n          // this case deals with space's that are removed from end of lines when wrapping\r\n          realLineCharCount++;\r\n          charCount++;\r\n        }\r\n\r\n        map[i] = { line: realLineCount, offset: realLineCharCount };\r\n\r\n        charCount += this._textLines[i].length;\r\n        realLineCharCount += this._textLines[i].length;\r\n      }\r\n\r\n      return map;\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @param {Boolean} [returnCloneOrEmpty=false]\r\n     * @private\r\n     */\r\n    _getStyleDeclaration: function(lineIndex, charIndex, returnCloneOrEmpty) {\r\n      if (this._styleMap) {\r\n        var map = this._styleMap[lineIndex];\r\n        lineIndex = map.line;\r\n        charIndex = map.offset + charIndex;\r\n      }\r\n      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex, returnCloneOrEmpty);\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @param {Object} style\r\n     * @private\r\n     */\r\n    _setStyleDeclaration: function(lineIndex, charIndex, style) {\r\n      var map = this._styleMap[lineIndex];\r\n      lineIndex = map.line;\r\n      charIndex = map.offset + charIndex;\r\n\r\n      this.styles[lineIndex][charIndex] = style;\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @private\r\n     */\r\n    _deleteStyleDeclaration: function(lineIndex, charIndex) {\r\n      var map = this._styleMap[lineIndex];\r\n      lineIndex = map.line;\r\n      charIndex = map.offset + charIndex;\r\n\r\n      delete this.styles[lineIndex][charIndex];\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @private\r\n     */\r\n    _getLineStyle: function(lineIndex) {\r\n      var map = this._styleMap[lineIndex];\r\n      return this.styles[map.line];\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Object} style\r\n     * @private\r\n     */\r\n    _setLineStyle: function(lineIndex, style) {\r\n      var map = this._styleMap[lineIndex];\r\n      this.styles[map.line] = style;\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @private\r\n     */\r\n    _deleteLineStyle: function(lineIndex) {\r\n      var map = this._styleMap[lineIndex];\r\n      delete this.styles[map.line];\r\n    },\r\n\r\n    /**\r\n     * Wraps text using the 'width' property of Textbox. First this function\r\n     * splits text on newlines, so we preserve newlines entered by the user.\r\n     * Then it wraps each line using the width of the Textbox by calling\r\n     * _wrapLine().\r\n     * @param {CanvasRenderingContext2D} ctx Context to use for measurements\r\n     * @param {String} text The string of text that is split into lines\r\n     * @returns {Array} Array of lines\r\n     */\r\n    _wrapText: function(ctx, text) {\r\n      var lines = text.split(this._reNewline), wrapped = [], i;\r\n\r\n      for (i = 0; i < lines.length; i++) {\r\n        wrapped = wrapped.concat(this._wrapLine(ctx, lines[i], i));\r\n      }\r\n\r\n      return wrapped;\r\n    },\r\n\r\n    /**\r\n     * Helper function to measure a string of text, given its lineIndex and charIndex offset\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {String} text\r\n     * @param {number} lineIndex\r\n     * @param {number} charOffset\r\n     * @returns {number}\r\n     * @private\r\n     */\r\n    _measureText: function(ctx, text, lineIndex, charOffset) {\r\n      var width = 0, decl;\r\n      charOffset = charOffset || 0;\r\n\r\n      for (var i = 0; i < text.length; i++) {\r\n        if (this.styles && this.styles[lineIndex] && (decl = this.styles[lineIndex][i + charOffset])) {\r\n          ctx.save();\r\n          width += this._applyCharStylesGetWidth(ctx, text[i], lineIndex, i, decl);\r\n          ctx.restore();\r\n        }\r\n        else {\r\n          // @note: we intentionally pass in an empty style declaration, because if we pass in nothing, it will\r\n          // retry fetching style declaration\r\n          width += this._applyCharStylesGetWidth(ctx, text[i], lineIndex, i, {});\r\n        }\r\n      }\r\n\r\n      return width;\r\n    },\r\n\r\n    /**\r\n     * Wraps a line of text using the width of the Textbox and a context.\r\n     * @param {CanvasRenderingContext2D} ctx Context to use for measurements\r\n     * @param {String} text The string of text to split into lines\r\n     * @param {Number} lineIndex\r\n     * @returns {Array} Array of line(s) into which the given text is wrapped\r\n     * to.\r\n     */\r\n    _wrapLine: function(ctx, text, lineIndex) {\r\n      var maxWidth  = this.width,\r\n          lineWidth = this._measureText(ctx, text, lineIndex, 0);\r\n\r\n      // first case: does the whole line fit?\r\n      if (lineWidth < maxWidth) {\r\n        // if the current line is only one word, we need to keep track of it if it's a large word\r\n        if (text.indexOf(' ') === -1 && lineWidth > this.dynamicMinWidth) {\r\n          this.dynamicMinWidth = lineWidth;\r\n        }\r\n\r\n        return [text];\r\n      }\r\n\r\n      // if the whole line doesn't fit, we break it up into words\r\n      var lines            = [],\r\n          line             = '',\r\n          words            = text.split(' '),\r\n          offset           = 0,\r\n          infix            = '',\r\n          wordWidth        = 0,\r\n          largestWordWidth = 0;\r\n\r\n      while (words.length > 0) {\r\n        infix = line === '' ? '' : ' ';\r\n        wordWidth = this._measureText(ctx, words[0], lineIndex, line.length + infix.length + offset);\r\n        lineWidth = line === '' ? wordWidth : this._measureText(ctx, line + infix + words[0], lineIndex, offset);\r\n\r\n        if (lineWidth < maxWidth || (line === '' && wordWidth >= maxWidth)) {\r\n          line += infix + words.shift();\r\n        }\r\n        else {\r\n          offset += line.length + 1; // add 1 because each word is separated by a space\r\n          lines.push(line);\r\n          line = '';\r\n        }\r\n\r\n        if (words.length === 0) {\r\n          lines.push(line);\r\n        }\r\n\r\n        // keep track of largest word\r\n        if (wordWidth > largestWordWidth) {\r\n          largestWordWidth = wordWidth;\r\n        }\r\n      }\r\n\r\n      if (largestWordWidth > this.dynamicMinWidth) {\r\n        this.dynamicMinWidth = largestWordWidth;\r\n      }\r\n\r\n      return lines;\r\n    },\r\n\r\n    /**\r\n     * Gets lines of text to render in the Textbox. This function calculates\r\n     * text wrapping on the fly everytime it is called.\r\n     * @returns {Array} Array of lines in the Textbox.\r\n     * @override\r\n     */\r\n    _splitTextIntoLines: function() {\r\n      this.ctx.save();\r\n      this._setTextStyles(this.ctx);\r\n\r\n      var lines = this._wrapText(this.ctx, this.text);\r\n\r\n      this.ctx.restore();\r\n      this._textLines = lines;\r\n      this._styleMap = this._generateStyleMap();\r\n      return lines;\r\n    },\r\n\r\n    /**\r\n     * When part of a group, we don't want the Textbox's scale to increase if\r\n     * the group's increases. That's why we reduce the scale of the Textbox by\r\n     * the amount that the group's increases. This is to maintain the effective\r\n     * scale of the Textbox at 1, so that font-size values make sense. Otherwise\r\n     * the same font-size value would result in different actual size depending\r\n     * on the value of the scale.\r\n     * @param {String} key\r\n     * @param {Any} value\r\n     */\r\n    setOnGroup: function(key, value) {\r\n      if (key === 'scaleX') {\r\n        this.set('scaleX', Math.abs(1 / value));\r\n        this.set('width', (this.get('width') * value) /\r\n          (typeof this.__oldScaleX === 'undefined' ? 1 : this.__oldScaleX));\r\n        this.__oldScaleX = value;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start).\r\n     * Overrides the superclass function to take into account text wrapping.\r\n     *\r\n     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.\r\n     */\r\n    get2DCursorLocation: function(selectionStart) {\r\n      if (typeof selectionStart === 'undefined') {\r\n        selectionStart = this.selectionStart;\r\n      }\r\n\r\n      var numLines = this._textLines.length,\r\n          removed  = 0;\r\n\r\n      for (var i = 0; i < numLines; i++) {\r\n        var line    = this._textLines[i],\r\n            lineLen = line.length;\r\n\r\n        if (selectionStart <= removed + lineLen) {\r\n          return {\r\n            lineIndex: i,\r\n            charIndex: selectionStart - removed\r\n          };\r\n        }\r\n\r\n        removed += lineLen;\r\n\r\n        if (this.text[removed] === '\\n' || this.text[removed] === ' ') {\r\n          removed++;\r\n        }\r\n      }\r\n\r\n      return {\r\n        lineIndex: numLines - 1,\r\n        charIndex: this._textLines[numLines - 1].length\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Overrides superclass function and uses text wrapping data to get cursor\r\n     * boundary offsets instead of the array of chars.\r\n     * @param {Array} chars Unused\r\n     * @param {String} typeOfBoundaries Can be 'cursor' or 'selection'\r\n     * @returns {Object} Object with 'top', 'left', and 'lineLeft' properties set.\r\n     */\r\n    _getCursorBoundariesOffsets: function(chars, typeOfBoundaries) {\r\n      var topOffset      = 0,\r\n          leftOffset     = 0,\r\n          cursorLocation = this.get2DCursorLocation(),\r\n          lineChars      = this._textLines[cursorLocation.lineIndex].split(''),\r\n          lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, cursorLocation.lineIndex));\r\n\r\n      for (var i = 0; i < cursorLocation.charIndex; i++) {\r\n        leftOffset += this._getWidthOfChar(this.ctx, lineChars[i], cursorLocation.lineIndex, i);\r\n      }\r\n\r\n      for (i = 0; i < cursorLocation.lineIndex; i++) {\r\n        topOffset += this._getHeightOfLine(this.ctx, i);\r\n      }\r\n\r\n      if (typeOfBoundaries === 'cursor') {\r\n        topOffset += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, cursorLocation.lineIndex)\r\n          / this.lineHeight - this.getCurrentCharFontSize(cursorLocation.lineIndex, cursorLocation.charIndex)\r\n          * (1 - this._fontSizeFraction);\r\n      }\r\n\r\n      return {\r\n        top: topOffset,\r\n        left: leftOffset,\r\n        lineLeft: lineLeftOffset\r\n      };\r\n    },\r\n\r\n    getMinWidth: function() {\r\n      return Math.max(this.minWidth, this.dynamicMinWidth);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @method toObject\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {\r\n        minWidth: this.minWidth\r\n      });\r\n    }\r\n  });\r\n  /**\r\n   * Returns fabric.Textbox instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Textbox\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Textbox} instance of fabric.Textbox\r\n   */\r\n  fabric.Textbox.fromObject = function(object) {\r\n    return new fabric.Textbox(object.text, clone(object));\r\n  };\r\n  /**\r\n   * Returns the default controls visibility required for Textboxes.\r\n   * @returns {Object}\r\n   */\r\n  fabric.Textbox.getTextboxControlVisibility = function() {\r\n    return {\r\n      tl: false,\r\n      tr: false,\r\n      br: false,\r\n      bl: false,\r\n      ml: true,\r\n      mt: false,\r\n      mr: true,\r\n      mb: false,\r\n      mtr: true\r\n    };\r\n  };\r\n  /**\r\n   * Contains all fabric.Textbox objects that have been created\r\n   * @static\r\n   * @memberOf fabric.Textbox\r\n   * @type Array\r\n   */\r\n  fabric.Textbox.instances = [];\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function() {\r\n\r\n  /**\r\n   * Override _setObjectScale and add Textbox specific resizing behavior. Resizing\r\n   * a Textbox doesn't scale text, it only changes width and makes text wrap automatically.\r\n   */\r\n  var setObjectScaleOverridden = fabric.Canvas.prototype._setObjectScale;\r\n\r\n  fabric.Canvas.prototype._setObjectScale = function(localMouse, transform,\r\n                                                     lockScalingX, lockScalingY, by, lockScalingFlip) {\r\n\r\n    var t = transform.target;\r\n    if (t instanceof fabric.Textbox) {\r\n      var w = t.width * ((localMouse.x / transform.scaleX) / (t.width + t.strokeWidth));\r\n      if (w >= t.getMinWidth()) {\r\n        t.set('width', w);\r\n      }\r\n    }\r\n    else {\r\n      setObjectScaleOverridden.call(fabric.Canvas.prototype, localMouse, transform,\r\n        lockScalingX, lockScalingY, by, lockScalingFlip);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Sets controls of this group to the Textbox's special configuration if\r\n   * one is present in the group. Deletes _controlsVisibility otherwise, so that\r\n   * it gets initialized to default value at runtime.\r\n   */\r\n  fabric.Group.prototype._refreshControlsVisibility = function() {\r\n    if (typeof fabric.Textbox === 'undefined') {\r\n      return;\r\n    }\r\n    for (var i = this._objects.length; i--;) {\r\n      if (this._objects[i] instanceof fabric.Textbox) {\r\n        this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility());\r\n        return;\r\n      }\r\n    }\r\n  };\r\n\r\n  var clone = fabric.util.object.clone;\r\n\r\n  fabric.util.object.extend(fabric.Textbox.prototype, /** @lends fabric.IText.prototype */ {\r\n    /**\r\n     * @private\r\n     */\r\n    _removeExtraneousStyles: function() {\r\n      for (var prop in this._styleMap) {\r\n        if (!this._textLines[prop]) {\r\n          delete this.styles[this._styleMap[prop].line];\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Inserts style object for a given line/char index\r\n     * @param {Number} lineIndex Index of a line\r\n     * @param {Number} charIndex Index of a char\r\n     * @param {Object} [style] Style object to insert, if given\r\n     */\r\n    insertCharStyleObject: function(lineIndex, charIndex, style) {\r\n      // adjust lineIndex and charIndex\r\n      var map = this._styleMap[lineIndex];\r\n      lineIndex = map.line;\r\n      charIndex = map.offset + charIndex;\r\n\r\n      fabric.IText.prototype.insertCharStyleObject.apply(this, [lineIndex, charIndex, style]);\r\n    },\r\n\r\n    /**\r\n     * Inserts new style object\r\n     * @param {Number} lineIndex Index of a line\r\n     * @param {Number} charIndex Index of a char\r\n     * @param {Boolean} isEndOfLine True if it's end of line\r\n     */\r\n    insertNewlineStyleObject: function(lineIndex, charIndex, isEndOfLine) {\r\n      // adjust lineIndex and charIndex\r\n      var map = this._styleMap[lineIndex];\r\n      lineIndex = map.line;\r\n      charIndex = map.offset + charIndex;\r\n\r\n      fabric.IText.prototype.insertNewlineStyleObject.apply(this, [lineIndex, charIndex, isEndOfLine]);\r\n    },\r\n\r\n    /**\r\n     * Shifts line styles up or down. This function is slightly different than the one in\r\n     * itext_behaviour as it takes into account the styleMap.\r\n     *\r\n     * @param {Number} lineIndex Index of a line\r\n     * @param {Number} offset Can be -1 or +1\r\n     */\r\n    shiftLineStyles: function(lineIndex, offset) {\r\n      // shift all line styles by 1 upward\r\n      var clonedStyles = clone(this.styles),\r\n          map          = this._styleMap[lineIndex];\r\n\r\n      // adjust line index\r\n      lineIndex = map.line;\r\n\r\n      for (var line in this.styles) {\r\n        var numericLine = parseInt(line, 10);\r\n\r\n        if (numericLine > lineIndex) {\r\n          this.styles[numericLine + offset] = clonedStyles[numericLine];\r\n\r\n          if (!clonedStyles[numericLine - offset]) {\r\n            delete this.styles[numericLine];\r\n          }\r\n        }\r\n      }\r\n      //TODO: evaluate if delete old style lines with offset -1\r\n    },\r\n\r\n    /**\r\n     * Figure out programatically the text on previous actual line (actual = separated by \\n);\r\n     *\r\n     * @param {Number} lIndex\r\n     * @returns {String}\r\n     * @private\r\n     */\r\n    _getTextOnPreviousLine: function(lIndex) {\r\n      var textOnPreviousLine = this._textLines[lIndex - 1];\r\n\r\n      while (this._styleMap[lIndex - 2] && this._styleMap[lIndex - 2].line === this._styleMap[lIndex - 1].line) {\r\n        textOnPreviousLine = this._textLines[lIndex - 2] + textOnPreviousLine;\r\n\r\n        lIndex--;\r\n      }\r\n\r\n      return textOnPreviousLine;\r\n    },\r\n\r\n    /**\r\n     * Removes style object\r\n     * @param {Boolean} isBeginningOfLine True if cursor is at the beginning of line\r\n     * @param {Number} [index] Optional index. When not given, current selectionStart is used.\r\n     */\r\n    removeStyleObject: function(isBeginningOfLine, index) {\r\n\r\n      var cursorLocation = this.get2DCursorLocation(index),\r\n          map            = this._styleMap[cursorLocation.lineIndex],\r\n          lineIndex      = map.line,\r\n          charIndex      = map.offset + cursorLocation.charIndex;\r\n\r\n      if (isBeginningOfLine) {\r\n        var textOnPreviousLine     = this._getTextOnPreviousLine(cursorLocation.lineIndex),\r\n            newCharIndexOnPrevLine = textOnPreviousLine ? textOnPreviousLine.length : 0;\r\n\r\n        if (!this.styles[lineIndex - 1]) {\r\n          this.styles[lineIndex - 1] = {};\r\n        }\r\n\r\n        for (charIndex in this.styles[lineIndex]) {\r\n          this.styles[lineIndex - 1][parseInt(charIndex, 10) + newCharIndexOnPrevLine]\r\n            = this.styles[lineIndex][charIndex];\r\n        }\r\n\r\n        this.shiftLineStyles(cursorLocation.lineIndex, -1);\r\n\r\n      }\r\n      else {\r\n        var currentLineStyles = this.styles[lineIndex];\r\n\r\n        if (currentLineStyles) {\r\n          delete currentLineStyles[charIndex];\r\n          //console.log('deleting', lineIndex, charIndex + offset);\r\n        }\r\n\r\n        var currentLineStylesCloned = clone(currentLineStyles);\r\n\r\n        // shift all styles by 1 backwards\r\n        for (var i in currentLineStylesCloned) {\r\n          var numericIndex = parseInt(i, 10);\r\n          if (numericIndex >= charIndex && numericIndex !== 0) {\r\n            currentLineStyles[numericIndex - 1] = currentLineStylesCloned[numericIndex];\r\n            delete currentLineStyles[numericIndex];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n})();\r\n\r\n\r\n(function() {\r\n  var override = fabric.IText.prototype._getNewSelectionStartFromOffset;\r\n  /**\r\n   * Overrides the IText implementation and adjusts character index as there is not always a linebreak\r\n   *\r\n   * @param {Number} mouseOffset\r\n   * @param {Number} prevWidth\r\n   * @param {Number} width\r\n   * @param {Number} index\r\n   * @param {Number} jlen\r\n   * @returns {Number}\r\n   */\r\n  fabric.IText.prototype._getNewSelectionStartFromOffset = function(mouseOffset, prevWidth, width, index, jlen) {\r\n    index = override.call(this, mouseOffset, prevWidth, width, index, jlen);\r\n\r\n    // the index passed into the function is padded by the amount of lines from _textLines (to account for \\n)\r\n    // we need to remove this padding, and pad it by actual lines, and / or spaces that are meant to be there\r\n    var tmp     = 0,\r\n        removed = 0;\r\n\r\n    // account for removed characters\r\n    for (var i = 0; i < this._textLines.length; i++) {\r\n      tmp += this._textLines[i].length;\r\n\r\n      if (tmp + removed >= index) {\r\n        break;\r\n      }\r\n\r\n      if (this.text[tmp + removed] === '\\n' || this.text[tmp + removed] === ' ') {\r\n        removed++;\r\n      }\r\n    }\r\n\r\n    return index - i + removed;\r\n  };\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  if (typeof document !== 'undefined' && typeof window !== 'undefined') {\r\n    return;\r\n  }\r\n\r\n  var DOMParser = require('xmldom').DOMParser,\r\n      URL = require('url'),\r\n      HTTP = require('http'),\r\n      HTTPS = require('https'),\r\n\r\n      Canvas = require('canvas'),\r\n      Image = require('canvas').Image;\r\n\r\n  /** @private */\r\n  function request(url, encoding, callback) {\r\n    var oURL = URL.parse(url);\r\n\r\n    // detect if http or https is used\r\n    if ( !oURL.port ) {\r\n      oURL.port = ( oURL.protocol.indexOf('https:') === 0 ) ? 443 : 80;\r\n    }\r\n\r\n    // assign request handler based on protocol\r\n    var reqHandler = (oURL.protocol.indexOf('https:') === 0 ) ? HTTPS : HTTP,\r\n        req = reqHandler.request({\r\n          hostname: oURL.hostname,\r\n          port: oURL.port,\r\n          path: oURL.path,\r\n          method: 'GET'\r\n        }, function(response) {\r\n          var body = '';\r\n          if (encoding) {\r\n            response.setEncoding(encoding);\r\n          }\r\n          response.on('end', function () {\r\n            callback(body);\r\n          });\r\n          response.on('data', function (chunk) {\r\n            if (response.statusCode === 200) {\r\n              body += chunk;\r\n            }\r\n          });\r\n        });\r\n\r\n    req.on('error', function(err) {\r\n      if (err.errno === process.ECONNREFUSED) {\r\n        fabric.log('ECONNREFUSED: connection refused to ' + oURL.hostname + ':' + oURL.port);\r\n      }\r\n      else {\r\n        fabric.log(err.message);\r\n      }\r\n      callback(null);\r\n    });\r\n\r\n    req.end();\r\n  }\r\n\r\n  /** @private */\r\n  function requestFs(path, callback) {\r\n    var fs = require('fs');\r\n    fs.readFile(path, function (err, data) {\r\n      if (err) {\r\n        fabric.log(err);\r\n        throw err;\r\n      }\r\n      else {\r\n        callback(data);\r\n      }\r\n    });\r\n  }\r\n\r\n  fabric.util.loadImage = function(url, callback, context) {\r\n    function createImageAndCallBack(data) {\r\n      if (data) {\r\n        img.src = new Buffer(data, 'binary');\r\n        // preserving original url, which seems to be lost in node-canvas\r\n        img._src = url;\r\n        callback && callback.call(context, img);\r\n      }\r\n      else {\r\n        img = null;\r\n        callback && callback.call(context, null, true);\r\n      }\r\n    }\r\n    var img = new Image();\r\n    if (url && (url instanceof Buffer || url.indexOf('data') === 0)) {\r\n      img.src = img._src = url;\r\n      callback && callback.call(context, img);\r\n    }\r\n    else if (url && url.indexOf('http') !== 0) {\r\n      requestFs(url, createImageAndCallBack);\r\n    }\r\n    else if (url) {\r\n      request(url, 'binary', createImageAndCallBack);\r\n    }\r\n    else {\r\n      callback && callback.call(context, url);\r\n    }\r\n  };\r\n\r\n  fabric.loadSVGFromURL = function(url, callback, reviver) {\r\n    url = url.replace(/^\\n\\s*/, '').replace(/\\?.*$/, '').trim();\r\n    if (url.indexOf('http') !== 0) {\r\n      requestFs(url, function(body) {\r\n        fabric.loadSVGFromString(body.toString(), callback, reviver);\r\n      });\r\n    }\r\n    else {\r\n      request(url, '', function(body) {\r\n        fabric.loadSVGFromString(body, callback, reviver);\r\n      });\r\n    }\r\n  };\r\n\r\n  fabric.loadSVGFromString = function(string, callback, reviver) {\r\n    var doc = new DOMParser().parseFromString(string);\r\n    fabric.parseSVGDocument(doc.documentElement, function(results, options) {\r\n      callback && callback(results, options);\r\n    }, reviver);\r\n  };\r\n\r\n  fabric.util.getScript = function(url, callback) {\r\n    request(url, '', function(body) {\r\n      eval(body);\r\n      callback && callback();\r\n    });\r\n  };\r\n\r\n  fabric.Image.fromObject = function(object, callback) {\r\n    fabric.util.loadImage(object.src, function(img) {\r\n      var oImg = new fabric.Image(img);\r\n\r\n      oImg._initConfig(object);\r\n      oImg._initFilters(object.filters, function(filters) {\r\n        oImg.filters = filters || [ ];\r\n        oImg._initFilters(object.resizeFilters, function(resizeFilters) {\r\n          oImg.resizeFilters = resizeFilters || [ ];\r\n          callback && callback(oImg);\r\n        });\r\n      });\r\n    });\r\n  };\r\n  /**\r\n   * Only available when running fabric on node.js\r\n   * @param {Number} width Canvas width\r\n   * @param {Number} height Canvas height\r\n   * @param {Object} [options] Options to pass to FabricCanvas.\r\n   * @param {Object} [nodeCanvasOptions] Options to pass to NodeCanvas.\r\n   * @return {Object} wrapped canvas instance\r\n   */\r\n  fabric.createCanvasForNode = function(width, height, options, nodeCanvasOptions) {\r\n    nodeCanvasOptions = nodeCanvasOptions || options;\r\n\r\n    var canvasEl = fabric.document.createElement('canvas'),\r\n        nodeCanvas = new Canvas(width || 600, height || 600, nodeCanvasOptions);\r\n\r\n    // jsdom doesn't create style on canvas element, so here be temp. workaround\r\n    canvasEl.style = { };\r\n\r\n    canvasEl.width = nodeCanvas.width;\r\n    canvasEl.height = nodeCanvas.height;\r\n\r\n    var FabricCanvas = fabric.Canvas || fabric.StaticCanvas,\r\n        fabricCanvas = new FabricCanvas(canvasEl, options);\r\n\r\n    fabricCanvas.contextContainer = nodeCanvas.getContext('2d');\r\n    fabricCanvas.nodeCanvas = nodeCanvas;\r\n    fabricCanvas.Font = Canvas.Font;\r\n\r\n    return fabricCanvas;\r\n  };\r\n\r\n  /** @ignore */\r\n  fabric.StaticCanvas.prototype.createPNGStream = function() {\r\n    return this.nodeCanvas.createPNGStream();\r\n  };\r\n\r\n  fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {\r\n    return this.nodeCanvas.createJPEGStream(opts);\r\n  };\r\n\r\n  var origSetWidth = fabric.StaticCanvas.prototype.setWidth;\r\n  fabric.StaticCanvas.prototype.setWidth = function(width, options) {\r\n    origSetWidth.call(this, width, options);\r\n    this.nodeCanvas.width = width;\r\n    return this;\r\n  };\r\n  if (fabric.Canvas) {\r\n    fabric.Canvas.prototype.setWidth = fabric.StaticCanvas.prototype.setWidth;\r\n  }\r\n\r\n  var origSetHeight = fabric.StaticCanvas.prototype.setHeight;\r\n  fabric.StaticCanvas.prototype.setHeight = function(height, options) {\r\n    origSetHeight.call(this, height, options);\r\n    this.nodeCanvas.height = height;\r\n    return this;\r\n  };\r\n  if (fabric.Canvas) {\r\n    fabric.Canvas.prototype.setHeight = fabric.StaticCanvas.prototype.setHeight;\r\n  }\r\n\r\n})();\r\n\r\n","Milople_Personalizedcool/js/fabric.curvedText.js":"(function (global){\r\n\r\n\t\"use strict\";\r\n\r\n\tvar fabric=global.fabric||(global.fabric={}),\r\n\t\t\textend=fabric.util.object.extend,\r\n\t\t\tclone=fabric.util.object.clone;\r\n\r\n\tif(fabric.CurvedText){\r\n\t\tfabric.warn('fabric.CurvedText is already defined');\r\n\t\treturn;\r\n\t}\r\n\tvar stateProperties=fabric.Text.prototype.stateProperties.concat();\r\n\tstateProperties.push(\r\n\t\t\t'radius',\r\n\t\t\t'spacing',\r\n\t\t\t'reverse',\r\n\t\t\t'effect',\r\n\t\t\t'range',\r\n\t\t\t'largeFont',\r\n\t\t\t'smallFont'\r\n\t\t\t);\r\n\tvar _dimensionAffectingProps=fabric.Text.prototype._dimensionAffectingProps;\r\n\t_dimensionAffectingProps['radius']=true;\r\n\t_dimensionAffectingProps['spacing']=true;\r\n\t_dimensionAffectingProps['reverse']=true;\r\n\t_dimensionAffectingProps['fill']=true;\r\n\t_dimensionAffectingProps['effect']=true;\r\n\t_dimensionAffectingProps['width']=true;\r\n\t_dimensionAffectingProps['height']=true;\r\n\t_dimensionAffectingProps['range']=true;\r\n\t_dimensionAffectingProps['fontSize']=true;\r\n\t_dimensionAffectingProps['shadow']=true;\r\n\t_dimensionAffectingProps['largeFont']=true;\r\n\t_dimensionAffectingProps['smallFont']=true;\r\n\r\n\r\n\tvar delegatedProperties=fabric.Group.prototype.delegatedProperties;\r\n\tdelegatedProperties['backgroundColor']=true;\r\n\tdelegatedProperties['textBackgroundColor']=true;\r\n\tdelegatedProperties['textDecoration']=true;\r\n\tdelegatedProperties['stroke']=true;\r\n\tdelegatedProperties['strokeWidth']=true;\r\n\tdelegatedProperties['shadow']=true;\r\n\tdelegatedProperties['fontWeight']=true;\r\n\tdelegatedProperties['fontStyle']=true;\r\n\tdelegatedProperties['strokeWidth']=true;\r\n\tdelegatedProperties['textAlign']=true;\r\n\r\n\t/**\r\n\t * Group class\r\n\t * @class fabric.CurvedText\r\n\t * @extends fabric.Text\r\n\t * @mixes fabric.Collection\r\n\t */\r\n\tfabric.CurvedText=fabric.util.createClass(fabric.Text, fabric.Collection, /** @lends fabric.CurvedText.prototype */ {\r\n\t\t/**\r\n\t\t * Type of an object\r\n\t\t * @type String\r\n\t\t * @default\r\n\t\t */\r\n\t\ttype: 'curvedText',\r\n\t\t/**\r\n\t\t * The radius of the curved Text\r\n\t\t * @type Number\r\n\t\t * @default 50\r\n\t\t */\r\n\t\tradius: 50,\r\n\t\t/**\r\n\t\t * Special Effects, Thanks to fahadnabbasi\r\n\t\t * https://github.com/EffEPi/fabric.curvedText/issues/9\r\n\t\t */\r\n\t\trange: 5,\r\n\t\tsmallFont: 10,\r\n\t\tlargeFont: 30,\r\n\t\teffect: 'curved',\r\n\t\t/**\r\n\t\t * Spacing between the letters\r\n\t\t * @type fabricNumber\r\n\t\t * @default 20\r\n\t\t */\r\n\t\tspacing: 20,\r\n//\t\tletters: null,\r\n\r\n\t\t/**\r\n\t\t * Reversing the radius (position of the original point)\r\n\t\t * @type Boolean\r\n\t\t * @default false\r\n\t\t */\r\n\t\treverse: false,\r\n\t\t/**\r\n\t\t * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})\r\n\t\t * as well as for history (undo/redo) purposes\r\n\t\t * @type Array\r\n\t\t */\r\n\t\tstateProperties: stateProperties,\r\n\t\t/**\r\n\t\t * Properties that are delegated to group objects when reading/writing\r\n\t\t * @param {Object} delegatedProperties\r\n\t\t */\r\n\t\tdelegatedProperties: delegatedProperties,\r\n\t\t/**\r\n\t\t * Properties which when set cause object to change dimensions\r\n\t\t * @type Object\r\n\t\t * @private\r\n\t\t */\r\n\t\t_dimensionAffectingProps: _dimensionAffectingProps,\r\n\t\t/**\r\n\t\t *\r\n\t\t * Rendering, is we are rendering and another rendering call is passed, then stop rendering the old and\r\n\t\t * rendering the new (trying to speed things up)\r\n\t\t */\r\n\t\t_isRendering: 0,\r\n\t\t/**\r\n\t\t * Added complexity\r\n\t\t */\r\n\t\tcomplexity: function (){\r\n\t\t\tthis.callSuper('complexity');\r\n\t\t},\r\n\t\tinitialize: function (text, options){\r\n\t\t\toptions||(options={});\r\n\t\t\tthis.letters=new fabric.Group([], {\r\n\t\t\t\tselectable: false,\r\n\t\t\t\tpadding: 0\r\n\t\t\t});\r\n\t\t\tthis.__skipDimension=true;\r\n\t\t\tthis.setOptions(options);\r\n\t\t\tthis.__skipDimension=false;\r\n//\t\t\tthis.callSuper('initialize', options);\r\n\t\t\tthis.setText(text);\r\n\t\t},\r\n\t\tsetText: function (text){\r\n\t\t\tif(this.letters){\r\n\t\t\t\twhile(text.length!==0&&this.letters.size()>=text.length){\r\n\t\t\t\t\tthis.letters.remove(this.letters.item(this.letters.size()-1));\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i=0; i<text.length; i++){\r\n\t\t\t\t\t//I need to pass the options from the main options\r\n\t\t\t\t\tif(this.letters.item(i)===undefined){\r\n\t\t\t\t\t\tthis.letters.add(new fabric.Text(text[i]));\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthis.letters.item(i).setText(text[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.callSuper('setText', text);\r\n\t\t},\r\n\t\t_initDimensions: function (ctx){\r\n\t\t\t// from fabric.Text.prototype._initDimensions\r\n\t\t\t// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\r\n\t\t\tif(this.__skipDimension){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif(!ctx){\r\n\t\t\t\tctx=fabric.util.createCanvasElement().getContext('2d');\r\n\t\t\t\tthis._setTextStyles(ctx);\r\n\t\t\t}\r\n\t\t\tthis._textLines=this.text.split(this._reNewline);\r\n\t\t\tthis._clearCache();\r\n\t\t\tvar currentTextAlign=this.textAlign;\r\n\t\t\tthis.textAlign='left';\r\n\t\t\tthis.width=this._getTextWidth(ctx);\r\n\t\t\tthis.textAlign=currentTextAlign;\r\n\t\t\tthis.height=this._getTextHeight(ctx);\r\n\t\t\t// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\r\n\t\t\tthis._render(ctx);\r\n\t\t},\r\n\t\t_render: function (ctx){\r\n\t\t\tvar renderingCode=fabric.util.getRandomInt(100, 999);\r\n\t\t\tthis._isRendering=renderingCode;\r\n\t\t\tif(this.letters){\r\n\t\t\t\tvar curAngle=0,\r\n\t\t\t\t\t\tcurAngleRotation=0,\r\n\t\t\t\t\t\tangleRadians=0,\r\n\t\t\t\t\t\talign=0,\r\n\t\t\t\t\t\ttextWidth=0,\r\n\t\t\t\t\t\tspace=parseInt(this.spacing),\r\n\t\t\t\t\t\tfixedLetterAngle=0;\r\n\r\n\t\t\t\t//get text width\r\n\t\t\t\tif(this.effect==='curved'){\r\n\t\t\t\t\tfor(var i=0, len=this.text.length; i<len; i++){\r\n\t\t\t\t\t\ttextWidth+=this.letters.item(i).width+space;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttextWidth-=space;\r\n\t\t\t\t}else if(this.effect==='arc'){\r\n\t\t\t\t\tfixedLetterAngle=((this.letters.item(0).fontSize+space)/this.radius)/(Math.PI/180);\r\n\t\t\t\t\ttextWidth=((this.text.length+1)*(this.letters.item(0).fontSize+space));\r\n\t\t\t\t}\r\n\t\t\t\t// Text align\r\n\t\t\t\tif(this.get('textAlign')==='right'){\r\n\t\t\t\t\tcurAngle=90-(((textWidth/2)/this.radius)/(Math.PI/180));\r\n\t\t\t\t}else if(this.get('textAlign')==='left'){\r\n\t\t\t\t\tcurAngle=-90-(((textWidth/2)/this.radius)/(Math.PI/180));\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcurAngle=-(((textWidth/2)/this.radius)/(Math.PI/180));\r\n\t\t\t\t}\r\n\t\t\t\tif(this.reverse)\r\n\t\t\t\t\tcurAngle=-curAngle;\r\n\r\n\t\t\t\tvar width=0,\r\n\t\t\t\t\t\tmultiplier=this.reverse?-1:1,\r\n\t\t\t\t\t\tthisLetterAngle=0,\r\n\t\t\t\t\t\tlastLetterAngle=0;\r\n\r\n\t\t\t\tfor(var i=0, len=this.text.length; i<len; i++){\r\n\t\t\t\t\tif(renderingCode!==this._isRendering)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\tfor(var key in this.delegatedProperties){\r\n\t\t\t\t\t\tthis.letters.item(i).set(key, this.get(key));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.letters.item(i).set('left', (width));\r\n\t\t\t\t\tthis.letters.item(i).set('top', (0));\r\n\t\t\t\t\tthis.letters.item(i).setAngle(0);\r\n\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\r\n\t\t\t\t\tif(this.effect==='curved'){\r\n\t\t\t\t\t\tthisLetterAngle=((this.letters.item(i).width+space)/this.radius)/(Math.PI/180);\r\n\t\t\t\t\t\tcurAngle=multiplier*((multiplier*curAngle)+lastLetterAngle);\r\n\t\t\t\t\t\tangleRadians=curAngle*(Math.PI/180);\r\n\t\t\t\t\t\tlastLetterAngle=thisLetterAngle;\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).setAngle(curAngle);\r\n\t\t\t\t\t\tthis.letters.item(i).set('top', multiplier*-1*(Math.cos(angleRadians)*this.radius));\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', multiplier*(Math.sin(angleRadians)*this.radius));\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\r\n\t\t\t\t\t}else if(this.effect==='arc'){//arc\r\n\t\t\t\t\t\tcurAngle=multiplier*((multiplier*curAngle)+fixedLetterAngle);\r\n\t\t\t\t\t\tangleRadians=curAngle*(Math.PI/180);\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).set('top', multiplier*-1*(Math.cos(angleRadians)*this.radius));\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', multiplier*(Math.sin(angleRadians)*this.radius));\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\t\t\t\t\t}else if(this.effect==='STRAIGHT'){//STRAIGHT\r\n\t\t\t\t\t\t//var newfont=(i*5)+15;\r\n\t\t\t\t\t\t//this.letters.item(i).set('fontSize',(newfont));\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', (width));\r\n\t\t\t\t\t\tthis.letters.item(i).set('top', (0));\r\n\t\t\t\t\t\tthis.letters.item(i).setAngle(0);\r\n\t\t\t\t\t\twidth+=this.letters.item(i).get('width');\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set({\r\n\t\t\t\t\t\t\tborderColor: 'red',\r\n\t\t\t\t\t\t\tcornerColor: 'green',\r\n\t\t\t\t\t\t\tcornerSize: 6,\r\n\t\t\t\t\t\t\ttransparentCorners: false\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\t\t\t\t\t}else if(this.effect==='smallToLarge'){//smallToLarge\r\n\t\t\t\t\t\tvar small=parseInt(this.smallFont);\r\n\t\t\t\t\t\tvar large=parseInt(this.largeFont);\r\n\t\t\t\t\t\t//var small = 20;\r\n\t\t\t\t\t\t//var large = 75;\r\n\t\t\t\t\t\tvar difference=large-small;\r\n\t\t\t\t\t\tvar center=Math.ceil(this.text.length/2);\r\n\t\t\t\t\t\tvar step=difference/(this.text.length);\r\n\t\t\t\t\t\tvar newfont=small+(i*step);\r\n\r\n\t\t\t\t\t\t//var newfont=(i*this.smallFont)+15;\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).set('fontSize', (newfont));\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', (width));\r\n\t\t\t\t\t\twidth+=this.letters.item(i).get('width');\r\n\t\t\t\t\t\t//this.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\t/*this.letters.item(i).set({\r\n\t\t\t\t\t\t borderColor: 'red',\r\n\t\t\t\t\t\t cornerColor: 'green',\r\n\t\t\t\t\t\t cornerSize: 6,\r\n\t\t\t\t\t\t transparentCorners: false\r\n\t\t\t\t\t\t });*/\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\t\t\t\t\t\tthis.letters.item(i).set('top', -1*this.letters.item(i).get('fontSize')+i);\r\n\t\t\t\t\t\t//this.letters.width=width;\r\n\t\t\t\t\t\t//this.letters.height=this.letters.item(i).get('height');\r\n\r\n\t\t\t\t\t}else if(this.effect==='largeToSmallTop'){//largeToSmallTop\r\n\t\t\t\t\t\tvar small=parseInt(this.largeFont);\r\n\t\t\t\t\t\tvar large=parseInt(this.smallFont);\r\n\t\t\t\t\t\t//var small = 20;\r\n\t\t\t\t\t\t//var large = 75;\r\n\t\t\t\t\t\tvar difference=large-small;\r\n\t\t\t\t\t\tvar center=Math.ceil(this.text.length/2);\r\n\t\t\t\t\t\tvar step=difference/(this.text.length);\r\n\t\t\t\t\t\tvar newfont=small+(i*step);\r\n\t\t\t\t\t\t//var newfont=((this.text.length-i)*this.smallFont)+12;\r\n\t\t\t\t\t\tthis.letters.item(i).set('fontSize', (newfont));\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', (width));\r\n\t\t\t\t\t\twidth+=this.letters.item(i).get('width');\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set({\r\n\t\t\t\t\t\t\tborderColor: 'red',\r\n\t\t\t\t\t\t\tcornerColor: 'green',\r\n\t\t\t\t\t\t\tcornerSize: 6,\r\n\t\t\t\t\t\t\ttransparentCorners: false\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\t\t\t\t\t\tthis.letters.item(i).top=-1*this.letters.item(i).get('fontSize')+(i/this.text.length);\r\n\r\n\t\t\t\t\t}else if(this.effect==='largeToSmallBottom'){\r\n\t\t\t\t\t\tvar small=parseInt(this.largeFont);\r\n\t\t\t\t\t\tvar large=parseInt(this.smallFont);\r\n\t\t\t\t\t\t//var small = 20;\r\n\t\t\t\t\t\t//var large = 75;\r\n\t\t\t\t\t\tvar difference=large-small;\r\n\t\t\t\t\t\tvar center=Math.ceil(this.text.length/2);\r\n\t\t\t\t\t\tvar step=difference/(this.text.length);\r\n\t\t\t\t\t\tvar newfont=small+(i*step);\r\n\t\t\t\t\t\t//var newfont=((this.text.length-i)*this.smallFont)+12;\r\n\t\t\t\t\t\tthis.letters.item(i).set('fontSize', (newfont));\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', (width));\r\n\t\t\t\t\t\twidth+=this.letters.item(i).get('width');\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set({\r\n\t\t\t\t\t\t\tborderColor: 'red',\r\n\t\t\t\t\t\t\tcornerColor: 'green',\r\n\t\t\t\t\t\t\tcornerSize: 6,\r\n\t\t\t\t\t\t\ttransparentCorners: false\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\t\t\t\t\t\t//this.letters.item(i).top =-1* this.letters.item(i).get('fontSize')+newfont-((this.text.length-i))-((this.text.length-i));\r\n\t\t\t\t\t\tthis.letters.item(i).top=-1*this.letters.item(i).get('fontSize')-i;\r\n\r\n\t\t\t\t\t}else if(this.effect==='bulge'){//bulge\r\n\t\t\t\t\t\tvar small=parseInt(this.smallFont);\r\n\t\t\t\t\t\tvar large=parseInt(this.largeFont);\r\n\t\t\t\t\t\t//var small = 20;\r\n\t\t\t\t\t\t//var large = 75;\r\n\t\t\t\t\t\tvar difference=large-small;\r\n\t\t\t\t\t\tvar center=Math.ceil(this.text.length/2);\r\n\t\t\t\t\t\tvar step=difference/(this.text.length-center);\r\n\t\t\t\t\t\tif(i<center)\r\n\t\t\t\t\t\t\tvar newfont=small+(i*step);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tvar newfont=large-((i-center+1)*step);\r\n\t\t\t\t\t\tthis.letters.item(i).set('fontSize', (newfont));\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', (width));\r\n\t\t\t\t\t\twidth+=this.letters.item(i).get('width');\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).set('top', -1*this.letters.item(i).get('height')/2);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar scaleX=this.letters.get('scaleX');\r\n\t\t\t\tvar scaleY=this.letters.get('scaleY');\r\n\t\t\t\tvar angle=this.letters.get('angle');\r\n\r\n\t\t\t\tthis.letters.set('scaleX', 1);\r\n\t\t\t\tthis.letters.set('scaleY', 1);\r\n\t\t\t\tthis.letters.set('angle', 0);\r\n\r\n\t\t\t\t// Update group coords\r\n\t\t\t\tthis.letters._calcBounds();\r\n\t\t\t\tthis.letters._updateObjectsCoords();\r\n\t\t\t\tthis.letters.saveCoords();\r\n\t\t\t\t// this.letters.render(ctx);\r\n\r\n\t\t\t\tthis.letters.set('scaleX', scaleX);\r\n\t\t\t\tthis.letters.set('scaleY', scaleY);\r\n\t\t\t\tthis.letters.set('angle', angle);\r\n\r\n\t\t\t\tthis.width=this.letters.width;\r\n\t\t\t\tthis.height=this.letters.height;\r\n\t\t\t\tthis.letters.left=-(this.letters.width/2);\r\n\t\t\t\tthis.letters.top=-(this.letters.height/2);\r\n//\t\t\t\tconsole.log('End rendering')\r\n\t\t\t}\r\n\t\t},\r\n\t\t_renderOld: function (ctx){\r\n\t\t\tif(this.letters){\r\n\t\t\t\tvar curAngle=0,\r\n\t\t\t\t\t\tangleRadians=0,\r\n\t\t\t\t\t\talign=0;\r\n\t\t\t\t// Text align\r\n\t\t\t\tvar rev=0;\r\n\t\t\t\tif(this.reverse){\r\n\t\t\t\t\trev=0.5;\r\n\t\t\t\t}\r\n\t\t\t\tif(this.get('textAlign')==='center'||this.get('textAlign')==='justify'){\r\n\t\t\t\t\talign=(this.spacing/2)*(this.text.length-rev);\t// Remove '-1' after this.text.length for proper angle rendering\r\n\t\t\t\t}else if(this.get('textAlign')==='right'){\r\n\t\t\t\t\talign=(this.spacing)*(this.text.length-rev);\t// Remove '-1' after this.text.length for proper angle rendering\r\n\t\t\t\t}\r\n\t\t\t\tvar multiplier=this.reverse?1:-1;\r\n\t\t\t\tfor(var i=0, len=this.text.length; i<len; i++){\r\n\t\t\t\t\t// Find coords of each letters (radians : angle*(Math.PI / 180)\r\n\t\t\t\t\tcurAngle=multiplier*(-i*parseInt(this.spacing, 10)+align);\r\n\t\t\t\t\tangleRadians=curAngle*(Math.PI/180);\r\n\r\n\t\t\t\t\tfor(var key in this.delegatedProperties){\r\n\t\t\t\t\t\tthis.letters.item(i).set(key, this.get(key));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.letters.item(i).set('top', (multiplier-Math.cos(angleRadians)*this.radius));\r\n\t\t\t\t\tthis.letters.item(i).set('left', (multiplier+Math.sin(angleRadians)*this.radius));\r\n\t\t\t\t\tthis.letters.item(i).setAngle(curAngle);\r\n\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\t\t\t\t}\r\n\t\t\t\t// Update group coords\r\n\t\t\t\tthis.letters._calcBounds();\r\n\t\t\t\tif(this.reverse){\r\n\t\t\t\t\tthis.letters.top=this.letters.top-this.height*2.5;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.letters.top=0;\r\n\t\t\t\t}\r\n\t\t\t\tthis.letters.left=this.letters.left-this.width/2; // Change here, for proper group display\r\n\t\t\t\t//this.letters._updateObjectsCoords();\t\t\t\t\t// Commented off this line for group misplacement\r\n\t\t\t\tthis.letters.saveCoords();\r\n//\t\t\t\tthis.letters.render(ctx);\r\n\t\t\t\tthis.width=this.letters.width;\r\n\t\t\t\tthis.height=this.letters.height;\r\n\t\t\t\tthis.letters.left=-(this.letters.width/2);\r\n\t\t\t\tthis.letters.top=-(this.letters.height/2);\r\n\t\t\t}\r\n\t\t},\r\n\t\trender: function (ctx, noTransform){\r\n\t\t\t// do not render if object is not visible\r\n\t\t\tif(!this.visible)\r\n\t\t\t\treturn;\r\n\t\t\tif(!this.letters)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tctx.save();\r\n\t\t\tthis.transform(ctx);\r\n\r\n\t\t\tvar groupScaleFactor=Math.max(this.scaleX, this.scaleY);\r\n\r\n\t\t\tthis.clipTo&&fabric.util.clipContext(this, ctx);\r\n\r\n\t\t\t//The array is now sorted in order of highest first, so start from end.\r\n\t\t\tfor(var i=0, len=this.letters.size(); i<len; i++){\r\n\t\t\t\tvar object=this.letters.item(i),\r\n\t\t\t\t\t\toriginalScaleFactor=object.borderScaleFactor,\r\n\t\t\t\t\t\toriginalHasRotatingPoint=object.hasRotatingPoint;\r\n\r\n\t\t\t\t// do not render if object is not visible\r\n\t\t\t\tif(!object.visible)\r\n\t\t\t\t\tcontinue;\r\n\r\n//\t\t\t\tobject.borderScaleFactor=groupScaleFactor;\r\n//\t\t\t\tobject.hasRotatingPoint=false;\r\n\r\n\t\t\t\tobject.render(ctx);\r\n\r\n//\t\t\t\tobject.borderScaleFactor=originalScaleFactor;\r\n//\t\t\t\tobject.hasRotatingPoint=originalHasRotatingPoint;\r\n\t\t\t}\r\n\t\t\tthis.clipTo&&ctx.restore();\r\n\r\n\t\t\t//Those lines causes double borders.. not sure why\r\n//\t\t\tif(!noTransform&&this.active){\r\n//\t\t\t\tthis.drawBorders(ctx);\r\n//\t\t\t\tthis.drawControls(ctx);\r\n//\t\t\t}\r\n\t\t\tctx.restore();\r\n\t\t\tthis.setCoords();\r\n\t\t},\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\t_set: function (key, value){\r\n\t\t\tthis.callSuper('_set', key, value);\r\n\t\t\tif(this.letters){\r\n\t\t\t\tthis.letters.set(key, value);\r\n\t\t\t\t//Properties are delegated with the object is rendered\r\n//\t\t\t\tif (key in this.delegatedProperties) {\r\n//\t\t\t\t\tvar i = this.letters.size();\r\n//\t\t\t\t\twhile (i--) {\r\n//\t\t\t\t\t\tthis.letters.item(i).set(key, value);\r\n//\t\t\t\t\t}\r\n//\t\t\t\t}\r\n\t\t\t\tif(key in this._dimensionAffectingProps){\r\n\t\t\t\t\tthis._initDimensions();\r\n\t\t\t\t\tthis.setCoords();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\ttoObject: function (propertiesToInclude){\r\n\t\t\tvar object=extend(this.callSuper('toObject', propertiesToInclude), {\r\n\t\t\t\tradius: this.radius,\r\n\t\t\t\tspacing: this.spacing,\r\n\t\t\t\treverse: this.reverse,\r\n\t\t\t\teffect: this.effect,\r\n\t\t\t\trange: this.range,\r\n\t\t\t\tsmallFont: this.smallFont,\r\n\t\t\t\tlargeFont: this.largeFont\r\n\t\t\t\t\t\t//\t\t\t\tletters: this.letters\t//No need to pass this, the letters are recreated on the fly every time when initiated\r\n\t\t\t});\r\n\t\t\tif(!this.includeDefaultValues){\r\n\t\t\t\tthis._removeDefaultValues(object);\r\n\t\t\t}\r\n\t\t\treturn object;\r\n\t\t},\r\n\t\t/**\r\n\t\t * Returns string represenation of a group\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\ttoString: function (){\r\n\t\t\treturn '#<fabric.CurvedText ('+this.complexity()+'): { \"text\": \"'+this.text+'\", \"fontFamily\": \"'+this.fontFamily+'\", \"radius\": \"'+this.radius+'\", \"spacing\": \"'+this.spacing+'\", \"reverse\": \"'+this.reverse+'\" }>';\r\n\t\t},\r\n\t\t/* _TO_SVG_START_ */\r\n\t\t/**\r\n\t\t * Returns svg representation of an instance\r\n\t\t * @param {Function} [reviver] Method for further parsing of svg representation.\r\n\t\t * @return {String} svg representation of an instance\r\n\t\t */\r\n\t\ttoSVG: function (reviver){\r\n\t\t\tvar markup=[\r\n\t\t\t\t'<g ',\r\n\t\t\t\t'transform=\"', this.getSvgTransform(),\r\n\t\t\t\t'\">'\r\n\t\t\t];\r\n\t\t\tif(this.letters){\r\n\t\t\t\tfor(var i=0, len=this.letters.size(); i<len; i++){\r\n\t\t\t\t\tmarkup.push(this.letters.item(i).toSVG(reviver));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tmarkup.push('</g>');\r\n\t\t\treturn reviver?reviver(markup.join('')):markup.join('');\r\n\t\t}\r\n\t\t/* _TO_SVG_END_ */\r\n\t});\r\n\r\n\t/**\r\n\t * Returns {@link fabric.CurvedText} instance from an object representation\r\n\t * @static\r\n\t * @memberOf fabric.CurvedText\r\n\t * @param {Object} object Object to create a group from\r\n\t * @param {Object} [options] Options object\r\n\t * @return {fabric.CurvedText} An instance of fabric.CurvedText\r\n\t */\r\n\tfabric.CurvedText.fromObject=function (object){\r\n\t\treturn new fabric.CurvedText(object.text, clone(object));\r\n\t};\r\n\r\n\tfabric.util.createAccessors(fabric.CurvedText);\r\n\r\n\t/**\r\n\t * Indicates that instances of this type are async\r\n\t * @static\r\n\t * @memberOf fabric.CurvedText\r\n\t * @type Boolean\r\n\t * @default\r\n\t */\r\n\tfabric.CurvedText.async=false;\r\n\r\n})(typeof exports!=='undefined'?exports:this);\r\n","Mageplaza_Core/js/jscolor.min.js":"/**\n * jscolor - JavaScript Color Picker\n *\n * @link    http://jscolor.com\n * @license For open source use: GPLv3\n *          For commercial use: JSColor Commercial License\n * @author  Jan Odvarko\n *\n * See usage examples at http://jscolor.com/examples/\n */\"use strict\";window.jscolor||(window.jscolor=function(){var e={register:function(){e.attachDOMReadyEvent(e.init),e.attachEvent(document,\"mousedown\",e.onDocumentMouseDown),e.attachEvent(document,\"touchstart\",e.onDocumentTouchStart),e.attachEvent(window,\"resize\",e.onWindowResize)},init:function(){e.jscolor.lookupClass&&e.jscolor.installByClassName(e.jscolor.lookupClass)},tryInstallOnElements:function(t,n){var r=new RegExp(\"(^|\\\\s)(\"+n+\")(\\\\s*(\\\\{[^}]*\\\\})|\\\\s|$)\",\"i\");for(var i=0;i<t.length;i+=1){if(t[i].type!==undefined&&t[i].type.toLowerCase()==\"color\"&&e.isColorAttrSupported)continue;var s;if(!t[i].jscolor&&t[i].className&&(s=t[i].className.match(r))){var o=t[i],u=null,a=e.getDataAttr(o,\"jscolor\");a!==null?u=a:s[4]&&(u=s[4]);var f={};if(u)try{f=(new Function(\"return (\"+u+\")\"))()}catch(l){e.warn(\"Error parsing jscolor options: \"+l+\":\\n\"+u)}o.jscolor=new e.jscolor(o,f)}}},isColorAttrSupported:function(){var e=document.createElement(\"input\");if(e.setAttribute){e.setAttribute(\"type\",\"color\");if(e.type.toLowerCase()==\"color\")return!0}return!1}(),isCanvasSupported:function(){var e=document.createElement(\"canvas\");return!!e.getContext&&!!e.getContext(\"2d\")}(),fetchElement:function(e){return typeof e==\"string\"?document.getElementById(e):e},isElementType:function(e,t){return e.nodeName.toLowerCase()===t.toLowerCase()},getDataAttr:function(e,t){var n=\"data-\"+t,r=e.getAttribute(n);return r!==null?r:null},attachEvent:function(e,t,n){e.addEventListener?e.addEventListener(t,n,!1):e.attachEvent&&e.attachEvent(\"on\"+t,n)},detachEvent:function(e,t,n){e.removeEventListener?e.removeEventListener(t,n,!1):e.detachEvent&&e.detachEvent(\"on\"+t,n)},_attachedGroupEvents:{},attachGroupEvent:function(t,n,r,i){e._attachedGroupEvents.hasOwnProperty(t)||(e._attachedGroupEvents[t]=[]),e._attachedGroupEvents[t].push([n,r,i]),e.attachEvent(n,r,i)},detachGroupEvents:function(t){if(e._attachedGroupEvents.hasOwnProperty(t)){for(var n=0;n<e._attachedGroupEvents[t].length;n+=1){var r=e._attachedGroupEvents[t][n];e.detachEvent(r[0],r[1],r[2])}delete e._attachedGroupEvents[t]}},attachDOMReadyEvent:function(e){var t=!1,n=function(){t||(t=!0,e())};if(document.readyState===\"complete\"){setTimeout(n,1);return}if(document.addEventListener)document.addEventListener(\"DOMContentLoaded\",n,!1),window.addEventListener(\"load\",n,!1);else if(document.attachEvent){document.attachEvent(\"onreadystatechange\",function(){document.readyState===\"complete\"&&(document.detachEvent(\"onreadystatechange\",arguments.callee),n())}),window.attachEvent(\"onload\",n);if(document.documentElement.doScroll&&window==window.top){var r=function(){if(!document.body)return;try{document.documentElement.doScroll(\"left\"),n()}catch(e){setTimeout(r,1)}};r()}}},warn:function(e){window.console&&window.console.warn&&window.console.warn(e)},preventDefault:function(e){e.preventDefault&&e.preventDefault(),e.returnValue=!1},captureTarget:function(t){t.setCapture&&(e._capturedTarget=t,e._capturedTarget.setCapture())},releaseTarget:function(){e._capturedTarget&&(e._capturedTarget.releaseCapture(),e._capturedTarget=null)},fireEvent:function(e,t){if(!e)return;if(document.createEvent){var n=document.createEvent(\"HTMLEvents\");n.initEvent(t,!0,!0),e.dispatchEvent(n)}else if(document.createEventObject){var n=document.createEventObject();e.fireEvent(\"on\"+t,n)}else e[\"on\"+t]&&e[\"on\"+t]()},classNameToList:function(e){return e.replace(/^\\s+|\\s+$/g,\"\").split(/\\s+/)},hasClass:function(e,t){return t?-1!=(\" \"+e.className.replace(/\\s+/g,\" \")+\" \").indexOf(\" \"+t+\" \"):!1},setClass:function(t,n){var r=e.classNameToList(n);for(var i=0;i<r.length;i+=1)e.hasClass(t,r[i])||(t.className+=(t.className?\" \":\"\")+r[i])},unsetClass:function(t,n){var r=e.classNameToList(n);for(var i=0;i<r.length;i+=1){var s=new RegExp(\"^\\\\s*\"+r[i]+\"\\\\s*|\"+\"\\\\s*\"+r[i]+\"\\\\s*$|\"+\"\\\\s+\"+r[i]+\"(\\\\s+)\",\"g\");t.className=t.className.replace(s,\"$1\")}},getStyle:function(e){return window.getComputedStyle?window.getComputedStyle(e):e.currentStyle},setStyle:function(){var e=document.createElement(\"div\"),t=function(t){for(var n=0;n<t.length;n+=1)if(t[n]in e.style)return t[n]},n={borderRadius:t([\"borderRadius\",\"MozBorderRadius\",\"webkitBorderRadius\"]),boxShadow:t([\"boxShadow\",\"MozBoxShadow\",\"webkitBoxShadow\"])};return function(e,t,r){switch(t.toLowerCase()){case\"opacity\":var i=Math.round(parseFloat(r)*100);e.style.opacity=r,e.style.filter=\"alpha(opacity=\"+i+\")\";break;default:e.style[n[t]]=r}}}(),setBorderRadius:function(t,n){e.setStyle(t,\"borderRadius\",n||\"0\")},setBoxShadow:function(t,n){e.setStyle(t,\"boxShadow\",n||\"none\")},getElementPos:function(t,n){var r=0,i=0,s=t.getBoundingClientRect();r=s.left,i=s.top;if(!n){var o=e.getViewPos();r+=o[0],i+=o[1]}return[r,i]},getElementSize:function(e){return[e.offsetWidth,e.offsetHeight]},getAbsPointerPos:function(e){e||(e=window.event);var t=0,n=0;return typeof e.changedTouches!=\"undefined\"&&e.changedTouches.length?(t=e.changedTouches[0].clientX,n=e.changedTouches[0].clientY):typeof e.clientX==\"number\"&&(t=e.clientX,n=e.clientY),{x:t,y:n}},getRelPointerPos:function(e){e||(e=window.event);var t=e.target||e.srcElement,n=t.getBoundingClientRect(),r=0,i=0,s=0,o=0;return typeof e.changedTouches!=\"undefined\"&&e.changedTouches.length?(s=e.changedTouches[0].clientX,o=e.changedTouches[0].clientY):typeof e.clientX==\"number\"&&(s=e.clientX,o=e.clientY),r=s-n.left,i=o-n.top,{x:r,y:i}},getViewPos:function(){var e=document.documentElement;return[(window.pageXOffset||e.scrollLeft)-(e.clientLeft||0),(window.pageYOffset||e.scrollTop)-(e.clientTop||0)]},getViewSize:function(){var e=document.documentElement;return[window.innerWidth||e.clientWidth,window.innerHeight||e.clientHeight]},redrawPosition:function(){if(e.picker&&e.picker.owner){var t=e.picker.owner,n,r;t.fixed?(n=e.getElementPos(t.targetElement,!0),r=[0,0]):(n=e.getElementPos(t.targetElement),r=e.getViewPos());var i=e.getElementSize(t.targetElement),s=e.getViewSize(),o=e.getPickerOuterDims(t),u,a,f;switch(t.position.toLowerCase()){case\"left\":u=1,a=0,f=-1;break;case\"right\":u=1,a=0,f=1;break;case\"top\":u=0,a=1,f=-1;break;default:u=0,a=1,f=1}var l=(i[a]+o[a])/2;if(!t.smartPosition)var c=[n[u],n[a]+i[a]-l+l*f];else var c=[-r[u]+n[u]+o[u]>s[u]?-r[u]+n[u]+i[u]/2>s[u]/2&&n[u]+i[u]-o[u]>=0?n[u]+i[u]-o[u]:n[u]:n[u],-r[a]+n[a]+i[a]+o[a]-l+l*f>s[a]?-r[a]+n[a]+i[a]/2>s[a]/2&&n[a]+i[a]-l-l*f>=0?n[a]+i[a]-l-l*f:n[a]+i[a]-l+l*f:n[a]+i[a]-l+l*f>=0?n[a]+i[a]-l+l*f:n[a]+i[a]-l-l*f];var h=c[u],p=c[a],d=t.fixed?\"fixed\":\"absolute\",v=(c[0]+o[0]>n[0]||c[0]<n[0]+i[0])&&c[1]+o[1]<n[1]+i[1];e._drawPosition(t,h,p,d,v)}},_drawPosition:function(t,n,r,i,s){var o=s?0:t.shadowBlur;e.picker.wrap.style.position=i,e.picker.wrap.style.left=n+\"px\",e.picker.wrap.style.top=r+\"px\",e.setBoxShadow(e.picker.boxS,t.shadow?new e.BoxShadow(0,o,t.shadowBlur,0,t.shadowColor):null)},getPickerDims:function(t){var n=!!e.getSliderComponent(t),r=[2*t.insetWidth+2*t.padding+t.width+(n?2*t.insetWidth+e.getPadToSliderPadding(t)+t.sliderSize:0),2*t.insetWidth+2*t.padding+t.height+(t.closable?2*t.insetWidth+t.padding+t.buttonHeight:0)];return r},getPickerOuterDims:function(t){var n=e.getPickerDims(t);return[n[0]+2*t.borderWidth,n[1]+2*t.borderWidth]},getPadToSliderPadding:function(e){return Math.max(e.padding,1.5*(2*e.pointerBorderWidth+e.pointerThickness))},getPadYComponent:function(e){switch(e.mode.charAt(1).toLowerCase()){case\"v\":return\"v\"}return\"s\"},getSliderComponent:function(e){if(e.mode.length>2)switch(e.mode.charAt(2).toLowerCase()){case\"s\":return\"s\";case\"v\":return\"v\"}return null},onDocumentMouseDown:function(t){t||(t=window.event);var n=t.target||t.srcElement;n._jscLinkedInstance?n._jscLinkedInstance.showOnClick&&n._jscLinkedInstance.show():n._jscControlName?e.onControlPointerStart(t,n,n._jscControlName,\"mouse\"):e.picker&&e.picker.owner&&e.picker.owner.hide()},onDocumentTouchStart:function(t){t||(t=window.event);var n=t.target||t.srcElement;n._jscLinkedInstance?n._jscLinkedInstance.showOnClick&&n._jscLinkedInstance.show():n._jscControlName?e.onControlPointerStart(t,n,n._jscControlName,\"touch\"):e.picker&&e.picker.owner&&e.picker.owner.hide()},onWindowResize:function(t){e.redrawPosition()},onParentScroll:function(t){e.picker&&e.picker.owner&&e.picker.owner.hide()},_pointerMoveEvent:{mouse:\"mousemove\",touch:\"touchmove\"},_pointerEndEvent:{mouse:\"mouseup\",touch:\"touchend\"},_pointerOrigin:null,_capturedTarget:null,onControlPointerStart:function(t,n,r,i){var s=n._jscInstance;e.preventDefault(t),e.captureTarget(n);var o=function(s,o){e.attachGroupEvent(\"drag\",s,e._pointerMoveEvent[i],e.onDocumentPointerMove(t,n,r,i,o)),e.attachGroupEvent(\"drag\",s,e._pointerEndEvent[i],e.onDocumentPointerEnd(t,n,r,i))};o(document,[0,0]);if(window.parent&&window.frameElement){var u=window.frameElement.getBoundingClientRect(),a=[-u.left,-u.top];o(window.parent.window.document,a)}var f=e.getAbsPointerPos(t),l=e.getRelPointerPos(t);e._pointerOrigin={x:f.x-l.x,y:f.y-l.y};switch(r){case\"pad\":switch(e.getSliderComponent(s)){case\"s\":s.hsv[1]===0&&s.fromHSV(null,100,null);break;case\"v\":s.hsv[2]===0&&s.fromHSV(null,null,100)}e.setPad(s,t,0,0);break;case\"sld\":e.setSld(s,t,0)}e.dispatchFineChange(s)},onDocumentPointerMove:function(t,n,r,i,s){return function(t){var i=n._jscInstance;switch(r){case\"pad\":t||(t=window.event),e.setPad(i,t,s[0],s[1]),e.dispatchFineChange(i);break;case\"sld\":t||(t=window.event),e.setSld(i,t,s[1]),e.dispatchFineChange(i)}}},onDocumentPointerEnd:function(t,n,r,i){return function(t){var r=n._jscInstance;e.detachGroupEvents(\"drag\"),e.releaseTarget(),e.dispatchChange(r)}},dispatchChange:function(t){t.valueElement&&e.isElementType(t.valueElement,\"input\")&&e.fireEvent(t.valueElement,\"change\")},dispatchFineChange:function(e){if(e.onFineChange){var t;typeof e.onFineChange==\"string\"?t=new Function(e.onFineChange):t=e.onFineChange,t.call(e)}},setPad:function(t,n,r,i){var s=e.getAbsPointerPos(n),o=r+s.x-e._pointerOrigin.x-t.padding-t.insetWidth,u=i+s.y-e._pointerOrigin.y-t.padding-t.insetWidth,a=o*(360/(t.width-1)),f=100-u*(100/(t.height-1));switch(e.getPadYComponent(t)){case\"s\":t.fromHSV(a,f,null,e.leaveSld);break;case\"v\":t.fromHSV(a,null,f,e.leaveSld)}},setSld:function(t,n,r){var i=e.getAbsPointerPos(n),s=r+i.y-e._pointerOrigin.y-t.padding-t.insetWidth,o=100-s*(100/(t.height-1));switch(e.getSliderComponent(t)){case\"s\":t.fromHSV(null,o,null,e.leavePad);break;case\"v\":t.fromHSV(null,null,o,e.leavePad)}},_vmlNS:\"jsc_vml_\",_vmlCSS:\"jsc_vml_css_\",_vmlReady:!1,initVML:function(){if(!e._vmlReady){var t=document;t.namespaces[e._vmlNS]||t.namespaces.add(e._vmlNS,\"urn:schemas-microsoft-com:vml\");if(!t.styleSheets[e._vmlCSS]){var n=[\"shape\",\"shapetype\",\"group\",\"background\",\"path\",\"formulas\",\"handles\",\"fill\",\"stroke\",\"shadow\",\"textbox\",\"textpath\",\"imagedata\",\"line\",\"polyline\",\"curve\",\"rect\",\"roundrect\",\"oval\",\"arc\",\"image\"],r=t.createStyleSheet();r.owningElement.id=e._vmlCSS;for(var i=0;i<n.length;i+=1)r.addRule(e._vmlNS+\"\\\\:\"+n[i],\"behavior:url(#default#VML);\")}e._vmlReady=!0}},createPalette:function(){var t={elm:null,draw:null};if(e.isCanvasSupported){var n=document.createElement(\"canvas\"),r=n.getContext(\"2d\"),i=function(e,t,i){n.width=e,n.height=t,r.clearRect(0,0,n.width,n.height);var s=r.createLinearGradient(0,0,n.width,0);s.addColorStop(0,\"#F00\"),s.addColorStop(1/6,\"#FF0\"),s.addColorStop(2/6,\"#0F0\"),s.addColorStop(.5,\"#0FF\"),s.addColorStop(4/6,\"#00F\"),s.addColorStop(5/6,\"#F0F\"),s.addColorStop(1,\"#F00\"),r.fillStyle=s,r.fillRect(0,0,n.width,n.height);var o=r.createLinearGradient(0,0,0,n.height);switch(i.toLowerCase()){case\"s\":o.addColorStop(0,\"rgba(255,255,255,0)\"),o.addColorStop(1,\"rgba(255,255,255,1)\");break;case\"v\":o.addColorStop(0,\"rgba(0,0,0,0)\"),o.addColorStop(1,\"rgba(0,0,0,1)\")}r.fillStyle=o,r.fillRect(0,0,n.width,n.height)};t.elm=n,t.draw=i}else{e.initVML();var s=document.createElement(\"div\");s.style.position=\"relative\",s.style.overflow=\"hidden\";var o=document.createElement(e._vmlNS+\":fill\");o.type=\"gradient\",o.method=\"linear\",o.angle=\"90\",o.colors=\"16.67% #F0F, 33.33% #00F, 50% #0FF, 66.67% #0F0, 83.33% #FF0\";var u=document.createElement(e._vmlNS+\":rect\");u.style.position=\"absolute\",u.style.left=\"-1px\",u.style.top=\"-1px\",u.stroked=!1,u.appendChild(o),s.appendChild(u);var a=document.createElement(e._vmlNS+\":fill\");a.type=\"gradient\",a.method=\"linear\",a.angle=\"180\",a.opacity=\"0\";var f=document.createElement(e._vmlNS+\":rect\");f.style.position=\"absolute\",f.style.left=\"-1px\",f.style.top=\"-1px\",f.stroked=!1,f.appendChild(a),s.appendChild(f);var i=function(e,t,n){s.style.width=e+\"px\",s.style.height=t+\"px\",u.style.width=f.style.width=e+1+\"px\",u.style.height=f.style.height=t+1+\"px\",o.color=\"#F00\",o.color2=\"#F00\";switch(n.toLowerCase()){case\"s\":a.color=a.color2=\"#FFF\";break;case\"v\":a.color=a.color2=\"#000\"}};t.elm=s,t.draw=i}return t},createSliderGradient:function(){var t={elm:null,draw:null};if(e.isCanvasSupported){var n=document.createElement(\"canvas\"),r=n.getContext(\"2d\"),i=function(e,t,i,s){n.width=e,n.height=t,r.clearRect(0,0,n.width,n.height);var o=r.createLinearGradient(0,0,0,n.height);o.addColorStop(0,i),o.addColorStop(1,s),r.fillStyle=o,r.fillRect(0,0,n.width,n.height)};t.elm=n,t.draw=i}else{e.initVML();var s=document.createElement(\"div\");s.style.position=\"relative\",s.style.overflow=\"hidden\";var o=document.createElement(e._vmlNS+\":fill\");o.type=\"gradient\",o.method=\"linear\",o.angle=\"180\";var u=document.createElement(e._vmlNS+\":rect\");u.style.position=\"absolute\",u.style.left=\"-1px\",u.style.top=\"-1px\",u.stroked=!1,u.appendChild(o),s.appendChild(u);var i=function(e,t,n,r){s.style.width=e+\"px\",s.style.height=t+\"px\",u.style.width=e+1+\"px\",u.style.height=t+1+\"px\",o.color=n,o.color2=r};t.elm=s,t.draw=i}return t},leaveValue:1,leaveStyle:2,leavePad:4,leaveSld:8,BoxShadow:function(){var e=function(e,t,n,r,i,s){this.hShadow=e,this.vShadow=t,this.blur=n,this.spread=r,this.color=i,this.inset=!!s};return e.prototype.toString=function(){var e=[Math.round(this.hShadow)+\"px\",Math.round(this.vShadow)+\"px\",Math.round(this.blur)+\"px\",Math.round(this.spread)+\"px\",this.color];return this.inset&&e.push(\"inset\"),e.join(\" \")},e}(),jscolor:function(t,n){function i(e,t,n){e/=255,t/=255,n/=255;var r=Math.min(Math.min(e,t),n),i=Math.max(Math.max(e,t),n),s=i-r;if(s===0)return[null,0,100*i];var o=e===r?3+(n-t)/s:t===r?5+(e-n)/s:1+(t-e)/s;return[60*(o===6?0:o),100*(s/i),100*i]}function s(e,t,n){var r=255*(n/100);if(e===null)return[r,r,r];e/=60,t/=100;var i=Math.floor(e),s=i%2?e-i:1-(e-i),o=r*(1-t),u=r*(1-t*s);switch(i){case 6:case 0:return[r,u,o];case 1:return[u,r,o];case 2:return[o,r,u];case 3:return[o,u,r];case 4:return[u,o,r];case 5:return[r,o,u]}}function o(){e.unsetClass(d.targetElement,d.activeClass),e.picker.wrap.parentNode.removeChild(e.picker.wrap),delete e.picker.owner}function u(){function l(){var e=d.insetColor.split(/\\s+/),n=e.length<2?e[0]:e[1]+\" \"+e[0]+\" \"+e[0]+\" \"+e[1];t.btn.style.borderColor=n}d._processParentElementsInDOM(),e.picker||(e.picker={owner:null,wrap:document.createElement(\"div\"),box:document.createElement(\"div\"),boxS:document.createElement(\"div\"),boxB:document.createElement(\"div\"),pad:document.createElement(\"div\"),padB:document.createElement(\"div\"),padM:document.createElement(\"div\"),padPal:e.createPalette(),cross:document.createElement(\"div\"),crossBY:document.createElement(\"div\"),crossBX:document.createElement(\"div\"),crossLY:document.createElement(\"div\"),crossLX:document.createElement(\"div\"),sld:document.createElement(\"div\"),sldB:document.createElement(\"div\"),sldM:document.createElement(\"div\"),sldGrad:e.createSliderGradient(),sldPtrS:document.createElement(\"div\"),sldPtrIB:document.createElement(\"div\"),sldPtrMB:document.createElement(\"div\"),sldPtrOB:document.createElement(\"div\"),btn:document.createElement(\"div\"),btnT:document.createElement(\"span\")},e.picker.pad.appendChild(e.picker.padPal.elm),e.picker.padB.appendChild(e.picker.pad),e.picker.cross.appendChild(e.picker.crossBY),e.picker.cross.appendChild(e.picker.crossBX),e.picker.cross.appendChild(e.picker.crossLY),e.picker.cross.appendChild(e.picker.crossLX),e.picker.padB.appendChild(e.picker.cross),e.picker.box.appendChild(e.picker.padB),e.picker.box.appendChild(e.picker.padM),e.picker.sld.appendChild(e.picker.sldGrad.elm),e.picker.sldB.appendChild(e.picker.sld),e.picker.sldB.appendChild(e.picker.sldPtrOB),e.picker.sldPtrOB.appendChild(e.picker.sldPtrMB),e.picker.sldPtrMB.appendChild(e.picker.sldPtrIB),e.picker.sldPtrIB.appendChild(e.picker.sldPtrS),e.picker.box.appendChild(e.picker.sldB),e.picker.box.appendChild(e.picker.sldM),e.picker.btn.appendChild(e.picker.btnT),e.picker.box.appendChild(e.picker.btn),e.picker.boxB.appendChild(e.picker.box),e.picker.wrap.appendChild(e.picker.boxS),e.picker.wrap.appendChild(e.picker.boxB));var t=e.picker,n=!!e.getSliderComponent(d),r=e.getPickerDims(d),i=2*d.pointerBorderWidth+d.pointerThickness+2*d.crossSize,s=e.getPadToSliderPadding(d),o=Math.min(d.borderRadius,Math.round(d.padding*Math.PI)),u=\"crosshair\";t.wrap.style.clear=\"both\",t.wrap.style.width=r[0]+2*d.borderWidth+\"px\",t.wrap.style.height=r[1]+2*d.borderWidth+\"px\",t.wrap.style.zIndex=d.zIndex,t.box.style.width=r[0]+\"px\",t.box.style.height=r[1]+\"px\",t.boxS.style.position=\"absolute\",t.boxS.style.left=\"0\",t.boxS.style.top=\"0\",t.boxS.style.width=\"100%\",t.boxS.style.height=\"100%\",e.setBorderRadius(t.boxS,o+\"px\"),t.boxB.style.position=\"relative\",t.boxB.style.border=d.borderWidth+\"px solid\",t.boxB.style.borderColor=d.borderColor,t.boxB.style.background=d.backgroundColor,e.setBorderRadius(t.boxB,o+\"px\"),t.padM.style.background=t.sldM.style.background=\"#FFF\",e.setStyle(t.padM,\"opacity\",\"0\"),e.setStyle(t.sldM,\"opacity\",\"0\"),t.pad.style.position=\"relative\",t.pad.style.width=d.width+\"px\",t.pad.style.height=d.height+\"px\",t.padPal.draw(d.width,d.height,e.getPadYComponent(d)),t.padB.style.position=\"absolute\",t.padB.style.left=d.padding+\"px\",t.padB.style.top=d.padding+\"px\",t.padB.style.border=d.insetWidth+\"px solid\",t.padB.style.borderColor=d.insetColor,t.padM._jscInstance=d,t.padM._jscControlName=\"pad\",t.padM.style.position=\"absolute\",t.padM.style.left=\"0\",t.padM.style.top=\"0\",t.padM.style.width=d.padding+2*d.insetWidth+d.width+s/2+\"px\",t.padM.style.height=r[1]+\"px\",t.padM.style.cursor=u,t.cross.style.position=\"absolute\",t.cross.style.left=t.cross.style.top=\"0\",t.cross.style.width=t.cross.style.height=i+\"px\",t.crossBY.style.position=t.crossBX.style.position=\"absolute\",t.crossBY.style.background=t.crossBX.style.background=d.pointerBorderColor,t.crossBY.style.width=t.crossBX.style.height=2*d.pointerBorderWidth+d.pointerThickness+\"px\",t.crossBY.style.height=t.crossBX.style.width=i+\"px\",t.crossBY.style.left=t.crossBX.style.top=Math.floor(i/2)-Math.floor(d.pointerThickness/2)-d.pointerBorderWidth+\"px\",t.crossBY.style.top=t.crossBX.style.left=\"0\",t.crossLY.style.position=t.crossLX.style.position=\"absolute\",t.crossLY.style.background=t.crossLX.style.background=d.pointerColor,t.crossLY.style.height=t.crossLX.style.width=i-2*d.pointerBorderWidth+\"px\",t.crossLY.style.width=t.crossLX.style.height=d.pointerThickness+\"px\",t.crossLY.style.left=t.crossLX.style.top=Math.floor(i/2)-Math.floor(d.pointerThickness/2)+\"px\",t.crossLY.style.top=t.crossLX.style.left=d.pointerBorderWidth+\"px\",t.sld.style.overflow=\"hidden\",t.sld.style.width=d.sliderSize+\"px\",t.sld.style.height=d.height+\"px\",t.sldGrad.draw(d.sliderSize,d.height,\"#000\",\"#000\"),t.sldB.style.display=n?\"block\":\"none\",t.sldB.style.position=\"absolute\",t.sldB.style.right=d.padding+\"px\",t.sldB.style.top=d.padding+\"px\",t.sldB.style.border=d.insetWidth+\"px solid\",t.sldB.style.borderColor=d.insetColor,t.sldM._jscInstance=d,t.sldM._jscControlName=\"sld\",t.sldM.style.display=n?\"block\":\"none\",t.sldM.style.position=\"absolute\",t.sldM.style.right=\"0\",t.sldM.style.top=\"0\",t.sldM.style.width=d.sliderSize+s/2+d.padding+2*d.insetWidth+\"px\",t.sldM.style.height=r[1]+\"px\",t.sldM.style.cursor=\"default\",t.sldPtrIB.style.border=t.sldPtrOB.style.border=d.pointerBorderWidth+\"px solid \"+d.pointerBorderColor,t.sldPtrOB.style.position=\"absolute\",t.sldPtrOB.style.left=-(2*d.pointerBorderWidth+d.pointerThickness)+\"px\",t.sldPtrOB.style.top=\"0\",t.sldPtrMB.style.border=d.pointerThickness+\"px solid \"+d.pointerColor,t.sldPtrS.style.width=d.sliderSize+\"px\",t.sldPtrS.style.height=m+\"px\",t.btn.style.display=d.closable?\"block\":\"none\",t.btn.style.position=\"absolute\",t.btn.style.left=d.padding+\"px\",t.btn.style.bottom=d.padding+\"px\",t.btn.style.padding=\"0 15px\",t.btn.style.height=d.buttonHeight+\"px\",t.btn.style.border=d.insetWidth+\"px solid\",l(),t.btn.style.color=d.buttonColor,t.btn.style.font=\"12px sans-serif\",t.btn.style.textAlign=\"center\";try{t.btn.style.cursor=\"pointer\"}catch(c){t.btn.style.cursor=\"hand\"}t.btn.onmousedown=function(){d.hide()},t.btnT.style.lineHeight=d.buttonHeight+\"px\",t.btnT.innerHTML=\"\",t.btnT.appendChild(document.createTextNode(d.closeText)),a(),f(),e.picker.owner&&e.picker.owner!==d&&e.unsetClass(e.picker.owner.targetElement,d.activeClass),e.picker.owner=d,e.isElementType(v,\"body\")?e.redrawPosition():e._drawPosition(d,0,0,\"relative\",!1),t.wrap.parentNode!=v&&v.appendChild(t.wrap),e.setClass(d.targetElement,d.activeClass)}function a(){switch(e.getPadYComponent(d)){case\"s\":var t=1;break;case\"v\":var t=2}var n=Math.round(d.hsv[0]/360*(d.width-1)),r=Math.round((1-d.hsv[t]/100)*(d.height-1)),i=2*d.pointerBorderWidth+d.pointerThickness+2*d.crossSize,o=-Math.floor(i/2);e.picker.cross.style.left=n+o+\"px\",e.picker.cross.style.top=r+o+\"px\";switch(e.getSliderComponent(d)){case\"s\":var u=s(d.hsv[0],100,d.hsv[2]),a=s(d.hsv[0],0,d.hsv[2]),f=\"rgb(\"+Math.round(u[0])+\",\"+Math.round(u[1])+\",\"+Math.round(u[2])+\")\",l=\"rgb(\"+Math.round(a[0])+\",\"+Math.round(a[1])+\",\"+Math.round(a[2])+\")\";e.picker.sldGrad.draw(d.sliderSize,d.height,f,l);break;case\"v\":var c=s(d.hsv[0],d.hsv[1],100),f=\"rgb(\"+Math.round(c[0])+\",\"+Math.round(c[1])+\",\"+Math.round(c[2])+\")\",l=\"#000\";e.picker.sldGrad.draw(d.sliderSize,d.height,f,l)}}function f(){var t=e.getSliderComponent(d);if(t){switch(t){case\"s\":var n=1;break;case\"v\":var n=2}var r=Math.round((1-d.hsv[n]/100)*(d.height-1));e.picker.sldPtrOB.style.top=r-(2*d.pointerBorderWidth+d.pointerThickness)-Math.floor(m/2)+\"px\"}}function l(){return e.picker&&e.picker.owner===d}function c(){d.importColor()}this.value=null,this.valueElement=t,this.styleElement=t,this.required=!0,this.refine=!0,this.hash=!1,this.uppercase=!0,this.onFineChange=null,this.activeClass=\"jscolor-active\",this.minS=0,this.maxS=100,this.minV=0,this.maxV=100,this.hsv=[0,0,100],this.rgb=[255,255,255],this.width=181,this.height=101,this.showOnClick=!0,this.mode=\"HSV\",this.position=\"bottom\",this.smartPosition=!0,this.sliderSize=16,this.crossSize=8,this.closable=!1,this.closeText=\"Close\",this.buttonColor=\"#000000\",this.buttonHeight=18,this.padding=12,this.backgroundColor=\"#FFFFFF\",this.borderWidth=1,this.borderColor=\"#BBBBBB\",this.borderRadius=8,this.insetWidth=1,this.insetColor=\"#BBBBBB\",this.shadow=!0,this.shadowBlur=15,this.shadowColor=\"rgba(0,0,0,0.2)\",this.pointerColor=\"#4C4C4C\",this.pointerBorderColor=\"#FFFFFF\",this.pointerBorderWidth=1,this.pointerThickness=2,this.zIndex=1e3,this.container=null;for(var r in n)n.hasOwnProperty(r)&&(this[r]=n[r]);this.hide=function(){l()&&o()},this.show=function(){u()},this.redraw=function(){l()&&u()},this.importColor=function(){this.valueElement?e.isElementType(this.valueElement,\"input\")?this.refine?!this.required&&/^\\s*$/.test(this.valueElement.value)?(this.valueElement.value=\"\",this.styleElement&&(this.styleElement.style.backgroundImage=this.styleElement._jscOrigStyle.backgroundImage,this.styleElement.style.backgroundColor=this.styleElement._jscOrigStyle.backgroundColor,this.styleElement.style.color=this.styleElement._jscOrigStyle.color),this.exportColor(e.leaveValue|e.leaveStyle)):this.fromString(this.valueElement.value)||this.exportColor():this.fromString(this.valueElement.value,e.leaveValue)||(this.styleElement&&(this.styleElement.style.backgroundImage=this.styleElement._jscOrigStyle.backgroundImage,this.styleElement.style.backgroundColor=this.styleElement._jscOrigStyle.backgroundColor,this.styleElement.style.color=this.styleElement._jscOrigStyle.color),this.exportColor(e.leaveValue|e.leaveStyle)):this.exportColor():this.exportColor()},this.exportColor=function(t){if(!(t&e.leaveValue)&&this.valueElement){var n=this.toString();this.uppercase&&(n=n.toUpperCase()),this.hash&&(n=\"#\"+n),e.isElementType(this.valueElement,\"input\")?this.valueElement.value=n:this.valueElement.innerHTML=n}t&e.leaveStyle||this.styleElement&&(this.styleElement.style.backgroundImage=\"none\",this.styleElement.style.backgroundColor=\"#\"+this.toString(),this.styleElement.style.color=this.isLight()?\"#000\":\"#FFF\"),!(t&e.leavePad)&&l()&&a(),!(t&e.leaveSld)&&l()&&f()},this.fromHSV=function(e,t,n,r){if(e!==null){if(isNaN(e))return!1;e=Math.max(0,Math.min(360,e))}if(t!==null){if(isNaN(t))return!1;t=Math.max(0,Math.min(100,this.maxS,t),this.minS)}if(n!==null){if(isNaN(n))return!1;n=Math.max(0,Math.min(100,this.maxV,n),this.minV)}this.rgb=s(e===null?this.hsv[0]:this.hsv[0]=e,t===null?this.hsv[1]:this.hsv[1]=t,n===null?this.hsv[2]:this.hsv[2]=n),this.exportColor(r)},this.fromRGB=function(e,t,n,r){if(e!==null){if(isNaN(e))return!1;e=Math.max(0,Math.min(255,e))}if(t!==null){if(isNaN(t))return!1;t=Math.max(0,Math.min(255,t))}if(n!==null){if(isNaN(n))return!1;n=Math.max(0,Math.min(255,n))}var o=i(e===null?this.rgb[0]:e,t===null?this.rgb[1]:t,n===null?this.rgb[2]:n);o[0]!==null&&(this.hsv[0]=Math.max(0,Math.min(360,o[0]))),o[2]!==0&&(this.hsv[1]=o[1]===null?null:Math.max(0,this.minS,Math.min(100,this.maxS,o[1]))),this.hsv[2]=o[2]===null?null:Math.max(0,this.minV,Math.min(100,this.maxV,o[2]));var u=s(this.hsv[0],this.hsv[1],this.hsv[2]);this.rgb[0]=u[0],this.rgb[1]=u[1],this.rgb[2]=u[2],this.exportColor(r)},this.fromString=function(e,t){var n;if(n=e.match(/^\\W*([0-9A-F]{3}([0-9A-F]{3})?)\\W*$/i))return n[1].length===6?this.fromRGB(parseInt(n[1].substr(0,2),16),parseInt(n[1].substr(2,2),16),parseInt(n[1].substr(4,2),16),t):this.fromRGB(parseInt(n[1].charAt(0)+n[1].charAt(0),16),parseInt(n[1].charAt(1)+n[1].charAt(1),16),parseInt(n[1].charAt(2)+n[1].charAt(2),16),t),!0;if(n=e.match(/^\\W*rgba?\\(([^)]*)\\)\\W*$/i)){var r=n[1].split(\",\"),i=/^\\s*(\\d*)(\\.\\d+)?\\s*$/,s,o,u;if(r.length>=3&&(s=r[0].match(i))&&(o=r[1].match(i))&&(u=r[2].match(i))){var a=parseFloat((s[1]||\"0\")+(s[2]||\"\")),f=parseFloat((o[1]||\"0\")+(o[2]||\"\")),l=parseFloat((u[1]||\"0\")+(u[2]||\"\"));return this.fromRGB(a,f,l,t),!0}}return!1},this.toString=function(){return(256|Math.round(this.rgb[0])).toString(16).substr(1)+(256|Math.round(this.rgb[1])).toString(16).substr(1)+(256|Math.round(this.rgb[2])).toString(16).substr(1)},this.toHEXString=function(){return\"#\"+this.toString().toUpperCase()},this.toRGBString=function(){return\"rgb(\"+Math.round(this.rgb[0])+\",\"+Math.round(this.rgb[1])+\",\"+Math.round(this.rgb[2])+\")\"},this.isLight=function(){return.213*this.rgb[0]+.715*this.rgb[1]+.072*this.rgb[2]>127.5},this._processParentElementsInDOM=function(){if(this._linkedElementsProcessed)return;this._linkedElementsProcessed=!0;var t=this.targetElement;do{var n=e.getStyle(t);n&&n.position.toLowerCase()===\"fixed\"&&(this.fixed=!0),t!==this.targetElement&&(t._jscEventsAttached||(e.attachEvent(t,\"scroll\",e.onParentScroll),t._jscEventsAttached=!0))}while((t=t.parentNode)&&!e.isElementType(t,\"body\"))};if(typeof t==\"string\"){var h=t,p=document.getElementById(h);p?this.targetElement=p:e.warn(\"Could not find target element with ID '\"+h+\"'\")}else t?this.targetElement=t:e.warn(\"Invalid target element: '\"+t+\"'\");if(this.targetElement._jscLinkedInstance){e.warn(\"Cannot link jscolor twice to the same element. Skipping.\");return}this.targetElement._jscLinkedInstance=this,this.valueElement=e.fetchElement(this.valueElement),this.styleElement=e.fetchElement(this.styleElement);var d=this,v=this.container?e.fetchElement(this.container):document.getElementsByTagName(\"body\")[0],m=3;if(e.isElementType(this.targetElement,\"button\"))if(this.targetElement.onclick){var g=this.targetElement.onclick;this.targetElement.onclick=function(e){return g.call(this,e),!1}}else this.targetElement.onclick=function(){return!1};if(this.valueElement&&e.isElementType(this.valueElement,\"input\")){var y=function(){d.fromString(d.valueElement.value,e.leaveValue),e.dispatchFineChange(d)};e.attachEvent(this.valueElement,\"keyup\",y),e.attachEvent(this.valueElement,\"input\",y),e.attachEvent(this.valueElement,\"blur\",c),this.valueElement.setAttribute(\"autocomplete\",\"off\")}this.styleElement&&(this.styleElement._jscOrigStyle={backgroundImage:this.styleElement.style.backgroundImage,backgroundColor:this.styleElement.style.backgroundColor,color:this.styleElement.style.color}),this.value?this.fromString(this.value)||this.exportColor():this.importColor()}};return e.jscolor.lookupClass=\"jscolor\",e.jscolor.installByClassName=function(t){var n=document.getElementsByTagName(\"input\"),r=document.getElementsByTagName(\"button\");e.tryInstallOnElements(n,t),e.tryInstallOnElements(r,t)},e.register(),e.jscolor}());","Mageplaza_Core/js/jquery.autocomplete.min.js":"/**\n *  Ajax Autocomplete for jQuery, version 1.3.0\n *  (c) 2017 Tomas Kirda\n *\n *  Ajax Autocomplete for jQuery is freely distributable under the terms of an MIT-style license.\n *  For details, see the web site: https://github.com/devbridge/jQuery-Autocomplete\n */\n!function(a){\"use strict\";\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(\"object\"==typeof exports&&\"function\"==typeof require?require(\"jquery\"):jQuery)}(function(a){\"use strict\";function b(c,d){var e=a.noop,f=this,g={ajaxSettings:{},autoSelectFirst:!1,appendTo:document.body,serviceUrl:null,lookup:null,onSelect:null,width:\"auto\",minChars:1,maxHeight:300,deferRequestBy:0,params:{},formatResult:b.formatResult,formatGroup:b.formatGroup,delimiter:null,zIndex:9999,type:\"GET\",noCache:!1,onSearchStart:e,onSearchComplete:e,onSearchError:e,preserveInput:!1,containerClass:\"autocomplete-suggestions\",tabDisabled:!1,dataType:\"text\",currentRequest:null,triggerSelectOnValidInput:!0,preventBadQueries:!0,lookupFilter:function(a,b,c){return-1!==a.value.toLowerCase().indexOf(c)},paramName:\"query\",transformResult:function(b){return\"string\"==typeof b?a.parseJSON(b):b},showNoSuggestionNotice:!1,noSuggestionNotice:\"No results\",orientation:\"bottom\",forceFixPosition:!1};f.element=c,f.el=a(c),f.suggestions=[],f.badQueries=[],f.selectedIndex=-1,f.currentValue=f.element.value,f.intervalId=0,f.cachedResponse={},f.onChangeInterval=null,f.onChange=null,f.isLocal=!1,f.suggestionsContainer=null,f.noSuggestionsContainer=null,f.options=a.extend({},g,d),f.classes={selected:\"autocomplete-selected\",suggestion:\"autocomplete-suggestion\"},f.hint=null,f.hintValue=\"\",f.selection=null,f.initialize(),f.setOptions(d)}var c=function(){return{escapeRegExChars:function(a){return a.replace(/[|\\\\{}()[\\]^$+*?.]/g,\"\\\\$&\")},createNode:function(a){var b=document.createElement(\"div\");return b.className=a,b.style.position=\"absolute\",b.style.display=\"none\",b}}}(),d={ESC:27,TAB:9,RETURN:13,LEFT:37,UP:38,RIGHT:39,DOWN:40};b.utils=c,a.Autocomplete=b,b.formatResult=function(a,b){if(!b)return a.value;var d=\"(\"+c.escapeRegExChars(b)+\")\";return a.value.replace(new RegExp(d,\"gi\"),\"<strong>$1</strong>\").replace(/&/g,\"&amp;\").replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\").replace(/\"/g,\"&quot;\").replace(/&lt;(\\/?strong)&gt;/g,\"<$1>\")},b.formatGroup=function(a,b){return'<div class=\"autocomplete-group\"><strong>'+b+\"</strong></div>\"},b.prototype={killerFn:null,initialize:function(){var c,d=this,e=\".\"+d.classes.suggestion,f=d.classes.selected,g=d.options;d.element.setAttribute(\"autocomplete\",\"off\"),d.killerFn=function(b){a(b.target).closest(\".\"+d.options.containerClass).length||(d.killSuggestions(),d.disableKillerFn())},d.noSuggestionsContainer=a('<div class=\"autocomplete-no-suggestion\"></div>').html(this.options.noSuggestionNotice).get(0),d.suggestionsContainer=b.utils.createNode(g.containerClass),c=a(d.suggestionsContainer),c.appendTo(g.appendTo),\"auto\"!==g.width&&c.css(\"width\",g.width),c.on(\"mouseover.autocomplete\",e,function(){d.activate(a(this).data(\"index\"))}),c.on(\"mouseout.autocomplete\",function(){d.selectedIndex=-1,c.children(\".\"+f).removeClass(f)}),c.on(\"click.autocomplete\",e,function(){return d.select(a(this).data(\"index\")),!1}),d.fixPositionCapture=function(){d.visible&&d.fixPosition()},a(window).on(\"resize.autocomplete\",d.fixPositionCapture),d.el.on(\"keydown.autocomplete\",function(a){d.onKeyPress(a)}),d.el.on(\"keyup.autocomplete\",function(a){d.onKeyUp(a)}),d.el.on(\"blur.autocomplete\",function(){d.onBlur()}),d.el.on(\"focus.autocomplete\",function(){d.onFocus()}),d.el.on(\"change.autocomplete\",function(a){d.onKeyUp(a)}),d.el.on(\"input.autocomplete\",function(a){d.onKeyUp(a)})},onFocus:function(){var a=this;a.fixPosition(),a.el.val().length>=a.options.minChars&&a.onValueChange()},onBlur:function(){this.enableKillerFn()},abortAjax:function(){var a=this;a.currentRequest&&(a.currentRequest.abort(),a.currentRequest=null)},setOptions:function(b){var c=this,d=c.options;a.extend(d,b),c.isLocal=a.isArray(d.lookup),c.isLocal&&(d.lookup=c.verifySuggestionsFormat(d.lookup)),d.orientation=c.validateOrientation(d.orientation,\"bottom\"),a(c.suggestionsContainer).css({\"max-height\":d.maxHeight+\"px\",width:d.width+\"px\",\"z-index\":d.zIndex})},clearCache:function(){this.cachedResponse={},this.badQueries=[]},clear:function(){this.clearCache(),this.currentValue=\"\",this.suggestions=[]},disable:function(){var a=this;a.disabled=!0,clearInterval(a.onChangeInterval),a.abortAjax()},enable:function(){this.disabled=!1},fixPosition:function(){var b=this,c=a(b.suggestionsContainer),d=c.parent().get(0);if(d===document.body||b.options.forceFixPosition){var e=b.options.orientation,f=c.outerHeight(),g=b.el.outerHeight(),h=b.el.offset(),i={top:h.top,left:h.left};if(\"auto\"===e){var j=a(window).height(),k=a(window).scrollTop(),l=-k+h.top-f,m=k+j-(h.top+g+f);e=Math.max(l,m)===l?\"top\":\"bottom\"}if(\"top\"===e?i.top+=-f:i.top+=g,d!==document.body){var n,o=c.css(\"opacity\");b.visible||c.css(\"opacity\",0).show(),n=c.offsetParent().offset(),i.top-=n.top,i.left-=n.left,b.visible||c.css(\"opacity\",o).hide()}\"auto\"===b.options.width&&(i.width=b.el.outerWidth()+\"px\"),c.css(i)}},enableKillerFn:function(){var b=this;a(document).on(\"click.autocomplete\",b.killerFn)},disableKillerFn:function(){var b=this;a(document).off(\"click.autocomplete\",b.killerFn)},killSuggestions:function(){var a=this;a.stopKillSuggestions(),a.intervalId=window.setInterval(function(){a.visible&&(a.options.preserveInput||a.el.val(a.currentValue),a.hide()),a.stopKillSuggestions()},50)},stopKillSuggestions:function(){window.clearInterval(this.intervalId)},isCursorAtEnd:function(){var a,b=this,c=b.el.val().length,d=b.element.selectionStart;return\"number\"==typeof d?d===c:document.selection?(a=document.selection.createRange(),a.moveStart(\"character\",-c),c===a.text.length):!0},onKeyPress:function(a){var b=this;if(!b.disabled&&!b.visible&&a.which===d.DOWN&&b.currentValue)return void b.suggest();if(!b.disabled&&b.visible){switch(a.which){case d.ESC:b.el.val(b.currentValue),b.hide();break;case d.RIGHT:if(b.hint&&b.options.onHint&&b.isCursorAtEnd()){b.selectHint();break}return;case d.TAB:if(b.hint&&b.options.onHint)return void b.selectHint();if(-1===b.selectedIndex)return void b.hide();if(b.select(b.selectedIndex),b.options.tabDisabled===!1)return;break;case d.RETURN:if(-1===b.selectedIndex)return void b.hide();b.select(b.selectedIndex);break;case d.UP:b.moveUp();break;case d.DOWN:b.moveDown();break;default:return}a.stopImmediatePropagation(),a.preventDefault()}},onKeyUp:function(a){var b=this;if(!b.disabled){switch(a.which){case d.UP:case d.DOWN:return}clearInterval(b.onChangeInterval),b.currentValue!==b.el.val()&&(b.findBestHint(),b.options.deferRequestBy>0?b.onChangeInterval=setInterval(function(){b.onValueChange()},b.options.deferRequestBy):b.onValueChange())}},onValueChange:function(){var b=this,c=b.options,d=b.el.val(),e=b.getQuery(d);return b.selection&&b.currentValue!==e&&(b.selection=null,(c.onInvalidateSelection||a.noop).call(b.element)),clearInterval(b.onChangeInterval),b.currentValue=d,b.selectedIndex=-1,c.triggerSelectOnValidInput&&b.isExactMatch(e)?void b.select(0):void(e.length<c.minChars?b.hide():b.getSuggestions(e))},isExactMatch:function(a){var b=this.suggestions;return 1===b.length&&b[0].value.toLowerCase()===a.toLowerCase()},getQuery:function(b){var c,d=this.options.delimiter;return d?(c=b.split(d),a.trim(c[c.length-1])):b},getSuggestionsLocal:function(b){var c,d=this,e=d.options,f=b.toLowerCase(),g=e.lookupFilter,h=parseInt(e.lookupLimit,10);return c={suggestions:a.grep(e.lookup,function(a){return g(a,b,f)})},h&&c.suggestions.length>h&&(c.suggestions=c.suggestions.slice(0,h)),c},getSuggestions:function(b){var c,d,e,f,g=this,h=g.options,i=h.serviceUrl;if(h.params[h.paramName]=b,d=h.ignoreParams?null:h.params,h.onSearchStart.call(g.element,h.params)!==!1){if(a.isFunction(h.lookup))return void h.lookup(b,function(a){g.suggestions=a.suggestions,g.suggest(),h.onSearchComplete.call(g.element,b,a.suggestions)});g.isLocal?c=g.getSuggestionsLocal(b):(a.isFunction(i)&&(i=i.call(g.element,b)),e=i+\"?\"+a.param(d||{}),c=g.cachedResponse[e]),c&&a.isArray(c.suggestions)?(g.suggestions=c.suggestions,g.suggest(),h.onSearchComplete.call(g.element,b,c.suggestions)):g.isBadQuery(b)?h.onSearchComplete.call(g.element,b,[]):(g.abortAjax(),f={url:i,data:d,type:h.type,dataType:h.dataType},a.extend(f,h.ajaxSettings),g.currentRequest=a.ajax(f).done(function(a){var c;g.currentRequest=null,c=h.transformResult(a,b),g.processResponse(c,b,e),h.onSearchComplete.call(g.element,b,c.suggestions)}).fail(function(a,c,d){h.onSearchError.call(g.element,b,a,c,d)}))}},isBadQuery:function(a){if(!this.options.preventBadQueries)return!1;for(var b=this.badQueries,c=b.length;c--;)if(0===a.indexOf(b[c]))return!0;return!1},hide:function(){var b=this,c=a(b.suggestionsContainer);a.isFunction(b.options.onHide)&&b.visible&&b.options.onHide.call(b.element,c),b.visible=!1,b.selectedIndex=-1,clearInterval(b.onChangeInterval),a(b.suggestionsContainer).hide(),b.signalHint(null)},suggest:function(){if(!this.suggestions.length)return void(this.options.showNoSuggestionNotice?this.noSuggestions():this.hide());var b,c=this,d=c.options,e=d.groupBy,f=d.formatResult,g=c.getQuery(c.currentValue),h=c.classes.suggestion,i=c.classes.selected,j=a(c.suggestionsContainer),k=a(c.noSuggestionsContainer),l=d.beforeRender,m=\"\",n=function(a,c){var f=a.data[e];return b===f?\"\":(b=f,d.formatGroup(a,b))};return d.triggerSelectOnValidInput&&c.isExactMatch(g)?void c.select(0):(a.each(c.suggestions,function(a,b){e&&(m+=n(b,g,a)),m+='<div class=\"'+h+'\" data-index=\"'+a+'\">'+f(b,g,a)+\"</div>\"}),this.adjustContainerWidth(),k.detach(),j.html(m),a.isFunction(l)&&l.call(c.element,j,c.suggestions),c.fixPosition(),j.show(),d.autoSelectFirst&&(c.selectedIndex=0,j.scrollTop(0),j.children(\".\"+h).first().addClass(i)),c.visible=!0,void c.findBestHint())},noSuggestions:function(){var b=this,c=a(b.suggestionsContainer),d=a(b.noSuggestionsContainer);this.adjustContainerWidth(),d.detach(),c.empty(),c.append(d),b.fixPosition(),c.show(),b.visible=!0},adjustContainerWidth:function(){var b,c=this,d=c.options,e=a(c.suggestionsContainer);\"auto\"===d.width?(b=c.el.outerWidth(),e.css(\"width\",b>0?b:300)):\"flex\"===d.width&&e.css(\"width\",\"\")},findBestHint:function(){var b=this,c=b.el.val().toLowerCase(),d=null;c&&(a.each(b.suggestions,function(a,b){var e=0===b.value.toLowerCase().indexOf(c);return e&&(d=b),!e}),b.signalHint(d))},signalHint:function(b){var c=\"\",d=this;b&&(c=d.currentValue+b.value.substr(d.currentValue.length)),d.hintValue!==c&&(d.hintValue=c,d.hint=b,(this.options.onHint||a.noop)(c))},verifySuggestionsFormat:function(b){return b.length&&\"string\"==typeof b[0]?a.map(b,function(a){return{value:a,data:null}}):b},validateOrientation:function(b,c){return b=a.trim(b||\"\").toLowerCase(),-1===a.inArray(b,[\"auto\",\"bottom\",\"top\"])&&(b=c),b},processResponse:function(a,b,c){var d=this,e=d.options;a.suggestions=d.verifySuggestionsFormat(a.suggestions),e.noCache||(d.cachedResponse[c]=a,e.preventBadQueries&&!a.suggestions.length&&d.badQueries.push(b)),b===d.getQuery(d.currentValue)&&(d.suggestions=a.suggestions,d.suggest())},activate:function(b){var c,d=this,e=d.classes.selected,f=a(d.suggestionsContainer),g=f.find(\".\"+d.classes.suggestion);return f.find(\".\"+e).removeClass(e),d.selectedIndex=b,-1!==d.selectedIndex&&g.length>d.selectedIndex?(c=g.get(d.selectedIndex),a(c).addClass(e),c):null},selectHint:function(){var b=this,c=a.inArray(b.hint,b.suggestions);b.select(c)},select:function(a){var b=this;b.hide(),b.onSelect(a),b.disableKillerFn()},moveUp:function(){var b=this;if(-1!==b.selectedIndex)return 0===b.selectedIndex?(a(b.suggestionsContainer).children().first().removeClass(b.classes.selected),b.selectedIndex=-1,b.el.val(b.currentValue),void b.findBestHint()):void b.adjustScroll(b.selectedIndex-1)},moveDown:function(){var a=this;a.selectedIndex!==a.suggestions.length-1&&a.adjustScroll(a.selectedIndex+1)},adjustScroll:function(b){var c=this,d=c.activate(b);if(d){var e,f,g,h=a(d).outerHeight();e=d.offsetTop,f=a(c.suggestionsContainer).scrollTop(),g=f+c.options.maxHeight-h,f>e?a(c.suggestionsContainer).scrollTop(e):e>g&&a(c.suggestionsContainer).scrollTop(e-c.options.maxHeight+h),c.options.preserveInput||c.el.val(c.getValue(c.suggestions[b].value)),c.signalHint(null)}},onSelect:function(b){var c=this,d=c.options.onSelect,e=c.suggestions[b];c.currentValue=c.getValue(e.value),c.currentValue===c.el.val()||c.options.preserveInput||c.el.val(c.currentValue),c.signalHint(null),c.suggestions=[],c.selection=e,a.isFunction(d)&&d.call(c.element,e)},getValue:function(a){var b,c,d=this,e=d.options.delimiter;return e?(b=d.currentValue,c=b.split(e),1===c.length?a:b.substr(0,b.length-c[c.length-1].length)+a):a},dispose:function(){var b=this;b.el.off(\".autocomplete\").removeData(\"autocomplete\"),b.disableKillerFn(),a(window).off(\"resize.autocomplete\",b.fixPositionCapture),a(b.suggestionsContainer).remove()}},a.fn.autocomplete=a.fn.devbridgeAutocomplete=function(c,d){var e=\"autocomplete\";return arguments.length?this.each(function(){var f=a(this),g=f.data(e);\"string\"==typeof c?g&&\"function\"==typeof g[c]&&g[c](d):(g&&g.dispose&&g.dispose(),g=new b(this,c),f.data(e,g))}):this.first().data(e)}});","Mageplaza_Core/js/ion.rangeSlider.min.js":"// Ion.RangeSlider | version 2.1.6 | https://github.com/IonDen/ion.rangeSlider\n;(function(f){\"function\"===typeof define&&define.amd?define([\"jquery\"],function(p){return f(p,document,window,navigator)}):\"object\"===typeof exports?f(require(\"jquery\"),document,window,navigator):f(jQuery,document,window,navigator)})(function(f,p,h,t,q){var u=0,m=function(){var a=t.userAgent,b=/msie\\s\\d+/i;return 0<a.search(b)&&(a=b.exec(a).toString(),a=a.split(\" \")[1],9>a)?(f(\"html\").addClass(\"lt-ie9\"),!0):!1}();Function.prototype.bind||(Function.prototype.bind=function(a){var b=this,d=[].slice;if(\"function\"!=\n    typeof b)throw new TypeError;var c=d.call(arguments,1),e=function(){if(this instanceof e){var g=function(){};g.prototype=b.prototype;var g=new g,l=b.apply(g,c.concat(d.call(arguments)));return Object(l)===l?l:g}return b.apply(a,c.concat(d.call(arguments)))};return e});Array.prototype.indexOf||(Array.prototype.indexOf=function(a,b){var d;if(null==this)throw new TypeError('\"this\" is null or not defined');var c=Object(this),e=c.length>>>0;if(0===e)return-1;d=+b||0;Infinity===Math.abs(d)&&(d=0);if(d>=\n    e)return-1;for(d=Math.max(0<=d?d:e-Math.abs(d),0);d<e;){if(d in c&&c[d]===a)return d;d++}return-1});var r=function(a,b,d){this.VERSION=\"2.1.6\";this.input=a;this.plugin_count=d;this.old_to=this.old_from=this.update_tm=this.calc_count=this.current_plugin=0;this.raf_id=this.old_min_interval=null;this.is_update=this.is_key=this.no_diapason=this.force_redraw=this.dragging=!1;this.is_start=this.is_first_update=!0;this.is_click=this.is_resize=this.is_active=this.is_finish=!1;b=b||{};this.$cache={win:f(h),\n    body:f(p.body),input:f(a),cont:null,rs:null,min:null,max:null,from:null,to:null,single:null,bar:null,line:null,s_single:null,s_from:null,s_to:null,shad_single:null,shad_from:null,shad_to:null,edge:null,grid:null,grid_labels:[]};this.coords={x_gap:0,x_pointer:0,w_rs:0,w_rs_old:0,w_handle:0,p_gap:0,p_gap_left:0,p_gap_right:0,p_step:0,p_pointer:0,p_handle:0,p_single_fake:0,p_single_real:0,p_from_fake:0,p_from_real:0,p_to_fake:0,p_to_real:0,p_bar_x:0,p_bar_w:0,grid_gap:0,big_num:0,big:[],big_w:[],big_p:[],\n    big_x:[]};this.labels={w_min:0,w_max:0,w_from:0,w_to:0,w_single:0,p_min:0,p_max:0,p_from_fake:0,p_from_left:0,p_to_fake:0,p_to_left:0,p_single_fake:0,p_single_left:0};var c=this.$cache.input;a=c.prop(\"value\");var e;d={type:\"single\",min:10,max:100,from:null,to:null,step:1,min_interval:0,max_interval:0,drag_interval:!1,values:[],p_values:[],from_fixed:!1,from_min:null,from_max:null,from_shadow:!1,to_fixed:!1,to_min:null,to_max:null,to_shadow:!1,prettify_enabled:!0,prettify_separator:\" \",prettify:null,\n    force_edges:!1,keyboard:!1,keyboard_step:5,grid:!1,grid_margin:!0,grid_num:4,grid_snap:!1,hide_min_max:!1,hide_from_to:!1,prefix:\"\",postfix:\"\",max_postfix:\"\",decorate_both:!0,values_separator:\" \\u2014 \",input_values_separator:\";\",disable:!1,onStart:null,onChange:null,onFinish:null,onUpdate:null};\"INPUT\"!==c[0].nodeName&&console&&console.warn&&console.warn(\"Base element should be <input>!\",c[0]);c={type:c.data(\"type\"),min:c.data(\"min\"),max:c.data(\"max\"),from:c.data(\"from\"),to:c.data(\"to\"),step:c.data(\"step\"),\n    min_interval:c.data(\"minInterval\"),max_interval:c.data(\"maxInterval\"),drag_interval:c.data(\"dragInterval\"),values:c.data(\"values\"),from_fixed:c.data(\"fromFixed\"),from_min:c.data(\"fromMin\"),from_max:c.data(\"fromMax\"),from_shadow:c.data(\"fromShadow\"),to_fixed:c.data(\"toFixed\"),to_min:c.data(\"toMin\"),to_max:c.data(\"toMax\"),to_shadow:c.data(\"toShadow\"),prettify_enabled:c.data(\"prettifyEnabled\"),prettify_separator:c.data(\"prettifySeparator\"),force_edges:c.data(\"forceEdges\"),keyboard:c.data(\"keyboard\"),\n    keyboard_step:c.data(\"keyboardStep\"),grid:c.data(\"grid\"),grid_margin:c.data(\"gridMargin\"),grid_num:c.data(\"gridNum\"),grid_snap:c.data(\"gridSnap\"),hide_min_max:c.data(\"hideMinMax\"),hide_from_to:c.data(\"hideFromTo\"),prefix:c.data(\"prefix\"),postfix:c.data(\"postfix\"),max_postfix:c.data(\"maxPostfix\"),decorate_both:c.data(\"decorateBoth\"),values_separator:c.data(\"valuesSeparator\"),input_values_separator:c.data(\"inputValuesSeparator\"),disable:c.data(\"disable\")};c.values=c.values&&c.values.split(\",\");for(e in c)c.hasOwnProperty(e)&&\n(c[e]!==q&&\"\"!==c[e]||delete c[e]);a!==q&&\"\"!==a&&(a=a.split(c.input_values_separator||b.input_values_separator||\";\"),a[0]&&a[0]==+a[0]&&(a[0]=+a[0]),a[1]&&a[1]==+a[1]&&(a[1]=+a[1]),b&&b.values&&b.values.length?(d.from=a[0]&&b.values.indexOf(a[0]),d.to=a[1]&&b.values.indexOf(a[1])):(d.from=a[0]&&+a[0],d.to=a[1]&&+a[1]));f.extend(d,b);f.extend(d,c);this.options=d;this.update_check={};this.validate();this.result={input:this.$cache.input,slider:null,min:this.options.min,max:this.options.max,from:this.options.from,\n    from_percent:0,from_value:null,to:this.options.to,to_percent:0,to_value:null};this.init()};r.prototype={init:function(a){this.no_diapason=!1;this.coords.p_step=this.convertToPercent(this.options.step,!0);this.target=\"base\";this.toggleInput();this.append();this.setMinMax();a?(this.force_redraw=!0,this.calc(!0),this.callOnUpdate()):(this.force_redraw=!0,this.calc(!0),this.callOnStart());this.updateScene()},append:function(){this.$cache.input.before('<span class=\"irs js-irs-'+this.plugin_count+'\"></span>');\n        this.$cache.input.prop(\"readonly\",!0);this.$cache.cont=this.$cache.input.prev();this.result.slider=this.$cache.cont;this.$cache.cont.html('<span class=\"irs\"><span class=\"irs-line\" tabindex=\"-1\"><span class=\"irs-line-left\"></span><span class=\"irs-line-mid\"></span><span class=\"irs-line-right\"></span></span><span class=\"irs-min\">0</span><span class=\"irs-max\">1</span><span class=\"irs-from\">0</span><span class=\"irs-to\">0</span><span class=\"irs-single\">0</span></span><span class=\"irs-grid\"></span><span class=\"irs-bar\"></span>');\n        this.$cache.rs=this.$cache.cont.find(\".irs\");this.$cache.min=this.$cache.cont.find(\".irs-min\");this.$cache.max=this.$cache.cont.find(\".irs-max\");this.$cache.from=this.$cache.cont.find(\".irs-from\");this.$cache.to=this.$cache.cont.find(\".irs-to\");this.$cache.single=this.$cache.cont.find(\".irs-single\");this.$cache.bar=this.$cache.cont.find(\".irs-bar\");this.$cache.line=this.$cache.cont.find(\".irs-line\");this.$cache.grid=this.$cache.cont.find(\".irs-grid\");\"single\"===this.options.type?(this.$cache.cont.append('<span class=\"irs-bar-edge\"></span><span class=\"irs-shadow shadow-single\"></span><span class=\"irs-slider single\"></span>'),\n            this.$cache.edge=this.$cache.cont.find(\".irs-bar-edge\"),this.$cache.s_single=this.$cache.cont.find(\".single\"),this.$cache.from[0].style.visibility=\"hidden\",this.$cache.to[0].style.visibility=\"hidden\",this.$cache.shad_single=this.$cache.cont.find(\".shadow-single\")):(this.$cache.cont.append('<span class=\"irs-shadow shadow-from\"></span><span class=\"irs-shadow shadow-to\"></span><span class=\"irs-slider from\"></span><span class=\"irs-slider to\"></span>'),this.$cache.s_from=this.$cache.cont.find(\".from\"),\n            this.$cache.s_to=this.$cache.cont.find(\".to\"),this.$cache.shad_from=this.$cache.cont.find(\".shadow-from\"),this.$cache.shad_to=this.$cache.cont.find(\".shadow-to\"),this.setTopHandler());this.options.hide_from_to&&(this.$cache.from[0].style.display=\"none\",this.$cache.to[0].style.display=\"none\",this.$cache.single[0].style.display=\"none\");this.appendGrid();this.options.disable?(this.appendDisableMask(),this.$cache.input[0].disabled=!0):(this.$cache.cont.removeClass(\"irs-disabled\"),this.$cache.input[0].disabled=\n            !1,this.bindEvents());this.options.drag_interval&&(this.$cache.bar[0].style.cursor=\"ew-resize\")},setTopHandler:function(){var a=this.options.max,b=this.options.to;this.options.from>this.options.min&&b===a?this.$cache.s_from.addClass(\"type_last\"):b<a&&this.$cache.s_to.addClass(\"type_last\")},changeLevel:function(a){switch(a){case \"single\":this.coords.p_gap=this.toFixed(this.coords.p_pointer-this.coords.p_single_fake);break;case \"from\":this.coords.p_gap=this.toFixed(this.coords.p_pointer-this.coords.p_from_fake);\n        this.$cache.s_from.addClass(\"state_hover\");this.$cache.s_from.addClass(\"type_last\");this.$cache.s_to.removeClass(\"type_last\");break;case \"to\":this.coords.p_gap=this.toFixed(this.coords.p_pointer-this.coords.p_to_fake);this.$cache.s_to.addClass(\"state_hover\");this.$cache.s_to.addClass(\"type_last\");this.$cache.s_from.removeClass(\"type_last\");break;case \"both\":this.coords.p_gap_left=this.toFixed(this.coords.p_pointer-this.coords.p_from_fake),this.coords.p_gap_right=this.toFixed(this.coords.p_to_fake-\n        this.coords.p_pointer),this.$cache.s_to.removeClass(\"type_last\"),this.$cache.s_from.removeClass(\"type_last\")}},appendDisableMask:function(){this.$cache.cont.append('<span class=\"irs-disable-mask\"></span>');this.$cache.cont.addClass(\"irs-disabled\")},remove:function(){this.$cache.cont.remove();this.$cache.cont=null;this.$cache.line.off(\"keydown.irs_\"+this.plugin_count);this.$cache.body.off(\"touchmove.irs_\"+this.plugin_count);this.$cache.body.off(\"mousemove.irs_\"+this.plugin_count);this.$cache.win.off(\"touchend.irs_\"+\n        this.plugin_count);this.$cache.win.off(\"mouseup.irs_\"+this.plugin_count);m&&(this.$cache.body.off(\"mouseup.irs_\"+this.plugin_count),this.$cache.body.off(\"mouseleave.irs_\"+this.plugin_count));this.$cache.grid_labels=[];this.coords.big=[];this.coords.big_w=[];this.coords.big_p=[];this.coords.big_x=[];cancelAnimationFrame(this.raf_id)},bindEvents:function(){if(!this.no_diapason){this.$cache.body.on(\"touchmove.irs_\"+this.plugin_count,this.pointerMove.bind(this));this.$cache.body.on(\"mousemove.irs_\"+this.plugin_count,\n        this.pointerMove.bind(this));this.$cache.win.on(\"touchend.irs_\"+this.plugin_count,this.pointerUp.bind(this));this.$cache.win.on(\"mouseup.irs_\"+this.plugin_count,this.pointerUp.bind(this));this.$cache.line.on(\"touchstart.irs_\"+this.plugin_count,this.pointerClick.bind(this,\"click\"));this.$cache.line.on(\"mousedown.irs_\"+this.plugin_count,this.pointerClick.bind(this,\"click\"));this.options.drag_interval&&\"double\"===this.options.type?(this.$cache.bar.on(\"touchstart.irs_\"+this.plugin_count,this.pointerDown.bind(this,\n        \"both\")),this.$cache.bar.on(\"mousedown.irs_\"+this.plugin_count,this.pointerDown.bind(this,\"both\"))):(this.$cache.bar.on(\"touchstart.irs_\"+this.plugin_count,this.pointerClick.bind(this,\"click\")),this.$cache.bar.on(\"mousedown.irs_\"+this.plugin_count,this.pointerClick.bind(this,\"click\")));\"single\"===this.options.type?(this.$cache.single.on(\"touchstart.irs_\"+this.plugin_count,this.pointerDown.bind(this,\"single\")),this.$cache.s_single.on(\"touchstart.irs_\"+this.plugin_count,this.pointerDown.bind(this,\"single\")),\n        this.$cache.shad_single.on(\"touchstart.irs_\"+this.plugin_count,this.pointerClick.bind(this,\"click\")),this.$cache.single.on(\"mousedown.irs_\"+this.plugin_count,this.pointerDown.bind(this,\"single\")),this.$cache.s_single.on(\"mousedown.irs_\"+this.plugin_count,this.pointerDown.bind(this,\"single\")),this.$cache.edge.on(\"mousedown.irs_\"+this.plugin_count,this.pointerClick.bind(this,\"click\")),this.$cache.shad_single.on(\"mousedown.irs_\"+this.plugin_count,this.pointerClick.bind(this,\"click\"))):(this.$cache.single.on(\"touchstart.irs_\"+\n        this.plugin_count,this.pointerDown.bind(this,null)),this.$cache.single.on(\"mousedown.irs_\"+this.plugin_count,this.pointerDown.bind(this,null)),this.$cache.from.on(\"touchstart.irs_\"+this.plugin_count,this.pointerDown.bind(this,\"from\")),this.$cache.s_from.on(\"touchstart.irs_\"+this.plugin_count,this.pointerDown.bind(this,\"from\")),this.$cache.to.on(\"touchstart.irs_\"+this.plugin_count,this.pointerDown.bind(this,\"to\")),this.$cache.s_to.on(\"touchstart.irs_\"+this.plugin_count,this.pointerDown.bind(this,\"to\")),\n        this.$cache.shad_from.on(\"touchstart.irs_\"+this.plugin_count,this.pointerClick.bind(this,\"click\")),this.$cache.shad_to.on(\"touchstart.irs_\"+this.plugin_count,this.pointerClick.bind(this,\"click\")),this.$cache.from.on(\"mousedown.irs_\"+this.plugin_count,this.pointerDown.bind(this,\"from\")),this.$cache.s_from.on(\"mousedown.irs_\"+this.plugin_count,this.pointerDown.bind(this,\"from\")),this.$cache.to.on(\"mousedown.irs_\"+this.plugin_count,this.pointerDown.bind(this,\"to\")),this.$cache.s_to.on(\"mousedown.irs_\"+\n        this.plugin_count,this.pointerDown.bind(this,\"to\")),this.$cache.shad_from.on(\"mousedown.irs_\"+this.plugin_count,this.pointerClick.bind(this,\"click\")),this.$cache.shad_to.on(\"mousedown.irs_\"+this.plugin_count,this.pointerClick.bind(this,\"click\")));if(this.options.keyboard)this.$cache.line.on(\"keydown.irs_\"+this.plugin_count,this.key.bind(this,\"keyboard\"));m&&(this.$cache.body.on(\"mouseup.irs_\"+this.plugin_count,this.pointerUp.bind(this)),this.$cache.body.on(\"mouseleave.irs_\"+this.plugin_count,this.pointerUp.bind(this)))}},\n    pointerMove:function(a){this.dragging&&(this.coords.x_pointer=(a.pageX||a.originalEvent.touches&&a.originalEvent.touches[0].pageX)-this.coords.x_gap,this.calc())},pointerUp:function(a){this.current_plugin===this.plugin_count&&this.is_active&&(this.is_active=!1,this.$cache.cont.find(\".state_hover\").removeClass(\"state_hover\"),this.force_redraw=!0,m&&f(\"*\").prop(\"unselectable\",!1),this.updateScene(),this.restoreOriginalMinInterval(),(f.contains(this.$cache.cont[0],a.target)||this.dragging)&&this.callOnFinish(),\n        this.dragging=!1)},pointerDown:function(a,b){b.preventDefault();var d=b.pageX||b.originalEvent.touches&&b.originalEvent.touches[0].pageX;2!==b.button&&(\"both\"===a&&this.setTempMinInterval(),a||(a=this.target||\"from\"),this.current_plugin=this.plugin_count,this.target=a,this.dragging=this.is_active=!0,this.coords.x_gap=this.$cache.rs.offset().left,this.coords.x_pointer=d-this.coords.x_gap,this.calcPointerPercent(),this.changeLevel(a),m&&f(\"*\").prop(\"unselectable\",!0),this.$cache.line.trigger(\"focus\"),\n        this.updateScene())},pointerClick:function(a,b){b.preventDefault();var d=b.pageX||b.originalEvent.touches&&b.originalEvent.touches[0].pageX;2!==b.button&&(this.current_plugin=this.plugin_count,this.target=a,this.is_click=!0,this.coords.x_gap=this.$cache.rs.offset().left,this.coords.x_pointer=+(d-this.coords.x_gap).toFixed(),this.force_redraw=!0,this.calc(),this.$cache.line.trigger(\"focus\"))},key:function(a,b){if(!(this.current_plugin!==this.plugin_count||b.altKey||b.ctrlKey||b.shiftKey||b.metaKey)){switch(b.which){case 83:case 65:case 40:case 37:b.preventDefault();\n        this.moveByKey(!1);break;case 87:case 68:case 38:case 39:b.preventDefault(),this.moveByKey(!0)}return!0}},moveByKey:function(a){var b=this.coords.p_pointer,b=a?b+this.options.keyboard_step:b-this.options.keyboard_step;this.coords.x_pointer=this.toFixed(this.coords.w_rs/100*b);this.is_key=!0;this.calc()},setMinMax:function(){this.options&&(this.options.hide_min_max?(this.$cache.min[0].style.display=\"none\",this.$cache.max[0].style.display=\"none\"):(this.options.values.length?(this.$cache.min.html(this.decorate(this.options.p_values[this.options.min])),\n        this.$cache.max.html(this.decorate(this.options.p_values[this.options.max]))):(this.$cache.min.html(this.decorate(this._prettify(this.options.min),this.options.min)),this.$cache.max.html(this.decorate(this._prettify(this.options.max),this.options.max))),this.labels.w_min=this.$cache.min.outerWidth(!1),this.labels.w_max=this.$cache.max.outerWidth(!1)))},setTempMinInterval:function(){var a=this.result.to-this.result.from;null===this.old_min_interval&&(this.old_min_interval=this.options.min_interval);\n        this.options.min_interval=a},restoreOriginalMinInterval:function(){null!==this.old_min_interval&&(this.options.min_interval=this.old_min_interval,this.old_min_interval=null)},calc:function(a){if(this.options){this.calc_count++;if(10===this.calc_count||a)this.calc_count=0,this.coords.w_rs=this.$cache.rs.outerWidth(!1),this.calcHandlePercent();if(this.coords.w_rs){this.calcPointerPercent();a=this.getHandleX();\"both\"===this.target&&(this.coords.p_gap=0,a=this.getHandleX());\"click\"===this.target&&(this.coords.p_gap=\n        this.coords.p_handle/2,a=this.getHandleX(),this.target=this.options.drag_interval?\"both_one\":this.chooseHandle(a));switch(this.target){case \"base\":var b=(this.options.max-this.options.min)/100;a=(this.result.from-this.options.min)/b;b=(this.result.to-this.options.min)/b;this.coords.p_single_real=this.toFixed(a);this.coords.p_from_real=this.toFixed(a);this.coords.p_to_real=this.toFixed(b);this.coords.p_single_real=this.checkDiapason(this.coords.p_single_real,this.options.from_min,this.options.from_max);\n        this.coords.p_from_real=this.checkDiapason(this.coords.p_from_real,this.options.from_min,this.options.from_max);this.coords.p_to_real=this.checkDiapason(this.coords.p_to_real,this.options.to_min,this.options.to_max);this.coords.p_single_fake=this.convertToFakePercent(this.coords.p_single_real);this.coords.p_from_fake=this.convertToFakePercent(this.coords.p_from_real);this.coords.p_to_fake=this.convertToFakePercent(this.coords.p_to_real);this.target=null;break;case \"single\":if(this.options.from_fixed)break;\n        this.coords.p_single_real=this.convertToRealPercent(a);this.coords.p_single_real=this.calcWithStep(this.coords.p_single_real);this.coords.p_single_real=this.checkDiapason(this.coords.p_single_real,this.options.from_min,this.options.from_max);this.coords.p_single_fake=this.convertToFakePercent(this.coords.p_single_real);break;case \"from\":if(this.options.from_fixed)break;this.coords.p_from_real=this.convertToRealPercent(a);this.coords.p_from_real=this.calcWithStep(this.coords.p_from_real);this.coords.p_from_real>\n    this.coords.p_to_real&&(this.coords.p_from_real=this.coords.p_to_real);this.coords.p_from_real=this.checkDiapason(this.coords.p_from_real,this.options.from_min,this.options.from_max);this.coords.p_from_real=this.checkMinInterval(this.coords.p_from_real,this.coords.p_to_real,\"from\");this.coords.p_from_real=this.checkMaxInterval(this.coords.p_from_real,this.coords.p_to_real,\"from\");this.coords.p_from_fake=this.convertToFakePercent(this.coords.p_from_real);break;case \"to\":if(this.options.to_fixed)break;\n        this.coords.p_to_real=this.convertToRealPercent(a);this.coords.p_to_real=this.calcWithStep(this.coords.p_to_real);this.coords.p_to_real<this.coords.p_from_real&&(this.coords.p_to_real=this.coords.p_from_real);this.coords.p_to_real=this.checkDiapason(this.coords.p_to_real,this.options.to_min,this.options.to_max);this.coords.p_to_real=this.checkMinInterval(this.coords.p_to_real,this.coords.p_from_real,\"to\");this.coords.p_to_real=this.checkMaxInterval(this.coords.p_to_real,this.coords.p_from_real,\"to\");\n        this.coords.p_to_fake=this.convertToFakePercent(this.coords.p_to_real);break;case \"both\":if(this.options.from_fixed||this.options.to_fixed)break;a=this.toFixed(a+.001*this.coords.p_handle);this.coords.p_from_real=this.convertToRealPercent(a)-this.coords.p_gap_left;this.coords.p_from_real=this.calcWithStep(this.coords.p_from_real);this.coords.p_from_real=this.checkDiapason(this.coords.p_from_real,this.options.from_min,this.options.from_max);this.coords.p_from_real=this.checkMinInterval(this.coords.p_from_real,\n        this.coords.p_to_real,\"from\");this.coords.p_from_fake=this.convertToFakePercent(this.coords.p_from_real);this.coords.p_to_real=this.convertToRealPercent(a)+this.coords.p_gap_right;this.coords.p_to_real=this.calcWithStep(this.coords.p_to_real);this.coords.p_to_real=this.checkDiapason(this.coords.p_to_real,this.options.to_min,this.options.to_max);this.coords.p_to_real=this.checkMinInterval(this.coords.p_to_real,this.coords.p_from_real,\"to\");this.coords.p_to_fake=this.convertToFakePercent(this.coords.p_to_real);\n        break;case \"both_one\":if(!this.options.from_fixed&&!this.options.to_fixed){var d=this.convertToRealPercent(a);a=this.result.to_percent-this.result.from_percent;var c=a/2,b=d-c,d=d+c;0>b&&(b=0,d=b+a);100<d&&(d=100,b=d-a);this.coords.p_from_real=this.calcWithStep(b);this.coords.p_from_real=this.checkDiapason(this.coords.p_from_real,this.options.from_min,this.options.from_max);this.coords.p_from_fake=this.convertToFakePercent(this.coords.p_from_real);this.coords.p_to_real=this.calcWithStep(d);this.coords.p_to_real=\n        this.checkDiapason(this.coords.p_to_real,this.options.to_min,this.options.to_max);this.coords.p_to_fake=this.convertToFakePercent(this.coords.p_to_real)}}\"single\"===this.options.type?(this.coords.p_bar_x=this.coords.p_handle/2,this.coords.p_bar_w=this.coords.p_single_fake,this.result.from_percent=this.coords.p_single_real,this.result.from=this.convertToValue(this.coords.p_single_real),this.options.values.length&&(this.result.from_value=this.options.values[this.result.from])):(this.coords.p_bar_x=\n        this.toFixed(this.coords.p_from_fake+this.coords.p_handle/2),this.coords.p_bar_w=this.toFixed(this.coords.p_to_fake-this.coords.p_from_fake),this.result.from_percent=this.coords.p_from_real,this.result.from=this.convertToValue(this.coords.p_from_real),this.result.to_percent=this.coords.p_to_real,this.result.to=this.convertToValue(this.coords.p_to_real),this.options.values.length&&(this.result.from_value=this.options.values[this.result.from],this.result.to_value=this.options.values[this.result.to]));\n        this.calcMinMax();this.calcLabels()}}},calcPointerPercent:function(){this.coords.w_rs?(0>this.coords.x_pointer||isNaN(this.coords.x_pointer)?this.coords.x_pointer=0:this.coords.x_pointer>this.coords.w_rs&&(this.coords.x_pointer=this.coords.w_rs),this.coords.p_pointer=this.toFixed(this.coords.x_pointer/this.coords.w_rs*100)):this.coords.p_pointer=0},convertToRealPercent:function(a){return a/(100-this.coords.p_handle)*100},convertToFakePercent:function(a){return a/100*(100-this.coords.p_handle)},getHandleX:function(){var a=\n        100-this.coords.p_handle,b=this.toFixed(this.coords.p_pointer-this.coords.p_gap);0>b?b=0:b>a&&(b=a);return b},calcHandlePercent:function(){this.coords.w_handle=\"single\"===this.options.type?this.$cache.s_single.outerWidth(!1):this.$cache.s_from.outerWidth(!1);this.coords.p_handle=this.toFixed(this.coords.w_handle/this.coords.w_rs*100)},chooseHandle:function(a){return\"single\"===this.options.type?\"single\":a>=this.coords.p_from_real+(this.coords.p_to_real-this.coords.p_from_real)/2?this.options.to_fixed?\n        \"from\":\"to\":this.options.from_fixed?\"to\":\"from\"},calcMinMax:function(){this.coords.w_rs&&(this.labels.p_min=this.labels.w_min/this.coords.w_rs*100,this.labels.p_max=this.labels.w_max/this.coords.w_rs*100)},calcLabels:function(){this.coords.w_rs&&!this.options.hide_from_to&&(\"single\"===this.options.type?(this.labels.w_single=this.$cache.single.outerWidth(!1),this.labels.p_single_fake=this.labels.w_single/this.coords.w_rs*100,this.labels.p_single_left=this.coords.p_single_fake+this.coords.p_handle/\n        2-this.labels.p_single_fake/2):(this.labels.w_from=this.$cache.from.outerWidth(!1),this.labels.p_from_fake=this.labels.w_from/this.coords.w_rs*100,this.labels.p_from_left=this.coords.p_from_fake+this.coords.p_handle/2-this.labels.p_from_fake/2,this.labels.p_from_left=this.toFixed(this.labels.p_from_left),this.labels.p_from_left=this.checkEdges(this.labels.p_from_left,this.labels.p_from_fake),this.labels.w_to=this.$cache.to.outerWidth(!1),this.labels.p_to_fake=this.labels.w_to/this.coords.w_rs*100,\n        this.labels.p_to_left=this.coords.p_to_fake+this.coords.p_handle/2-this.labels.p_to_fake/2,this.labels.p_to_left=this.toFixed(this.labels.p_to_left),this.labels.p_to_left=this.checkEdges(this.labels.p_to_left,this.labels.p_to_fake),this.labels.w_single=this.$cache.single.outerWidth(!1),this.labels.p_single_fake=this.labels.w_single/this.coords.w_rs*100,this.labels.p_single_left=(this.labels.p_from_left+this.labels.p_to_left+this.labels.p_to_fake)/2-this.labels.p_single_fake/2,this.labels.p_single_left=\n        this.toFixed(this.labels.p_single_left)),this.labels.p_single_left=this.checkEdges(this.labels.p_single_left,this.labels.p_single_fake))},updateScene:function(){this.raf_id&&(cancelAnimationFrame(this.raf_id),this.raf_id=null);clearTimeout(this.update_tm);this.update_tm=null;this.options&&(this.drawHandles(),this.is_active?this.raf_id=requestAnimationFrame(this.updateScene.bind(this)):this.update_tm=setTimeout(this.updateScene.bind(this),300))},drawHandles:function(){this.coords.w_rs=this.$cache.rs.outerWidth(!1);\n        if(this.coords.w_rs){this.coords.w_rs!==this.coords.w_rs_old&&(this.target=\"base\",this.is_resize=!0);if(this.coords.w_rs!==this.coords.w_rs_old||this.force_redraw)this.setMinMax(),this.calc(!0),this.drawLabels(),this.options.grid&&(this.calcGridMargin(),this.calcGridLabels()),this.force_redraw=!0,this.coords.w_rs_old=this.coords.w_rs,this.drawShadow();if(this.coords.w_rs&&(this.dragging||this.force_redraw||this.is_key)){if(this.old_from!==this.result.from||this.old_to!==this.result.to||this.force_redraw||\n            this.is_key){this.drawLabels();this.$cache.bar[0].style.left=this.coords.p_bar_x+\"%\";this.$cache.bar[0].style.width=this.coords.p_bar_w+\"%\";if(\"single\"===this.options.type)this.$cache.s_single[0].style.left=this.coords.p_single_fake+\"%\";else{this.$cache.s_from[0].style.left=this.coords.p_from_fake+\"%\";this.$cache.s_to[0].style.left=this.coords.p_to_fake+\"%\";if(this.old_from!==this.result.from||this.force_redraw)this.$cache.from[0].style.left=this.labels.p_from_left+\"%\";if(this.old_to!==this.result.to||\n            this.force_redraw)this.$cache.to[0].style.left=this.labels.p_to_left+\"%\"}this.$cache.single[0].style.left=this.labels.p_single_left+\"%\";this.writeToInput();this.old_from===this.result.from&&this.old_to===this.result.to||this.is_start||(this.$cache.input.trigger(\"change\"),this.$cache.input.trigger(\"input\"));this.old_from=this.result.from;this.old_to=this.result.to;this.is_resize||this.is_update||this.is_start||this.is_finish||this.callOnChange();if(this.is_key||this.is_click||this.is_first_update)this.is_first_update=\n            this.is_click=this.is_key=!1,this.callOnFinish();this.is_finish=this.is_resize=this.is_update=!1}this.force_redraw=this.is_click=this.is_key=this.is_start=!1}}},drawLabels:function(){if(this.options){var a=this.options.values.length,b=this.options.p_values,d;if(!this.options.hide_from_to)if(\"single\"===this.options.type)a=a?this.decorate(b[this.result.from]):this.decorate(this._prettify(this.result.from),this.result.from),this.$cache.single.html(a),this.calcLabels(),this.$cache.min[0].style.visibility=\n        this.labels.p_single_left<this.labels.p_min+1?\"hidden\":\"visible\",this.$cache.max[0].style.visibility=this.labels.p_single_left+this.labels.p_single_fake>100-this.labels.p_max-1?\"hidden\":\"visible\";else{a?(this.options.decorate_both?(a=this.decorate(b[this.result.from]),a+=this.options.values_separator,a+=this.decorate(b[this.result.to])):a=this.decorate(b[this.result.from]+this.options.values_separator+b[this.result.to]),d=this.decorate(b[this.result.from]),b=this.decorate(b[this.result.to])):(this.options.decorate_both?\n        (a=this.decorate(this._prettify(this.result.from),this.result.from),a+=this.options.values_separator,a+=this.decorate(this._prettify(this.result.to),this.result.to)):a=this.decorate(this._prettify(this.result.from)+this.options.values_separator+this._prettify(this.result.to),this.result.to),d=this.decorate(this._prettify(this.result.from),this.result.from),b=this.decorate(this._prettify(this.result.to),this.result.to));this.$cache.single.html(a);this.$cache.from.html(d);this.$cache.to.html(b);this.calcLabels();\n        b=Math.min(this.labels.p_single_left,this.labels.p_from_left);a=this.labels.p_single_left+this.labels.p_single_fake;d=this.labels.p_to_left+this.labels.p_to_fake;var c=Math.max(a,d);this.labels.p_from_left+this.labels.p_from_fake>=this.labels.p_to_left?(this.$cache.from[0].style.visibility=\"hidden\",this.$cache.to[0].style.visibility=\"hidden\",this.$cache.single[0].style.visibility=\"visible\",this.result.from===this.result.to?(\"from\"===this.target?this.$cache.from[0].style.visibility=\"visible\":\"to\"===\n        this.target?this.$cache.to[0].style.visibility=\"visible\":this.target||(this.$cache.from[0].style.visibility=\"visible\"),this.$cache.single[0].style.visibility=\"hidden\",c=d):(this.$cache.from[0].style.visibility=\"hidden\",this.$cache.to[0].style.visibility=\"hidden\",this.$cache.single[0].style.visibility=\"visible\",c=Math.max(a,d))):(this.$cache.from[0].style.visibility=\"visible\",this.$cache.to[0].style.visibility=\"visible\",this.$cache.single[0].style.visibility=\"hidden\");this.$cache.min[0].style.visibility=\n            b<this.labels.p_min+1?\"hidden\":\"visible\";this.$cache.max[0].style.visibility=c>100-this.labels.p_max-1?\"hidden\":\"visible\"}}},drawShadow:function(){var a=this.options,b=this.$cache,d=\"number\"===typeof a.from_min&&!isNaN(a.from_min),c=\"number\"===typeof a.from_max&&!isNaN(a.from_max),e=\"number\"===typeof a.to_min&&!isNaN(a.to_min),g=\"number\"===typeof a.to_max&&!isNaN(a.to_max);\"single\"===a.type?a.from_shadow&&(d||c)?(d=this.convertToPercent(d?a.from_min:a.min),c=this.convertToPercent(c?a.from_max:a.max)-\n        d,d=this.toFixed(d-this.coords.p_handle/100*d),c=this.toFixed(c-this.coords.p_handle/100*c),d+=this.coords.p_handle/2,b.shad_single[0].style.display=\"block\",b.shad_single[0].style.left=d+\"%\",b.shad_single[0].style.width=c+\"%\"):b.shad_single[0].style.display=\"none\":(a.from_shadow&&(d||c)?(d=this.convertToPercent(d?a.from_min:a.min),c=this.convertToPercent(c?a.from_max:a.max)-d,d=this.toFixed(d-this.coords.p_handle/100*d),c=this.toFixed(c-this.coords.p_handle/100*c),d+=this.coords.p_handle/2,b.shad_from[0].style.display=\n        \"block\",b.shad_from[0].style.left=d+\"%\",b.shad_from[0].style.width=c+\"%\"):b.shad_from[0].style.display=\"none\",a.to_shadow&&(e||g)?(e=this.convertToPercent(e?a.to_min:a.min),a=this.convertToPercent(g?a.to_max:a.max)-e,e=this.toFixed(e-this.coords.p_handle/100*e),a=this.toFixed(a-this.coords.p_handle/100*a),e+=this.coords.p_handle/2,b.shad_to[0].style.display=\"block\",b.shad_to[0].style.left=e+\"%\",b.shad_to[0].style.width=a+\"%\"):b.shad_to[0].style.display=\"none\")},writeToInput:function(){\"single\"===\n    this.options.type?(this.options.values.length?this.$cache.input.prop(\"value\",this.result.from_value):this.$cache.input.prop(\"value\",this.result.from),this.$cache.input.data(\"from\",this.result.from)):(this.options.values.length?this.$cache.input.prop(\"value\",this.result.from_value+this.options.input_values_separator+this.result.to_value):this.$cache.input.prop(\"value\",this.result.from+this.options.input_values_separator+this.result.to),this.$cache.input.data(\"from\",this.result.from),this.$cache.input.data(\"to\",\n        this.result.to))},callOnStart:function(){this.writeToInput();if(this.options.onStart&&\"function\"===typeof this.options.onStart)this.options.onStart(this.result)},callOnChange:function(){this.writeToInput();if(this.options.onChange&&\"function\"===typeof this.options.onChange)this.options.onChange(this.result)},callOnFinish:function(){this.writeToInput();if(this.options.onFinish&&\"function\"===typeof this.options.onFinish)this.options.onFinish(this.result)},callOnUpdate:function(){this.writeToInput();\n        if(this.options.onUpdate&&\"function\"===typeof this.options.onUpdate)this.options.onUpdate(this.result)},toggleInput:function(){this.$cache.input.toggleClass(\"irs-hidden-input\")},convertToPercent:function(a,b){var d=this.options.max-this.options.min;return d?this.toFixed((b?a:a-this.options.min)/(d/100)):(this.no_diapason=!0,0)},convertToValue:function(a){var b=this.options.min,d=this.options.max,c=b.toString().split(\".\")[1],e=d.toString().split(\".\")[1],g,l,f=0,k=0;if(0===a)return this.options.min;\n        if(100===a)return this.options.max;c&&(f=g=c.length);e&&(f=l=e.length);g&&l&&(f=g>=l?g:l);0>b&&(k=Math.abs(b),b=+(b+k).toFixed(f),d=+(d+k).toFixed(f));a=(d-b)/100*a+b;(b=this.options.step.toString().split(\".\")[1])?a=+a.toFixed(b.length):(a/=this.options.step,a*=this.options.step,a=+a.toFixed(0));k&&(a-=k);k=b?+a.toFixed(b.length):this.toFixed(a);k<this.options.min?k=this.options.min:k>this.options.max&&(k=this.options.max);return k},calcWithStep:function(a){var b=Math.round(a/this.coords.p_step)*\n        this.coords.p_step;100<b&&(b=100);100===a&&(b=100);return this.toFixed(b)},checkMinInterval:function(a,b,d){var c=this.options;if(!c.min_interval)return a;a=this.convertToValue(a);b=this.convertToValue(b);\"from\"===d?b-a<c.min_interval&&(a=b-c.min_interval):a-b<c.min_interval&&(a=b+c.min_interval);return this.convertToPercent(a)},checkMaxInterval:function(a,b,d){var c=this.options;if(!c.max_interval)return a;a=this.convertToValue(a);b=this.convertToValue(b);\"from\"===d?b-a>c.max_interval&&(a=b-c.max_interval):\n        a-b>c.max_interval&&(a=b+c.max_interval);return this.convertToPercent(a)},checkDiapason:function(a,b,d){a=this.convertToValue(a);var c=this.options;\"number\"!==typeof b&&(b=c.min);\"number\"!==typeof d&&(d=c.max);a<b&&(a=b);a>d&&(a=d);return this.convertToPercent(a)},toFixed:function(a){a=a.toFixed(20);return+a},_prettify:function(a){return this.options.prettify_enabled?this.options.prettify&&\"function\"===typeof this.options.prettify?this.options.prettify(a):this.prettify(a):a},prettify:function(a){return a.toString().replace(/(\\d{1,3}(?=(?:\\d\\d\\d)+(?!\\d)))/g,\n        \"$1\"+this.options.prettify_separator)},checkEdges:function(a,b){if(!this.options.force_edges)return this.toFixed(a);0>a?a=0:a>100-b&&(a=100-b);return this.toFixed(a)},validate:function(){var a=this.options,b=this.result,d=a.values,c=d.length,e,g;\"string\"===typeof a.min&&(a.min=+a.min);\"string\"===typeof a.max&&(a.max=+a.max);\"string\"===typeof a.from&&(a.from=+a.from);\"string\"===typeof a.to&&(a.to=+a.to);\"string\"===typeof a.step&&(a.step=+a.step);\"string\"===typeof a.from_min&&(a.from_min=+a.from_min);\n        \"string\"===typeof a.from_max&&(a.from_max=+a.from_max);\"string\"===typeof a.to_min&&(a.to_min=+a.to_min);\"string\"===typeof a.to_max&&(a.to_max=+a.to_max);\"string\"===typeof a.keyboard_step&&(a.keyboard_step=+a.keyboard_step);\"string\"===typeof a.grid_num&&(a.grid_num=+a.grid_num);a.max<a.min&&(a.max=a.min);if(c)for(a.p_values=[],a.min=0,a.max=c-1,a.step=1,a.grid_num=a.max,a.grid_snap=!0,g=0;g<c;g++)e=+d[g],isNaN(e)?e=d[g]:(d[g]=e,e=this._prettify(e)),a.p_values.push(e);if(\"number\"!==typeof a.from||isNaN(a.from))a.from=\n            a.min;if(\"number\"!==typeof a.to||isNaN(a.to))a.to=a.max;\"single\"===a.type?(a.from<a.min&&(a.from=a.min),a.from>a.max&&(a.from=a.max)):(a.from<a.min&&(a.from=a.min),a.from>a.max&&(a.from=a.max),a.to<a.min&&(a.to=a.min),a.to>a.max&&(a.to=a.max),this.update_check.from&&(this.update_check.from!==a.from&&a.from>a.to&&(a.from=a.to),this.update_check.to!==a.to&&a.to<a.from&&(a.to=a.from)),a.from>a.to&&(a.from=a.to),a.to<a.from&&(a.to=a.from));if(\"number\"!==typeof a.step||isNaN(a.step)||!a.step||0>a.step)a.step=\n            1;if(\"number\"!==typeof a.keyboard_step||isNaN(a.keyboard_step)||!a.keyboard_step||0>a.keyboard_step)a.keyboard_step=5;\"number\"===typeof a.from_min&&a.from<a.from_min&&(a.from=a.from_min);\"number\"===typeof a.from_max&&a.from>a.from_max&&(a.from=a.from_max);\"number\"===typeof a.to_min&&a.to<a.to_min&&(a.to=a.to_min);\"number\"===typeof a.to_max&&a.from>a.to_max&&(a.to=a.to_max);if(b){b.min!==a.min&&(b.min=a.min);b.max!==a.max&&(b.max=a.max);if(b.from<b.min||b.from>b.max)b.from=a.from;if(b.to<b.min||b.to>\n            b.max)b.to=a.to}if(\"number\"!==typeof a.min_interval||isNaN(a.min_interval)||!a.min_interval||0>a.min_interval)a.min_interval=0;if(\"number\"!==typeof a.max_interval||isNaN(a.max_interval)||!a.max_interval||0>a.max_interval)a.max_interval=0;a.min_interval&&a.min_interval>a.max-a.min&&(a.min_interval=a.max-a.min);a.max_interval&&a.max_interval>a.max-a.min&&(a.max_interval=a.max-a.min)},decorate:function(a,b){var d=\"\",c=this.options;c.prefix&&(d+=c.prefix);d+=a;c.max_postfix&&(c.values.length&&a===c.p_values[c.max]?\n        (d+=c.max_postfix,c.postfix&&(d+=\" \")):b===c.max&&(d+=c.max_postfix,c.postfix&&(d+=\" \")));c.postfix&&(d+=c.postfix);return d},updateFrom:function(){this.result.from=this.options.from;this.result.from_percent=this.convertToPercent(this.result.from);this.options.values&&(this.result.from_value=this.options.values[this.result.from])},updateTo:function(){this.result.to=this.options.to;this.result.to_percent=this.convertToPercent(this.result.to);this.options.values&&(this.result.to_value=this.options.values[this.result.to])},\n    updateResult:function(){this.result.min=this.options.min;this.result.max=this.options.max;this.updateFrom();this.updateTo()},appendGrid:function(){if(this.options.grid){var a=this.options,b,d;b=a.max-a.min;var c=a.grid_num,e,g,f=4,h,k,m,n=\"\";this.calcGridMargin();a.grid_snap?(c=b/a.step,e=this.toFixed(a.step/(b/100))):e=this.toFixed(100/c);4<c&&(f=3);7<c&&(f=2);14<c&&(f=1);28<c&&(f=0);for(b=0;b<c+1;b++){h=f;g=this.toFixed(e*b);100<g&&(g=100,h-=2,0>h&&(h=0));this.coords.big[b]=g;k=(g-e*(b-1))/(h+1);\n        for(d=1;d<=h&&0!==g;d++)m=this.toFixed(g-k*d),n+='<span class=\"irs-grid-pol small\" style=\"left: '+m+'%\"></span>';n+='<span class=\"irs-grid-pol\" style=\"left: '+g+'%\"></span>';d=this.convertToValue(g);d=a.values.length?a.p_values[d]:this._prettify(d);n+='<span class=\"irs-grid-text js-grid-text-'+b+'\" style=\"left: '+g+'%\">'+d+\"</span>\"}this.coords.big_num=Math.ceil(c+1);this.$cache.cont.addClass(\"irs-with-grid\");this.$cache.grid.html(n);this.cacheGridLabels()}},cacheGridLabels:function(){var a,b,d=this.coords.big_num;\n        for(b=0;b<d;b++)a=this.$cache.grid.find(\".js-grid-text-\"+b),this.$cache.grid_labels.push(a);this.calcGridLabels()},calcGridLabels:function(){var a,b;b=[];var d=[],c=this.coords.big_num;for(a=0;a<c;a++)this.coords.big_w[a]=this.$cache.grid_labels[a].outerWidth(!1),this.coords.big_p[a]=this.toFixed(this.coords.big_w[a]/this.coords.w_rs*100),this.coords.big_x[a]=this.toFixed(this.coords.big_p[a]/2),b[a]=this.toFixed(this.coords.big[a]-this.coords.big_x[a]),d[a]=this.toFixed(b[a]+this.coords.big_p[a]);\n        this.options.force_edges&&(b[0]<-this.coords.grid_gap&&(b[0]=-this.coords.grid_gap,d[0]=this.toFixed(b[0]+this.coords.big_p[0]),this.coords.big_x[0]=this.coords.grid_gap),d[c-1]>100+this.coords.grid_gap&&(d[c-1]=100+this.coords.grid_gap,b[c-1]=this.toFixed(d[c-1]-this.coords.big_p[c-1]),this.coords.big_x[c-1]=this.toFixed(this.coords.big_p[c-1]-this.coords.grid_gap)));this.calcGridCollision(2,b,d);this.calcGridCollision(4,b,d);for(a=0;a<c;a++)b=this.$cache.grid_labels[a][0],this.coords.big_x[a]!==\n        Number.POSITIVE_INFINITY&&(b.style.marginLeft=-this.coords.big_x[a]+\"%\")},calcGridCollision:function(a,b,d){var c,e,g,f=this.coords.big_num;for(c=0;c<f;c+=a){e=c+a/2;if(e>=f)break;g=this.$cache.grid_labels[e][0];g.style.visibility=d[c]<=b[e]?\"visible\":\"hidden\"}},calcGridMargin:function(){this.options.grid_margin&&(this.coords.w_rs=this.$cache.rs.outerWidth(!1),this.coords.w_rs&&(this.coords.w_handle=\"single\"===this.options.type?this.$cache.s_single.outerWidth(!1):this.$cache.s_from.outerWidth(!1),\n        this.coords.p_handle=this.toFixed(this.coords.w_handle/this.coords.w_rs*100),this.coords.grid_gap=this.toFixed(this.coords.p_handle/2-.1),this.$cache.grid[0].style.width=this.toFixed(100-this.coords.p_handle)+\"%\",this.$cache.grid[0].style.left=this.coords.grid_gap+\"%\"))},update:function(a){this.input&&(this.is_update=!0,this.options.from=this.result.from,this.options.to=this.result.to,this.update_check.from=this.result.from,this.update_check.to=this.result.to,this.options=f.extend(this.options,a),\n        this.validate(),this.updateResult(a),this.toggleInput(),this.remove(),this.init(!0))},reset:function(){this.input&&(this.updateResult(),this.update())},destroy:function(){this.input&&(this.toggleInput(),this.$cache.input.prop(\"readonly\",!1),f.data(this.input,\"ionRangeSlider\",null),this.remove(),this.options=this.input=null)}};f.fn.ionRangeSlider=function(a){return this.each(function(){f.data(this,\"ionRangeSlider\")||f.data(this,\"ionRangeSlider\",new r(this,a,u++))})};(function(){for(var a=0,b=[\"ms\",\n    \"moz\",\"webkit\",\"o\"],d=0;d<b.length&&!h.requestAnimationFrame;++d)h.requestAnimationFrame=h[b[d]+\"RequestAnimationFrame\"],h.cancelAnimationFrame=h[b[d]+\"CancelAnimationFrame\"]||h[b[d]+\"CancelRequestAnimationFrame\"];h.requestAnimationFrame||(h.requestAnimationFrame=function(b,d){var c=(new Date).getTime(),e=Math.max(0,16-(c-a)),f=h.setTimeout(function(){b(c+e)},e);a=c+e;return f});h.cancelAnimationFrame||(h.cancelAnimationFrame=function(a){clearTimeout(a)})})()});\n","Mageplaza_Core/js/jquery.magnific-popup.min.js":"// Magnific Popup v1.1.0 by Dmitry Semenov\n// http://bit.ly/magnific-popup#build=inline+image+ajax+iframe+gallery+retina+imagezoom\n(function(a){typeof define==\"function\"&&define.amd?define([\"jquery\"],a):typeof exports==\"object\"?a(require(\"jquery\")):a(window.jQuery||window.Zepto)})(function(a){var b=\"Close\",c=\"BeforeClose\",d=\"AfterClose\",e=\"BeforeAppend\",f=\"MarkupParse\",g=\"Open\",h=\"Change\",i=\"mfp\",j=\".\"+i,k=\"mfp-ready\",l=\"mfp-removing\",m=\"mfp-prevent-close\",n,o=function(){},p=!!window.jQuery,q,r=a(window),s,t,u,v,w=function(a,b){n.ev.on(i+a+j,b)},x=function(b,c,d,e){var f=document.createElement(\"div\");return f.className=\"mfp-\"+b,d&&(f.innerHTML=d),e?c&&c.appendChild(f):(f=a(f),c&&f.appendTo(c)),f},y=function(b,c){n.ev.triggerHandler(i+b,c),n.st.callbacks&&(b=b.charAt(0).toLowerCase()+b.slice(1),n.st.callbacks[b]&&n.st.callbacks[b].apply(n,a.isArray(c)?c:[c]))},z=function(b){if(b!==v||!n.currTemplate.closeBtn)n.currTemplate.closeBtn=a(n.st.closeMarkup.replace(\"%title%\",n.st.tClose)),v=b;return n.currTemplate.closeBtn},A=function(){a.magnificPopup.instance||(n=new o,n.init(),a.magnificPopup.instance=n)},B=function(){var a=document.createElement(\"p\").style,b=[\"ms\",\"O\",\"Moz\",\"Webkit\"];if(a.transition!==undefined)return!0;while(b.length)if(b.pop()+\"Transition\"in a)return!0;return!1};o.prototype={constructor:o,init:function(){var b=navigator.appVersion;n.isLowIE=n.isIE8=document.all&&!document.addEventListener,n.isAndroid=/android/gi.test(b),n.isIOS=/iphone|ipad|ipod/gi.test(b),n.supportsTransition=B(),n.probablyMobile=n.isAndroid||n.isIOS||/(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent),s=a(document),n.popupsCache={}},open:function(b){var c;if(b.isObj===!1){n.items=b.items.toArray(),n.index=0;var d=b.items,e;for(c=0;c<d.length;c++){e=d[c],e.parsed&&(e=e.el[0]);if(e===b.el[0]){n.index=c;break}}}else n.items=a.isArray(b.items)?b.items:[b.items],n.index=b.index||0;if(n.isOpen){n.updateItemHTML();return}n.types=[],u=\"\",b.mainEl&&b.mainEl.length?n.ev=b.mainEl.eq(0):n.ev=s,b.key?(n.popupsCache[b.key]||(n.popupsCache[b.key]={}),n.currTemplate=n.popupsCache[b.key]):n.currTemplate={},n.st=a.extend(!0,{},a.magnificPopup.defaults,b),n.fixedContentPos=n.st.fixedContentPos===\"auto\"?!n.probablyMobile:n.st.fixedContentPos,n.st.modal&&(n.st.closeOnContentClick=!1,n.st.closeOnBgClick=!1,n.st.showCloseBtn=!1,n.st.enableEscapeKey=!1),n.bgOverlay||(n.bgOverlay=x(\"bg\").on(\"click\"+j,function(){n.close()}),n.wrap=x(\"wrap\").attr(\"tabindex\",-1).on(\"click\"+j,function(a){n._checkIfClose(a.target)&&n.close()}),n.container=x(\"container\",n.wrap)),n.contentContainer=x(\"content\"),n.st.preloader&&(n.preloader=x(\"preloader\",n.container,n.st.tLoading));var h=a.magnificPopup.modules;for(c=0;c<h.length;c++){var i=h[c];i=i.charAt(0).toUpperCase()+i.slice(1),n[\"init\"+i].call(n)}y(\"BeforeOpen\"),n.st.showCloseBtn&&(n.st.closeBtnInside?(w(f,function(a,b,c,d){c.close_replaceWith=z(d.type)}),u+=\" mfp-close-btn-in\"):n.wrap.append(z())),n.st.alignTop&&(u+=\" mfp-align-top\"),n.fixedContentPos?n.wrap.css({overflow:n.st.overflowY,overflowX:\"hidden\",overflowY:n.st.overflowY}):n.wrap.css({top:r.scrollTop(),position:\"absolute\"}),(n.st.fixedBgPos===!1||n.st.fixedBgPos===\"auto\"&&!n.fixedContentPos)&&n.bgOverlay.css({height:s.height(),position:\"absolute\"}),n.st.enableEscapeKey&&s.on(\"keyup\"+j,function(a){a.keyCode===27&&n.close()}),r.on(\"resize\"+j,function(){n.updateSize()}),n.st.closeOnContentClick||(u+=\" mfp-auto-cursor\"),u&&n.wrap.addClass(u);var l=n.wH=r.height(),m={};if(n.fixedContentPos&&n._hasScrollBar(l)){var o=n._getScrollbarSize();o&&(m.marginRight=o)}n.fixedContentPos&&(n.isIE7?a(\"body, html\").css(\"overflow\",\"hidden\"):m.overflow=\"hidden\");var p=n.st.mainClass;return n.isIE7&&(p+=\" mfp-ie7\"),p&&n._addClassToMFP(p),n.updateItemHTML(),y(\"BuildControls\"),a(\"html\").css(m),n.bgOverlay.add(n.wrap).prependTo(n.st.prependTo||a(document.body)),n._lastFocusedEl=document.activeElement,setTimeout(function(){n.content?(n._addClassToMFP(k),n._setFocus()):n.bgOverlay.addClass(k),s.on(\"focusin\"+j,n._onFocusIn)},16),n.isOpen=!0,n.updateSize(l),y(g),b},close:function(){if(!n.isOpen)return;y(c),n.isOpen=!1,n.st.removalDelay&&!n.isLowIE&&n.supportsTransition?(n._addClassToMFP(l),setTimeout(function(){n._close()},n.st.removalDelay)):n._close()},_close:function(){y(b);var c=l+\" \"+k+\" \";n.bgOverlay.detach(),n.wrap.detach(),n.container.empty(),n.st.mainClass&&(c+=n.st.mainClass+\" \"),n._removeClassFromMFP(c);if(n.fixedContentPos){var e={marginRight:\"\"};n.isIE7?a(\"body, html\").css(\"overflow\",\"\"):e.overflow=\"\",a(\"html\").css(e)}s.off(\"keyup\"+j+\" focusin\"+j),n.ev.off(j),n.wrap.attr(\"class\",\"mfp-wrap\").removeAttr(\"style\"),n.bgOverlay.attr(\"class\",\"mfp-bg\"),n.container.attr(\"class\",\"mfp-container\"),n.st.showCloseBtn&&(!n.st.closeBtnInside||n.currTemplate[n.currItem.type]===!0)&&n.currTemplate.closeBtn&&n.currTemplate.closeBtn.detach(),n.st.autoFocusLast&&n._lastFocusedEl&&a(n._lastFocusedEl).focus(),n.currItem=null,n.content=null,n.currTemplate=null,n.prevHeight=0,y(d)},updateSize:function(a){if(n.isIOS){var b=document.documentElement.clientWidth/window.innerWidth,c=window.innerHeight*b;n.wrap.css(\"height\",c),n.wH=c}else n.wH=a||r.height();n.fixedContentPos||n.wrap.css(\"height\",n.wH),y(\"Resize\")},updateItemHTML:function(){var b=n.items[n.index];n.contentContainer.detach(),n.content&&n.content.detach(),b.parsed||(b=n.parseEl(n.index));var c=b.type;y(\"BeforeChange\",[n.currItem?n.currItem.type:\"\",c]),n.currItem=b;if(!n.currTemplate[c]){var d=n.st[c]?n.st[c].markup:!1;y(\"FirstMarkupParse\",d),d?n.currTemplate[c]=a(d):n.currTemplate[c]=!0}t&&t!==b.type&&n.container.removeClass(\"mfp-\"+t+\"-holder\");var e=n[\"get\"+c.charAt(0).toUpperCase()+c.slice(1)](b,n.currTemplate[c]);n.appendContent(e,c),b.preloaded=!0,y(h,b),t=b.type,n.container.prepend(n.contentContainer),y(\"AfterChange\")},appendContent:function(a,b){n.content=a,a?n.st.showCloseBtn&&n.st.closeBtnInside&&n.currTemplate[b]===!0?n.content.find(\".mfp-close\").length||n.content.append(z()):n.content=a:n.content=\"\",y(e),n.container.addClass(\"mfp-\"+b+\"-holder\"),n.contentContainer.append(n.content)},parseEl:function(b){var c=n.items[b],d;c.tagName?c={el:a(c)}:(d=c.type,c={data:c,src:c.src});if(c.el){var e=n.types;for(var f=0;f<e.length;f++)if(c.el.hasClass(\"mfp-\"+e[f])){d=e[f];break}c.src=c.el.attr(\"data-mfp-src\"),c.src||(c.src=c.el.attr(\"href\"))}return c.type=d||n.st.type||\"inline\",c.index=b,c.parsed=!0,n.items[b]=c,y(\"ElementParse\",c),n.items[b]},addGroup:function(a,b){var c=function(c){c.mfpEl=this,n._openClick(c,a,b)};b||(b={});var d=\"click.magnificPopup\";b.mainEl=a,b.items?(b.isObj=!0,a.off(d).on(d,c)):(b.isObj=!1,b.delegate?a.off(d).on(d,b.delegate,c):(b.items=a,a.off(d).on(d,c)))},_openClick:function(b,c,d){var e=d.midClick!==undefined?d.midClick:a.magnificPopup.defaults.midClick;if(!e&&(b.which===2||b.ctrlKey||b.metaKey||b.altKey||b.shiftKey))return;var f=d.disableOn!==undefined?d.disableOn:a.magnificPopup.defaults.disableOn;if(f)if(a.isFunction(f)){if(!f.call(n))return!0}else if(r.width()<f)return!0;b.type&&(b.preventDefault(),n.isOpen&&b.stopPropagation()),d.el=a(b.mfpEl),d.delegate&&(d.items=c.find(d.delegate)),n.open(d)},updateStatus:function(a,b){if(n.preloader){q!==a&&n.container.removeClass(\"mfp-s-\"+q),!b&&a===\"loading\"&&(b=n.st.tLoading);var c={status:a,text:b};y(\"UpdateStatus\",c),a=c.status,b=c.text,n.preloader.html(b),n.preloader.find(\"a\").on(\"click\",function(a){a.stopImmediatePropagation()}),n.container.addClass(\"mfp-s-\"+a),q=a}},_checkIfClose:function(b){if(a(b).hasClass(m))return;var c=n.st.closeOnContentClick,d=n.st.closeOnBgClick;if(c&&d)return!0;if(!n.content||a(b).hasClass(\"mfp-close\")||n.preloader&&b===n.preloader[0])return!0;if(b!==n.content[0]&&!a.contains(n.content[0],b)){if(d&&a.contains(document,b))return!0}else if(c)return!0;return!1},_addClassToMFP:function(a){n.bgOverlay.addClass(a),n.wrap.addClass(a)},_removeClassFromMFP:function(a){this.bgOverlay.removeClass(a),n.wrap.removeClass(a)},_hasScrollBar:function(a){return(n.isIE7?s.height():document.body.scrollHeight)>(a||r.height())},_setFocus:function(){(n.st.focus?n.content.find(n.st.focus).eq(0):n.wrap).focus()},_onFocusIn:function(b){if(b.target!==n.wrap[0]&&!a.contains(n.wrap[0],b.target))return n._setFocus(),!1},_parseMarkup:function(b,c,d){var e;d.data&&(c=a.extend(d.data,c)),y(f,[b,c,d]),a.each(c,function(c,d){if(d===undefined||d===!1)return!0;e=c.split(\"_\");if(e.length>1){var f=b.find(j+\"-\"+e[0]);if(f.length>0){var g=e[1];g===\"replaceWith\"?f[0]!==d[0]&&f.replaceWith(d):g===\"img\"?f.is(\"img\")?f.attr(\"src\",d):f.replaceWith(a(\"<img>\").attr(\"src\",d).attr(\"class\",f.attr(\"class\"))):f.attr(e[1],d)}}else b.find(j+\"-\"+c).html(d)})},_getScrollbarSize:function(){if(n.scrollbarSize===undefined){var a=document.createElement(\"div\");a.style.cssText=\"width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;\",document.body.appendChild(a),n.scrollbarSize=a.offsetWidth-a.clientWidth,document.body.removeChild(a)}return n.scrollbarSize}},a.magnificPopup={instance:null,proto:o.prototype,modules:[],open:function(b,c){return A(),b?b=a.extend(!0,{},b):b={},b.isObj=!0,b.index=c||0,this.instance.open(b)},close:function(){return a.magnificPopup.instance&&a.magnificPopup.instance.close()},registerModule:function(b,c){c.options&&(a.magnificPopup.defaults[b]=c.options),a.extend(this.proto,c.proto),this.modules.push(b)},defaults:{disableOn:0,key:null,midClick:!1,mainClass:\"\",preloader:!0,focus:\"\",closeOnContentClick:!1,closeOnBgClick:!0,closeBtnInside:!0,showCloseBtn:!0,enableEscapeKey:!0,modal:!1,alignTop:!1,removalDelay:0,prependTo:null,fixedContentPos:\"auto\",fixedBgPos:\"auto\",overflowY:\"auto\",closeMarkup:'<button title=\"%title%\" type=\"button\" class=\"mfp-close\">&#215;</button>',tClose:\"Close (Esc)\",tLoading:\"Loading...\",autoFocusLast:!0}},a.fn.magnificPopup=function(b){A();var c=a(this);if(typeof b==\"string\")if(b===\"open\"){var d,e=p?c.data(\"magnificPopup\"):c[0].magnificPopup,f=parseInt(arguments[1],10)||0;e.items?d=e.items[f]:(d=c,e.delegate&&(d=d.find(e.delegate)),d=d.eq(f)),n._openClick({mfpEl:d},c,e)}else n.isOpen&&n[b].apply(n,Array.prototype.slice.call(arguments,1));else b=a.extend(!0,{},b),p?c.data(\"magnificPopup\",b):c[0].magnificPopup=b,n.addGroup(c,b);return c};var C=\"inline\",D,E,F,G=function(){F&&(E.after(F.addClass(D)).detach(),F=null)};a.magnificPopup.registerModule(C,{options:{hiddenClass:\"hide\",markup:\"\",tNotFound:\"Content not found\"},proto:{initInline:function(){n.types.push(C),w(b+\".\"+C,function(){G()})},getInline:function(b,c){G();if(b.src){var d=n.st.inline,e=a(b.src);if(e.length){var f=e[0].parentNode;f&&f.tagName&&(E||(D=d.hiddenClass,E=x(D),D=\"mfp-\"+D),F=e.after(E).detach().removeClass(D)),n.updateStatus(\"ready\")}else n.updateStatus(\"error\",d.tNotFound),e=a(\"<div>\");return b.inlineElement=e,e}return n.updateStatus(\"ready\"),n._parseMarkup(c,{},b),c}}});var H=\"ajax\",I,J=function(){I&&a(document.body).removeClass(I)},K=function(){J(),n.req&&n.req.abort()};a.magnificPopup.registerModule(H,{options:{settings:null,cursor:\"mfp-ajax-cur\",tError:'<a href=\"%url%\">The content</a> could not be loaded.'},proto:{initAjax:function(){n.types.push(H),I=n.st.ajax.cursor,w(b+\".\"+H,K),w(\"BeforeChange.\"+H,K)},getAjax:function(b){I&&a(document.body).addClass(I),n.updateStatus(\"loading\");var c=a.extend({url:b.src,success:function(c,d,e){var f={data:c,xhr:e};y(\"ParseAjax\",f),n.appendContent(a(f.data),H),b.finished=!0,J(),n._setFocus(),setTimeout(function(){n.wrap.addClass(k)},16),n.updateStatus(\"ready\"),y(\"AjaxContentAdded\")},error:function(){J(),b.finished=b.loadError=!0,n.updateStatus(\"error\",n.st.ajax.tError.replace(\"%url%\",b.src))}},n.st.ajax.settings);return n.req=a.ajax(c),\"\"}}});var L,M=function(b){if(b.data&&b.data.title!==undefined)return b.data.title;var c=n.st.image.titleSrc;if(c){if(a.isFunction(c))return c.call(n,b);if(b.el)return b.el.attr(c)||\"\"}return\"\"};a.magnificPopup.registerModule(\"image\",{options:{markup:'<div class=\"mfp-figure\"><div class=\"mfp-close\"></div><figure><div class=\"mfp-img\"></div><figcaption><div class=\"mfp-bottom-bar\"><div class=\"mfp-title\"></div><div class=\"mfp-counter\"></div></div></figcaption></figure></div>',cursor:\"mfp-zoom-out-cur\",titleSrc:\"title\",verticalFit:!0,tError:'<a href=\"%url%\">The image</a> could not be loaded.'},proto:{initImage:function(){var c=n.st.image,d=\".image\";n.types.push(\"image\"),w(g+d,function(){n.currItem.type===\"image\"&&c.cursor&&a(document.body).addClass(c.cursor)}),w(b+d,function(){c.cursor&&a(document.body).removeClass(c.cursor),r.off(\"resize\"+j)}),w(\"Resize\"+d,n.resizeImage),n.isLowIE&&w(\"AfterChange\",n.resizeImage)},resizeImage:function(){var a=n.currItem;if(!a||!a.img)return;if(n.st.image.verticalFit){var b=0;n.isLowIE&&(b=parseInt(a.img.css(\"padding-top\"),10)+parseInt(a.img.css(\"padding-bottom\"),10)),a.img.css(\"max-height\",n.wH-b)}},_onImageHasSize:function(a){a.img&&(a.hasSize=!0,L&&clearInterval(L),a.isCheckingImgSize=!1,y(\"ImageHasSize\",a),a.imgHidden&&(n.content&&n.content.removeClass(\"mfp-loading\"),a.imgHidden=!1))},findImageSize:function(a){var b=0,c=a.img[0],d=function(e){L&&clearInterval(L),L=setInterval(function(){if(c.naturalWidth>0){n._onImageHasSize(a);return}b>200&&clearInterval(L),b++,b===3?d(10):b===40?d(50):b===100&&d(500)},e)};d(1)},getImage:function(b,c){var d=0,e=function(){b&&(b.img[0].complete?(b.img.off(\".mfploader\"),b===n.currItem&&(n._onImageHasSize(b),n.updateStatus(\"ready\")),b.hasSize=!0,b.loaded=!0,y(\"ImageLoadComplete\")):(d++,d<200?setTimeout(e,100):f()))},f=function(){b&&(b.img.off(\".mfploader\"),b===n.currItem&&(n._onImageHasSize(b),n.updateStatus(\"error\",g.tError.replace(\"%url%\",b.src))),b.hasSize=!0,b.loaded=!0,b.loadError=!0)},g=n.st.image,h=c.find(\".mfp-img\");if(h.length){var i=document.createElement(\"img\");i.className=\"mfp-img\",b.el&&b.el.find(\"img\").length&&(i.alt=b.el.find(\"img\").attr(\"alt\")),b.img=a(i).on(\"load.mfploader\",e).on(\"error.mfploader\",f),i.src=b.src,h.is(\"img\")&&(b.img=b.img.clone()),i=b.img[0],i.naturalWidth>0?b.hasSize=!0:i.width||(b.hasSize=!1)}return n._parseMarkup(c,{title:M(b),img_replaceWith:b.img},b),n.resizeImage(),b.hasSize?(L&&clearInterval(L),b.loadError?(c.addClass(\"mfp-loading\"),n.updateStatus(\"error\",g.tError.replace(\"%url%\",b.src))):(c.removeClass(\"mfp-loading\"),n.updateStatus(\"ready\")),c):(n.updateStatus(\"loading\"),b.loading=!0,b.hasSize||(b.imgHidden=!0,c.addClass(\"mfp-loading\"),n.findImageSize(b)),c)}}});var N,O=function(){return N===undefined&&(N=document.createElement(\"p\").style.MozTransform!==undefined),N};a.magnificPopup.registerModule(\"zoom\",{options:{enabled:!1,easing:\"ease-in-out\",duration:300,opener:function(a){return a.is(\"img\")?a:a.find(\"img\")}},proto:{initZoom:function(){var a=n.st.zoom,d=\".zoom\",e;if(!a.enabled||!n.supportsTransition)return;var f=a.duration,g=function(b){var c=b.clone().removeAttr(\"style\").removeAttr(\"class\").addClass(\"mfp-animated-image\"),d=\"all \"+a.duration/1e3+\"s \"+a.easing,e={position:\"fixed\",zIndex:9999,left:0,top:0,\"-webkit-backface-visibility\":\"hidden\"},f=\"transition\";return e[\"-webkit-\"+f]=e[\"-moz-\"+f]=e[\"-o-\"+f]=e[f]=d,c.css(e),c},h=function(){n.content.css(\"visibility\",\"visible\")},i,j;w(\"BuildControls\"+d,function(){if(n._allowZoom()){clearTimeout(i),n.content.css(\"visibility\",\"hidden\"),e=n._getItemToZoom();if(!e){h();return}j=g(e),j.css(n._getOffset()),n.wrap.append(j),i=setTimeout(function(){j.css(n._getOffset(!0)),i=setTimeout(function(){h(),setTimeout(function(){j.remove(),e=j=null,y(\"ZoomAnimationEnded\")},16)},f)},16)}}),w(c+d,function(){if(n._allowZoom()){clearTimeout(i),n.st.removalDelay=f;if(!e){e=n._getItemToZoom();if(!e)return;j=g(e)}j.css(n._getOffset(!0)),n.wrap.append(j),n.content.css(\"visibility\",\"hidden\"),setTimeout(function(){j.css(n._getOffset())},16)}}),w(b+d,function(){n._allowZoom()&&(h(),j&&j.remove(),e=null)})},_allowZoom:function(){return n.currItem.type===\"image\"},_getItemToZoom:function(){return n.currItem.hasSize?n.currItem.img:!1},_getOffset:function(b){var c;b?c=n.currItem.img:c=n.st.zoom.opener(n.currItem.el||n.currItem);var d=c.offset(),e=parseInt(c.css(\"padding-top\"),10),f=parseInt(c.css(\"padding-bottom\"),10);d.top-=a(window).scrollTop()-e;var g={width:c.width(),height:(p?c.innerHeight():c[0].offsetHeight)-f-e};return O()?g[\"-moz-transform\"]=g.transform=\"translate(\"+d.left+\"px,\"+d.top+\"px)\":(g.left=d.left,g.top=d.top),g}}});var P=\"iframe\",Q=\"//about:blank\",R=function(a){if(n.currTemplate[P]){var b=n.currTemplate[P].find(\"iframe\");b.length&&(a||(b[0].src=Q),n.isIE8&&b.css(\"display\",a?\"block\":\"none\"))}};a.magnificPopup.registerModule(P,{options:{markup:'<div class=\"mfp-iframe-scaler\"><div class=\"mfp-close\"></div><iframe class=\"mfp-iframe\" src=\"//about:blank\" frameborder=\"0\" allowfullscreen></iframe></div>',srcAction:\"iframe_src\",patterns:{youtube:{index:\"youtube.com\",id:\"v=\",src:\"//www.youtube.com/embed/%id%?autoplay=1\"},vimeo:{index:\"vimeo.com/\",id:\"/\",src:\"//player.vimeo.com/video/%id%?autoplay=1\"},gmaps:{index:\"//maps.google.\",src:\"%id%&output=embed\"}}},proto:{initIframe:function(){n.types.push(P),w(\"BeforeChange\",function(a,b,c){b!==c&&(b===P?R():c===P&&R(!0))}),w(b+\".\"+P,function(){R()})},getIframe:function(b,c){var d=b.src,e=n.st.iframe;a.each(e.patterns,function(){if(d.indexOf(this.index)>-1)return this.id&&(typeof this.id==\"string\"?d=d.substr(d.lastIndexOf(this.id)+this.id.length,d.length):d=this.id.call(this,d)),d=this.src.replace(\"%id%\",d),!1});var f={};return e.srcAction&&(f[e.srcAction]=d),n._parseMarkup(c,f,b),n.updateStatus(\"ready\"),c}}});var S=function(a){var b=n.items.length;return a>b-1?a-b:a<0?b+a:a},T=function(a,b,c){return a.replace(/%curr%/gi,b+1).replace(/%total%/gi,c)};a.magnificPopup.registerModule(\"gallery\",{options:{enabled:!1,arrowMarkup:'<button title=\"%title%\" type=\"button\" class=\"mfp-arrow mfp-arrow-%dir%\"></button>',preload:[0,2],navigateByImgClick:!0,arrows:!0,tPrev:\"Previous (Left arrow key)\",tNext:\"Next (Right arrow key)\",tCounter:\"%curr% of %total%\"},proto:{initGallery:function(){var c=n.st.gallery,d=\".mfp-gallery\";n.direction=!0;if(!c||!c.enabled)return!1;u+=\" mfp-gallery\",w(g+d,function(){c.navigateByImgClick&&n.wrap.on(\"click\"+d,\".mfp-img\",function(){if(n.items.length>1)return n.next(),!1}),s.on(\"keydown\"+d,function(a){a.keyCode===37?n.prev():a.keyCode===39&&n.next()})}),w(\"UpdateStatus\"+d,function(a,b){b.text&&(b.text=T(b.text,n.currItem.index,n.items.length))}),w(f+d,function(a,b,d,e){var f=n.items.length;d.counter=f>1?T(c.tCounter,e.index,f):\"\"}),w(\"BuildControls\"+d,function(){if(n.items.length>1&&c.arrows&&!n.arrowLeft){var b=c.arrowMarkup,d=n.arrowLeft=a(b.replace(/%title%/gi,c.tPrev).replace(/%dir%/gi,\"left\")).addClass(m),e=n.arrowRight=a(b.replace(/%title%/gi,c.tNext).replace(/%dir%/gi,\"right\")).addClass(m);d.click(function(){n.prev()}),e.click(function(){n.next()}),n.container.append(d.add(e))}}),w(h+d,function(){n._preloadTimeout&&clearTimeout(n._preloadTimeout),n._preloadTimeout=setTimeout(function(){n.preloadNearbyImages(),n._preloadTimeout=null},16)}),w(b+d,function(){s.off(d),n.wrap.off(\"click\"+d),n.arrowRight=n.arrowLeft=null})},next:function(){n.direction=!0,n.index=S(n.index+1),n.updateItemHTML()},prev:function(){n.direction=!1,n.index=S(n.index-1),n.updateItemHTML()},goTo:function(a){n.direction=a>=n.index,n.index=a,n.updateItemHTML()},preloadNearbyImages:function(){var a=n.st.gallery.preload,b=Math.min(a[0],n.items.length),c=Math.min(a[1],n.items.length),d;for(d=1;d<=(n.direction?c:b);d++)n._preloadItem(n.index+d);for(d=1;d<=(n.direction?b:c);d++)n._preloadItem(n.index-d)},_preloadItem:function(b){b=S(b);if(n.items[b].preloaded)return;var c=n.items[b];c.parsed||(c=n.parseEl(b)),y(\"LazyLoad\",c),c.type===\"image\"&&(c.img=a('<img class=\"mfp-img\" />').on(\"load.mfploader\",function(){c.hasSize=!0}).on(\"error.mfploader\",function(){c.hasSize=!0,c.loadError=!0,y(\"LazyLoadError\",c)}).attr(\"src\",c.src)),c.preloaded=!0}}});var U=\"retina\";a.magnificPopup.registerModule(U,{options:{replaceSrc:function(a){return a.src.replace(/\\.\\w+$/,function(a){return\"@2x\"+a})},ratio:1},proto:{initRetina:function(){if(window.devicePixelRatio>1){var a=n.st.retina,b=a.ratio;b=isNaN(b)?b():b,b>1&&(w(\"ImageHasSize.\"+U,function(a,c){c.img.css({\"max-width\":c.img[0].naturalWidth/b,width:\"100%\"})}),w(\"ElementParse.\"+U,function(c,d){d.src=a.replaceSrc(d,b)}))}}}}),A()})","Mageplaza_Core/js/bootstrap.min.js":"/*!\n * Bootstrap v3.3.6 (http://getbootstrap.com)\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under the MIT license\n */\nif(\"undefined\"==typeof jQuery)throw new Error(\"Bootstrap's JavaScript requires jQuery\");+function(a){\"use strict\";var b=a.fn.jquery.split(\" \")[0].split(\".\");if(b[0]<2&&b[1]<9||1==b[0]&&9==b[1]&&b[2]<1||b[0]>2)throw new Error(\"Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3\")}(jQuery),+function(a){\"use strict\";function b(){var a=document.createElement(\"bootstrap\"),b={WebkitTransition:\"webkitTransitionEnd\",MozTransition:\"transitionend\",OTransition:\"oTransitionEnd otransitionend\",transition:\"transitionend\"};for(var c in b)if(void 0!==a.style[c])return{end:b[c]};return!1}a.fn.emulateTransitionEnd=function(b){var c=!1,d=this;a(this).one(\"bsTransitionEnd\",function(){c=!0});var e=function(){c||a(d).trigger(a.support.transition.end)};return setTimeout(e,b),this},a(function(){a.support.transition=b(),a.support.transition&&(a.event.special.bsTransitionEnd={bindType:a.support.transition.end,delegateType:a.support.transition.end,handle:function(b){return a(b.target).is(this)?b.handleObj.handler.apply(this,arguments):void 0}})})}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var c=a(this),e=c.data(\"bs.alert\");e||c.data(\"bs.alert\",e=new d(this)),\"string\"==typeof b&&e[b].call(c)})}var c='[data-dismiss=\"alert\"]',d=function(b){a(b).on(\"click\",c,this.close)};d.VERSION=\"3.3.6\",d.TRANSITION_DURATION=150,d.prototype.close=function(b){function c(){g.detach().trigger(\"closed.bs.alert\").remove()}var e=a(this),f=e.attr(\"data-target\");f||(f=e.attr(\"href\"),f=f&&f.replace(/.*(?=#[^\\s]*$)/,\"\"));var g=a(f);b&&b.preventDefault(),g.length||(g=e.closest(\".alert\")),g.trigger(b=a.Event(\"close.bs.alert\")),b.isDefaultPrevented()||(g.removeClass(\"in\"),a.support.transition&&g.hasClass(\"fade\")?g.one(\"bsTransitionEnd\",c).emulateTransitionEnd(d.TRANSITION_DURATION):c())};var e=a.fn.alert;a.fn.alert=b,a.fn.alert.Constructor=d,a.fn.alert.noConflict=function(){return a.fn.alert=e,this},a(document).on(\"click.bs.alert.data-api\",c,d.prototype.close)}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.button\"),f=\"object\"==typeof b&&b;e||d.data(\"bs.button\",e=new c(this,f)),\"toggle\"==b?e.toggle():b&&e.setState(b)})}var c=function(b,d){this.$element=a(b),this.options=a.extend({},c.DEFAULTS,d),this.isLoading=!1};c.VERSION=\"3.3.6\",c.DEFAULTS={loadingText:\"loading...\"},c.prototype.setState=function(b){var c=\"disabled\",d=this.$element,e=d.is(\"input\")?\"val\":\"html\",f=d.data();b+=\"Text\",null==f.resetText&&d.data(\"resetText\",d[e]()),setTimeout(a.proxy(function(){d[e](null==f[b]?this.options[b]:f[b]),\"loadingText\"==b?(this.isLoading=!0,d.addClass(c).attr(c,c)):this.isLoading&&(this.isLoading=!1,d.removeClass(c).removeAttr(c))},this),0)},c.prototype.toggle=function(){var a=!0,b=this.$element.closest('[data-toggle=\"buttons\"]');if(b.length){var c=this.$element.find(\"input\");\"radio\"==c.prop(\"type\")?(c.prop(\"checked\")&&(a=!1),b.find(\".active\").removeClass(\"active\"),this.$element.addClass(\"active\")):\"checkbox\"==c.prop(\"type\")&&(c.prop(\"checked\")!==this.$element.hasClass(\"active\")&&(a=!1),this.$element.toggleClass(\"active\")),c.prop(\"checked\",this.$element.hasClass(\"active\")),a&&c.trigger(\"change\")}else this.$element.attr(\"aria-pressed\",!this.$element.hasClass(\"active\")),this.$element.toggleClass(\"active\")};var d=a.fn.button;a.fn.button=b,a.fn.button.Constructor=c,a.fn.button.noConflict=function(){return a.fn.button=d,this},a(document).on(\"click.bs.button.data-api\",'[data-toggle^=\"button\"]',function(c){var d=a(c.target);d.hasClass(\"btn\")||(d=d.closest(\".btn\")),b.call(d,\"toggle\"),a(c.target).is('input[type=\"radio\"]')||a(c.target).is('input[type=\"checkbox\"]')||c.preventDefault()}).on(\"focus.bs.button.data-api blur.bs.button.data-api\",'[data-toggle^=\"button\"]',function(b){a(b.target).closest(\".btn\").toggleClass(\"focus\",/^focus(in)?$/.test(b.type))})}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.carousel\"),f=a.extend({},c.DEFAULTS,d.data(),\"object\"==typeof b&&b),g=\"string\"==typeof b?b:f.slide;e||d.data(\"bs.carousel\",e=new c(this,f)),\"number\"==typeof b?e.to(b):g?e[g]():f.interval&&e.pause().cycle()})}var c=function(b,c){this.$element=a(b),this.$indicators=this.$element.find(\".carousel-indicators\"),this.options=c,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&&this.$element.on(\"keydown.bs.carousel\",a.proxy(this.keydown,this)),\"hover\"==this.options.pause&&!(\"ontouchstart\"in document.documentElement)&&this.$element.on(\"mouseenter.bs.carousel\",a.proxy(this.pause,this)).on(\"mouseleave.bs.carousel\",a.proxy(this.cycle,this))};c.VERSION=\"3.3.6\",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:\"hover\",wrap:!0,keyboard:!0},c.prototype.keydown=function(a){if(!/input|textarea/i.test(a.target.tagName)){switch(a.which){case 37:this.prev();break;case 39:this.next();break;default:return}a.preventDefault()}},c.prototype.cycle=function(b){return b||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(a.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(a){return this.$items=a.parent().children(\".item\"),this.$items.index(a||this.$active)},c.prototype.getItemForDirection=function(a,b){var c=this.getItemIndex(b),d=\"prev\"==a&&0===c||\"next\"==a&&c==this.$items.length-1;if(d&&!this.options.wrap)return b;var e=\"prev\"==a?-1:1,f=(c+e)%this.$items.length;return this.$items.eq(f)},c.prototype.to=function(a){var b=this,c=this.getItemIndex(this.$active=this.$element.find(\".item.active\"));return a>this.$items.length-1||0>a?void 0:this.sliding?this.$element.one(\"slid.bs.carousel\",function(){b.to(a)}):c==a?this.pause().cycle():this.slide(a>c?\"next\":\"prev\",this.$items.eq(a))},c.prototype.pause=function(b){return b||(this.paused=!0),this.$element.find(\".next, .prev\").length&&a.support.transition&&(this.$element.trigger(a.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){return this.sliding?void 0:this.slide(\"next\")},c.prototype.prev=function(){return this.sliding?void 0:this.slide(\"prev\")},c.prototype.slide=function(b,d){var e=this.$element.find(\".item.active\"),f=d||this.getItemForDirection(b,e),g=this.interval,h=\"next\"==b?\"left\":\"right\",i=this;if(f.hasClass(\"active\"))return this.sliding=!1;var j=f[0],k=a.Event(\"slide.bs.carousel\",{relatedTarget:j,direction:h});if(this.$element.trigger(k),!k.isDefaultPrevented()){if(this.sliding=!0,g&&this.pause(),this.$indicators.length){this.$indicators.find(\".active\").removeClass(\"active\");var l=a(this.$indicators.children()[this.getItemIndex(f)]);l&&l.addClass(\"active\")}var m=a.Event(\"slid.bs.carousel\",{relatedTarget:j,direction:h});return a.support.transition&&this.$element.hasClass(\"slide\")?(f.addClass(b),f[0].offsetWidth,e.addClass(h),f.addClass(h),e.one(\"bsTransitionEnd\",function(){f.removeClass([b,h].join(\" \")).addClass(\"active\"),e.removeClass([\"active\",h].join(\" \")),i.sliding=!1,setTimeout(function(){i.$element.trigger(m)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(e.removeClass(\"active\"),f.addClass(\"active\"),this.sliding=!1,this.$element.trigger(m)),g&&this.cycle(),this}};var d=a.fn.carousel;a.fn.carousel=b,a.fn.carousel.Constructor=c,a.fn.carousel.noConflict=function(){return a.fn.carousel=d,this};var e=function(c){var d,e=a(this),f=a(e.attr(\"data-target\")||(d=e.attr(\"href\"))&&d.replace(/.*(?=#[^\\s]+$)/,\"\"));if(f.hasClass(\"carousel\")){var g=a.extend({},f.data(),e.data()),h=e.attr(\"data-slide-to\");h&&(g.interval=!1),b.call(f,g),h&&f.data(\"bs.carousel\").to(h),c.preventDefault()}};a(document).on(\"click.bs.carousel.data-api\",\"[data-slide]\",e).on(\"click.bs.carousel.data-api\",\"[data-slide-to]\",e),a(window).on(\"load\",function(){a('[data-ride=\"carousel\"]').each(function(){var c=a(this);b.call(c,c.data())})})}(jQuery),+function(a){\"use strict\";function b(b){var c,d=b.attr(\"data-target\")||(c=b.attr(\"href\"))&&c.replace(/.*(?=#[^\\s]+$)/,\"\");return a(d)}function c(b){return this.each(function(){var c=a(this),e=c.data(\"bs.collapse\"),f=a.extend({},d.DEFAULTS,c.data(),\"object\"==typeof b&&b);!e&&f.toggle&&/show|hide/.test(b)&&(f.toggle=!1),e||c.data(\"bs.collapse\",e=new d(this,f)),\"string\"==typeof b&&e[b]()})}var d=function(b,c){this.$element=a(b),this.options=a.extend({},d.DEFAULTS,c),this.$trigger=a('[data-toggle=\"collapse\"][href=\"#'+b.id+'\"],[data-toggle=\"collapse\"][data-target=\"#'+b.id+'\"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};d.VERSION=\"3.3.6\",d.TRANSITION_DURATION=350,d.DEFAULTS={toggle:!0},d.prototype.dimension=function(){var a=this.$element.hasClass(\"width\");return a?\"width\":\"height\"},d.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass(\"in\")){var b,e=this.$parent&&this.$parent.children(\".panel\").children(\".in, .collapsing\");if(!(e&&e.length&&(b=e.data(\"bs.collapse\"),b&&b.transitioning))){var f=a.Event(\"show.bs.collapse\");if(this.$element.trigger(f),!f.isDefaultPrevented()){e&&e.length&&(c.call(e,\"hide\"),b||e.data(\"bs.collapse\",null));var g=this.dimension();this.$element.removeClass(\"collapse\").addClass(\"collapsing\")[g](0).attr(\"aria-expanded\",!0),this.$trigger.removeClass(\"collapsed\").attr(\"aria-expanded\",!0),this.transitioning=1;var h=function(){this.$element.removeClass(\"collapsing\").addClass(\"collapse in\")[g](\"\"),this.transitioning=0,this.$element.trigger(\"shown.bs.collapse\")};if(!a.support.transition)return h.call(this);var i=a.camelCase([\"scroll\",g].join(\"-\"));this.$element.one(\"bsTransitionEnd\",a.proxy(h,this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])}}}},d.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass(\"in\")){var b=a.Event(\"hide.bs.collapse\");if(this.$element.trigger(b),!b.isDefaultPrevented()){var c=this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight,this.$element.addClass(\"collapsing\").removeClass(\"collapse in\").attr(\"aria-expanded\",!1),this.$trigger.addClass(\"collapsed\").attr(\"aria-expanded\",!1),this.transitioning=1;var e=function(){this.transitioning=0,this.$element.removeClass(\"collapsing\").addClass(\"collapse\").trigger(\"hidden.bs.collapse\")};return a.support.transition?void this.$element[c](0).one(\"bsTransitionEnd\",a.proxy(e,this)).emulateTransitionEnd(d.TRANSITION_DURATION):e.call(this)}}},d.prototype.toggle=function(){this[this.$element.hasClass(\"in\")?\"hide\":\"show\"]()},d.prototype.getParent=function(){return a(this.options.parent).find('[data-toggle=\"collapse\"][data-parent=\"'+this.options.parent+'\"]').each(a.proxy(function(c,d){var e=a(d);this.addAriaAndCollapsedClass(b(e),e)},this)).end()},d.prototype.addAriaAndCollapsedClass=function(a,b){var c=a.hasClass(\"in\");a.attr(\"aria-expanded\",c),b.toggleClass(\"collapsed\",!c).attr(\"aria-expanded\",c)};var e=a.fn.collapse;a.fn.collapse=c,a.fn.collapse.Constructor=d,a.fn.collapse.noConflict=function(){return a.fn.collapse=e,this},a(document).on(\"click.bs.collapse.data-api\",'[data-toggle=\"collapse\"]',function(d){var e=a(this);e.attr(\"data-target\")||d.preventDefault();var f=b(e),g=f.data(\"bs.collapse\"),h=g?\"toggle\":e.data();c.call(f,h)})}(jQuery),+function(a){\"use strict\";function b(b){var c=b.attr(\"data-target\");c||(c=b.attr(\"href\"),c=c&&/#[A-Za-z]/.test(c)&&c.replace(/.*(?=#[^\\s]*$)/,\"\"));var d=c&&a(c);return d&&d.length?d:b.parent()}function c(c){c&&3===c.which||(a(e).remove(),a(f).each(function(){var d=a(this),e=b(d),f={relatedTarget:this};e.hasClass(\"open\")&&(c&&\"click\"==c.type&&/input|textarea/i.test(c.target.tagName)&&a.contains(e[0],c.target)||(e.trigger(c=a.Event(\"hide.bs.dropdown\",f)),c.isDefaultPrevented()||(d.attr(\"aria-expanded\",\"false\"),e.removeClass(\"open\").trigger(a.Event(\"hidden.bs.dropdown\",f)))))}))}function d(b){return this.each(function(){var c=a(this),d=c.data(\"bs.dropdown\");d||c.data(\"bs.dropdown\",d=new g(this)),\"string\"==typeof b&&d[b].call(c)})}var e=\".dropdown-backdrop\",f='[data-toggle=\"dropdown\"]',g=function(b){a(b).on(\"click.bs.dropdown\",this.toggle)};g.VERSION=\"3.3.6\",g.prototype.toggle=function(d){var e=a(this);if(!e.is(\".disabled, :disabled\")){var f=b(e),g=f.hasClass(\"open\");if(c(),!g){\"ontouchstart\"in document.documentElement&&!f.closest(\".navbar-nav\").length&&a(document.createElement(\"div\")).addClass(\"dropdown-backdrop\").insertAfter(a(this)).on(\"click\",c);var h={relatedTarget:this};if(f.trigger(d=a.Event(\"show.bs.dropdown\",h)),d.isDefaultPrevented())return;e.trigger(\"focus\").attr(\"aria-expanded\",\"true\"),f.toggleClass(\"open\").trigger(a.Event(\"shown.bs.dropdown\",h))}return!1}},g.prototype.keydown=function(c){if(/(38|40|27|32)/.test(c.which)&&!/input|textarea/i.test(c.target.tagName)){var d=a(this);if(c.preventDefault(),c.stopPropagation(),!d.is(\".disabled, :disabled\")){var e=b(d),g=e.hasClass(\"open\");if(!g&&27!=c.which||g&&27==c.which)return 27==c.which&&e.find(f).trigger(\"focus\"),d.trigger(\"click\");var h=\" li:not(.disabled):visible a\",i=e.find(\".dropdown-menu\"+h);if(i.length){var j=i.index(c.target);38==c.which&&j>0&&j--,40==c.which&&j<i.length-1&&j++,~j||(j=0),i.eq(j).trigger(\"focus\")}}}};var h=a.fn.dropdown;a.fn.dropdown=d,a.fn.dropdown.Constructor=g,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=h,this},a(document).on(\"click.bs.dropdown.data-api\",c).on(\"click.bs.dropdown.data-api\",\".dropdown form\",function(a){a.stopPropagation()}).on(\"click.bs.dropdown.data-api\",f,g.prototype.toggle).on(\"keydown.bs.dropdown.data-api\",f,g.prototype.keydown).on(\"keydown.bs.dropdown.data-api\",\".dropdown-menu\",g.prototype.keydown)}(jQuery),+function(a){\"use strict\";function b(b,d){return this.each(function(){var e=a(this),f=e.data(\"bs.modal\"),g=a.extend({},c.DEFAULTS,e.data(),\"object\"==typeof b&&b);f||e.data(\"bs.modal\",f=new c(this,g)),\"string\"==typeof b?f[b](d):g.show&&f.show(d)})}var c=function(b,c){this.options=c,this.$body=a(document.body),this.$element=a(b),this.$dialog=this.$element.find(\".modal-dialog\"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.options.remote&&this.$element.find(\".modal-content\").load(this.options.remote,a.proxy(function(){this.$element.trigger(\"loaded.bs.modal\")},this))};c.VERSION=\"3.3.6\",c.TRANSITION_DURATION=300,c.BACKDROP_TRANSITION_DURATION=150,c.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},c.prototype.toggle=function(a){return this.isShown?this.hide():this.show(a)},c.prototype.show=function(b){var d=this,e=a.Event(\"show.bs.modal\",{relatedTarget:b});this.$element.trigger(e),this.isShown||e.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass(\"modal-open\"),this.escape(),this.resize(),this.$element.on(\"click.dismiss.bs.modal\",'[data-dismiss=\"modal\"]',a.proxy(this.hide,this)),this.$dialog.on(\"mousedown.dismiss.bs.modal\",function(){d.$element.one(\"mouseup.dismiss.bs.modal\",function(b){a(b.target).is(d.$element)&&(d.ignoreBackdropClick=!0)})}),this.backdrop(function(){var e=a.support.transition&&d.$element.hasClass(\"fade\");d.$element.parent().length||d.$element.appendTo(d.$body),d.$element.show().scrollTop(0),d.adjustDialog(),e&&d.$element[0].offsetWidth,d.$element.addClass(\"in\"),d.enforceFocus();var f=a.Event(\"shown.bs.modal\",{relatedTarget:b});e?d.$dialog.one(\"bsTransitionEnd\",function(){d.$element.trigger(\"focus\").trigger(f)}).emulateTransitionEnd(c.TRANSITION_DURATION):d.$element.trigger(\"focus\").trigger(f)}))},c.prototype.hide=function(b){b&&b.preventDefault(),b=a.Event(\"hide.bs.modal\"),this.$element.trigger(b),this.isShown&&!b.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off(\"focusin.bs.modal\"),this.$element.removeClass(\"in\").off(\"click.dismiss.bs.modal\").off(\"mouseup.dismiss.bs.modal\"),this.$dialog.off(\"mousedown.dismiss.bs.modal\"),a.support.transition&&this.$element.hasClass(\"fade\")?this.$element.one(\"bsTransitionEnd\",a.proxy(this.hideModal,this)).emulateTransitionEnd(c.TRANSITION_DURATION):this.hideModal())},c.prototype.enforceFocus=function(){a(document).off(\"focusin.bs.modal\").on(\"focusin.bs.modal\",a.proxy(function(a){this.$element[0]===a.target||this.$element.has(a.target).length||this.$element.trigger(\"focus\")},this))},c.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on(\"keydown.dismiss.bs.modal\",a.proxy(function(a){27==a.which&&this.hide()},this)):this.isShown||this.$element.off(\"keydown.dismiss.bs.modal\")},c.prototype.resize=function(){this.isShown?a(window).on(\"resize.bs.modal\",a.proxy(this.handleUpdate,this)):a(window).off(\"resize.bs.modal\")},c.prototype.hideModal=function(){var a=this;this.$element.hide(),this.backdrop(function(){a.$body.removeClass(\"modal-open\"),a.resetAdjustments(),a.resetScrollbar(),a.$element.trigger(\"hidden.bs.modal\")})},c.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},c.prototype.backdrop=function(b){var d=this,e=this.$element.hasClass(\"fade\")?\"fade\":\"\";if(this.isShown&&this.options.backdrop){var f=a.support.transition&&e;if(this.$backdrop=a(document.createElement(\"div\")).addClass(\"modal-backdrop \"+e).appendTo(this.$body),this.$element.on(\"click.dismiss.bs.modal\",a.proxy(function(a){return this.ignoreBackdropClick?void(this.ignoreBackdropClick=!1):void(a.target===a.currentTarget&&(\"static\"==this.options.backdrop?this.$element[0].focus():this.hide()))},this)),f&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass(\"in\"),!b)return;f?this.$backdrop.one(\"bsTransitionEnd\",b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):b()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass(\"in\");var g=function(){d.removeBackdrop(),b&&b()};a.support.transition&&this.$element.hasClass(\"fade\")?this.$backdrop.one(\"bsTransitionEnd\",g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION):g()}else b&&b()},c.prototype.handleUpdate=function(){this.adjustDialog()},c.prototype.adjustDialog=function(){var a=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&a?this.scrollbarWidth:\"\",paddingRight:this.bodyIsOverflowing&&!a?this.scrollbarWidth:\"\"})},c.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:\"\",paddingRight:\"\"})},c.prototype.checkScrollbar=function(){var a=window.innerWidth;if(!a){var b=document.documentElement.getBoundingClientRect();a=b.right-Math.abs(b.left)}this.bodyIsOverflowing=document.body.clientWidth<a,this.scrollbarWidth=this.measureScrollbar()},c.prototype.setScrollbar=function(){var a=parseInt(this.$body.css(\"padding-right\")||0,10);this.originalBodyPad=document.body.style.paddingRight||\"\",this.bodyIsOverflowing&&this.$body.css(\"padding-right\",a+this.scrollbarWidth)},c.prototype.resetScrollbar=function(){this.$body.css(\"padding-right\",this.originalBodyPad)},c.prototype.measureScrollbar=function(){var a=document.createElement(\"div\");a.className=\"modal-scrollbar-measure\",this.$body.append(a);var b=a.offsetWidth-a.clientWidth;return this.$body[0].removeChild(a),b};var d=a.fn.modal;a.fn.modal=b,a.fn.modal.Constructor=c,a.fn.modal.noConflict=function(){return a.fn.modal=d,this},a(document).on(\"click.bs.modal.data-api\",'[data-toggle=\"modal\"]',function(c){var d=a(this),e=d.attr(\"href\"),f=a(d.attr(\"data-target\")||e&&e.replace(/.*(?=#[^\\s]+$)/,\"\")),g=f.data(\"bs.modal\")?\"toggle\":a.extend({remote:!/#/.test(e)&&e},f.data(),d.data());d.is(\"a\")&&c.preventDefault(),f.one(\"show.bs.modal\",function(a){a.isDefaultPrevented()||f.one(\"hidden.bs.modal\",function(){d.is(\":visible\")&&d.trigger(\"focus\")})}),b.call(f,g,this)})}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.tooltip\"),f=\"object\"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data(\"bs.tooltip\",e=new c(this,f)),\"string\"==typeof b&&e[b]())})}var c=function(a,b){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.inState=null,this.init(\"tooltip\",a,b)};c.VERSION=\"3.3.6\",c.TRANSITION_DURATION=150,c.DEFAULTS={animation:!0,placement:\"top\",selector:!1,template:'<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',trigger:\"hover focus\",title:\"\",delay:0,html:!1,container:!1,viewport:{selector:\"body\",padding:0}},c.prototype.init=function(b,c,d){if(this.enabled=!0,this.type=b,this.$element=a(c),this.options=this.getOptions(d),this.$viewport=this.options.viewport&&a(a.isFunction(this.options.viewport)?this.options.viewport.call(this,this.$element):this.options.viewport.selector||this.options.viewport),this.inState={click:!1,hover:!1,focus:!1},this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error(\"`selector` option must be specified when initializing \"+this.type+\" on the window.document object!\");for(var e=this.options.trigger.split(\" \"),f=e.length;f--;){var g=e[f];if(\"click\"==g)this.$element.on(\"click.\"+this.type,this.options.selector,a.proxy(this.toggle,this));else if(\"manual\"!=g){var h=\"hover\"==g?\"mouseenter\":\"focusin\",i=\"hover\"==g?\"mouseleave\":\"focusout\";this.$element.on(h+\".\"+this.type,this.options.selector,a.proxy(this.enter,this)),this.$element.on(i+\".\"+this.type,this.options.selector,a.proxy(this.leave,this))}}this.options.selector?this._options=a.extend({},this.options,{trigger:\"manual\",selector:\"\"}):this.fixTitle()},c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.getOptions=function(b){return b=a.extend({},this.getDefaults(),this.$element.data(),b),b.delay&&\"number\"==typeof b.delay&&(b.delay={show:b.delay,hide:b.delay}),b},c.prototype.getDelegateOptions=function(){var b={},c=this.getDefaults();return this._options&&a.each(this._options,function(a,d){c[a]!=d&&(b[a]=d)}),b},c.prototype.enter=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data(\"bs.\"+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data(\"bs.\"+this.type,c)),b instanceof a.Event&&(c.inState[\"focusin\"==b.type?\"focus\":\"hover\"]=!0),c.tip().hasClass(\"in\")||\"in\"==c.hoverState?void(c.hoverState=\"in\"):(clearTimeout(c.timeout),c.hoverState=\"in\",c.options.delay&&c.options.delay.show?void(c.timeout=setTimeout(function(){\"in\"==c.hoverState&&c.show()},c.options.delay.show)):c.show())},c.prototype.isInStateTrue=function(){for(var a in this.inState)if(this.inState[a])return!0;return!1},c.prototype.leave=function(b){var c=b instanceof this.constructor?b:a(b.currentTarget).data(\"bs.\"+this.type);return c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data(\"bs.\"+this.type,c)),b instanceof a.Event&&(c.inState[\"focusout\"==b.type?\"focus\":\"hover\"]=!1),c.isInStateTrue()?void 0:(clearTimeout(c.timeout),c.hoverState=\"out\",c.options.delay&&c.options.delay.hide?void(c.timeout=setTimeout(function(){\"out\"==c.hoverState&&c.hide()},c.options.delay.hide)):c.hide())},c.prototype.show=function(){var b=a.Event(\"show.bs.\"+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(b);var d=a.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(b.isDefaultPrevented()||!d)return;var e=this,f=this.tip(),g=this.getUID(this.type);this.setContent(),f.attr(\"id\",g),this.$element.attr(\"aria-describedby\",g),this.options.animation&&f.addClass(\"fade\");var h=\"function\"==typeof this.options.placement?this.options.placement.call(this,f[0],this.$element[0]):this.options.placement,i=/\\s?auto?\\s?/i,j=i.test(h);j&&(h=h.replace(i,\"\")||\"top\"),f.detach().css({top:0,left:0,display:\"block\"}).addClass(h).data(\"bs.\"+this.type,this),this.options.container?f.appendTo(this.options.container):f.insertAfter(this.$element),this.$element.trigger(\"inserted.bs.\"+this.type);var k=this.getPosition(),l=f[0].offsetWidth,m=f[0].offsetHeight;if(j){var n=h,o=this.getPosition(this.$viewport);h=\"bottom\"==h&&k.bottom+m>o.bottom?\"top\":\"top\"==h&&k.top-m<o.top?\"bottom\":\"right\"==h&&k.right+l>o.width?\"left\":\"left\"==h&&k.left-l<o.left?\"right\":h,f.removeClass(n).addClass(h)}var p=this.getCalculatedOffset(h,k,l,m);this.applyPlacement(p,h);var q=function(){var a=e.hoverState;e.$element.trigger(\"shown.bs.\"+e.type),e.hoverState=null,\"out\"==a&&e.leave(e)};a.support.transition&&this.$tip.hasClass(\"fade\")?f.one(\"bsTransitionEnd\",q).emulateTransitionEnd(c.TRANSITION_DURATION):q()}},c.prototype.applyPlacement=function(b,c){var d=this.tip(),e=d[0].offsetWidth,f=d[0].offsetHeight,g=parseInt(d.css(\"margin-top\"),10),h=parseInt(d.css(\"margin-left\"),10);isNaN(g)&&(g=0),isNaN(h)&&(h=0),b.top+=g,b.left+=h,a.offset.setOffset(d[0],a.extend({using:function(a){d.css({top:Math.round(a.top),left:Math.round(a.left)})}},b),0),d.addClass(\"in\");var i=d[0].offsetWidth,j=d[0].offsetHeight;\"top\"==c&&j!=f&&(b.top=b.top+f-j);var k=this.getViewportAdjustedDelta(c,b,i,j);k.left?b.left+=k.left:b.top+=k.top;var l=/top|bottom/.test(c),m=l?2*k.left-e+i:2*k.top-f+j,n=l?\"offsetWidth\":\"offsetHeight\";d.offset(b),this.replaceArrow(m,d[0][n],l)},c.prototype.replaceArrow=function(a,b,c){this.arrow().css(c?\"left\":\"top\",50*(1-a/b)+\"%\").css(c?\"top\":\"left\",\"\")},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle();a.find(\".tooltip-inner\")[this.options.html?\"html\":\"text\"](b),a.removeClass(\"fade in top bottom left right\")},c.prototype.hide=function(b){function d(){\"in\"!=e.hoverState&&f.detach(),e.$element.removeAttr(\"aria-describedby\").trigger(\"hidden.bs.\"+e.type),b&&b()}var e=this,f=a(this.$tip),g=a.Event(\"hide.bs.\"+this.type);return this.$element.trigger(g),g.isDefaultPrevented()?void 0:(f.removeClass(\"in\"),a.support.transition&&f.hasClass(\"fade\")?f.one(\"bsTransitionEnd\",d).emulateTransitionEnd(c.TRANSITION_DURATION):d(),this.hoverState=null,this)},c.prototype.fixTitle=function(){var a=this.$element;(a.attr(\"title\")||\"string\"!=typeof a.attr(\"data-original-title\"))&&a.attr(\"data-original-title\",a.attr(\"title\")||\"\").attr(\"title\",\"\")},c.prototype.hasContent=function(){return this.getTitle()},c.prototype.getPosition=function(b){b=b||this.$element;var c=b[0],d=\"BODY\"==c.tagName,e=c.getBoundingClientRect();null==e.width&&(e=a.extend({},e,{width:e.right-e.left,height:e.bottom-e.top}));var f=d?{top:0,left:0}:b.offset(),g={scroll:d?document.documentElement.scrollTop||document.body.scrollTop:b.scrollTop()},h=d?{width:a(window).width(),height:a(window).height()}:null;return a.extend({},e,g,h,f)},c.prototype.getCalculatedOffset=function(a,b,c,d){return\"bottom\"==a?{top:b.top+b.height,left:b.left+b.width/2-c/2}:\"top\"==a?{top:b.top-d,left:b.left+b.width/2-c/2}:\"left\"==a?{top:b.top+b.height/2-d/2,left:b.left-c}:{top:b.top+b.height/2-d/2,left:b.left+b.width}},c.prototype.getViewportAdjustedDelta=function(a,b,c,d){var e={top:0,left:0};if(!this.$viewport)return e;var f=this.options.viewport&&this.options.viewport.padding||0,g=this.getPosition(this.$viewport);if(/right|left/.test(a)){var h=b.top-f-g.scroll,i=b.top+f-g.scroll+d;h<g.top?e.top=g.top-h:i>g.top+g.height&&(e.top=g.top+g.height-i)}else{var j=b.left-f,k=b.left+f+c;j<g.left?e.left=g.left-j:k>g.right&&(e.left=g.left+g.width-k)}return e},c.prototype.getTitle=function(){var a,b=this.$element,c=this.options;return a=b.attr(\"data-original-title\")||(\"function\"==typeof c.title?c.title.call(b[0]):c.title)},c.prototype.getUID=function(a){do a+=~~(1e6*Math.random());while(document.getElementById(a));return a},c.prototype.tip=function(){if(!this.$tip&&(this.$tip=a(this.options.template),1!=this.$tip.length))throw new Error(this.type+\" `template` option must consist of exactly 1 top-level element!\");return this.$tip},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(\".tooltip-arrow\")},c.prototype.enable=function(){this.enabled=!0},c.prototype.disable=function(){this.enabled=!1},c.prototype.toggleEnabled=function(){this.enabled=!this.enabled},c.prototype.toggle=function(b){var c=this;b&&(c=a(b.currentTarget).data(\"bs.\"+this.type),c||(c=new this.constructor(b.currentTarget,this.getDelegateOptions()),a(b.currentTarget).data(\"bs.\"+this.type,c))),b?(c.inState.click=!c.inState.click,c.isInStateTrue()?c.enter(c):c.leave(c)):c.tip().hasClass(\"in\")?c.leave(c):c.enter(c)},c.prototype.destroy=function(){var a=this;clearTimeout(this.timeout),this.hide(function(){a.$element.off(\".\"+a.type).removeData(\"bs.\"+a.type),a.$tip&&a.$tip.detach(),a.$tip=null,a.$arrow=null,a.$viewport=null})};var d=a.fn.tooltip;a.fn.tooltip=b,a.fn.tooltip.Constructor=c,a.fn.tooltip.noConflict=function(){return a.fn.tooltip=d,this}}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.popover\"),f=\"object\"==typeof b&&b;(e||!/destroy|hide/.test(b))&&(e||d.data(\"bs.popover\",e=new c(this,f)),\"string\"==typeof b&&e[b]())})}var c=function(a,b){this.init(\"popover\",a,b)};if(!a.fn.tooltip)throw new Error(\"Popover requires tooltip.js\");c.VERSION=\"3.3.6\",c.DEFAULTS=a.extend({},a.fn.tooltip.Constructor.DEFAULTS,{placement:\"right\",trigger:\"click\",content:\"\",template:'<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'}),c.prototype=a.extend({},a.fn.tooltip.Constructor.prototype),c.prototype.constructor=c,c.prototype.getDefaults=function(){return c.DEFAULTS},c.prototype.setContent=function(){var a=this.tip(),b=this.getTitle(),c=this.getContent();a.find(\".popover-title\")[this.options.html?\"html\":\"text\"](b),a.find(\".popover-content\").children().detach().end()[this.options.html?\"string\"==typeof c?\"html\":\"append\":\"text\"](c),a.removeClass(\"fade top bottom left right in\"),a.find(\".popover-title\").html()||a.find(\".popover-title\").hide()},c.prototype.hasContent=function(){return this.getTitle()||this.getContent()},c.prototype.getContent=function(){var a=this.$element,b=this.options;return a.attr(\"data-content\")||(\"function\"==typeof b.content?b.content.call(a[0]):b.content)},c.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(\".arrow\")};var d=a.fn.popover;a.fn.popover=b,a.fn.popover.Constructor=c,a.fn.popover.noConflict=function(){return a.fn.popover=d,this}}(jQuery),+function(a){\"use strict\";function b(c,d){this.$body=a(document.body),this.$scrollElement=a(a(c).is(document.body)?window:c),this.options=a.extend({},b.DEFAULTS,d),this.selector=(this.options.target||\"\")+\" .nav li > a\",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on(\"scroll.bs.scrollspy\",a.proxy(this.process,this)),this.refresh(),this.process()}function c(c){return this.each(function(){var d=a(this),e=d.data(\"bs.scrollspy\"),f=\"object\"==typeof c&&c;e||d.data(\"bs.scrollspy\",e=new b(this,f)),\"string\"==typeof c&&e[c]()})}b.VERSION=\"3.3.6\",b.DEFAULTS={offset:10},b.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},b.prototype.refresh=function(){var b=this,c=\"offset\",d=0;this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight(),a.isWindow(this.$scrollElement[0])||(c=\"position\",d=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var b=a(this),e=b.data(\"target\")||b.attr(\"href\"),f=/^#./.test(e)&&a(e);return f&&f.length&&f.is(\":visible\")&&[[f[c]().top+d,e]]||null}).sort(function(a,b){return a[0]-b[0]}).each(function(){b.offsets.push(this[0]),b.targets.push(this[1])})},b.prototype.process=function(){var a,b=this.$scrollElement.scrollTop()+this.options.offset,c=this.getScrollHeight(),d=this.options.offset+c-this.$scrollElement.height(),e=this.offsets,f=this.targets,g=this.activeTarget;if(this.scrollHeight!=c&&this.refresh(),b>=d)return g!=(a=f[f.length-1])&&this.activate(a);if(g&&b<e[0])return this.activeTarget=null,this.clear();for(a=e.length;a--;)g!=f[a]&&b>=e[a]&&(void 0===e[a+1]||b<e[a+1])&&this.activate(f[a])},b.prototype.activate=function(b){this.activeTarget=b,this.clear();var c=this.selector+'[data-target=\"'+b+'\"],'+this.selector+'[href=\"'+b+'\"]',d=a(c).parents(\"li\").addClass(\"active\");\n    d.parent(\".dropdown-menu\").length&&(d=d.closest(\"li.dropdown\").addClass(\"active\")),d.trigger(\"activate.bs.scrollspy\")},b.prototype.clear=function(){a(this.selector).parentsUntil(this.options.target,\".active\").removeClass(\"active\")};var d=a.fn.scrollspy;a.fn.scrollspy=c,a.fn.scrollspy.Constructor=b,a.fn.scrollspy.noConflict=function(){return a.fn.scrollspy=d,this},a(window).on(\"load.bs.scrollspy.data-api\",function(){a('[data-spy=\"scroll\"]').each(function(){var b=a(this);c.call(b,b.data())})})}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.tab\");e||d.data(\"bs.tab\",e=new c(this)),\"string\"==typeof b&&e[b]()})}var c=function(b){this.element=a(b)};c.VERSION=\"3.3.6\",c.TRANSITION_DURATION=150,c.prototype.show=function(){var b=this.element,c=b.closest(\"ul:not(.dropdown-menu)\"),d=b.data(\"target\");if(d||(d=b.attr(\"href\"),d=d&&d.replace(/.*(?=#[^\\s]*$)/,\"\")),!b.parent(\"li\").hasClass(\"active\")){var e=c.find(\".active:last a\"),f=a.Event(\"hide.bs.tab\",{relatedTarget:b[0]}),g=a.Event(\"show.bs.tab\",{relatedTarget:e[0]});if(e.trigger(f),b.trigger(g),!g.isDefaultPrevented()&&!f.isDefaultPrevented()){var h=a(d);this.activate(b.closest(\"li\"),c),this.activate(h,h.parent(),function(){e.trigger({type:\"hidden.bs.tab\",relatedTarget:b[0]}),b.trigger({type:\"shown.bs.tab\",relatedTarget:e[0]})})}}},c.prototype.activate=function(b,d,e){function f(){g.removeClass(\"active\").find(\"> .dropdown-menu > .active\").removeClass(\"active\").end().find('[data-toggle=\"tab\"]').attr(\"aria-expanded\",!1),b.addClass(\"active\").find('[data-toggle=\"tab\"]').attr(\"aria-expanded\",!0),h?(b[0].offsetWidth,b.addClass(\"in\")):b.removeClass(\"fade\"),b.parent(\".dropdown-menu\").length&&b.closest(\"li.dropdown\").addClass(\"active\").end().find('[data-toggle=\"tab\"]').attr(\"aria-expanded\",!0),e&&e()}var g=d.find(\"> .active\"),h=e&&a.support.transition&&(g.length&&g.hasClass(\"fade\")||!!d.find(\"> .fade\").length);g.length&&h?g.one(\"bsTransitionEnd\",f).emulateTransitionEnd(c.TRANSITION_DURATION):f(),g.removeClass(\"in\")};var d=a.fn.tab;a.fn.tab=b,a.fn.tab.Constructor=c,a.fn.tab.noConflict=function(){return a.fn.tab=d,this};var e=function(c){c.preventDefault(),b.call(a(this),\"show\")};a(document).on(\"click.bs.tab.data-api\",'[data-toggle=\"tab\"]',e).on(\"click.bs.tab.data-api\",'[data-toggle=\"pill\"]',e)}(jQuery),+function(a){\"use strict\";function b(b){return this.each(function(){var d=a(this),e=d.data(\"bs.affix\"),f=\"object\"==typeof b&&b;e||d.data(\"bs.affix\",e=new c(this,f)),\"string\"==typeof b&&e[b]()})}var c=function(b,d){this.options=a.extend({},c.DEFAULTS,d),this.$target=a(this.options.target).on(\"scroll.bs.affix.data-api\",a.proxy(this.checkPosition,this)).on(\"click.bs.affix.data-api\",a.proxy(this.checkPositionWithEventLoop,this)),this.$element=a(b),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};c.VERSION=\"3.3.6\",c.RESET=\"affix affix-top affix-bottom\",c.DEFAULTS={offset:0,target:window},c.prototype.getState=function(a,b,c,d){var e=this.$target.scrollTop(),f=this.$element.offset(),g=this.$target.height();if(null!=c&&\"top\"==this.affixed)return c>e?\"top\":!1;if(\"bottom\"==this.affixed)return null!=c?e+this.unpin<=f.top?!1:\"bottom\":a-d>=e+g?!1:\"bottom\";var h=null==this.affixed,i=h?e:f.top,j=h?g:b;return null!=c&&c>=e?\"top\":null!=d&&i+j>=a-d?\"bottom\":!1},c.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass(\"affix\");var a=this.$target.scrollTop(),b=this.$element.offset();return this.pinnedOffset=b.top-a},c.prototype.checkPositionWithEventLoop=function(){setTimeout(a.proxy(this.checkPosition,this),1)},c.prototype.checkPosition=function(){if(this.$element.is(\":visible\")){var b=this.$element.height(),d=this.options.offset,e=d.top,f=d.bottom,g=Math.max(a(document).height(),a(document.body).height());\"object\"!=typeof d&&(f=e=d),\"function\"==typeof e&&(e=d.top(this.$element)),\"function\"==typeof f&&(f=d.bottom(this.$element));var h=this.getState(g,b,e,f);if(this.affixed!=h){null!=this.unpin&&this.$element.css(\"top\",\"\");var i=\"affix\"+(h?\"-\"+h:\"\"),j=a.Event(i+\".bs.affix\");if(this.$element.trigger(j),j.isDefaultPrevented())return;this.affixed=h,this.unpin=\"bottom\"==h?this.getPinnedOffset():null,this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace(\"affix\",\"affixed\")+\".bs.affix\")}\"bottom\"==h&&this.$element.offset({top:g-b-f})}};var d=a.fn.affix;a.fn.affix=b,a.fn.affix.Constructor=c,a.fn.affix.noConflict=function(){return a.fn.affix=d,this},a(window).on(\"load\",function(){a('[data-spy=\"affix\"]').each(function(){var c=a(this),d=c.data();d.offset=d.offset||{},null!=d.offsetBottom&&(d.offset.bottom=d.offsetBottom),null!=d.offsetTop&&(d.offset.top=d.offsetTop),b.call(c,d)})})}(jQuery);","Magestore_Bannerslider/js/jquery/slider/jquery-flexslider-min.js":"/*\n * jQuery FlexSlider v2.5.0\n * Copyright 2012 WooThemes\n * Contributing Author: Tyler Smith\n */!function($){$.flexslider=function(e,t){var a=$(e);a.vars=$.extend({},$.flexslider.defaults,t);var n=a.vars.namespace,i=window.navigator&&window.navigator.msPointerEnabled&&window.MSGesture,s=(\"ontouchstart\"in window||i||window.DocumentTouch&&document instanceof DocumentTouch)&&a.vars.touch,r=\"click touchend MSPointerUp keyup\",o=\"\",l,c=\"vertical\"===a.vars.direction,d=a.vars.reverse,u=a.vars.itemWidth>0,v=\"fade\"===a.vars.animation,p=\"\"!==a.vars.asNavFor,m={},f=!0;$.data(e,\"flexslider\",a),m={init:function(){a.animating=!1,a.currentSlide=parseInt(a.vars.startAt?a.vars.startAt:0,10),isNaN(a.currentSlide)&&(a.currentSlide=0),a.animatingTo=a.currentSlide,a.atEnd=0===a.currentSlide||a.currentSlide===a.last,a.containerSelector=a.vars.selector.substr(0,a.vars.selector.search(\" \")),a.slides=$(a.vars.selector,a),a.container=$(a.containerSelector,a),a.count=a.slides.length,a.syncExists=$(a.vars.sync).length>0,\"slide\"===a.vars.animation&&(a.vars.animation=\"swing\"),a.prop=c?\"top\":\"marginLeft\",a.args={},a.manualPause=!1,a.stopped=!1,a.started=!1,a.startTimeout=null,a.transitions=!a.vars.video&&!v&&a.vars.useCSS&&function(){var e=document.createElement(\"div\"),t=[\"perspectiveProperty\",\"WebkitPerspective\",\"MozPerspective\",\"OPerspective\",\"msPerspective\"];for(var n in t)if(void 0!==e.style[t[n]])return a.pfx=t[n].replace(\"Perspective\",\"\").toLowerCase(),a.prop=\"-\"+a.pfx+\"-transform\",!0;return!1}(),a.ensureAnimationEnd=\"\",\"\"!==a.vars.controlsContainer&&(a.controlsContainer=$(a.vars.controlsContainer).length>0&&$(a.vars.controlsContainer)),\"\"!==a.vars.manualControls&&(a.manualControls=$(a.vars.manualControls).length>0&&$(a.vars.manualControls)),\"\"!==a.vars.customDirectionNav&&(a.customDirectionNav=2===$(a.vars.customDirectionNav).length&&$(a.vars.customDirectionNav)),a.vars.randomize&&(a.slides.sort(function(){return Math.round(Math.random())-.5}),a.container.empty().append(a.slides)),a.doMath(),a.setup(\"init\"),a.vars.controlNav&&m.controlNav.setup(),a.vars.directionNav&&m.directionNav.setup(),a.vars.keyboard&&(1===$(a.containerSelector).length||a.vars.multipleKeyboard)&&$(document).bind(\"keyup\",function(e){var t=e.keyCode;if(!a.animating&&(39===t||37===t)){var n=39===t?a.getTarget(\"next\"):37===t?a.getTarget(\"prev\"):!1;a.flexAnimate(n,a.vars.pauseOnAction)}}),a.vars.mousewheel&&a.bind(\"mousewheel\",function(e,t,n,i){e.preventDefault();var s=a.getTarget(0>t?\"next\":\"prev\");a.flexAnimate(s,a.vars.pauseOnAction)}),a.vars.pausePlay&&m.pausePlay.setup(),a.vars.slideshow&&a.vars.pauseInvisible&&m.pauseInvisible.init(),a.vars.slideshow&&(a.vars.pauseOnHover&&a.hover(function(){a.manualPlay||a.manualPause||a.pause()},function(){a.manualPause||a.manualPlay||a.stopped||a.play()}),a.vars.pauseInvisible&&m.pauseInvisible.isHidden()||(a.vars.initDelay>0?a.startTimeout=setTimeout(a.play,a.vars.initDelay):a.play())),p&&m.asNav.setup(),s&&a.vars.touch&&m.touch(),(!v||v&&a.vars.smoothHeight)&&$(window).bind(\"resize orientationchange focus\",m.resize),a.find(\"img\").attr(\"draggable\",\"false\"),setTimeout(function(){a.vars.start(a)},200)},asNav:{setup:function(){a.asNav=!0,a.animatingTo=Math.floor(a.currentSlide/a.move),a.currentItem=a.currentSlide,a.slides.removeClass(n+\"active-slide\").eq(a.currentItem).addClass(n+\"active-slide\"),i?(e._slider=a,a.slides.each(function(){var e=this;e._gesture=new MSGesture,e._gesture.target=e,e.addEventListener(\"MSPointerDown\",function(e){e.preventDefault(),e.currentTarget._gesture&&e.currentTarget._gesture.addPointer(e.pointerId)},!1),e.addEventListener(\"MSGestureTap\",function(e){e.preventDefault();var t=$(this),n=t.index();$(a.vars.asNavFor).data(\"flexslider\").animating||t.hasClass(\"active\")||(a.direction=a.currentItem<n?\"next\":\"prev\",a.flexAnimate(n,a.vars.pauseOnAction,!1,!0,!0))})})):a.slides.on(r,function(e){e.preventDefault();var t=$(this),i=t.index(),s=t.offset().left-$(a).scrollLeft();0>=s&&t.hasClass(n+\"active-slide\")?a.flexAnimate(a.getTarget(\"prev\"),!0):$(a.vars.asNavFor).data(\"flexslider\").animating||t.hasClass(n+\"active-slide\")||(a.direction=a.currentItem<i?\"next\":\"prev\",a.flexAnimate(i,a.vars.pauseOnAction,!1,!0,!0))})}},controlNav:{setup:function(){a.manualControls?m.controlNav.setupManual():m.controlNav.setupPaging()},setupPaging:function(){var e=\"thumbnails\"===a.vars.controlNav?\"control-thumbs\":\"control-paging\",t=1,i,s;if(a.controlNavScaffold=$('<ol class=\"'+n+\"control-nav \"+n+e+'\"></ol>'),a.pagingCount>1)for(var l=0;l<a.pagingCount;l++){if(s=a.slides.eq(l),i=\"thumbnails\"===a.vars.controlNav?'<img src=\"'+s.attr(\"data-thumb\")+'\"/>':\"<a>\"+t+\"</a>\",\"thumbnails\"===a.vars.controlNav&&!0===a.vars.thumbCaptions){var c=s.attr(\"data-thumbcaption\");\"\"!==c&&void 0!==c&&(i+='<span class=\"'+n+'caption\">'+c+\"</span>\")}a.controlNavScaffold.append(\"<li>\"+i+\"</li>\"),t++}a.controlsContainer?$(a.controlsContainer).append(a.controlNavScaffold):a.append(a.controlNavScaffold),m.controlNav.set(),m.controlNav.active(),a.controlNavScaffold.delegate(\"a, img\",r,function(e){if(e.preventDefault(),\"\"===o||o===e.type){var t=$(this),i=a.controlNav.index(t);t.hasClass(n+\"active\")||(a.direction=i>a.currentSlide?\"next\":\"prev\",a.flexAnimate(i,a.vars.pauseOnAction))}\"\"===o&&(o=e.type),m.setToClearWatchedEvent()})},setupManual:function(){a.controlNav=a.manualControls,m.controlNav.active(),a.controlNav.bind(r,function(e){if(e.preventDefault(),\"\"===o||o===e.type){var t=$(this),i=a.controlNav.index(t);t.hasClass(n+\"active\")||(a.direction=i>a.currentSlide?\"next\":\"prev\",a.flexAnimate(i,a.vars.pauseOnAction))}\"\"===o&&(o=e.type),m.setToClearWatchedEvent()})},set:function(){var e=\"thumbnails\"===a.vars.controlNav?\"img\":\"a\";a.controlNav=$(\".\"+n+\"control-nav li \"+e,a.controlsContainer?a.controlsContainer:a)},active:function(){a.controlNav.removeClass(n+\"active\").eq(a.animatingTo).addClass(n+\"active\")},update:function(e,t){a.pagingCount>1&&\"add\"===e?a.controlNavScaffold.append($(\"<li><a>\"+a.count+\"</a></li>\")):1===a.pagingCount?a.controlNavScaffold.find(\"li\").remove():a.controlNav.eq(t).closest(\"li\").remove(),m.controlNav.set(),a.pagingCount>1&&a.pagingCount!==a.controlNav.length?a.update(t,e):m.controlNav.active()}},directionNav:{setup:function(){var e=$('<ul class=\"'+n+'direction-nav\"><li class=\"'+n+'nav-prev\"><a class=\"'+n+'prev\" href=\"#\">'+a.vars.prevText+'</a></li><li class=\"'+n+'nav-next\"><a class=\"'+n+'next\" href=\"#\">'+a.vars.nextText+\"</a></li></ul>\");a.customDirectionNav?a.directionNav=a.customDirectionNav:a.controlsContainer?($(a.controlsContainer).append(e),a.directionNav=$(\".\"+n+\"direction-nav li a\",a.controlsContainer)):(a.append(e),a.directionNav=$(\".\"+n+\"direction-nav li a\",a)),m.directionNav.update(),a.directionNav.bind(r,function(e){e.preventDefault();var t;(\"\"===o||o===e.type)&&(t=a.getTarget($(this).hasClass(n+\"next\")?\"next\":\"prev\"),a.flexAnimate(t,a.vars.pauseOnAction)),\"\"===o&&(o=e.type),m.setToClearWatchedEvent()})},update:function(){var e=n+\"disabled\";1===a.pagingCount?a.directionNav.addClass(e).attr(\"tabindex\",\"-1\"):a.vars.animationLoop?a.directionNav.removeClass(e).removeAttr(\"tabindex\"):0===a.animatingTo?a.directionNav.removeClass(e).filter(\".\"+n+\"prev\").addClass(e).attr(\"tabindex\",\"-1\"):a.animatingTo===a.last?a.directionNav.removeClass(e).filter(\".\"+n+\"next\").addClass(e).attr(\"tabindex\",\"-1\"):a.directionNav.removeClass(e).removeAttr(\"tabindex\")}},pausePlay:{setup:function(){var e=$('<div class=\"'+n+'pauseplay\"><a></a></div>');a.controlsContainer?(a.controlsContainer.append(e),a.pausePlay=$(\".\"+n+\"pauseplay a\",a.controlsContainer)):(a.append(e),a.pausePlay=$(\".\"+n+\"pauseplay a\",a)),m.pausePlay.update(a.vars.slideshow?n+\"pause\":n+\"play\"),a.pausePlay.bind(r,function(e){e.preventDefault(),(\"\"===o||o===e.type)&&($(this).hasClass(n+\"pause\")?(a.manualPause=!0,a.manualPlay=!1,a.pause()):(a.manualPause=!1,a.manualPlay=!0,a.play())),\"\"===o&&(o=e.type),m.setToClearWatchedEvent()})},update:function(e){\"play\"===e?a.pausePlay.removeClass(n+\"pause\").addClass(n+\"play\").html(a.vars.playText):a.pausePlay.removeClass(n+\"play\").addClass(n+\"pause\").html(a.vars.pauseText)}},touch:function(){function t(t){t.stopPropagation(),a.animating?t.preventDefault():(a.pause(),e._gesture.addPointer(t.pointerId),w=0,p=c?a.h:a.w,f=Number(new Date),l=u&&d&&a.animatingTo===a.last?0:u&&d?a.limit-(a.itemW+a.vars.itemMargin)*a.move*a.animatingTo:u&&a.currentSlide===a.last?a.limit:u?(a.itemW+a.vars.itemMargin)*a.move*a.currentSlide:d?(a.last-a.currentSlide+a.cloneOffset)*p:(a.currentSlide+a.cloneOffset)*p)}function n(t){t.stopPropagation();var a=t.target._slider;if(a){var n=-t.translationX,i=-t.translationY;return w+=c?i:n,m=w,y=c?Math.abs(w)<Math.abs(-n):Math.abs(w)<Math.abs(-i),t.detail===t.MSGESTURE_FLAG_INERTIA?void setImmediate(function(){e._gesture.stop()}):void((!y||Number(new Date)-f>500)&&(t.preventDefault(),!v&&a.transitions&&(a.vars.animationLoop||(m=w/(0===a.currentSlide&&0>w||a.currentSlide===a.last&&w>0?Math.abs(w)/p+2:1)),a.setProps(l+m,\"setTouch\"))))}}function s(e){e.stopPropagation();var t=e.target._slider;if(t){if(t.animatingTo===t.currentSlide&&!y&&null!==m){var a=d?-m:m,n=t.getTarget(a>0?\"next\":\"prev\");t.canAdvance(n)&&(Number(new Date)-f<550&&Math.abs(a)>50||Math.abs(a)>p/2)?t.flexAnimate(n,t.vars.pauseOnAction):v||t.flexAnimate(t.currentSlide,t.vars.pauseOnAction,!0)}r=null,o=null,m=null,l=null,w=0}}var r,o,l,p,m,f,g,h,S,y=!1,x=0,b=0,w=0;i?(e.style.msTouchAction=\"none\",e._gesture=new MSGesture,e._gesture.target=e,e.addEventListener(\"MSPointerDown\",t,!1),e._slider=a,e.addEventListener(\"MSGestureChange\",n,!1),e.addEventListener(\"MSGestureEnd\",s,!1)):(g=function(t){a.animating?t.preventDefault():(window.navigator.msPointerEnabled||1===t.touches.length)&&(a.pause(),p=c?a.h:a.w,f=Number(new Date),x=t.touches[0].pageX,b=t.touches[0].pageY,l=u&&d&&a.animatingTo===a.last?0:u&&d?a.limit-(a.itemW+a.vars.itemMargin)*a.move*a.animatingTo:u&&a.currentSlide===a.last?a.limit:u?(a.itemW+a.vars.itemMargin)*a.move*a.currentSlide:d?(a.last-a.currentSlide+a.cloneOffset)*p:(a.currentSlide+a.cloneOffset)*p,r=c?b:x,o=c?x:b,e.addEventListener(\"touchmove\",h,!1),e.addEventListener(\"touchend\",S,!1))},h=function(e){x=e.touches[0].pageX,b=e.touches[0].pageY,m=c?r-b:r-x,y=c?Math.abs(m)<Math.abs(x-o):Math.abs(m)<Math.abs(b-o);var t=500;(!y||Number(new Date)-f>t)&&(e.preventDefault(),!v&&a.transitions&&(a.vars.animationLoop||(m/=0===a.currentSlide&&0>m||a.currentSlide===a.last&&m>0?Math.abs(m)/p+2:1),a.setProps(l+m,\"setTouch\")))},S=function(t){if(e.removeEventListener(\"touchmove\",h,!1),a.animatingTo===a.currentSlide&&!y&&null!==m){var n=d?-m:m,i=a.getTarget(n>0?\"next\":\"prev\");a.canAdvance(i)&&(Number(new Date)-f<550&&Math.abs(n)>50||Math.abs(n)>p/2)?a.flexAnimate(i,a.vars.pauseOnAction):v||a.flexAnimate(a.currentSlide,a.vars.pauseOnAction,!0)}e.removeEventListener(\"touchend\",S,!1),r=null,o=null,m=null,l=null},e.addEventListener(\"touchstart\",g,!1))},resize:function(){!a.animating&&a.is(\":visible\")&&(u||a.doMath(),v?m.smoothHeight():u?(a.slides.width(a.computedW),a.update(a.pagingCount),a.setProps()):c?(a.viewport.height(a.h),a.setProps(a.h,\"setTotal\")):(a.vars.smoothHeight&&m.smoothHeight(),a.newSlides.width(a.computedW),a.setProps(a.computedW,\"setTotal\")))},smoothHeight:function(e){if(!c||v){var t=v?a:a.viewport;e?t.animate({height:a.slides.eq(a.animatingTo).height()},e):t.height(a.slides.eq(a.animatingTo).height())}},sync:function(e){var t=$(a.vars.sync).data(\"flexslider\"),n=a.animatingTo;switch(e){case\"animate\":t.flexAnimate(n,a.vars.pauseOnAction,!1,!0);break;case\"play\":t.playing||t.asNav||t.play();break;case\"pause\":t.pause()}},uniqueID:function(e){return e.filter(\"[id]\").add(e.find(\"[id]\")).each(function(){var e=$(this);e.attr(\"id\",e.attr(\"id\")+\"_clone\")}),e},pauseInvisible:{visProp:null,init:function(){var e=m.pauseInvisible.getHiddenProp();if(e){var t=e.replace(/[H|h]idden/,\"\")+\"visibilitychange\";document.addEventListener(t,function(){m.pauseInvisible.isHidden()?a.startTimeout?clearTimeout(a.startTimeout):a.pause():a.started?a.play():a.vars.initDelay>0?setTimeout(a.play,a.vars.initDelay):a.play()})}},isHidden:function(){var e=m.pauseInvisible.getHiddenProp();return e?document[e]:!1},getHiddenProp:function(){var e=[\"webkit\",\"moz\",\"ms\",\"o\"];if(\"hidden\"in document)return\"hidden\";for(var t=0;t<e.length;t++)if(e[t]+\"Hidden\"in document)return e[t]+\"Hidden\";return null}},setToClearWatchedEvent:function(){clearTimeout(l),l=setTimeout(function(){o=\"\"},3e3)}},a.flexAnimate=function(e,t,i,r,o){if(a.vars.animationLoop||e===a.currentSlide||(a.direction=e>a.currentSlide?\"next\":\"prev\"),p&&1===a.pagingCount&&(a.direction=a.currentItem<e?\"next\":\"prev\"),!a.animating&&(a.canAdvance(e,o)||i)&&a.is(\":visible\")){if(p&&r){var l=$(a.vars.asNavFor).data(\"flexslider\");if(a.atEnd=0===e||e===a.count-1,l.flexAnimate(e,!0,!1,!0,o),a.direction=a.currentItem<e?\"next\":\"prev\",l.direction=a.direction,Math.ceil((e+1)/a.visible)-1===a.currentSlide||0===e)return a.currentItem=e,a.slides.removeClass(n+\"active-slide\").eq(e).addClass(n+\"active-slide\"),!1;a.currentItem=e,a.slides.removeClass(n+\"active-slide\").eq(e).addClass(n+\"active-slide\"),e=Math.floor(e/a.visible)}if(a.animating=!0,a.animatingTo=e,t&&a.pause(),a.vars.before(a),a.syncExists&&!o&&m.sync(\"animate\"),a.vars.controlNav&&m.controlNav.active(),u||a.slides.removeClass(n+\"active-slide\").eq(e).addClass(n+\"active-slide\"),a.atEnd=0===e||e===a.last,a.vars.directionNav&&m.directionNav.update(),e===a.last&&(a.vars.end(a),a.vars.animationLoop||a.pause()),v)s?(a.slides.eq(a.currentSlide).css({opacity:0,zIndex:1}),a.slides.eq(e).css({opacity:1,zIndex:2}),a.wrapup(f)):(a.slides.eq(a.currentSlide).css({zIndex:1}).animate({opacity:0},a.vars.animationSpeed,a.vars.easing),a.slides.eq(e).css({zIndex:2}).animate({opacity:1},a.vars.animationSpeed,a.vars.easing,a.wrapup));else{var f=c?a.slides.filter(\":first\").height():a.computedW,g,h,S;u?(g=a.vars.itemMargin,S=(a.itemW+g)*a.move*a.animatingTo,h=S>a.limit&&1!==a.visible?a.limit:S):h=0===a.currentSlide&&e===a.count-1&&a.vars.animationLoop&&\"next\"!==a.direction?d?(a.count+a.cloneOffset)*f:0:a.currentSlide===a.last&&0===e&&a.vars.animationLoop&&\"prev\"!==a.direction?d?0:(a.count+1)*f:d?(a.count-1-e+a.cloneOffset)*f:(e+a.cloneOffset)*f,a.setProps(h,\"\",a.vars.animationSpeed),a.transitions?(a.vars.animationLoop&&a.atEnd||(a.animating=!1,a.currentSlide=a.animatingTo),a.container.unbind(\"webkitTransitionEnd transitionend\"),a.container.bind(\"webkitTransitionEnd transitionend\",function(){clearTimeout(a.ensureAnimationEnd),a.wrapup(f)}),clearTimeout(a.ensureAnimationEnd),a.ensureAnimationEnd=setTimeout(function(){a.wrapup(f)},a.vars.animationSpeed+100)):a.container.animate(a.args,a.vars.animationSpeed,a.vars.easing,function(){a.wrapup(f)})}a.vars.smoothHeight&&m.smoothHeight(a.vars.animationSpeed)}},a.wrapup=function(e){v||u||(0===a.currentSlide&&a.animatingTo===a.last&&a.vars.animationLoop?a.setProps(e,\"jumpEnd\"):a.currentSlide===a.last&&0===a.animatingTo&&a.vars.animationLoop&&a.setProps(e,\"jumpStart\")),a.animating=!1,a.currentSlide=a.animatingTo,a.vars.after(a)},a.animateSlides=function(){!a.animating&&f&&a.flexAnimate(a.getTarget(\"next\"))},a.pause=function(){clearInterval(a.animatedSlides),a.animatedSlides=null,a.playing=!1,a.vars.pausePlay&&m.pausePlay.update(\"play\"),a.syncExists&&m.sync(\"pause\")},a.play=function(){a.playing&&clearInterval(a.animatedSlides),a.animatedSlides=a.animatedSlides||setInterval(a.animateSlides,a.vars.slideshowSpeed),a.started=a.playing=!0,a.vars.pausePlay&&m.pausePlay.update(\"pause\"),a.syncExists&&m.sync(\"play\")},a.stop=function(){a.pause(),a.stopped=!0},a.canAdvance=function(e,t){var n=p?a.pagingCount-1:a.last;return t?!0:p&&a.currentItem===a.count-1&&0===e&&\"prev\"===a.direction?!0:p&&0===a.currentItem&&e===a.pagingCount-1&&\"next\"!==a.direction?!1:e!==a.currentSlide||p?a.vars.animationLoop?!0:a.atEnd&&0===a.currentSlide&&e===n&&\"next\"!==a.direction?!1:a.atEnd&&a.currentSlide===n&&0===e&&\"next\"===a.direction?!1:!0:!1},a.getTarget=function(e){return a.direction=e,\"next\"===e?a.currentSlide===a.last?0:a.currentSlide+1:0===a.currentSlide?a.last:a.currentSlide-1},a.setProps=function(e,t,n){var i=function(){var n=e?e:(a.itemW+a.vars.itemMargin)*a.move*a.animatingTo,i=function(){if(u)return\"setTouch\"===t?e:d&&a.animatingTo===a.last?0:d?a.limit-(a.itemW+a.vars.itemMargin)*a.move*a.animatingTo:a.animatingTo===a.last?a.limit:n;switch(t){case\"setTotal\":return d?(a.count-1-a.currentSlide+a.cloneOffset)*e:(a.currentSlide+a.cloneOffset)*e;case\"setTouch\":return d?e:e;case\"jumpEnd\":return d?e:a.count*e;case\"jumpStart\":return d?a.count*e:e;default:return e}}();return-1*i+\"px\"}();a.transitions&&(i=c?\"translate3d(0,\"+i+\",0)\":\"translate3d(\"+i+\",0,0)\",n=void 0!==n?n/1e3+\"s\":\"0s\",a.container.css(\"-\"+a.pfx+\"-transition-duration\",n),a.container.css(\"transition-duration\",n)),a.args[a.prop]=i,(a.transitions||void 0===n)&&a.container.css(a.args),a.container.css(\"transform\",i)},a.setup=function(e){if(v)a.slides.css({width:\"100%\",\"float\":\"left\",marginRight:\"-100%\",position:\"relative\"}),\"init\"===e&&(s?a.slides.css({opacity:0,display:\"block\",webkitTransition:\"opacity \"+a.vars.animationSpeed/1e3+\"s ease\",zIndex:1}).eq(a.currentSlide).css({opacity:1,zIndex:2}):0==a.vars.fadeFirstSlide?a.slides.css({opacity:0,display:\"block\",zIndex:1}).eq(a.currentSlide).css({zIndex:2}).css({opacity:1}):a.slides.css({opacity:0,display:\"block\",zIndex:1}).eq(a.currentSlide).css({zIndex:2}).animate({opacity:1},a.vars.animationSpeed,a.vars.easing)),a.vars.smoothHeight&&m.smoothHeight();else{var t,i;\"init\"===e&&(a.viewport=$('<div class=\"'+n+'viewport\"></div>').css({overflow:\"hidden\",position:\"relative\"}).appendTo(a).append(a.container),a.cloneCount=0,a.cloneOffset=0,d&&(i=$.makeArray(a.slides).reverse(),a.slides=$(i),a.container.empty().append(a.slides))),a.vars.animationLoop&&!u&&(a.cloneCount=2,a.cloneOffset=1,\"init\"!==e&&a.container.find(\".clone\").remove(),a.container.append(m.uniqueID(a.slides.first().clone().addClass(\"clone\")).attr(\"aria-hidden\",\"true\")).prepend(m.uniqueID(a.slides.last().clone().addClass(\"clone\")).attr(\"aria-hidden\",\"true\"))),a.newSlides=$(a.vars.selector,a),t=d?a.count-1-a.currentSlide+a.cloneOffset:a.currentSlide+a.cloneOffset,c&&!u?(a.container.height(200*(a.count+a.cloneCount)+\"%\").css(\"position\",\"absolute\").width(\"100%\"),setTimeout(function(){a.newSlides.css({display:\"block\"}),a.doMath(),a.viewport.height(a.h),a.setProps(t*a.h,\"init\")},\"init\"===e?100:0)):(a.container.width(200*(a.count+a.cloneCount)+\"%\"),a.setProps(t*a.computedW,\"init\"),setTimeout(function(){a.doMath(),a.newSlides.css({width:a.computedW,\"float\":\"left\",display:\"block\"}),a.vars.smoothHeight&&m.smoothHeight()},\"init\"===e?100:0))}u||a.slides.removeClass(n+\"active-slide\").eq(a.currentSlide).addClass(n+\"active-slide\"),a.vars.init(a)},a.doMath=function(){var e=a.slides.first(),t=a.vars.itemMargin,n=a.vars.minItems,i=a.vars.maxItems;a.w=void 0===a.viewport?a.width():a.viewport.width(),a.h=e.height(),a.boxPadding=e.outerWidth()-e.width(),u?(a.itemT=a.vars.itemWidth+t,a.minW=n?n*a.itemT:a.w,a.maxW=i?i*a.itemT-t:a.w,a.itemW=a.minW>a.w?(a.w-t*(n-1))/n:a.maxW<a.w?(a.w-t*(i-1))/i:a.vars.itemWidth>a.w?a.w:a.vars.itemWidth,a.visible=Math.floor(a.w/a.itemW),a.move=a.vars.move>0&&a.vars.move<a.visible?a.vars.move:a.visible,a.pagingCount=Math.ceil((a.count-a.visible)/a.move+1),a.last=a.pagingCount-1,a.limit=1===a.pagingCount?0:a.vars.itemWidth>a.w?a.itemW*(a.count-1)+t*(a.count-1):(a.itemW+t)*a.count-a.w-t):(a.itemW=a.w,a.pagingCount=a.count,a.last=a.count-1),a.computedW=a.itemW-a.boxPadding},a.update=function(e,t){a.doMath(),u||(e<a.currentSlide?a.currentSlide+=1:e<=a.currentSlide&&0!==e&&(a.currentSlide-=1),a.animatingTo=a.currentSlide),a.vars.controlNav&&!a.manualControls&&(\"add\"===t&&!u||a.pagingCount>a.controlNav.length?m.controlNav.update(\"add\"):(\"remove\"===t&&!u||a.pagingCount<a.controlNav.length)&&(u&&a.currentSlide>a.last&&(a.currentSlide-=1,a.animatingTo-=1),m.controlNav.update(\"remove\",a.last))),a.vars.directionNav&&m.directionNav.update()},a.addSlide=function(e,t){var n=$(e);a.count+=1,a.last=a.count-1,c&&d?void 0!==t?a.slides.eq(a.count-t).after(n):a.container.prepend(n):void 0!==t?a.slides.eq(t).before(n):a.container.append(n),a.update(t,\"add\"),a.slides=$(a.vars.selector+\":not(.clone)\",a),a.setup(),a.vars.added(a)},a.removeSlide=function(e){var t=isNaN(e)?a.slides.index($(e)):e;a.count-=1,a.last=a.count-1,isNaN(e)?$(e,a.slides).remove():c&&d?a.slides.eq(a.last).remove():a.slides.eq(e).remove(),a.doMath(),a.update(t,\"remove\"),a.slides=$(a.vars.selector+\":not(.clone)\",a),a.setup(),a.vars.removed(a)},m.init()},$(window).blur(function(e){focused=!1}).focus(function(e){focused=!0}),$.flexslider.defaults={namespace:\"flex-\",selector:\".slides > li\",animation:\"fade\",easing:\"swing\",direction:\"horizontal\",reverse:!1,animationLoop:!0,smoothHeight:!1,startAt:0,slideshow:!0,slideshowSpeed:7e3,animationSpeed:600,initDelay:0,randomize:!1,fadeFirstSlide:!0,thumbCaptions:!1,pauseOnAction:!0,pauseOnHover:!1,pauseInvisible:!0,useCSS:!0,touch:!0,video:!1,controlNav:!0,directionNav:!0,prevText:\"Previous\",nextText:\"Next\",keyboard:!0,multipleKeyboard:!1,mousewheel:!1,pausePlay:!1,pauseText:\"Pause\",playText:\"Play\",controlsContainer:\"\",manualControls:\"\",customDirectionNav:\"\",sync:\"\",asNavFor:\"\",itemWidth:0,itemMargin:0,minItems:1,maxItems:0,move:0,allowOneSlide:!0,start:function(){},before:function(){},after:function(){},end:function(){},added:function(){},removed:function(){},init:function(){}},$.fn.flexslider=function(e){if(void 0===e&&(e={}),\"object\"==typeof e)return this.each(function(){var t=$(this),a=e.selector?e.selector:\".slides > li\",n=t.find(a);1===n.length&&e.allowOneSlide===!0||0===n.length?(n.fadeIn(400),e.start&&e.start(t)):void 0===t.data(\"flexslider\")&&new $.flexslider(this,e)});var t=$(this).data(\"flexslider\");switch(e){case\"play\":t.play();break;case\"pause\":t.pause();break;case\"stop\":t.stop();break;case\"next\":t.flexAnimate(t.getTarget(\"next\"),!0);break;case\"prev\":case\"previous\":t.flexAnimate(t.getTarget(\"prev\"),!0);break;default:\"number\"==typeof e&&t.flexAnimate(e,!0)}}}(jQuery);\n","TemplateMonster_FilmSlider/js/slider/item/sortable.js":"/**\n *\n * Copyright \u00c2\u00a9 2015 TemplateMonster. All rights reserved.\n * See COPYING.txt for license details.\n *\n */\n\ndefine([\n    'jquery',\n    'TemplateMonster_FilmSlider/js/slider/item/sliderpagedit',\n    'TemplateMonster_FilmSlider/js/slider/item/canvas',\n],function($){\n'use strict';\n\n    /**\n     * Make ul sortable\n     */\n    $.widget('tm.sliderItemLayerSortable', $.tm.sliderPageEdit,{\n\n        options: {\n            sortableItemId: 'data-id',\n            sortableOptions: {}\n        },\n\n        _create: function() {\n            $(this.element).sortable(this.options.sortableOptions);\n            $(this.element).on(\"sortupdate\", $.proxy(function( event, ui ) {\n                var arr = $(this.element).sortable('toArray',{attribute:this.options.sortableItemId});\n                this._setLayersOrder(event, ui,arr);\n            },this));\n\n            $(this.element).on(\"click\", \"li\", $.proxy(function(event){\n                this._selectLayerItem(event);\n                if($(event.target).data('type') == 'text') {\n                    this._textSettingFieldUnable();\n                } else {\n                    this._textSettingFieldDisable();\n                }\n            },this));\n\n\n            $(this.options.imageCanvasBlock).on(\"click\",\"div\",$.proxy(function(event){\n                if($(event.target).data('type') == 'text') {\n                    this._textSettingFieldUnable();\n                } else {\n                    this._textSettingFieldDisable();\n                }\n            },this));\n        },\n\n        _setLayersOrder: function(event, ui,arr){\n            this._changeSortableItemOrder(arr);\n            this._changeLayoutImageZindex(arr);\n        },\n\n    });\n\n    return $.tm.sliderItemLayerSortable;\n});"}
    }
});
