require.config({
    config: {
        'jsbuild':{"Lof_AdvancedReports/vendors/moment/min/tests.js":"\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('af');\n\n    test('parse', function (assert) {\n        var tests = 'Januarie Jan_Februarie Feb_Maart Mar_April Apr_Mei Mei_Junie Jun_Julie Jul_Augustus Aug_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sondag, Februarie 14de 2010, 3:25:50 nm'],\n                ['ddd, hA',                            'Son, 3NM'],\n                ['M Mo MM MMMM MMM',                   '2 2de 02 Februarie Feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14de 14'],\n                ['d do dddd ddd dd',                   '0 0de Sondag Son So'],\n                ['DDD DDDo DDDD',                      '45 45ste 045'],\n                ['w wo ww',                            '6 6de 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'nm NM'],\n                ['[the] DDDo [day of the year]',       'the 45ste day of the year'],\n                ['LT',                                 '15:25'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 Februarie 2010'],\n                ['LLL',                                '14 Februarie 2010 15:25'],\n                ['LLLL',                               'Sondag, 14 Februarie 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Feb 2010'],\n                ['lll',                                '14 Feb 2010 15:25'],\n                ['llll',                               'Son, 14 Feb 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ste', '1ste');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2de', '2de');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3de', '3de');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4de', '4de');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5de', '5de');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6de', '6de');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7de', '7de');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ste', '8ste');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9de', '9de');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10de', '10de');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11de', '11de');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12de', '12de');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13de', '13de');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14de', '14de');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15de', '15de');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16de', '16de');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17de', '17de');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18de', '18de');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19de', '19de');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ste', '20ste');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ste', '21ste');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ste', '22ste');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ste', '23ste');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ste', '24ste');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ste', '25ste');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ste', '26ste');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ste', '27ste');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ste', '28ste');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ste', '29ste');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ste', '30ste');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ste', '31ste');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Januarie Jan_Februarie Feb_Maart Mar_April Apr_Mei Mei_Junie Jun_Julie Jul_Augustus Aug_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Sondag Son So_Maandag Maa Ma_Dinsdag Din Di_Woensdag Woe Wo_Donderdag Don Do_Vrydag Vry Vr_Saterdag Sat Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\\'n paar sekondes', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\\'n minuut',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\\'n minuut',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minute',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\\'n uur',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\\'n uur',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ure',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ure',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ure',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\\'n dag',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\\'n dag',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dae',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\\'n dag',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dae',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dae',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\\'n maand',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\\'n maand',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\\'n maand',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 maande',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 maande',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 maande',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\\'n maand',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 maande',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\\'n jaar',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jaar',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\\'n jaar',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jaar',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'oor \\'n paar sekondes',  'prefix');\n        assert.equal(moment(0).from(30000), '\\'n paar sekondes gelede', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\\'n paar sekondes gelede',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'oor \\'n paar sekondes', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'oor 5 dae', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Vandag om 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Vandag om 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Vandag om 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'M\u00c3\u00b4re om 12:00',       'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Vandag om 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Gister om 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[Laas] dddd [om] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[Laas] dddd [om] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[Laas] dddd [om] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ste', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1ste', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1ste', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),    '2 02 2de', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),    '2 02 2de', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ar-ma');\n\n    test('parse', function (assert) {\n        var tests = '\u00d9\u008a\u00d9\u0086\u00d8\u00a7\u00d9\u008a\u00d8\u00b1:\u00d9\u008a\u00d9\u0086\u00d8\u00a7\u00d9\u008a\u00d8\u00b1_\u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1:\u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1_\u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3:\u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3_\u00d8\u00a3\u00d8\u00a8\u00d8\u00b1\u00d9\u008a\u00d9\u0084:\u00d8\u00a3\u00d8\u00a8\u00d8\u00b1\u00d9\u008a\u00d9\u0084_\u00d9\u0085\u00d8\u00a7\u00d9\u008a:\u00d9\u0085\u00d8\u00a7\u00d9\u008a_\u00d9\u008a\u00d9\u0088\u00d9\u0086\u00d9\u008a\u00d9\u0088:\u00d9\u008a\u00d9\u0088\u00d9\u0086\u00d9\u008a\u00d9\u0088_\u00d9\u008a\u00d9\u0088\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d8\u00b2:\u00d9\u008a\u00d9\u0088\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d8\u00b2_\u00d8\u00ba\u00d8\u00b4\u00d8\u00aa:\u00d8\u00ba\u00d8\u00b4\u00d8\u00aa_\u00d8\u00b4\u00d8\u00aa\u00d9\u0086\u00d8\u00a8\u00d8\u00b1:\u00d8\u00b4\u00d8\u00aa\u00d9\u0086\u00d8\u00a8\u00d8\u00b1_\u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1:\u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1_\u00d9\u0086\u00d9\u0088\u00d9\u0086\u00d8\u00a8\u00d8\u00b1:\u00d9\u0086\u00d9\u0088\u00d9\u0086\u00d8\u00a8\u00d8\u00b1_\u00d8\u00af\u00d8\u00ac\u00d9\u0086\u00d8\u00a8\u00d8\u00b1:\u00d8\u00af\u00d8\u00ac\u00d9\u0086\u00d8\u00a8\u00d8\u00b1'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(':');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      '\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af, \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 14 2010, 3:25:50 pm'],\n                ['ddd, hA',                            '\u00d8\u00a7\u00d8\u00ad\u00d8\u00af, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 \u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00a7\u00d8\u00ad\u00d8\u00af \u00d8\u00ad'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '8 8 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45 day of the year'],\n                ['LT',                                 '15:25'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 2010'],\n                ['LLL',                                '14 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 2010 15:25'],\n                ['LLLL',                               '\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af 14 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 2010'],\n                ['lll',                                '14 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 2010 15:25'],\n                ['llll',                               '\u00d8\u00a7\u00d8\u00ad\u00d8\u00af 14 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d9\u008a\u00d9\u0086\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u008a\u00d9\u0086\u00d8\u00a7\u00d9\u008a\u00d8\u00b1_\u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1_\u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3 \u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3_\u00d8\u00a3\u00d8\u00a8\u00d8\u00b1\u00d9\u008a\u00d9\u0084 \u00d8\u00a3\u00d8\u00a8\u00d8\u00b1\u00d9\u008a\u00d9\u0084_\u00d9\u0085\u00d8\u00a7\u00d9\u008a \u00d9\u0085\u00d8\u00a7\u00d9\u008a_\u00d9\u008a\u00d9\u0088\u00d9\u0086\u00d9\u008a\u00d9\u0088 \u00d9\u008a\u00d9\u0088\u00d9\u0086\u00d9\u008a\u00d9\u0088_\u00d9\u008a\u00d9\u0088\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d8\u00b2 \u00d9\u008a\u00d9\u0088\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d8\u00b2_\u00d8\u00ba\u00d8\u00b4\u00d8\u00aa \u00d8\u00ba\u00d8\u00b4\u00d8\u00aa_\u00d8\u00b4\u00d8\u00aa\u00d9\u0086\u00d8\u00a8\u00d8\u00b1 \u00d8\u00b4\u00d8\u00aa\u00d9\u0086\u00d8\u00a8\u00d8\u00b1_\u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1 \u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1_\u00d9\u0086\u00d9\u0088\u00d9\u0086\u00d8\u00a8\u00d8\u00b1 \u00d9\u0086\u00d9\u0088\u00d9\u0086\u00d8\u00a8\u00d8\u00b1_\u00d8\u00af\u00d8\u00ac\u00d9\u0086\u00d8\u00a8\u00d8\u00b1 \u00d8\u00af\u00d8\u00ac\u00d9\u0086\u00d8\u00a8\u00d8\u00b1'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00a7\u00d8\u00ad\u00d8\u00af \u00d8\u00ad_\u00d8\u00a7\u00d9\u0084\u00d8\u00a5\u00d8\u00aa\u00d9\u0086\u00d9\u008a\u00d9\u0086 \u00d8\u00a7\u00d8\u00aa\u00d9\u0086\u00d9\u008a\u00d9\u0086 \u00d9\u0086_\u00d8\u00a7\u00d9\u0084\u00d8\u00ab\u00d9\u0084\u00d8\u00a7\u00d8\u00ab\u00d8\u00a7\u00d8\u00a1 \u00d8\u00ab\u00d9\u0084\u00d8\u00a7\u00d8\u00ab\u00d8\u00a7\u00d8\u00a1 \u00d8\u00ab_\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00b1\u00d8\u00a8\u00d8\u00b9\u00d8\u00a7\u00d8\u00a1 \u00d8\u00a7\u00d8\u00b1\u00d8\u00a8\u00d8\u00b9\u00d8\u00a7\u00d8\u00a1 \u00d8\u00b1_\u00d8\u00a7\u00d9\u0084\u00d8\u00ae\u00d9\u0085\u00d9\u008a\u00d8\u00b3 \u00d8\u00ae\u00d9\u0085\u00d9\u008a\u00d8\u00b3 \u00d8\u00ae_\u00d8\u00a7\u00d9\u0084\u00d8\u00ac\u00d9\u0085\u00d8\u00b9\u00d8\u00a9 \u00d8\u00ac\u00d9\u0085\u00d8\u00b9\u00d8\u00a9 \u00d8\u00ac_\u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a8\u00d8\u00aa \u00d8\u00b3\u00d8\u00a8\u00d8\u00aa \u00d8\u00b3'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d8\u00af\u00d9\u0082\u00d9\u008a\u00d9\u0082\u00d8\u00a9',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d8\u00af\u00d9\u0082\u00d9\u008a\u00d9\u0082\u00d8\u00a9',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d8\u00af\u00d9\u0082\u00d8\u00a7\u00d8\u00a6\u00d9\u0082',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d8\u00af\u00d9\u0082\u00d8\u00a7\u00d8\u00a6\u00d9\u0082',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a7\u00d8\u00aa',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a7\u00d8\u00aa',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a7\u00d8\u00aa',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d9\u008a\u00d9\u0088\u00d9\u0085',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d9\u008a\u00d9\u0088\u00d9\u0085',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d9\u008a\u00d9\u0088\u00d9\u0085',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d8\u00b3\u00d9\u0086\u00d8\u00a9',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00d8\u00b3\u00d9\u0086\u00d9\u0088\u00d8\u00a7\u00d8\u00aa',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d8\u00b3\u00d9\u0086\u00d8\u00a9',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d8\u00b3\u00d9\u0086\u00d9\u0088\u00d8\u00a7\u00d8\u00aa',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d9\u0081\u00d9\u008a \u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00d9\u0085\u00d9\u0086\u00d8\u00b0 \u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00d9\u0085\u00d9\u0086\u00d8\u00b0 \u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d9\u0081\u00d9\u008a \u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00d9\u0081\u00d9\u008a 5 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d8\u00ba\u00d8\u00af\u00d8\u00a7 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 12:00',      'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d8\u00a3\u00d9\u0085\u00d8\u00b3 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '1 01 1', 'Dec 31 2011 should be week 1');\n        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '1 01 1', 'Jan  6 2012 should be week 1');\n        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 should be week 2');\n        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '2 02 2', 'Jan 13 2012 should be week 2');\n        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ar-sa');\n\n    test('parse', function (assert) {\n        var tests = '\u00d9\u008a\u00d9\u0086\u00d8\u00a7\u00d9\u008a\u00d8\u00b1:\u00d9\u008a\u00d9\u0086\u00d8\u00a7\u00d9\u008a\u00d8\u00b1_\u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1:\u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1_\u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3:\u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3_\u00d8\u00a3\u00d8\u00a8\u00d8\u00b1\u00d9\u008a\u00d9\u0084:\u00d8\u00a3\u00d8\u00a8\u00d8\u00b1\u00d9\u008a\u00d9\u0084_\u00d9\u0085\u00d8\u00a7\u00d9\u008a\u00d9\u0088:\u00d9\u0085\u00d8\u00a7\u00d9\u008a\u00d9\u0088_\u00d9\u008a\u00d9\u0088\u00d9\u0086\u00d9\u008a\u00d9\u0088:\u00d9\u008a\u00d9\u0088\u00d9\u0086\u00d9\u008a\u00d9\u0088_\u00d9\u008a\u00d9\u0088\u00d9\u0084\u00d9\u008a\u00d9\u0088:\u00d9\u008a\u00d9\u0088\u00d9\u0084\u00d9\u008a\u00d9\u0088_\u00d8\u00a3\u00d8\u00ba\u00d8\u00b3\u00d8\u00b7\u00d8\u00b3:\u00d8\u00a3\u00d8\u00ba\u00d8\u00b3\u00d8\u00b7\u00d8\u00b3_\u00d8\u00b3\u00d8\u00a8\u00d8\u00aa\u00d9\u0085\u00d8\u00a8\u00d8\u00b1:\u00d8\u00b3\u00d8\u00a8\u00d8\u00aa\u00d9\u0085\u00d8\u00a8\u00d8\u00b1_\u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1:\u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1_\u00d9\u0086\u00d9\u0088\u00d9\u0081\u00d9\u0085\u00d8\u00a8\u00d8\u00b1:\u00d9\u0086\u00d9\u0088\u00d9\u0081\u00d9\u0085\u00d8\u00a8\u00d8\u00b1_\u00d8\u00af\u00d9\u008a\u00d8\u00b3\u00d9\u0085\u00d8\u00a8\u00d8\u00b1:\u00d8\u00af\u00d9\u008a\u00d8\u00b3\u00d9\u0085\u00d8\u00a8\u00d8\u00b1'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' instead is month ' + moment(input, mmm).month());\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(':');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      '\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af\u00d8\u008c \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a1\u00d9\u00a4 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0\u00d8\u008c \u00d9\u00a3:\u00d9\u00a2\u00d9\u00a5:\u00d9\u00a5\u00d9\u00a0 \u00d9\u0085'],\n                ['ddd, hA',                            '\u00d8\u00a3\u00d8\u00ad\u00d8\u00af\u00d8\u008c \u00d9\u00a3\u00d9\u0085'],\n                ['M Mo MM MMMM MMM',                   '\u00d9\u00a2 \u00d9\u00a2 \u00d9\u00a0\u00d9\u00a2 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1'],\n                ['YYYY YY',                            '\u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0 \u00d9\u00a1\u00d9\u00a0'],\n                ['D Do DD',                            '\u00d9\u00a1\u00d9\u00a4 \u00d9\u00a1\u00d9\u00a4 \u00d9\u00a1\u00d9\u00a4'],\n                ['d do dddd ddd dd',                   '\u00d9\u00a0 \u00d9\u00a0 \u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00ad'],\n                ['DDD DDDo DDDD',                      '\u00d9\u00a4\u00d9\u00a5 \u00d9\u00a4\u00d9\u00a5 \u00d9\u00a0\u00d9\u00a4\u00d9\u00a5'],\n                ['w wo ww',                            '\u00d9\u00a8 \u00d9\u00a8 \u00d9\u00a0\u00d9\u00a8'],\n                ['h hh',                               '\u00d9\u00a3 \u00d9\u00a0\u00d9\u00a3'],\n                ['H HH',                               '\u00d9\u00a1\u00d9\u00a5 \u00d9\u00a1\u00d9\u00a5'],\n                ['m mm',                               '\u00d9\u00a2\u00d9\u00a5 \u00d9\u00a2\u00d9\u00a5'],\n                ['s ss',                               '\u00d9\u00a5\u00d9\u00a0 \u00d9\u00a5\u00d9\u00a0'],\n                ['a A',                                '\u00d9\u0085 \u00d9\u0085'],\n                ['[the] DDDo [day of the year]',       'the \u00d9\u00a4\u00d9\u00a5 day of the year'],\n                ['LT',                                 '\u00d9\u00a1\u00d9\u00a5:\u00d9\u00a2\u00d9\u00a5'],\n                ['LTS',                                '\u00d9\u00a1\u00d9\u00a5:\u00d9\u00a2\u00d9\u00a5:\u00d9\u00a5\u00d9\u00a0'],\n                ['L',                                  '\u00d9\u00a1\u00d9\u00a4/\u00d9\u00a0\u00d9\u00a2/\u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0'],\n                ['LL',                                 '\u00d9\u00a1\u00d9\u00a4 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0'],\n                ['LLL',                                '\u00d9\u00a1\u00d9\u00a4 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0 \u00d9\u00a1\u00d9\u00a5:\u00d9\u00a2\u00d9\u00a5'],\n                ['LLLL',                               '\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d9\u00a1\u00d9\u00a4 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0 \u00d9\u00a1\u00d9\u00a5:\u00d9\u00a2\u00d9\u00a5'],\n                ['l',                                  '\u00d9\u00a1\u00d9\u00a4/\u00d9\u00a2/\u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0'],\n                ['ll',                                 '\u00d9\u00a1\u00d9\u00a4 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0'],\n                ['lll',                                '\u00d9\u00a1\u00d9\u00a4 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0 \u00d9\u00a1\u00d9\u00a5:\u00d9\u00a2\u00d9\u00a5'],\n                ['llll',                               '\u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d9\u00a1\u00d9\u00a4 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0 \u00d9\u00a1\u00d9\u00a5:\u00d9\u00a2\u00d9\u00a5']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '\u00d9\u00a1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '\u00d9\u00a2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '\u00d9\u00a3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '\u00d9\u00a4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '\u00d9\u00a5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '\u00d9\u00a6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '\u00d9\u00a7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '\u00d9\u00a8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '\u00d9\u00a9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a0', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a1', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a2', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a3', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a4', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a5', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a6', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a7', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a8', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a9', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a0', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a1', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a2', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a3', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a4', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a5', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a6', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a7', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a8', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a9', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '\u00d9\u00a3\u00d9\u00a0', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '\u00d9\u00a3\u00d9\u00a1', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d9\u008a\u00d9\u0086\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u008a\u00d9\u0086\u00d8\u00a7\u00d9\u008a\u00d8\u00b1_\u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1_\u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3 \u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3_\u00d8\u00a3\u00d8\u00a8\u00d8\u00b1\u00d9\u008a\u00d9\u0084 \u00d8\u00a3\u00d8\u00a8\u00d8\u00b1\u00d9\u008a\u00d9\u0084_\u00d9\u0085\u00d8\u00a7\u00d9\u008a\u00d9\u0088 \u00d9\u0085\u00d8\u00a7\u00d9\u008a\u00d9\u0088_\u00d9\u008a\u00d9\u0088\u00d9\u0086\u00d9\u008a\u00d9\u0088 \u00d9\u008a\u00d9\u0088\u00d9\u0086\u00d9\u008a\u00d9\u0088_\u00d9\u008a\u00d9\u0088\u00d9\u0084\u00d9\u008a\u00d9\u0088 \u00d9\u008a\u00d9\u0088\u00d9\u0084\u00d9\u008a\u00d9\u0088_\u00d8\u00a3\u00d8\u00ba\u00d8\u00b3\u00d8\u00b7\u00d8\u00b3 \u00d8\u00a3\u00d8\u00ba\u00d8\u00b3\u00d8\u00b7\u00d8\u00b3_\u00d8\u00b3\u00d8\u00a8\u00d8\u00aa\u00d9\u0085\u00d8\u00a8\u00d8\u00b1 \u00d8\u00b3\u00d8\u00a8\u00d8\u00aa\u00d9\u0085\u00d8\u00a8\u00d8\u00b1_\u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1 \u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1_\u00d9\u0086\u00d9\u0088\u00d9\u0081\u00d9\u0085\u00d8\u00a8\u00d8\u00b1 \u00d9\u0086\u00d9\u0088\u00d9\u0081\u00d9\u0085\u00d8\u00a8\u00d8\u00b1_\u00d8\u00af\u00d9\u008a\u00d8\u00b3\u00d9\u0085\u00d8\u00a8\u00d8\u00b1 \u00d8\u00af\u00d9\u008a\u00d8\u00b3\u00d9\u0085\u00d8\u00a8\u00d8\u00b1'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00ad_\u00d8\u00a7\u00d9\u0084\u00d8\u00a5\u00d8\u00ab\u00d9\u0086\u00d9\u008a\u00d9\u0086 \u00d8\u00a5\u00d8\u00ab\u00d9\u0086\u00d9\u008a\u00d9\u0086 \u00d9\u0086_\u00d8\u00a7\u00d9\u0084\u00d8\u00ab\u00d9\u0084\u00d8\u00a7\u00d8\u00ab\u00d8\u00a7\u00d8\u00a1 \u00d8\u00ab\u00d9\u0084\u00d8\u00a7\u00d8\u00ab\u00d8\u00a7\u00d8\u00a1 \u00d8\u00ab_\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00b1\u00d8\u00a8\u00d8\u00b9\u00d8\u00a7\u00d8\u00a1 \u00d8\u00a3\u00d8\u00b1\u00d8\u00a8\u00d8\u00b9\u00d8\u00a7\u00d8\u00a1 \u00d8\u00b1_\u00d8\u00a7\u00d9\u0084\u00d8\u00ae\u00d9\u0085\u00d9\u008a\u00d8\u00b3 \u00d8\u00ae\u00d9\u0085\u00d9\u008a\u00d8\u00b3 \u00d8\u00ae_\u00d8\u00a7\u00d9\u0084\u00d8\u00ac\u00d9\u0085\u00d8\u00b9\u00d8\u00a9 \u00d8\u00ac\u00d9\u0085\u00d8\u00b9\u00d8\u00a9 \u00d8\u00ac_\u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a8\u00d8\u00aa \u00d8\u00b3\u00d8\u00a8\u00d8\u00aa \u00d8\u00b3'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d8\u00af\u00d9\u0082\u00d9\u008a\u00d9\u0082\u00d8\u00a9',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d8\u00af\u00d9\u0082\u00d9\u008a\u00d9\u0082\u00d8\u00a9',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '\u00d9\u00a2 \u00d8\u00af\u00d9\u0082\u00d8\u00a7\u00d8\u00a6\u00d9\u0082',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '\u00d9\u00a4\u00d9\u00a4 \u00d8\u00af\u00d9\u0082\u00d8\u00a7\u00d8\u00a6\u00d9\u0082',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00d9\u00a2 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a7\u00d8\u00aa',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '\u00d9\u00a5 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a7\u00d8\u00aa',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '\u00d9\u00a2\u00d9\u00a1 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a7\u00d8\u00aa',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d9\u008a\u00d9\u0088\u00d9\u0085',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d9\u008a\u00d9\u0088\u00d9\u0085',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00d9\u00a2 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d9\u008a\u00d9\u0088\u00d9\u0085',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '\u00d9\u00a5 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '\u00d9\u00a2\u00d9\u00a5 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '\u00d9\u00a2 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '\u00d9\u00a2 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '\u00d9\u00a3 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '\u00d9\u00a5 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d8\u00b3\u00d9\u0086\u00d8\u00a9',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00d9\u00a2 \u00d8\u00b3\u00d9\u0086\u00d9\u0088\u00d8\u00a7\u00d8\u00aa',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d8\u00b3\u00d9\u0086\u00d8\u00a9',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '\u00d9\u00a5 \u00d8\u00b3\u00d9\u0086\u00d9\u0088\u00d8\u00a7\u00d8\u00aa',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d9\u0081\u00d9\u008a \u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00d9\u0085\u00d9\u0086\u00d8\u00b0 \u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00d9\u0085\u00d9\u0086\u00d8\u00b0 \u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d9\u0081\u00d9\u008a \u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00d9\u0081\u00d9\u008a \u00d9\u00a5 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u00a1\u00d9\u00a2:\u00d9\u00a0\u00d9\u00a0',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u00a1\u00d9\u00a2:\u00d9\u00a2\u00d9\u00a5',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u00a1\u00d9\u00a3:\u00d9\u00a0\u00d9\u00a0',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d8\u00ba\u00d8\u00af\u00d8\u00a7 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u00a1\u00d9\u00a2:\u00d9\u00a0\u00d9\u00a0',       'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u00a1\u00d9\u00a1:\u00d9\u00a0\u00d9\u00a0',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d8\u00a3\u00d9\u0085\u00d8\u00b3 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u00a1\u00d9\u00a2:\u00d9\u00a0\u00d9\u00a0',      'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting wednesday custom', function (assert) {\n        assert.equal(moment('2003 1 6', 'gggg w d').format('YYYY-MM-DD'), '\u00d9\u00a2\u00d9\u00a0\u00d9\u00a0\u00d9\u00a2-\u00d9\u00a1\u00d9\u00a2-\u00d9\u00a2\u00d9\u00a8', 'Week 1 of 2003 should be Dec 28 2002');\n        assert.equal(moment('2003 1 0', 'gggg w e').format('YYYY-MM-DD'), '\u00d9\u00a2\u00d9\u00a0\u00d9\u00a0\u00d9\u00a2-\u00d9\u00a1\u00d9\u00a2-\u00d9\u00a2\u00d9\u00a8', 'Week 1 of 2003 should be Dec 28 2002');\n        assert.equal(moment('2003 1 6', 'gggg w d').format('gggg w d'), '\u00d9\u00a2\u00d9\u00a0\u00d9\u00a0\u00d9\u00a3 \u00d9\u00a1 \u00d9\u00a6', 'Saturday of week 1 of 2003 parsed should be formatted as 2003 1 6');\n        assert.equal(moment('2003 1 0', 'gggg w e').format('gggg w e'), '\u00d9\u00a2\u00d9\u00a0\u00d9\u00a0\u00d9\u00a3 \u00d9\u00a1 \u00d9\u00a0', '1st day of week 1 of 2003 parsed should be formatted as 2003 1 0');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '\u00d9\u00a1 \u00d9\u00a0\u00d9\u00a1 \u00d9\u00a1', 'Dec 31 2011 should be week 1');\n        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '\u00d9\u00a1 \u00d9\u00a0\u00d9\u00a1 \u00d9\u00a1', 'Jan  6 2012 should be week 1');\n        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '\u00d9\u00a2 \u00d9\u00a0\u00d9\u00a2 \u00d9\u00a2', 'Jan  7 2012 should be week 2');\n        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '\u00d9\u00a2 \u00d9\u00a0\u00d9\u00a2 \u00d9\u00a2', 'Jan 13 2012 should be week 2');\n        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '\u00d9\u00a3 \u00d9\u00a0\u00d9\u00a3 \u00d9\u00a3', 'Jan 14 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ar-tn');\n\n    test('parse', function (assert) {\n        var tests = '\u00d8\u00ac\u00d8\u00a7\u00d9\u0086\u00d9\u0081\u00d9\u008a:\u00d8\u00ac\u00d8\u00a7\u00d9\u0086\u00d9\u0081\u00d9\u008a_\u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a:\u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a_\u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3:\u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3_\u00d8\u00a3\u00d9\u0081\u00d8\u00b1\u00d9\u008a\u00d9\u0084:\u00d8\u00a3\u00d9\u0081\u00d8\u00b1\u00d9\u008a\u00d9\u0084_\u00d9\u0085\u00d8\u00a7\u00d9\u008a:\u00d9\u0085\u00d8\u00a7\u00d9\u008a_\u00d8\u00ac\u00d9\u0088\u00d8\u00a7\u00d9\u0086:\u00d8\u00ac\u00d9\u0088\u00d8\u00a7\u00d9\u0086_\u00d8\u00ac\u00d9\u0088\u00d9\u008a\u00d9\u0084\u00d9\u008a\u00d8\u00a9:\u00d8\u00ac\u00d9\u0088\u00d9\u008a\u00d9\u0084\u00d9\u008a\u00d8\u00a9_\u00d8\u00a3\u00d9\u0088\u00d8\u00aa:\u00d8\u00a3\u00d9\u0088\u00d8\u00aa_\u00d8\u00b3\u00d8\u00a8\u00d8\u00aa\u00d9\u0085\u00d8\u00a8\u00d8\u00b1:\u00d8\u00b3\u00d8\u00a8\u00d8\u00aa\u00d9\u0085\u00d8\u00a8\u00d8\u00b1_\u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1:\u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1_\u00d9\u0086\u00d9\u0088\u00d9\u0081\u00d9\u0085\u00d8\u00a8\u00d8\u00b1:\u00d9\u0086\u00d9\u0088\u00d9\u0081\u00d9\u0085\u00d8\u00a8\u00d8\u00b1_\u00d8\u00af\u00d9\u008a\u00d8\u00b3\u00d9\u0085\u00d8\u00a8\u00d8\u00b1:\u00d8\u00af\u00d9\u008a\u00d8\u00b3\u00d9\u0085\u00d8\u00a8\u00d8\u00b1'.split('_'),\n            i;\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(':');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a', '\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af, \u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a 14 2010, 3:25:50 pm'],\n                ['ddd, hA', '\u00d8\u00a3\u00d8\u00ad\u00d8\u00af, 3PM'],\n                ['M Mo MM MMMM MMM', '2 2 02 \u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a \u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a'],\n                ['YYYY YY', '2010 10'],\n                ['D Do DD', '14 14 14'],\n                ['d do dddd ddd dd', '0 0 \u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00ad'],\n                ['DDD DDDo DDDD', '45 45 045'],\n                ['w wo ww', '6 6 06'],\n                ['h hh', '3 03'],\n                ['H HH', '15 15'],\n                ['m mm', '25 25'],\n                ['s ss', '50 50'],\n                ['a A', 'pm PM'],\n                ['[the] DDDo [day of the year]', 'the 45 day of the year'],\n                ['LT', '15:25'],\n                ['LTS', '15:25:50'],\n                ['L', '14/02/2010'],\n                ['LL', '14 \u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a 2010'],\n                ['LLL', '14 \u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a 2010 15:25'],\n                ['LLLL', '\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af 14 \u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a 2010 15:25'],\n                ['l', '14/2/2010'],\n                ['ll', '14 \u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a 2010'],\n                ['lll', '14 \u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a 2010 15:25'],\n                ['llll', '\u00d8\u00a3\u00d8\u00ad\u00d8\u00af 14 \u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d8\u00ac\u00d8\u00a7\u00d9\u0086\u00d9\u0081\u00d9\u008a \u00d8\u00ac\u00d8\u00a7\u00d9\u0086\u00d9\u0081\u00d9\u008a_\u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a \u00d9\u0081\u00d9\u008a\u00d9\u0081\u00d8\u00b1\u00d9\u008a_\u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3 \u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3_\u00d8\u00a3\u00d9\u0081\u00d8\u00b1\u00d9\u008a\u00d9\u0084 \u00d8\u00a3\u00d9\u0081\u00d8\u00b1\u00d9\u008a\u00d9\u0084_\u00d9\u0085\u00d8\u00a7\u00d9\u008a \u00d9\u0085\u00d8\u00a7\u00d9\u008a_\u00d8\u00ac\u00d9\u0088\u00d8\u00a7\u00d9\u0086 \u00d8\u00ac\u00d9\u0088\u00d8\u00a7\u00d9\u0086_\u00d8\u00ac\u00d9\u0088\u00d9\u008a\u00d9\u0084\u00d9\u008a\u00d8\u00a9 \u00d8\u00ac\u00d9\u0088\u00d9\u008a\u00d9\u0084\u00d9\u008a\u00d8\u00a9_\u00d8\u00a3\u00d9\u0088\u00d8\u00aa \u00d8\u00a3\u00d9\u0088\u00d8\u00aa_\u00d8\u00b3\u00d8\u00a8\u00d8\u00aa\u00d9\u0085\u00d8\u00a8\u00d8\u00b1 \u00d8\u00b3\u00d8\u00a8\u00d8\u00aa\u00d9\u0085\u00d8\u00a8\u00d8\u00b1_\u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1 \u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1_\u00d9\u0086\u00d9\u0088\u00d9\u0081\u00d9\u0085\u00d8\u00a8\u00d8\u00b1 \u00d9\u0086\u00d9\u0088\u00d9\u0081\u00d9\u0085\u00d8\u00a8\u00d8\u00b1_\u00d8\u00af\u00d9\u008a\u00d8\u00b3\u00d9\u0085\u00d8\u00a8\u00d8\u00b1 \u00d8\u00af\u00d9\u008a\u00d8\u00b3\u00d9\u0085\u00d8\u00a8\u00d8\u00b1'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00ad_\u00d8\u00a7\u00d9\u0084\u00d8\u00a5\u00d8\u00ab\u00d9\u0086\u00d9\u008a\u00d9\u0086 \u00d8\u00a5\u00d8\u00ab\u00d9\u0086\u00d9\u008a\u00d9\u0086 \u00d9\u0086_\u00d8\u00a7\u00d9\u0084\u00d8\u00ab\u00d9\u0084\u00d8\u00a7\u00d8\u00ab\u00d8\u00a7\u00d8\u00a1 \u00d8\u00ab\u00d9\u0084\u00d8\u00a7\u00d8\u00ab\u00d8\u00a7\u00d8\u00a1 \u00d8\u00ab_\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00b1\u00d8\u00a8\u00d8\u00b9\u00d8\u00a7\u00d8\u00a1 \u00d8\u00a3\u00d8\u00b1\u00d8\u00a8\u00d8\u00b9\u00d8\u00a7\u00d8\u00a1 \u00d8\u00b1_\u00d8\u00a7\u00d9\u0084\u00d8\u00ae\u00d9\u0085\u00d9\u008a\u00d8\u00b3 \u00d8\u00ae\u00d9\u0085\u00d9\u008a\u00d8\u00b3 \u00d8\u00ae_\u00d8\u00a7\u00d9\u0084\u00d8\u00ac\u00d9\u0085\u00d8\u00b9\u00d8\u00a9 \u00d8\u00ac\u00d9\u0085\u00d8\u00b9\u00d8\u00a9 \u00d8\u00ac_\u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a8\u00d8\u00aa \u00d8\u00b3\u00d8\u00a8\u00d8\u00aa \u00d8\u00b3'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            s: 44\n        }), true), '\u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            s: 45\n        }), true), '\u00d8\u00af\u00d9\u0082\u00d9\u008a\u00d9\u0082\u00d8\u00a9', '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            s: 89\n        }), true), '\u00d8\u00af\u00d9\u0082\u00d9\u008a\u00d9\u0082\u00d8\u00a9', '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            s: 90\n        }), true), '2 \u00d8\u00af\u00d9\u0082\u00d8\u00a7\u00d8\u00a6\u00d9\u0082', '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            m: 44\n        }), true), '44 \u00d8\u00af\u00d9\u0082\u00d8\u00a7\u00d8\u00a6\u00d9\u0082', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            m: 45\n        }), true), '\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9', '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            m: 89\n        }), true), '\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9', '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            m: 90\n        }), true), '2 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a7\u00d8\u00aa', '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            h: 5\n        }), true), '5 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a7\u00d8\u00aa', '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            h: 21\n        }), true), '21 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a7\u00d8\u00aa', '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            h: 22\n        }), true), '\u00d9\u008a\u00d9\u0088\u00d9\u0085', '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            h: 35\n        }), true), '\u00d9\u008a\u00d9\u0088\u00d9\u0085', '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            h: 36\n        }), true), '2 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085', '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 1\n        }), true), '\u00d9\u008a\u00d9\u0088\u00d9\u0085', '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 5\n        }), true), '5 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085', '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 25\n        }), true), '25 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085', '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 26\n        }), true), '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1', '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 30\n        }), true), '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1', '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 43\n        }), true), '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1', '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 46\n        }), true), '2 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1', '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 74\n        }), true), '2 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1', '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 76\n        }), true), '3 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1', '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            M: 1\n        }), true), '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1', '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            M: 5\n        }), true), '5 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1', '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 345\n        }), true), '\u00d8\u00b3\u00d9\u0086\u00d8\u00a9', '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 548\n        }), true), '2 \u00d8\u00b3\u00d9\u0086\u00d9\u0088\u00d8\u00a7\u00d8\u00aa', '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            y: 1\n        }), true), '\u00d8\u00b3\u00d9\u0086\u00d8\u00a9', '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            y: 5\n        }), true), '5 \u00d8\u00b3\u00d9\u0086\u00d9\u0088\u00d8\u00a7\u00d8\u00aa', '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d9\u0081\u00d9\u008a \u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086', 'prefix');\n        assert.equal(moment(0).from(30000), '\u00d9\u0085\u00d9\u0086\u00d8\u00b0 \u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00d9\u0085\u00d9\u0086\u00d8\u00b0 \u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086', 'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({\n            s: 30\n        }).fromNow(), '\u00d9\u0081\u00d9\u008a \u00d8\u00ab\u00d9\u0088\u00d8\u00a7\u00d9\u0086', 'in a few seconds');\n        assert.equal(moment().add({\n            d: 5\n        }).fromNow(), '\u00d9\u0081\u00d9\u008a 5 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                  '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 12:00', 'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),     '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 12:25', 'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),      '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 13:00', 'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),      '\u00d8\u00ba\u00d8\u00af\u00d8\u00a7 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(), '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 11:00', 'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(), '\u00d8\u00a3\u00d9\u0085\u00d8\u00b3 \u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({\n                d: i\n            });\n            assert.equal(m.calendar(), m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'), 'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'), 'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'), 'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({\n                d: i\n            });\n            assert.equal(m.calendar(), m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'), 'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'), 'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format('dddd [\u00d8\u00b9\u00d9\u0084\u00d9\u0089 \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'), 'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({\n                w: 1\n            }),\n            weeksFromNow = moment().add({\n                w: 1\n            });\n\n        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');\n        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');\n\n        weeksAgo = moment().subtract({\n            w: 2\n        });\n        weeksFromNow = moment().add({\n            w: 2\n        });\n\n        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ar');\n\n    var months = [\n        '\u00d9\u0083\u00d8\u00a7\u00d9\u0086\u00d9\u0088\u00d9\u0086 \u00d8\u00a7\u00d9\u0084\u00d8\u00ab\u00d8\u00a7\u00d9\u0086\u00d9\u008a \u00d9\u008a\u00d9\u0086\u00d8\u00a7\u00d9\u008a\u00d8\u00b1',\n        '\u00d8\u00b4\u00d8\u00a8\u00d8\u00a7\u00d8\u00b7 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1',\n        '\u00d8\u00a2\u00d8\u00b0\u00d8\u00a7\u00d8\u00b1 \u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3',\n        '\u00d9\u0086\u00d9\u008a\u00d8\u00b3\u00d8\u00a7\u00d9\u0086 \u00d8\u00a3\u00d8\u00a8\u00d8\u00b1\u00d9\u008a\u00d9\u0084',\n        '\u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d8\u00b1 \u00d9\u0085\u00d8\u00a7\u00d9\u008a\u00d9\u0088',\n        '\u00d8\u00ad\u00d8\u00b2\u00d9\u008a\u00d8\u00b1\u00d8\u00a7\u00d9\u0086 \u00d9\u008a\u00d9\u0088\u00d9\u0086\u00d9\u008a\u00d9\u0088',\n        '\u00d8\u00aa\u00d9\u0085\u00d9\u0088\u00d8\u00b2 \u00d9\u008a\u00d9\u0088\u00d9\u0084\u00d9\u008a\u00d9\u0088',\n        '\u00d8\u00a2\u00d8\u00a8 \u00d8\u00a3\u00d8\u00ba\u00d8\u00b3\u00d8\u00b7\u00d8\u00b3',\n        '\u00d8\u00a3\u00d9\u008a\u00d9\u0084\u00d9\u0088\u00d9\u0084 \u00d8\u00b3\u00d8\u00a8\u00d8\u00aa\u00d9\u0085\u00d8\u00a8\u00d8\u00b1',\n        '\u00d8\u00aa\u00d8\u00b4\u00d8\u00b1\u00d9\u008a\u00d9\u0086 \u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d9\u0088\u00d9\u0084 \u00d8\u00a3\u00d9\u0083\u00d8\u00aa\u00d9\u0088\u00d8\u00a8\u00d8\u00b1',\n        '\u00d8\u00aa\u00d8\u00b4\u00d8\u00b1\u00d9\u008a\u00d9\u0086 \u00d8\u00a7\u00d9\u0084\u00d8\u00ab\u00d8\u00a7\u00d9\u0086\u00d9\u008a \u00d9\u0086\u00d9\u0088\u00d9\u0081\u00d9\u0085\u00d8\u00a8\u00d8\u00b1',\n        '\u00d9\u0083\u00d8\u00a7\u00d9\u0086\u00d9\u0088\u00d9\u0086 \u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d9\u0088\u00d9\u0084 \u00d8\u00af\u00d9\u008a\u00d8\u00b3\u00d9\u0085\u00d8\u00a8\u00d8\u00b1'\n    ];\n\n    test('parse', function (assert) {\n        var tests = months, i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' instead is month ' + moment(input, mmm).month());\n        }\n        for (i = 0; i < 12; i++) {\n            equalTest(tests[i], 'MMM', i);\n            equalTest(tests[i], 'MMM', i);\n            equalTest(tests[i], 'MMMM', i);\n            equalTest(tests[i], 'MMMM', i);\n            equalTest(tests[i].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      '\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af\u00d8\u008c \u00d8\u00b4\u00d8\u00a8\u00d8\u00a7\u00d8\u00b7 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a1\u00d9\u00a4 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0\u00d8\u008c \u00d9\u00a3:\u00d9\u00a2\u00d9\u00a5:\u00d9\u00a5\u00d9\u00a0 \u00d9\u0085'],\n                ['ddd, hA',                            '\u00d8\u00a3\u00d8\u00ad\u00d8\u00af\u00d8\u008c \u00d9\u00a3\u00d9\u0085'],\n                ['M Mo MM MMMM MMM',                   '\u00d9\u00a2 \u00d9\u00a2 \u00d9\u00a0\u00d9\u00a2 \u00d8\u00b4\u00d8\u00a8\u00d8\u00a7\u00d8\u00b7 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d8\u00b4\u00d8\u00a8\u00d8\u00a7\u00d8\u00b7 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1'],\n                ['YYYY YY',                            '\u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0 \u00d9\u00a1\u00d9\u00a0'],\n                ['D Do DD',                            '\u00d9\u00a1\u00d9\u00a4 \u00d9\u00a1\u00d9\u00a4 \u00d9\u00a1\u00d9\u00a4'],\n                ['d do dddd ddd dd',                   '\u00d9\u00a0 \u00d9\u00a0 \u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00ad'],\n                ['DDD DDDo DDDD',                      '\u00d9\u00a4\u00d9\u00a5 \u00d9\u00a4\u00d9\u00a5 \u00d9\u00a0\u00d9\u00a4\u00d9\u00a5'],\n                ['w wo ww',                            '\u00d9\u00a8 \u00d9\u00a8 \u00d9\u00a0\u00d9\u00a8'],\n                ['h hh',                               '\u00d9\u00a3 \u00d9\u00a0\u00d9\u00a3'],\n                ['H HH',                               '\u00d9\u00a1\u00d9\u00a5 \u00d9\u00a1\u00d9\u00a5'],\n                ['m mm',                               '\u00d9\u00a2\u00d9\u00a5 \u00d9\u00a2\u00d9\u00a5'],\n                ['s ss',                               '\u00d9\u00a5\u00d9\u00a0 \u00d9\u00a5\u00d9\u00a0'],\n                ['a A',                                '\u00d9\u0085 \u00d9\u0085'],\n                ['[the] DDDo [day of the year]',       'the \u00d9\u00a4\u00d9\u00a5 day of the year'],\n                ['LT',                                 '\u00d9\u00a1\u00d9\u00a5:\u00d9\u00a2\u00d9\u00a5'],\n                ['LTS',                                '\u00d9\u00a1\u00d9\u00a5:\u00d9\u00a2\u00d9\u00a5:\u00d9\u00a5\u00d9\u00a0'],\n                ['L',                                  '\u00d9\u00a1\u00d9\u00a4/\\u200f\u00d9\u00a2/\\u200f\u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0'],\n                ['LL',                                 '\u00d9\u00a1\u00d9\u00a4 \u00d8\u00b4\u00d8\u00a8\u00d8\u00a7\u00d8\u00b7 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0'],\n                ['LLL',                                '\u00d9\u00a1\u00d9\u00a4 \u00d8\u00b4\u00d8\u00a8\u00d8\u00a7\u00d8\u00b7 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0 \u00d9\u00a1\u00d9\u00a5:\u00d9\u00a2\u00d9\u00a5'],\n                ['LLLL',                               '\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d9\u00a1\u00d9\u00a4 \u00d8\u00b4\u00d8\u00a8\u00d8\u00a7\u00d8\u00b7 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0 \u00d9\u00a1\u00d9\u00a5:\u00d9\u00a2\u00d9\u00a5'],\n                ['l',                                  '\u00d9\u00a1\u00d9\u00a4/\\u200f\u00d9\u00a2/\\u200f\u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0'],\n                ['ll',                                 '\u00d9\u00a1\u00d9\u00a4 \u00d8\u00b4\u00d8\u00a8\u00d8\u00a7\u00d8\u00b7 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0'],\n                ['lll',                                '\u00d9\u00a1\u00d9\u00a4 \u00d8\u00b4\u00d8\u00a8\u00d8\u00a7\u00d8\u00b7 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0 \u00d9\u00a1\u00d9\u00a5:\u00d9\u00a2\u00d9\u00a5'],\n                ['llll',                               '\u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d9\u00a1\u00d9\u00a4 \u00d8\u00b4\u00d8\u00a8\u00d8\u00a7\u00d8\u00b7 \u00d9\u0081\u00d8\u00a8\u00d8\u00b1\u00d8\u00a7\u00d9\u008a\u00d8\u00b1 \u00d9\u00a2\u00d9\u00a0\u00d9\u00a1\u00d9\u00a0 \u00d9\u00a1\u00d9\u00a5:\u00d9\u00a2\u00d9\u00a5']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '\u00d9\u00a1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '\u00d9\u00a2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '\u00d9\u00a3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '\u00d9\u00a4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '\u00d9\u00a5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '\u00d9\u00a6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '\u00d9\u00a7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '\u00d9\u00a8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '\u00d9\u00a9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a0', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a1', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a2', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a3', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a4', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a5', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a6', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a7', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a8', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00d9\u00a1\u00d9\u00a9', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a0', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a1', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a2', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a3', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a4', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a5', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a6', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a7', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a8', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '\u00d9\u00a2\u00d9\u00a9', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '\u00d9\u00a3\u00d9\u00a0', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '\u00d9\u00a3\u00d9\u00a1', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = months, i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM'), expected[i], expected[i]);\n            assert.equal(moment([2011, i, 1]).format('MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00a3\u00d8\u00ad\u00d8\u00af \u00d8\u00ad_\u00d8\u00a7\u00d9\u0084\u00d8\u00a5\u00d8\u00ab\u00d9\u0086\u00d9\u008a\u00d9\u0086 \u00d8\u00a5\u00d8\u00ab\u00d9\u0086\u00d9\u008a\u00d9\u0086 \u00d9\u0086_\u00d8\u00a7\u00d9\u0084\u00d8\u00ab\u00d9\u0084\u00d8\u00a7\u00d8\u00ab\u00d8\u00a7\u00d8\u00a1 \u00d8\u00ab\u00d9\u0084\u00d8\u00a7\u00d8\u00ab\u00d8\u00a7\u00d8\u00a1 \u00d8\u00ab_\u00d8\u00a7\u00d9\u0084\u00d8\u00a3\u00d8\u00b1\u00d8\u00a8\u00d8\u00b9\u00d8\u00a7\u00d8\u00a1 \u00d8\u00a3\u00d8\u00b1\u00d8\u00a8\u00d8\u00b9\u00d8\u00a7\u00d8\u00a1 \u00d8\u00b1_\u00d8\u00a7\u00d9\u0084\u00d8\u00ae\u00d9\u0085\u00d9\u008a\u00d8\u00b3 \u00d8\u00ae\u00d9\u0085\u00d9\u008a\u00d8\u00b3 \u00d8\u00ae_\u00d8\u00a7\u00d9\u0084\u00d8\u00ac\u00d9\u0085\u00d8\u00b9\u00d8\u00a9 \u00d8\u00ac\u00d9\u0085\u00d8\u00b9\u00d8\u00a9 \u00d8\u00ac_\u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a8\u00d8\u00aa \u00d8\u00b3\u00d8\u00a8\u00d8\u00aa \u00d8\u00b3'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d9\u00a4\u00d9\u00a4 \u00d8\u00ab\u00d8\u00a7\u00d9\u0086\u00d9\u008a\u00d8\u00a9', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d8\u00af\u00d9\u0082\u00d9\u008a\u00d9\u0082\u00d8\u00a9 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af\u00d8\u00a9',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d8\u00af\u00d9\u0082\u00d9\u008a\u00d9\u0082\u00d8\u00a9 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af\u00d8\u00a9',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '\u00d8\u00af\u00d9\u0082\u00d9\u008a\u00d9\u0082\u00d8\u00aa\u00d8\u00a7\u00d9\u0086',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '\u00d9\u00a4\u00d9\u00a4 \u00d8\u00af\u00d9\u0082\u00d9\u008a\u00d9\u0082\u00d8\u00a9',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af\u00d8\u00a9',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af\u00d8\u00a9',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa\u00d8\u00a7\u00d9\u0086',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '\u00d9\u00a5 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a7\u00d8\u00aa',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '\u00d9\u00a2\u00d9\u00a1 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00d9\u008a\u00d9\u0088\u00d9\u0085\u00d8\u00a7\u00d9\u0086',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '\u00d9\u00a5 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '\u00d9\u00a2\u00d9\u00a5 \u00d9\u008a\u00d9\u0088\u00d9\u0085\u00d9\u008b\u00d8\u00a7',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1\u00d8\u00a7\u00d9\u0086',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1\u00d8\u00a7\u00d9\u0086',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '\u00d9\u00a3 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d8\u00b4\u00d9\u0087\u00d8\u00b1 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '\u00d9\u00a5 \u00d8\u00a3\u00d8\u00b4\u00d9\u0087\u00d8\u00b1',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d8\u00b9\u00d8\u00a7\u00d9\u0085 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00d8\u00b9\u00d8\u00a7\u00d9\u0085\u00d8\u00a7\u00d9\u0086',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d8\u00b9\u00d8\u00a7\u00d9\u0085 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '\u00d9\u00a5 \u00d8\u00a3\u00d8\u00b9\u00d9\u0088\u00d8\u00a7\u00d9\u0085',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d8\u00a8\u00d8\u00b9\u00d8\u00af \u00d9\u00a3\u00d9\u00a0 \u00d8\u00ab\u00d8\u00a7\u00d9\u0086\u00d9\u008a\u00d8\u00a9',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00d9\u0085\u00d9\u0086\u00d8\u00b0 \u00d9\u00a3\u00d9\u00a0 \u00d8\u00ab\u00d8\u00a7\u00d9\u0086\u00d9\u008a\u00d8\u00a9', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00d9\u0085\u00d9\u0086\u00d8\u00b0 \u00d8\u00ab\u00d8\u00a7\u00d9\u0086\u00d9\u008a\u00d8\u00a9 \u00d9\u0088\u00d8\u00a7\u00d8\u00ad\u00d8\u00af\u00d8\u00a9',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d8\u00a8\u00d8\u00b9\u00d8\u00af \u00d9\u00a3\u00d9\u00a0 \u00d8\u00ab\u00d8\u00a7\u00d9\u0086\u00d9\u008a\u00d8\u00a9', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00d8\u00a8\u00d8\u00b9\u00d8\u00af \u00d9\u00a5 \u00d8\u00a3\u00d9\u008a\u00d8\u00a7\u00d9\u0085', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0086\u00d8\u00af \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u00a1\u00d9\u00a2:\u00d9\u00a0\u00d9\u00a0',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0086\u00d8\u00af \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u00a1\u00d9\u00a2:\u00d9\u00a2\u00d9\u00a5',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0086\u00d8\u00af \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u00a1\u00d9\u00a3:\u00d9\u00a0\u00d9\u00a0',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d8\u00ba\u00d8\u00af\u00d9\u008b\u00d8\u00a7 \u00d8\u00b9\u00d9\u0086\u00d8\u00af \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u00a1\u00d9\u00a2:\u00d9\u00a0\u00d9\u00a0',      'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d8\u00a7\u00d9\u0084\u00d9\u008a\u00d9\u0088\u00d9\u0085 \u00d8\u00b9\u00d9\u0086\u00d8\u00af \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u00a1\u00d9\u00a1:\u00d9\u00a0\u00d9\u00a0',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d8\u00a3\u00d9\u0085\u00d8\u00b3 \u00d8\u00b9\u00d9\u0086\u00d8\u00af \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9 \u00d9\u00a1\u00d9\u00a2:\u00d9\u00a0\u00d9\u00a0',       'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0086\u00d8\u00af \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0086\u00d8\u00af \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0086\u00d8\u00af \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0086\u00d8\u00af \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0086\u00d8\u00af \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b9\u00d9\u0086\u00d8\u00af \u00d8\u00a7\u00d9\u0084\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00a9] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting wednesday custom', function (assert) {\n        assert.equal(moment('2003 1 6', 'gggg w d').format('YYYY-MM-DD'), '\u00d9\u00a2\u00d9\u00a0\u00d9\u00a0\u00d9\u00a2-\u00d9\u00a1\u00d9\u00a2-\u00d9\u00a2\u00d9\u00a8', 'Week 1 of 2003 should be Dec 28 2002');\n        assert.equal(moment('2003 1 0', 'gggg w e').format('YYYY-MM-DD'), '\u00d9\u00a2\u00d9\u00a0\u00d9\u00a0\u00d9\u00a2-\u00d9\u00a1\u00d9\u00a2-\u00d9\u00a2\u00d9\u00a8', 'Week 1 of 2003 should be Dec 28 2002');\n        assert.equal(moment('2003 1 6', 'gggg w d').format('gggg w d'), '\u00d9\u00a2\u00d9\u00a0\u00d9\u00a0\u00d9\u00a3 \u00d9\u00a1 \u00d9\u00a6', 'Saturday of week 1 of 2003 parsed should be formatted as 2003 1 6');\n        assert.equal(moment('2003 1 0', 'gggg w e').format('gggg w e'), '\u00d9\u00a2\u00d9\u00a0\u00d9\u00a0\u00d9\u00a3 \u00d9\u00a1 \u00d9\u00a0', '1st day of week 1 of 2003 parsed should be formatted as 2003 1 0');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '\u00d9\u00a1 \u00d9\u00a0\u00d9\u00a1 \u00d9\u00a1', 'Dec 31 2011 should be week 1');\n        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '\u00d9\u00a1 \u00d9\u00a0\u00d9\u00a1 \u00d9\u00a1', 'Jan  6 2012 should be week 1');\n        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '\u00d9\u00a2 \u00d9\u00a0\u00d9\u00a2 \u00d9\u00a2', 'Jan  7 2012 should be week 2');\n        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '\u00d9\u00a2 \u00d9\u00a0\u00d9\u00a2 \u00d9\u00a2', 'Jan 13 2012 should be week 2');\n        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '\u00d9\u00a3 \u00d9\u00a0\u00d9\u00a3 \u00d9\u00a3', 'Jan 14 2012 should be week 3');\n    });\n\n    test('no leading zeros in long date formats', function (assert) {\n        var i, j, longDateStr, shortDateStr;\n        for (i = 1; i <= 9; ++i) {\n            for (j = 1; j <= 9; ++j) {\n                longDateStr = moment([2014, i, j]).format('L');\n                shortDateStr = moment([2014, i, j]).format('l');\n                assert.equal(longDateStr, shortDateStr, 'should not have leading zeros in month or day');\n            }\n        }\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('az');\n\n    test('parse', function (assert) {\n        var tests = 'yanvar yan_fevral fev_mart mar_Aprel apr_may may_iyun iyn_iyul iyl_Avqust avq_sentyabr sen_oktyabr okt_noyabr noy_dekabr dek'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, D MMMM YYYY, HH:mm:ss',        'Bazar, 14 fevral 2010, 15:25:50'],\n                ['ddd, A h',                           'Baz, g\u00c3\u00bcnd\u00c3\u00bcz 3'],\n                ['M Mo MM MMMM MMM',                   '2 2-nci 02 fevral fev'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14-\u00c3\u00bcnc\u00c3\u00bc 14'],\n                ['d do dddd ddd dd',                   '0 0-\u00c4\u00b1nc\u00c4\u00b1 Bazar Baz Bz'],\n                ['DDD DDDo DDDD',                      '45 45-inci 045'],\n                ['w wo ww',                            '7 7-nci 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'g\u00c3\u00bcnd\u00c3\u00bcz g\u00c3\u00bcnd\u00c3\u00bcz'],\n                ['[ilin] DDDo [g\u00c3\u00bcn\u00c3\u00bc]',                 'ilin 45-inci g\u00c3\u00bcn\u00c3\u00bc'],\n                ['LT',                                 '15:25'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 fevral 2010'],\n                ['LLL',                                '14 fevral 2010 15:25'],\n                ['LLLL',                               'Bazar, 14 fevral 2010 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 fev 2010'],\n                ['lll',                                '14 fev 2010 15:25'],\n                ['llll',                               'Baz, 14 fev 2010 15:25']\n            ],\n            DDDo = [\n                [359, '360-\u00c4\u00b1nc\u00c4\u00b1'],\n                [199, '200-\u00c3\u00bcnc\u00c3\u00bc'],\n                [149, '150-nci']\n            ],\n            dt = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            DDDoDt,\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(dt.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n        for (i = 0; i < DDDo.length; i++) {\n            DDDoDt = moment([2010]);\n            assert.equal(DDDoDt.add(DDDo[i][0], 'days').format('DDDo'), DDDo[i][1], DDDo[i][0] + ' ---> ' + DDDo[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-inci', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-nci', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-\u00c3\u00bcnc\u00c3\u00bc', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-\u00c3\u00bcnc\u00c3\u00bc', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-inci', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-nc\u00c4\u00b1', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-nci', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-inci', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-uncu', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-uncu', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-inci', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-nci', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-\u00c3\u00bcnc\u00c3\u00bc', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-\u00c3\u00bcnc\u00c3\u00bc', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-inci', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-nc\u00c4\u00b1', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-nci', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-inci', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-uncu', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-nci', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-inci', '21th');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-nci', '22th');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-\u00c3\u00bcnc\u00c3\u00bc', '23th');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-\u00c3\u00bcnc\u00c3\u00bc', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-inci', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-nc\u00c4\u00b1', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-nci', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-inci', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-uncu', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-uncu', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-inci', '31st');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'yanvar yan_fevral fev_mart mar_aprel apr_may may_iyun iyn_iyul iyl_avqust avq_sentyabr sen_oktyabr okt_noyabr noy_dekabr dek'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Bazar Baz Bz_Bazar ert\u00c9\u0099si BzE BE_\u00c3\u0087\u00c9\u0099r\u00c5\u009f\u00c9\u0099nb\u00c9\u0099 ax\u00c5\u009fam\u00c4\u00b1 \u00c3\u0087Ax \u00c3\u0087A_\u00c3\u0087\u00c9\u0099r\u00c5\u009f\u00c9\u0099nb\u00c9\u0099 \u00c3\u0087\u00c9\u0099r \u00c3\u0087\u00c9\u0099_C\u00c3\u00bcm\u00c9\u0099 ax\u00c5\u009fam\u00c4\u00b1 CAx CA_C\u00c3\u00bcm\u00c9\u0099 C\u00c3\u00bcm C\u00c3\u00bc_\u00c5\u009e\u00c9\u0099nb\u00c9\u0099 \u00c5\u009e\u00c9\u0099n \u00c5\u009e\u00c9\u0099'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'birne\u00c3\u00a7\u00c9\u0099 saniyy\u00c9\u0099', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'bir d\u00c9\u0099qiq\u00c9\u0099',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'bir d\u00c9\u0099qiq\u00c9\u0099',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 d\u00c9\u0099qiq\u00c9\u0099',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 d\u00c9\u0099qiq\u00c9\u0099',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'bir saat',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'bir saat',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 saat',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 saat',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 saat',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'bir g\u00c3\u00bcn',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'bir g\u00c3\u00bcn',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 g\u00c3\u00bcn',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'bir g\u00c3\u00bcn',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 g\u00c3\u00bcn',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 g\u00c3\u00bcn',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'bir ay',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'bir ay',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ay',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ay',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ay',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'bir ay',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ay',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'bir il',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 il',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'bir il',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 il',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'birne\u00c3\u00a7\u00c9\u0099 saniyy\u00c9\u0099 sonra',  'prefix');\n        assert.equal(moment(0).from(30000), 'birne\u00c3\u00a7\u00c9\u0099 saniyy\u00c9\u0099 \u00c9\u0099vv\u00c9\u0099l', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'birne\u00c3\u00a7\u00c9\u0099 saniyy\u00c9\u0099 \u00c9\u0099vv\u00c9\u0099l',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'birne\u00c3\u00a7\u00c9\u0099 saniyy\u00c9\u0099 sonra', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 g\u00c3\u00bcn sonra', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'bug\u00c3\u00bcn saat 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'bug\u00c3\u00bcn saat 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'bug\u00c3\u00bcn saat 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'sabah saat 12:00',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'bug\u00c3\u00bcn saat 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'd\u00c3\u00bcn\u00c9\u0099n 12:00',          'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[g\u00c9\u0099l\u00c9\u0099n h\u00c9\u0099ft\u00c9\u0099] dddd [saat] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[g\u00c9\u0099l\u00c9\u0099n h\u00c9\u0099ft\u00c9\u0099] dddd [saat] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[g\u00c9\u0099l\u00c9\u0099n h\u00c9\u0099ft\u00c9\u0099] dddd [saat] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[ke\u00c3\u00a7\u00c9\u0099n h\u00c9\u0099ft\u00c9\u0099] dddd [saat] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[ke\u00c3\u00a7\u00c9\u0099n h\u00c9\u0099ft\u00c9\u0099] dddd [saat] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[ke\u00c3\u00a7\u00c9\u0099n h\u00c9\u0099ft\u00c9\u0099] dddd [saat] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-inci', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-inci', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-nci', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-nci', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-\u00c3\u00bcnc\u00c3\u00bc', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('be');\n\n    test('parse', function (assert) {\n        var tests = '\u00d1\u0081\u00d1\u0082\u00d1\u0083\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0081\u00d1\u0082\u00d1\u0083\u00d0\u00b4_\u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d1\u008b \u00d0\u00bb\u00d1\u008e\u00d1\u0082_\u00d1\u0081\u00d0\u00b0\u00d0\u00ba\u00d0\u00b0\u00d0\u00b2\u00d1\u0096\u00d0\u00ba \u00d1\u0081\u00d0\u00b0\u00d0\u00ba_\u00d0\u00ba\u00d1\u0080\u00d0\u00b0\u00d1\u0081\u00d0\u00b0\u00d0\u00b2\u00d1\u0096\u00d0\u00ba \u00d0\u00ba\u00d1\u0080\u00d0\u00b0\u00d1\u0081_\u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00b2_\u00d1\u0087\u00d1\u008d\u00d1\u0080\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0087\u00d1\u008d\u00d1\u0080\u00d0\u00b2_\u00d0\u00bb\u00d1\u0096\u00d0\u00bf\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00bb\u00d1\u0096\u00d0\u00bf_\u00d0\u00b6\u00d0\u00bd\u00d1\u0096\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b6\u00d0\u00bd\u00d1\u0096\u00d0\u00b2_\u00d0\u00b2\u00d0\u00b5\u00d1\u0080\u00d0\u00b0\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b2\u00d0\u00b5\u00d1\u0080_\u00d0\u00ba\u00d0\u00b0\u00d1\u0081\u00d1\u0082\u00d1\u0080\u00d1\u008b\u00d1\u0087\u00d0\u00bd\u00d1\u0096\u00d0\u00ba \u00d0\u00ba\u00d0\u00b0\u00d1\u0081\u00d1\u0082_\u00d0\u00bb\u00d1\u0096\u00d1\u0081\u00d1\u0082\u00d0\u00b0\u00d0\u00bf\u00d0\u00b0\u00d0\u00b4 \u00d0\u00bb\u00d1\u0096\u00d1\u0081\u00d1\u0082_\u00d1\u0081\u00d0\u00bd\u00d0\u00b5\u00d0\u00b6\u00d0\u00b0\u00d0\u00bd\u00d1\u008c \u00d1\u0081\u00d0\u00bd\u00d0\u00b5\u00d0\u00b6'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, HH:mm:ss',       '\u00d0\u00bd\u00d1\u008f\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bb\u00d1\u008f, 14-\u00d0\u00b3\u00d0\u00b0 \u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00b0\u00d0\u00b3\u00d0\u00b0 2010, 15:25:50'],\n                ['ddd, h A',                           '\u00d0\u00bd\u00d0\u00b4, 3 \u00d0\u00b4\u00d0\u00bd\u00d1\u008f'],\n                ['M Mo MM MMMM MMM',                   '2 2-\u00d1\u0096 02 \u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d1\u008b \u00d0\u00bb\u00d1\u008e\u00d1\u0082'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14-\u00d0\u00b3\u00d0\u00b0 14'],\n                ['d do dddd ddd dd',                   '0 0-\u00d1\u008b \u00d0\u00bd\u00d1\u008f\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bb\u00d1\u008f \u00d0\u00bd\u00d0\u00b4 \u00d0\u00bd\u00d0\u00b4'],\n                ['DDD DDDo DDDD',                      '45 45-\u00d1\u008b 045'],\n                ['w wo ww',                            '7 7-\u00d1\u008b 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00d0\u00b4\u00d0\u00bd\u00d1\u008f \u00d0\u00b4\u00d0\u00bd\u00d1\u008f'],\n                ['DDDo [\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b0]',                   '45-\u00d1\u008b \u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b0'],\n                ['LT',                                 '15:25'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 \u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00b0\u00d0\u00b3\u00d0\u00b0 2010 \u00d0\u00b3.'],\n                ['LLL',                                '14 \u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00b0\u00d0\u00b3\u00d0\u00b0 2010 \u00d0\u00b3., 15:25'],\n                ['LLLL',                               '\u00d0\u00bd\u00d1\u008f\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bb\u00d1\u008f, 14 \u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00b0\u00d0\u00b3\u00d0\u00b0 2010 \u00d0\u00b3., 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 \u00d0\u00bb\u00d1\u008e\u00d1\u0082 2010 \u00d0\u00b3.'],\n                ['lll',                                '14 \u00d0\u00bb\u00d1\u008e\u00d1\u0082 2010 \u00d0\u00b3., 15:25'],\n                ['llll',                               '\u00d0\u00bd\u00d0\u00b4, 14 \u00d0\u00bb\u00d1\u008e\u00d1\u0082 2010 \u00d0\u00b3., 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format meridiem', function (assert) {\n        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), '\u00d0\u00bd\u00d0\u00be\u00d1\u0087\u00d1\u008b', 'night');\n        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), '\u00d0\u00bd\u00d0\u00be\u00d1\u0087\u00d1\u008b', 'night');\n        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), '\u00d1\u0080\u00d0\u00b0\u00d0\u00bd\u00d1\u0096\u00d1\u0086\u00d1\u008b', 'morning');\n        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), '\u00d1\u0080\u00d0\u00b0\u00d0\u00bd\u00d1\u0096\u00d1\u0086\u00d1\u008b', 'morning');\n        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), '\u00d0\u00b4\u00d0\u00bd\u00d1\u008f', 'afternoon');\n        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), '\u00d0\u00b4\u00d0\u00bd\u00d1\u008f', 'afternoon');\n        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), '\u00d0\u00b2\u00d0\u00b5\u00d1\u0087\u00d0\u00b0\u00d1\u0080\u00d0\u00b0', 'evening');\n        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), '\u00d0\u00b2\u00d0\u00b5\u00d1\u0087\u00d0\u00b0\u00d1\u0080\u00d0\u00b0', 'evening');\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-\u00d1\u008b', '1-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-\u00d1\u0096', '2-\u00d1\u0096');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-\u00d1\u0096', '3-\u00d1\u0096');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-\u00d1\u008b', '4-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-\u00d1\u008b', '5-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-\u00d1\u008b', '6-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-\u00d1\u008b', '7-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-\u00d1\u008b', '8-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-\u00d1\u008b', '9-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-\u00d1\u008b', '10-\u00d1\u008b');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-\u00d1\u008b', '11-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-\u00d1\u008b', '12-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-\u00d1\u008b', '13-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-\u00d1\u008b', '14-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-\u00d1\u008b', '15-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-\u00d1\u008b', '16-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-\u00d1\u008b', '17-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-\u00d1\u008b', '18-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-\u00d1\u008b', '19-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-\u00d1\u008b', '20-\u00d1\u008b');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-\u00d1\u008b', '21-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-\u00d1\u0096', '22-\u00d1\u0096');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-\u00d1\u0096', '23-\u00d1\u0096');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-\u00d1\u008b', '24-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-\u00d1\u008b', '25-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-\u00d1\u008b', '26-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-\u00d1\u008b', '27-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-\u00d1\u008b', '28-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-\u00d1\u008b', '29-\u00d1\u008b');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-\u00d1\u008b', '30-\u00d1\u008b');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-\u00d1\u008b', '31-\u00d1\u008b');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d1\u0081\u00d1\u0082\u00d1\u0083\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0081\u00d1\u0082\u00d1\u0083\u00d0\u00b4_\u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d1\u008b \u00d0\u00bb\u00d1\u008e\u00d1\u0082_\u00d1\u0081\u00d0\u00b0\u00d0\u00ba\u00d0\u00b0\u00d0\u00b2\u00d1\u0096\u00d0\u00ba \u00d1\u0081\u00d0\u00b0\u00d0\u00ba_\u00d0\u00ba\u00d1\u0080\u00d0\u00b0\u00d1\u0081\u00d0\u00b0\u00d0\u00b2\u00d1\u0096\u00d0\u00ba \u00d0\u00ba\u00d1\u0080\u00d0\u00b0\u00d1\u0081_\u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00b2_\u00d1\u0087\u00d1\u008d\u00d1\u0080\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0087\u00d1\u008d\u00d1\u0080\u00d0\u00b2_\u00d0\u00bb\u00d1\u0096\u00d0\u00bf\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00bb\u00d1\u0096\u00d0\u00bf_\u00d0\u00b6\u00d0\u00bd\u00d1\u0096\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b6\u00d0\u00bd\u00d1\u0096\u00d0\u00b2_\u00d0\u00b2\u00d0\u00b5\u00d1\u0080\u00d0\u00b0\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b2\u00d0\u00b5\u00d1\u0080_\u00d0\u00ba\u00d0\u00b0\u00d1\u0081\u00d1\u0082\u00d1\u0080\u00d1\u008b\u00d1\u0087\u00d0\u00bd\u00d1\u0096\u00d0\u00ba \u00d0\u00ba\u00d0\u00b0\u00d1\u0081\u00d1\u0082_\u00d0\u00bb\u00d1\u0096\u00d1\u0081\u00d1\u0082\u00d0\u00b0\u00d0\u00bf\u00d0\u00b0\u00d0\u00b4 \u00d0\u00bb\u00d1\u0096\u00d1\u0081\u00d1\u0082_\u00d1\u0081\u00d0\u00bd\u00d0\u00b5\u00d0\u00b6\u00d0\u00b0\u00d0\u00bd\u00d1\u008c \u00d1\u0081\u00d0\u00bd\u00d0\u00b5\u00d0\u00b6'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format month case', function (assert) {\n        var months = {\n            'nominative': '\u00d1\u0081\u00d1\u0082\u00d1\u0083\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d1\u008b_\u00d1\u0081\u00d0\u00b0\u00d0\u00ba\u00d0\u00b0\u00d0\u00b2\u00d1\u0096\u00d0\u00ba_\u00d0\u00ba\u00d1\u0080\u00d0\u00b0\u00d1\u0081\u00d0\u00b0\u00d0\u00b2\u00d1\u0096\u00d0\u00ba_\u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d1\u0087\u00d1\u008d\u00d1\u0080\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00bb\u00d1\u0096\u00d0\u00bf\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00b6\u00d0\u00bd\u00d1\u0096\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00b2\u00d0\u00b5\u00d1\u0080\u00d0\u00b0\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00ba\u00d0\u00b0\u00d1\u0081\u00d1\u0082\u00d1\u0080\u00d1\u008b\u00d1\u0087\u00d0\u00bd\u00d1\u0096\u00d0\u00ba_\u00d0\u00bb\u00d1\u0096\u00d1\u0081\u00d1\u0082\u00d0\u00b0\u00d0\u00bf\u00d0\u00b0\u00d0\u00b4_\u00d1\u0081\u00d0\u00bd\u00d0\u00b5\u00d0\u00b6\u00d0\u00b0\u00d0\u00bd\u00d1\u008c'.split('_'),\n            'accusative': '\u00d1\u0081\u00d1\u0082\u00d1\u0083\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008f_\u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00b0\u00d0\u00b3\u00d0\u00b0_\u00d1\u0081\u00d0\u00b0\u00d0\u00ba\u00d0\u00b0\u00d0\u00b2\u00d1\u0096\u00d0\u00ba\u00d0\u00b0_\u00d0\u00ba\u00d1\u0080\u00d0\u00b0\u00d1\u0081\u00d0\u00b0\u00d0\u00b2\u00d1\u0096\u00d0\u00ba\u00d0\u00b0_\u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d1\u009e\u00d0\u00bd\u00d1\u008f_\u00d1\u0087\u00d1\u008d\u00d1\u0080\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008f_\u00d0\u00bb\u00d1\u0096\u00d0\u00bf\u00d0\u00b5\u00d0\u00bd\u00d1\u008f_\u00d0\u00b6\u00d0\u00bd\u00d1\u0096\u00d1\u009e\u00d0\u00bd\u00d1\u008f_\u00d0\u00b2\u00d0\u00b5\u00d1\u0080\u00d0\u00b0\u00d1\u0081\u00d0\u00bd\u00d1\u008f_\u00d0\u00ba\u00d0\u00b0\u00d1\u0081\u00d1\u0082\u00d1\u0080\u00d1\u008b\u00d1\u0087\u00d0\u00bd\u00d1\u0096\u00d0\u00ba\u00d0\u00b0_\u00d0\u00bb\u00d1\u0096\u00d1\u0081\u00d1\u0082\u00d0\u00b0\u00d0\u00bf\u00d0\u00b0\u00d0\u00b4\u00d0\u00b0_\u00d1\u0081\u00d0\u00bd\u00d0\u00b5\u00d0\u00b6\u00d0\u00bd\u00d1\u008f'.split('_')\n        }, i;\n        for (i = 0; i < 12; i++) {\n            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);\n            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);\n        }\n    });\n\n    test('format month case with escaped symbols', function (assert) {\n        var months = {\n            'nominative': '\u00d1\u0081\u00d1\u0082\u00d1\u0083\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d1\u008b_\u00d1\u0081\u00d0\u00b0\u00d0\u00ba\u00d0\u00b0\u00d0\u00b2\u00d1\u0096\u00d0\u00ba_\u00d0\u00ba\u00d1\u0080\u00d0\u00b0\u00d1\u0081\u00d0\u00b0\u00d0\u00b2\u00d1\u0096\u00d0\u00ba_\u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d1\u0087\u00d1\u008d\u00d1\u0080\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00bb\u00d1\u0096\u00d0\u00bf\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00b6\u00d0\u00bd\u00d1\u0096\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00b2\u00d0\u00b5\u00d1\u0080\u00d0\u00b0\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00ba\u00d0\u00b0\u00d1\u0081\u00d1\u0082\u00d1\u0080\u00d1\u008b\u00d1\u0087\u00d0\u00bd\u00d1\u0096\u00d0\u00ba_\u00d0\u00bb\u00d1\u0096\u00d1\u0081\u00d1\u0082\u00d0\u00b0\u00d0\u00bf\u00d0\u00b0\u00d0\u00b4_\u00d1\u0081\u00d0\u00bd\u00d0\u00b5\u00d0\u00b6\u00d0\u00b0\u00d0\u00bd\u00d1\u008c'.split('_'),\n            'accusative': '\u00d1\u0081\u00d1\u0082\u00d1\u0083\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008f_\u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00b0\u00d0\u00b3\u00d0\u00b0_\u00d1\u0081\u00d0\u00b0\u00d0\u00ba\u00d0\u00b0\u00d0\u00b2\u00d1\u0096\u00d0\u00ba\u00d0\u00b0_\u00d0\u00ba\u00d1\u0080\u00d0\u00b0\u00d1\u0081\u00d0\u00b0\u00d0\u00b2\u00d1\u0096\u00d0\u00ba\u00d0\u00b0_\u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d1\u009e\u00d0\u00bd\u00d1\u008f_\u00d1\u0087\u00d1\u008d\u00d1\u0080\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008f_\u00d0\u00bb\u00d1\u0096\u00d0\u00bf\u00d0\u00b5\u00d0\u00bd\u00d1\u008f_\u00d0\u00b6\u00d0\u00bd\u00d1\u0096\u00d1\u009e\u00d0\u00bd\u00d1\u008f_\u00d0\u00b2\u00d0\u00b5\u00d1\u0080\u00d0\u00b0\u00d1\u0081\u00d0\u00bd\u00d1\u008f_\u00d0\u00ba\u00d0\u00b0\u00d1\u0081\u00d1\u0082\u00d1\u0080\u00d1\u008b\u00d1\u0087\u00d0\u00bd\u00d1\u0096\u00d0\u00ba\u00d0\u00b0_\u00d0\u00bb\u00d1\u0096\u00d1\u0081\u00d1\u0082\u00d0\u00b0\u00d0\u00bf\u00d0\u00b0\u00d0\u00b4\u00d0\u00b0_\u00d1\u0081\u00d0\u00bd\u00d0\u00b5\u00d0\u00b6\u00d0\u00bd\u00d1\u008f'.split('_')\n        }, i;\n        for (i = 0; i < 12; i++) {\n            assert.equal(moment([2013, i, 1]).format('D[] MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);\n            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMMM[</b>]'), '<i>1</i> <b>' + months.accusative[i] + '</b>', '1 <b>' + months.accusative[i] + '</b>');\n            assert.equal(moment([2013, i, 1]).format('D[-\u00d1\u008b \u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c] MMMM'), '1-\u00d1\u008b \u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c ' + months.accusative[i], '1-\u00d1\u008b \u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c ' + months.accusative[i]);\n            assert.equal(moment([2013, i, 1]).format('D, MMMM'), '1, ' + months.nominative[i], '1, ' + months.nominative[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d0\u00bd\u00d1\u008f\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bb\u00d1\u008f \u00d0\u00bd\u00d0\u00b4 \u00d0\u00bd\u00d0\u00b4_\u00d0\u00bf\u00d0\u00b0\u00d0\u00bd\u00d1\u008f\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bb\u00d0\u00b0\u00d0\u00ba \u00d0\u00bf\u00d0\u00bd \u00d0\u00bf\u00d0\u00bd_\u00d0\u00b0\u00d1\u009e\u00d1\u0082\u00d0\u00be\u00d1\u0080\u00d0\u00b0\u00d0\u00ba \u00d0\u00b0\u00d1\u0082 \u00d0\u00b0\u00d1\u0082_\u00d1\u0081\u00d0\u00b5\u00d1\u0080\u00d0\u00b0\u00d0\u00b4\u00d0\u00b0 \u00d1\u0081\u00d1\u0080 \u00d1\u0081\u00d1\u0080_\u00d1\u0087\u00d0\u00b0\u00d1\u0086\u00d0\u00b2\u00d0\u00b5\u00d1\u0080 \u00d1\u0087\u00d1\u0086 \u00d1\u0087\u00d1\u0086_\u00d0\u00bf\u00d1\u008f\u00d1\u0082\u00d0\u00bd\u00d1\u0096\u00d1\u0086\u00d0\u00b0 \u00d0\u00bf\u00d1\u0082 \u00d0\u00bf\u00d1\u0082_\u00d1\u0081\u00d1\u0083\u00d0\u00b1\u00d0\u00be\u00d1\u0082\u00d0\u00b0 \u00d1\u0081\u00d0\u00b1 \u00d1\u0081\u00d0\u00b1'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00bb\u00d1\u008c\u00d0\u00ba\u00d1\u0096 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4',    '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d1\u0085\u00d0\u00b2\u00d1\u0096\u00d0\u00bb\u00d1\u0096\u00d0\u00bd\u00d0\u00b0',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d1\u0085\u00d0\u00b2\u00d1\u0096\u00d0\u00bb\u00d1\u0096\u00d0\u00bd\u00d0\u00b0',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d1\u0085\u00d0\u00b2\u00d1\u0096\u00d0\u00bb\u00d1\u0096\u00d0\u00bd\u00d1\u008b',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 31}), true),  '31 \u00d1\u0085\u00d0\u00b2\u00d1\u0096\u00d0\u00bb\u00d1\u0096\u00d0\u00bd\u00d0\u00b0',  '31 minutes = 31 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d1\u0085\u00d0\u00b2\u00d1\u0096\u00d0\u00bb\u00d1\u0096\u00d0\u00bd\u00d1\u008b', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d0\u00b3\u00d0\u00b0\u00d0\u00b4\u00d0\u00b7\u00d1\u0096\u00d0\u00bd\u00d0\u00b0',    '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d0\u00b3\u00d0\u00b0\u00d0\u00b4\u00d0\u00b7\u00d1\u0096\u00d0\u00bd\u00d0\u00b0',    '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00d0\u00b3\u00d0\u00b0\u00d0\u00b4\u00d0\u00b7\u00d1\u0096\u00d0\u00bd\u00d1\u008b',    '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d0\u00b3\u00d0\u00b0\u00d0\u00b4\u00d0\u00b7\u00d1\u0096\u00d0\u00bd',    '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d0\u00b3\u00d0\u00b0\u00d0\u00b4\u00d0\u00b7\u00d1\u0096\u00d0\u00bd\u00d0\u00b0',   '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00d0\u00b4\u00d0\u00bd\u00d1\u0096',     '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d0\u00b4\u00d0\u00b7\u00d1\u0091\u00d0\u00bd',     '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 \u00d0\u00b4\u00d0\u00b7\u00d1\u0091\u00d0\u00bd',     '11 days = 11 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 \u00d0\u00b4\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c',     '21 days = 21 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d0\u00b4\u00d0\u00b7\u00d1\u0091\u00d0\u00bd',    '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d1\u008b',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d1\u008b',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d1\u008b',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d0\u00b0\u00d1\u009e',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d0\u00b3\u00d0\u00be\u00d0\u00b4',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00d0\u00b3\u00d0\u00b0\u00d0\u00b4\u00d1\u008b',    '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d0\u00b3\u00d0\u00be\u00d0\u00b4',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d0\u00b3\u00d0\u00b0\u00d0\u00b4\u00d0\u00be\u00d1\u009e',    '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d0\u00bf\u00d1\u0080\u00d0\u00b0\u00d0\u00b7 \u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00bb\u00d1\u008c\u00d0\u00ba\u00d1\u0096 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4', 'prefix');\n        assert.equal(moment(0).from(30000), '\u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00bb\u00d1\u008c\u00d0\u00ba\u00d1\u0096 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 \u00d1\u0082\u00d0\u00b0\u00d0\u00bc\u00d1\u0083', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d0\u00bf\u00d1\u0080\u00d0\u00b0\u00d0\u00b7 \u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00bb\u00d1\u008c\u00d0\u00ba\u00d1\u0096 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00d0\u00bf\u00d1\u0080\u00d0\u00b0\u00d0\u00b7 5 \u00d0\u00b4\u00d0\u00b7\u00d1\u0091\u00d0\u00bd', 'in 5 days');\n        assert.equal(moment().add({m: 31}).fromNow(), '\u00d0\u00bf\u00d1\u0080\u00d0\u00b0\u00d0\u00b7 31 \u00d1\u0085\u00d0\u00b2\u00d1\u0096\u00d0\u00bb\u00d1\u0096\u00d0\u00bd\u00d1\u0083', 'in 31 minutes = in 31 minutes');\n        assert.equal(moment().subtract({m: 31}).fromNow(), '31 \u00d1\u0085\u00d0\u00b2\u00d1\u0096\u00d0\u00bb\u00d1\u0096\u00d0\u00bd\u00d1\u0083 \u00d1\u0082\u00d0\u00b0\u00d0\u00bc\u00d1\u0083', '31 minutes ago = 31 minutes ago');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d0\u00a1\u00d1\u0091\u00d0\u00bd\u00d0\u00bd\u00d1\u008f \u00d1\u009e 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d0\u00a1\u00d1\u0091\u00d0\u00bd\u00d0\u00bd\u00d1\u008f \u00d1\u009e 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d0\u00a1\u00d1\u0091\u00d0\u00bd\u00d0\u00bd\u00d1\u008f \u00d1\u009e 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d0\u0097\u00d0\u00b0\u00d1\u009e\u00d1\u0082\u00d1\u0080\u00d0\u00b0 \u00d1\u009e 12:00',    'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d0\u00a1\u00d1\u0091\u00d0\u00bd\u00d0\u00bd\u00d1\u008f \u00d1\u009e 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d0\u00a3\u00d1\u0087\u00d0\u00be\u00d1\u0080\u00d0\u00b0 \u00d1\u009e 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        function makeFormat(d) {\n            return '[\u00d0\u00a3] dddd [\u00d1\u009e] LT';\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n            case 3:\n            case 5:\n            case 6:\n                return '[\u00d0\u00a3 \u00d0\u00bc\u00d1\u0096\u00d0\u00bd\u00d1\u0083\u00d0\u00bb\u00d1\u0083\u00d1\u008e] dddd [\u00d1\u009e] LT';\n            case 1:\n            case 2:\n            case 4:\n                return '[\u00d0\u00a3 \u00d0\u00bc\u00d1\u0096\u00d0\u00bd\u00d1\u0083\u00d0\u00bb\u00d1\u008b] dddd [\u00d1\u009e] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-\u00d1\u008b', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-\u00d1\u008b', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-\u00d1\u0096', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-\u00d1\u0096', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-\u00d1\u0096', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('bg');\n\n    test('parse', function (assert) {\n        var tests = '\u00d1\u008f\u00d0\u00bd\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 \u00d1\u008f\u00d0\u00bd\u00d1\u0080_\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2_\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b8\u00d0\u00bb \u00d0\u00b0\u00d0\u00bf\u00d1\u0080_\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9 \u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d1\u008e\u00d0\u00bd\u00d0\u00b8 \u00d1\u008e\u00d0\u00bd\u00d0\u00b8_\u00d1\u008e\u00d0\u00bb\u00d0\u00b8 \u00d1\u008e\u00d0\u00bb\u00d0\u00b8_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3_\u00d1\u0081\u00d0\u00b5\u00d0\u00bf\u00d1\u0082\u00d0\u00b5\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d1\u0081\u00d0\u00b5\u00d0\u00bf_\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d0\u00be\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d0\u00be\u00d0\u00ba\u00d1\u0082_\u00d0\u00bd\u00d0\u00be\u00d0\u00b5\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d0\u00bd\u00d0\u00be\u00d0\u00b5_\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b5\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, H:mm:ss',        '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d0\u00bb\u00d1\u008f, \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 14-\u00d1\u0082\u00d0\u00b8 2010, 15:25:50'],\n                ['ddd, hA',                            '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2-\u00d1\u0080\u00d0\u00b8 02 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14-\u00d1\u0082\u00d0\u00b8 14'],\n                ['d do dddd ddd dd',                   '0 0-\u00d0\u00b5\u00d0\u00b2 \u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d0\u00bb\u00d1\u008f \u00d0\u00bd\u00d0\u00b5\u00d0\u00b4 \u00d0\u00bd\u00d0\u00b4'],\n                ['DDD DDDo DDDD',                      '45 45-\u00d1\u0082\u00d0\u00b8 045'],\n                ['w wo ww',                            '7 7-\u00d0\u00bc\u00d0\u00b8 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45-\u00d1\u0082\u00d0\u00b8 day of the year'],\n                ['LT',                                 '15:25'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 2010'],\n                ['LLL',                                '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 2010 15:25'],\n                ['LLLL',                               '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d0\u00bb\u00d1\u008f, 14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 2010 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2 2010'],\n                ['lll',                                '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2 2010 15:25'],\n                ['llll',                               '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4, 14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-\u00d0\u00b2\u00d0\u00b8', '1-\u00d0\u00b2\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-\u00d1\u0080\u00d0\u00b8', '2-\u00d1\u0080\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-\u00d1\u0082\u00d0\u00b8', '3-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-\u00d1\u0082\u00d0\u00b8', '4-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-\u00d1\u0082\u00d0\u00b8', '5-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-\u00d1\u0082\u00d0\u00b8', '6-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-\u00d0\u00bc\u00d0\u00b8', '7-\u00d0\u00bc\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-\u00d0\u00bc\u00d0\u00b8', '8-\u00d0\u00bc\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-\u00d1\u0082\u00d0\u00b8', '9-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-\u00d1\u0082\u00d0\u00b8', '10-\u00d1\u0082\u00d0\u00b8');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-\u00d1\u0082\u00d0\u00b8', '11-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-\u00d1\u0082\u00d0\u00b8', '12-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-\u00d1\u0082\u00d0\u00b8', '13-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-\u00d1\u0082\u00d0\u00b8', '14-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-\u00d1\u0082\u00d0\u00b8', '15-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-\u00d1\u0082\u00d0\u00b8', '16-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-\u00d1\u0082\u00d0\u00b8', '17-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-\u00d1\u0082\u00d0\u00b8', '18-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-\u00d1\u0082\u00d0\u00b8', '19-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-\u00d1\u0082\u00d0\u00b8', '20-\u00d1\u0082\u00d0\u00b8');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-\u00d0\u00b2\u00d0\u00b8', '21-\u00d0\u00b2\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-\u00d1\u0080\u00d0\u00b8', '22-\u00d1\u0080\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-\u00d1\u0082\u00d0\u00b8', '23-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-\u00d1\u0082\u00d0\u00b8', '24-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-\u00d1\u0082\u00d0\u00b8', '25-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-\u00d1\u0082\u00d0\u00b8', '26-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-\u00d0\u00bc\u00d0\u00b8', '27-\u00d0\u00bc\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-\u00d0\u00bc\u00d0\u00b8', '28-\u00d0\u00bc\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-\u00d1\u0082\u00d0\u00b8', '29-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-\u00d1\u0082\u00d0\u00b8', '30-\u00d1\u0082\u00d0\u00b8');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-\u00d0\u00b2\u00d0\u00b8', '31-\u00d0\u00b2\u00d0\u00b8');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d1\u008f\u00d0\u00bd\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 \u00d1\u008f\u00d0\u00bd\u00d1\u0080_\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2_\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b8\u00d0\u00bb \u00d0\u00b0\u00d0\u00bf\u00d1\u0080_\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9 \u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d1\u008e\u00d0\u00bd\u00d0\u00b8 \u00d1\u008e\u00d0\u00bd\u00d0\u00b8_\u00d1\u008e\u00d0\u00bb\u00d0\u00b8 \u00d1\u008e\u00d0\u00bb\u00d0\u00b8_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3_\u00d1\u0081\u00d0\u00b5\u00d0\u00bf\u00d1\u0082\u00d0\u00b5\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d1\u0081\u00d0\u00b5\u00d0\u00bf_\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d0\u00be\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d0\u00be\u00d0\u00ba\u00d1\u0082_\u00d0\u00bd\u00d0\u00be\u00d0\u00b5\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d0\u00bd\u00d0\u00be\u00d0\u00b5_\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b5\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d0\u00bb\u00d1\u008f \u00d0\u00bd\u00d0\u00b5\u00d0\u00b4 \u00d0\u00bd\u00d0\u00b4_\u00d0\u00bf\u00d0\u00be\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d0\u00bb\u00d0\u00bd\u00d0\u00b8\u00d0\u00ba \u00d0\u00bf\u00d0\u00be\u00d0\u00bd \u00d0\u00bf\u00d0\u00bd_\u00d0\u00b2\u00d1\u0082\u00d0\u00be\u00d1\u0080\u00d0\u00bd\u00d0\u00b8\u00d0\u00ba \u00d0\u00b2\u00d1\u0082\u00d0\u00be \u00d0\u00b2\u00d1\u0082_\u00d1\u0081\u00d1\u0080\u00d1\u008f\u00d0\u00b4\u00d0\u00b0 \u00d1\u0081\u00d1\u0080\u00d1\u008f \u00d1\u0081\u00d1\u0080_\u00d1\u0087\u00d0\u00b5\u00d1\u0082\u00d0\u00b2\u00d1\u008a\u00d1\u0080\u00d1\u0082\u00d1\u008a\u00d0\u00ba \u00d1\u0087\u00d0\u00b5\u00d1\u0082 \u00d1\u0087\u00d1\u0082_\u00d0\u00bf\u00d0\u00b5\u00d1\u0082\u00d1\u008a\u00d0\u00ba \u00d0\u00bf\u00d0\u00b5\u00d1\u0082 \u00d0\u00bf\u00d1\u0082_\u00d1\u0081\u00d1\u008a\u00d0\u00b1\u00d0\u00be\u00d1\u0082\u00d0\u00b0 \u00d1\u0081\u00d1\u008a\u00d0\u00b1 \u00d1\u0081\u00d0\u00b1'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d0\u00bd\u00d1\u008f\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b0',          '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b0',          '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b8',        '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b8',       '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d1\u0087\u00d0\u00b0\u00d1\u0081',             '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d1\u0087\u00d0\u00b0\u00d1\u0081',             '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00d1\u0087\u00d0\u00b0\u00d1\u0081\u00d0\u00b0',          '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d1\u0087\u00d0\u00b0\u00d1\u0081\u00d0\u00b0',          '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d1\u0087\u00d0\u00b0\u00d1\u0081\u00d0\u00b0',         '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd',             '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd',             '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00d0\u00b4\u00d0\u00bd\u00d0\u00b8',           '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd',             '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d0\u00b4\u00d0\u00bd\u00d0\u00b8',           '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d0\u00b4\u00d0\u00bd\u00d0\u00b8',          '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086',           '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086',           '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086',           '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086\u00d0\u00b0',        '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086\u00d0\u00b0',        '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086\u00d0\u00b0',        '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086',           '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086\u00d0\u00b0',        '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d0\u00b0',          '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d0\u00b8',        '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d0\u00b0',          '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d0\u00b8',        '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d1\u0081\u00d0\u00bb\u00d0\u00b5\u00d0\u00b4 \u00d0\u00bd\u00d1\u008f\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00b4\u00d0\u00b8 \u00d0\u00bd\u00d1\u008f\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00b4\u00d0\u00b8 \u00d0\u00bd\u00d1\u008f\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d1\u0081\u00d0\u00bb\u00d0\u00b5\u00d0\u00b4 \u00d0\u00bd\u00d1\u008f\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00d1\u0081\u00d0\u00bb\u00d0\u00b5\u00d0\u00b4 5 \u00d0\u00b4\u00d0\u00bd\u00d0\u00b8', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d0\u0094\u00d0\u00bd\u00d0\u00b5\u00d1\u0081 \u00d0\u00b2 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d0\u0094\u00d0\u00bd\u00d0\u00b5\u00d1\u0081 \u00d0\u00b2 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d0\u0094\u00d0\u00bd\u00d0\u00b5\u00d1\u0081 \u00d0\u00b2 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d0\u00a3\u00d1\u0082\u00d1\u0080\u00d0\u00b5 \u00d0\u00b2 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d0\u0094\u00d0\u00bd\u00d0\u00b5\u00d1\u0081 \u00d0\u00b2 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d0\u0092\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b0 \u00d0\u00b2 12:00', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d0\u00b2] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d0\u00b2] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d0\u00b2] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n            case 3:\n            case 6:\n                return '[\u00d0\u0092 \u00d0\u00b8\u00d0\u00b7\u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d0\u00b0\u00d0\u00bb\u00d0\u00b0\u00d1\u0082\u00d0\u00b0] dddd [\u00d0\u00b2] LT';\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n                return '[\u00d0\u0092 \u00d0\u00b8\u00d0\u00b7\u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d0\u00b0\u00d0\u00bb\u00d0\u00b8\u00d1\u008f] dddd [\u00d0\u00b2] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-\u00d0\u00b2\u00d0\u00b8', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-\u00d0\u00b2\u00d0\u00b8', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-\u00d1\u0080\u00d0\u00b8', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-\u00d1\u0080\u00d0\u00b8', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-\u00d1\u0082\u00d0\u00b8', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('bn');\n\n    test('parse', function (assert) {\n        var tests = '\u00e0\u00a6\u009c\u00e0\u00a6\u00be\u00e0\u00a6\u00a8\u00e0\u00a7\u0081\u00e0\u00a7\u009f\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u0080 \u00e0\u00a6\u009c\u00e0\u00a6\u00be\u00e0\u00a6\u00a8\u00e0\u00a7\u0081_\u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac\u00e0\u00a7\u0081\u00e0\u00a7\u009f\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u0080 \u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac_\u00e0\u00a6\u00ae\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u008d\u00e0\u00a6\u009a \u00e0\u00a6\u00ae\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u008d\u00e0\u00a6\u009a_\u00e0\u00a6\u008f\u00e0\u00a6\u00aa\u00e0\u00a7\u008d\u00e0\u00a6\u00b0\u00e0\u00a6\u00bf\u00e0\u00a6\u00b2 \u00e0\u00a6\u008f\u00e0\u00a6\u00aa\u00e0\u00a6\u00b0_\u00e0\u00a6\u00ae\u00e0\u00a7\u0087 \u00e0\u00a6\u00ae\u00e0\u00a7\u0087_\u00e0\u00a6\u009c\u00e0\u00a7\u0081\u00e0\u00a6\u00a8 \u00e0\u00a6\u009c\u00e0\u00a7\u0081\u00e0\u00a6\u00a8_\u00e0\u00a6\u009c\u00e0\u00a7\u0081\u00e0\u00a6\u00b2\u00e0\u00a6\u00be\u00e0\u00a6\u0087 \u00e0\u00a6\u009c\u00e0\u00a7\u0081\u00e0\u00a6\u00b2_\u00e0\u00a6\u0085\u00e0\u00a6\u0097\u00e0\u00a6\u00be\u00e0\u00a6\u00b8\u00e0\u00a7\u008d\u00e0\u00a6\u009f \u00e0\u00a6\u0085\u00e0\u00a6\u0097_\u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u00aa\u00e0\u00a7\u008d\u00e0\u00a6\u009f\u00e0\u00a7\u0087\u00e0\u00a6\u00ae\u00e0\u00a7\u008d\u00e0\u00a6\u00ac\u00e0\u00a6\u00b0 \u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u00aa\u00e0\u00a7\u008d\u00e0\u00a6\u009f_\u00e0\u00a6\u0085\u00e0\u00a6\u0095\u00e0\u00a7\u008d\u00e0\u00a6\u009f\u00e0\u00a7\u008b\u00e0\u00a6\u00ac\u00e0\u00a6\u00b0 \u00e0\u00a6\u0085\u00e0\u00a6\u0095\u00e0\u00a7\u008d\u00e0\u00a6\u009f\u00e0\u00a7\u008b_\u00e0\u00a6\u00a8\u00e0\u00a6\u00ad\u00e0\u00a7\u0087\u00e0\u00a6\u00ae\u00e0\u00a7\u008d\u00e0\u00a6\u00ac\u00e0\u00a6\u00b0 \u00e0\u00a6\u00a8\u00e0\u00a6\u00ad_\u00e0\u00a6\u00a1\u00e0\u00a6\u00bf\u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u00ae\u00e0\u00a7\u008d\u00e0\u00a6\u00ac\u00e0\u00a6\u00b0 \u00e0\u00a6\u00a1\u00e0\u00a6\u00bf\u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u00ae\u00e0\u00a7\u008d'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, a h:mm:ss \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f',  '\u00e0\u00a6\u00b0\u00e0\u00a6\u00ac\u00e0\u00a6\u00bf\u00e0\u00a6\u00ac\u00e0\u00a6\u00be\u00e0\u00a6\u00b0, \u00e0\u00a7\u00a7\u00e0\u00a7\u00aa \u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac\u00e0\u00a7\u0081\u00e0\u00a7\u009f\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u0080 \u00e0\u00a7\u00a8\u00e0\u00a7\u00a6\u00e0\u00a7\u00a7\u00e0\u00a7\u00a6, \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a9:\u00e0\u00a7\u00a8\u00e0\u00a7\u00ab:\u00e0\u00a7\u00ab\u00e0\u00a7\u00a6 \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f'],\n                ['ddd, a h \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f',                       '\u00e0\u00a6\u00b0\u00e0\u00a6\u00ac\u00e0\u00a6\u00bf, \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a9 \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f'],\n                ['M Mo MM MMMM MMM',                   '\u00e0\u00a7\u00a8 \u00e0\u00a7\u00a8 \u00e0\u00a7\u00a6\u00e0\u00a7\u00a8 \u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac\u00e0\u00a7\u0081\u00e0\u00a7\u009f\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u0080 \u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac'],\n                ['YYYY YY',                            '\u00e0\u00a7\u00a8\u00e0\u00a7\u00a6\u00e0\u00a7\u00a7\u00e0\u00a7\u00a6 \u00e0\u00a7\u00a7\u00e0\u00a7\u00a6'],\n                ['D Do DD',                            '\u00e0\u00a7\u00a7\u00e0\u00a7\u00aa \u00e0\u00a7\u00a7\u00e0\u00a7\u00aa \u00e0\u00a7\u00a7\u00e0\u00a7\u00aa'],\n                ['d do dddd ddd dd',                   '\u00e0\u00a7\u00a6 \u00e0\u00a7\u00a6 \u00e0\u00a6\u00b0\u00e0\u00a6\u00ac\u00e0\u00a6\u00bf\u00e0\u00a6\u00ac\u00e0\u00a6\u00be\u00e0\u00a6\u00b0 \u00e0\u00a6\u00b0\u00e0\u00a6\u00ac\u00e0\u00a6\u00bf \u00e0\u00a6\u00b0\u00e0\u00a6\u00ac'],\n                ['DDD DDDo DDDD',                      '\u00e0\u00a7\u00aa\u00e0\u00a7\u00ab \u00e0\u00a7\u00aa\u00e0\u00a7\u00ab \u00e0\u00a7\u00a6\u00e0\u00a7\u00aa\u00e0\u00a7\u00ab'],\n                ['w wo ww',                            '\u00e0\u00a7\u00ae \u00e0\u00a7\u00ae \u00e0\u00a7\u00a6\u00e0\u00a7\u00ae'],\n                ['h hh',                               '\u00e0\u00a7\u00a9 \u00e0\u00a7\u00a6\u00e0\u00a7\u00a9'],\n                ['H HH',                               '\u00e0\u00a7\u00a7\u00e0\u00a7\u00ab \u00e0\u00a7\u00a7\u00e0\u00a7\u00ab'],\n                ['m mm',                               '\u00e0\u00a7\u00a8\u00e0\u00a7\u00ab \u00e0\u00a7\u00a8\u00e0\u00a7\u00ab'],\n                ['s ss',                               '\u00e0\u00a7\u00ab\u00e0\u00a7\u00a6 \u00e0\u00a7\u00ab\u00e0\u00a7\u00a6'],\n                ['a A',                                '\u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0'],\n                ['LT',                                 '\u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a9:\u00e0\u00a7\u00a8\u00e0\u00a7\u00ab \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f'],\n                ['LTS',                                '\u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a9:\u00e0\u00a7\u00a8\u00e0\u00a7\u00ab:\u00e0\u00a7\u00ab\u00e0\u00a7\u00a6 \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f'],\n                ['L',                                  '\u00e0\u00a7\u00a7\u00e0\u00a7\u00aa/\u00e0\u00a7\u00a6\u00e0\u00a7\u00a8/\u00e0\u00a7\u00a8\u00e0\u00a7\u00a6\u00e0\u00a7\u00a7\u00e0\u00a7\u00a6'],\n                ['LL',                                 '\u00e0\u00a7\u00a7\u00e0\u00a7\u00aa \u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac\u00e0\u00a7\u0081\u00e0\u00a7\u009f\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u0080 \u00e0\u00a7\u00a8\u00e0\u00a7\u00a6\u00e0\u00a7\u00a7\u00e0\u00a7\u00a6'],\n                ['LLL',                                '\u00e0\u00a7\u00a7\u00e0\u00a7\u00aa \u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac\u00e0\u00a7\u0081\u00e0\u00a7\u009f\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u0080 \u00e0\u00a7\u00a8\u00e0\u00a7\u00a6\u00e0\u00a7\u00a7\u00e0\u00a7\u00a6, \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a9:\u00e0\u00a7\u00a8\u00e0\u00a7\u00ab \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f'],\n                ['LLLL',                               '\u00e0\u00a6\u00b0\u00e0\u00a6\u00ac\u00e0\u00a6\u00bf\u00e0\u00a6\u00ac\u00e0\u00a6\u00be\u00e0\u00a6\u00b0, \u00e0\u00a7\u00a7\u00e0\u00a7\u00aa \u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac\u00e0\u00a7\u0081\u00e0\u00a7\u009f\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u0080 \u00e0\u00a7\u00a8\u00e0\u00a7\u00a6\u00e0\u00a7\u00a7\u00e0\u00a7\u00a6, \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a9:\u00e0\u00a7\u00a8\u00e0\u00a7\u00ab \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f'],\n                ['l',                                  '\u00e0\u00a7\u00a7\u00e0\u00a7\u00aa/\u00e0\u00a7\u00a8/\u00e0\u00a7\u00a8\u00e0\u00a7\u00a6\u00e0\u00a7\u00a7\u00e0\u00a7\u00a6'],\n                ['ll',                                 '\u00e0\u00a7\u00a7\u00e0\u00a7\u00aa \u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac \u00e0\u00a7\u00a8\u00e0\u00a7\u00a6\u00e0\u00a7\u00a7\u00e0\u00a7\u00a6'],\n                ['lll',                                '\u00e0\u00a7\u00a7\u00e0\u00a7\u00aa \u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac \u00e0\u00a7\u00a8\u00e0\u00a7\u00a6\u00e0\u00a7\u00a7\u00e0\u00a7\u00a6, \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a9:\u00e0\u00a7\u00a8\u00e0\u00a7\u00ab \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f'],\n                ['llll',                               '\u00e0\u00a6\u00b0\u00e0\u00a6\u00ac\u00e0\u00a6\u00bf, \u00e0\u00a7\u00a7\u00e0\u00a7\u00aa \u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac \u00e0\u00a7\u00a8\u00e0\u00a7\u00a6\u00e0\u00a7\u00a7\u00e0\u00a7\u00a6, \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a9:\u00e0\u00a7\u00a8\u00e0\u00a7\u00ab \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '\u00e0\u00a7\u00a7', '\u00e0\u00a7\u00a7');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '\u00e0\u00a7\u00a8', '\u00e0\u00a7\u00a8');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '\u00e0\u00a7\u00a9', '\u00e0\u00a7\u00a9');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '\u00e0\u00a7\u00aa', '\u00e0\u00a7\u00aa');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '\u00e0\u00a7\u00ab', '\u00e0\u00a7\u00ab');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '\u00e0\u00a7\u00ac', '\u00e0\u00a7\u00ac');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '\u00e0\u00a7\u00ad', '\u00e0\u00a7\u00ad');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '\u00e0\u00a7\u00ae', '\u00e0\u00a7\u00ae');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '\u00e0\u00a7\u00af', '\u00e0\u00a7\u00af');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00e0\u00a7\u00a7\u00e0\u00a7\u00a6', '\u00e0\u00a7\u00a7\u00e0\u00a7\u00a6');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00e0\u00a7\u00a7\u00e0\u00a7\u00a7', '\u00e0\u00a7\u00a7\u00e0\u00a7\u00a7');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00e0\u00a7\u00a7\u00e0\u00a7\u00a8', '\u00e0\u00a7\u00a7\u00e0\u00a7\u00a8');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00e0\u00a7\u00a7\u00e0\u00a7\u00a9', '\u00e0\u00a7\u00a7\u00e0\u00a7\u00a9');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00e0\u00a7\u00a7\u00e0\u00a7\u00aa', '\u00e0\u00a7\u00a7\u00e0\u00a7\u00aa');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00e0\u00a7\u00a7\u00e0\u00a7\u00ab', '\u00e0\u00a7\u00a7\u00e0\u00a7\u00ab');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00e0\u00a7\u00a7\u00e0\u00a7\u00ac', '\u00e0\u00a7\u00a7\u00e0\u00a7\u00ac');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00e0\u00a7\u00a7\u00e0\u00a7\u00ad', '\u00e0\u00a7\u00a7\u00e0\u00a7\u00ad');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00e0\u00a7\u00a7\u00e0\u00a7\u00ae', '\u00e0\u00a7\u00a7\u00e0\u00a7\u00ae');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00e0\u00a7\u00a7\u00e0\u00a7\u00af', '\u00e0\u00a7\u00a7\u00e0\u00a7\u00af');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00e0\u00a7\u00a8\u00e0\u00a7\u00a6', '\u00e0\u00a7\u00a8\u00e0\u00a7\u00a6');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '\u00e0\u00a7\u00a8\u00e0\u00a7\u00a7', '\u00e0\u00a7\u00a8\u00e0\u00a7\u00a7');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '\u00e0\u00a7\u00a8\u00e0\u00a7\u00a8', '\u00e0\u00a7\u00a8\u00e0\u00a7\u00a8');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '\u00e0\u00a7\u00a8\u00e0\u00a7\u00a9', '\u00e0\u00a7\u00a8\u00e0\u00a7\u00a9');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '\u00e0\u00a7\u00a8\u00e0\u00a7\u00aa', '\u00e0\u00a7\u00a8\u00e0\u00a7\u00aa');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '\u00e0\u00a7\u00a8\u00e0\u00a7\u00ab', '\u00e0\u00a7\u00a8\u00e0\u00a7\u00ab');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '\u00e0\u00a7\u00a8\u00e0\u00a7\u00ac', '\u00e0\u00a7\u00a8\u00e0\u00a7\u00ac');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '\u00e0\u00a7\u00a8\u00e0\u00a7\u00ad', '\u00e0\u00a7\u00a8\u00e0\u00a7\u00ad');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '\u00e0\u00a7\u00a8\u00e0\u00a7\u00ae', '\u00e0\u00a5\u00a8\u00e0\u00a7\u00ae');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '\u00e0\u00a7\u00a8\u00e0\u00a7\u00af', '\u00e0\u00a7\u00a8\u00e0\u00a7\u00af');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '\u00e0\u00a7\u00a9\u00e0\u00a7\u00a6', '\u00e0\u00a7\u00a9\u00e0\u00a7\u00a6');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '\u00e0\u00a7\u00a9\u00e0\u00a7\u00a7', '\u00e0\u00a7\u00a9\u00e0\u00a7\u00a7');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e0\u00a6\u009c\u00e0\u00a6\u00be\u00e0\u00a6\u00a8\u00e0\u00a7\u0081\u00e0\u00a7\u009f\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u0080 \u00e0\u00a6\u009c\u00e0\u00a6\u00be\u00e0\u00a6\u00a8\u00e0\u00a7\u0081_\u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac\u00e0\u00a7\u0081\u00e0\u00a7\u009f\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u0080 \u00e0\u00a6\u00ab\u00e0\u00a7\u0087\u00e0\u00a6\u00ac_\u00e0\u00a6\u00ae\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u008d\u00e0\u00a6\u009a \u00e0\u00a6\u00ae\u00e0\u00a6\u00be\u00e0\u00a6\u00b0\u00e0\u00a7\u008d\u00e0\u00a6\u009a_\u00e0\u00a6\u008f\u00e0\u00a6\u00aa\u00e0\u00a7\u008d\u00e0\u00a6\u00b0\u00e0\u00a6\u00bf\u00e0\u00a6\u00b2 \u00e0\u00a6\u008f\u00e0\u00a6\u00aa\u00e0\u00a6\u00b0_\u00e0\u00a6\u00ae\u00e0\u00a7\u0087 \u00e0\u00a6\u00ae\u00e0\u00a7\u0087_\u00e0\u00a6\u009c\u00e0\u00a7\u0081\u00e0\u00a6\u00a8 \u00e0\u00a6\u009c\u00e0\u00a7\u0081\u00e0\u00a6\u00a8_\u00e0\u00a6\u009c\u00e0\u00a7\u0081\u00e0\u00a6\u00b2\u00e0\u00a6\u00be\u00e0\u00a6\u0087 \u00e0\u00a6\u009c\u00e0\u00a7\u0081\u00e0\u00a6\u00b2_\u00e0\u00a6\u0085\u00e0\u00a6\u0097\u00e0\u00a6\u00be\u00e0\u00a6\u00b8\u00e0\u00a7\u008d\u00e0\u00a6\u009f \u00e0\u00a6\u0085\u00e0\u00a6\u0097_\u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u00aa\u00e0\u00a7\u008d\u00e0\u00a6\u009f\u00e0\u00a7\u0087\u00e0\u00a6\u00ae\u00e0\u00a7\u008d\u00e0\u00a6\u00ac\u00e0\u00a6\u00b0 \u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u00aa\u00e0\u00a7\u008d\u00e0\u00a6\u009f_\u00e0\u00a6\u0085\u00e0\u00a6\u0095\u00e0\u00a7\u008d\u00e0\u00a6\u009f\u00e0\u00a7\u008b\u00e0\u00a6\u00ac\u00e0\u00a6\u00b0 \u00e0\u00a6\u0085\u00e0\u00a6\u0095\u00e0\u00a7\u008d\u00e0\u00a6\u009f\u00e0\u00a7\u008b_\u00e0\u00a6\u00a8\u00e0\u00a6\u00ad\u00e0\u00a7\u0087\u00e0\u00a6\u00ae\u00e0\u00a7\u008d\u00e0\u00a6\u00ac\u00e0\u00a6\u00b0 \u00e0\u00a6\u00a8\u00e0\u00a6\u00ad_\u00e0\u00a6\u00a1\u00e0\u00a6\u00bf\u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u00ae\u00e0\u00a7\u008d\u00e0\u00a6\u00ac\u00e0\u00a6\u00b0 \u00e0\u00a6\u00a1\u00e0\u00a6\u00bf\u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u00ae\u00e0\u00a7\u008d'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e0\u00a6\u00b0\u00e0\u00a6\u00ac\u00e0\u00a6\u00bf\u00e0\u00a6\u00ac\u00e0\u00a6\u00be\u00e0\u00a6\u00b0 \u00e0\u00a6\u00b0\u00e0\u00a6\u00ac\u00e0\u00a6\u00bf \u00e0\u00a6\u00b0\u00e0\u00a6\u00ac_\u00e0\u00a6\u00b8\u00e0\u00a7\u008b\u00e0\u00a6\u00ae\u00e0\u00a6\u00ac\u00e0\u00a6\u00be\u00e0\u00a6\u00b0 \u00e0\u00a6\u00b8\u00e0\u00a7\u008b\u00e0\u00a6\u00ae \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae_\u00e0\u00a6\u00ae\u00e0\u00a6\u0099\u00e0\u00a7\u008d\u00e0\u00a6\u0097\u00e0\u00a6\u00b2\u00e0\u00a6\u00ac\u00e0\u00a6\u00be\u00e0\u00a6\u00b0 \u00e0\u00a6\u00ae\u00e0\u00a6\u0099\u00e0\u00a7\u008d\u00e0\u00a6\u0097\u00e0\u00a6\u00b2 \u00e0\u00a6\u00ae\u00e0\u00a6\u0099\u00e0\u00a7\u008d\u00e0\u00a6\u0097_\u00e0\u00a6\u00ac\u00e0\u00a7\u0081\u00e0\u00a6\u00a7\u00e0\u00a6\u00ac\u00e0\u00a6\u00be\u00e0\u00a6\u00b0 \u00e0\u00a6\u00ac\u00e0\u00a7\u0081\u00e0\u00a6\u00a7 \u00e0\u00a6\u00ac\u00e0\u00a7\u0081_\u00e0\u00a6\u00ac\u00e0\u00a7\u0083\u00e0\u00a6\u00b9\u00e0\u00a6\u00b8\u00e0\u00a7\u008d\u00e0\u00a6\u00aa\u00e0\u00a6\u00a4\u00e0\u00a7\u008d\u00e0\u00a6\u00a4\u00e0\u00a6\u00bf\u00e0\u00a6\u00ac\u00e0\u00a6\u00be\u00e0\u00a6\u00b0 \u00e0\u00a6\u00ac\u00e0\u00a7\u0083\u00e0\u00a6\u00b9\u00e0\u00a6\u00b8\u00e0\u00a7\u008d\u00e0\u00a6\u00aa\u00e0\u00a6\u00a4\u00e0\u00a7\u008d\u00e0\u00a6\u00a4\u00e0\u00a6\u00bf \u00e0\u00a6\u00ac\u00e0\u00a7\u008d\u00e0\u00a6\u00b0\u00e0\u00a6\u00bf\u00e0\u00a6\u00b9_\u00e0\u00a6\u00b6\u00e0\u00a7\u0081\u00e0\u00a6\u0095\u00e0\u00a7\u008d\u00e0\u00a6\u00b0\u00e0\u00a6\u00ac\u00e0\u00a6\u00be\u00e0\u00a6\u00b0 \u00e0\u00a6\u00b6\u00e0\u00a7\u0081\u00e0\u00a6\u0095\u00e0\u00a7\u008d\u00e0\u00a6\u00b0 \u00e0\u00a6\u00b6\u00e0\u00a7\u0081_\u00e0\u00a6\u00b6\u00e0\u00a6\u00a8\u00e0\u00a6\u00bf\u00e0\u00a6\u00ac\u00e0\u00a6\u00be\u00e0\u00a6\u00b0 \u00e0\u00a6\u00b6\u00e0\u00a6\u00a8\u00e0\u00a6\u00bf \u00e0\u00a6\u00b6\u00e0\u00a6\u00a8\u00e0\u00a6\u00bf'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e0\u00a6\u0095\u00e0\u00a7\u009f\u00e0\u00a7\u0087\u00e0\u00a6\u0095 \u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u0095\u00e0\u00a7\u0087\u00e0\u00a6\u00a8\u00e0\u00a7\u008d\u00e0\u00a6\u00a1', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00e0\u00a6\u008f\u00e0\u00a6\u0095 \u00e0\u00a6\u00ae\u00e0\u00a6\u00bf\u00e0\u00a6\u00a8\u00e0\u00a6\u00bf\u00e0\u00a6\u009f',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00e0\u00a6\u008f\u00e0\u00a6\u0095 \u00e0\u00a6\u00ae\u00e0\u00a6\u00bf\u00e0\u00a6\u00a8\u00e0\u00a6\u00bf\u00e0\u00a6\u009f',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '\u00e0\u00a7\u00a8 \u00e0\u00a6\u00ae\u00e0\u00a6\u00bf\u00e0\u00a6\u00a8\u00e0\u00a6\u00bf\u00e0\u00a6\u009f',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '\u00e0\u00a7\u00aa\u00e0\u00a7\u00aa \u00e0\u00a6\u00ae\u00e0\u00a6\u00bf\u00e0\u00a6\u00a8\u00e0\u00a6\u00bf\u00e0\u00a6\u009f',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00e0\u00a6\u008f\u00e0\u00a6\u0095 \u00e0\u00a6\u0098\u00e0\u00a6\u00a8\u00e0\u00a7\u008d\u00e0\u00a6\u009f\u00e0\u00a6\u00be',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00e0\u00a6\u008f\u00e0\u00a6\u0095 \u00e0\u00a6\u0098\u00e0\u00a6\u00a8\u00e0\u00a7\u008d\u00e0\u00a6\u009f\u00e0\u00a6\u00be',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00e0\u00a7\u00a8 \u00e0\u00a6\u0098\u00e0\u00a6\u00a8\u00e0\u00a7\u008d\u00e0\u00a6\u009f\u00e0\u00a6\u00be',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '\u00e0\u00a7\u00ab \u00e0\u00a6\u0098\u00e0\u00a6\u00a8\u00e0\u00a7\u008d\u00e0\u00a6\u009f\u00e0\u00a6\u00be',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '\u00e0\u00a7\u00a8\u00e0\u00a7\u00a7 \u00e0\u00a6\u0098\u00e0\u00a6\u00a8\u00e0\u00a7\u008d\u00e0\u00a6\u009f\u00e0\u00a6\u00be',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00e0\u00a6\u008f\u00e0\u00a6\u0095 \u00e0\u00a6\u00a6\u00e0\u00a6\u00bf\u00e0\u00a6\u00a8',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00e0\u00a6\u008f\u00e0\u00a6\u0095 \u00e0\u00a6\u00a6\u00e0\u00a6\u00bf\u00e0\u00a6\u00a8',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00e0\u00a7\u00a8 \u00e0\u00a6\u00a6\u00e0\u00a6\u00bf\u00e0\u00a6\u00a8',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00e0\u00a6\u008f\u00e0\u00a6\u0095 \u00e0\u00a6\u00a6\u00e0\u00a6\u00bf\u00e0\u00a6\u00a8',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '\u00e0\u00a7\u00ab \u00e0\u00a6\u00a6\u00e0\u00a6\u00bf\u00e0\u00a6\u00a8',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '\u00e0\u00a7\u00a8\u00e0\u00a7\u00ab \u00e0\u00a6\u00a6\u00e0\u00a6\u00bf\u00e0\u00a6\u00a8',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00e0\u00a6\u008f\u00e0\u00a6\u0095 \u00e0\u00a6\u00ae\u00e0\u00a6\u00be\u00e0\u00a6\u00b8',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00e0\u00a6\u008f\u00e0\u00a6\u0095 \u00e0\u00a6\u00ae\u00e0\u00a6\u00be\u00e0\u00a6\u00b8',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '\u00e0\u00a7\u00a8 \u00e0\u00a6\u00ae\u00e0\u00a6\u00be\u00e0\u00a6\u00b8',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '\u00e0\u00a7\u00a8 \u00e0\u00a6\u00ae\u00e0\u00a6\u00be\u00e0\u00a6\u00b8',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '\u00e0\u00a7\u00a9 \u00e0\u00a6\u00ae\u00e0\u00a6\u00be\u00e0\u00a6\u00b8',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00e0\u00a6\u008f\u00e0\u00a6\u0095 \u00e0\u00a6\u00ae\u00e0\u00a6\u00be\u00e0\u00a6\u00b8',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '\u00e0\u00a7\u00ab \u00e0\u00a6\u00ae\u00e0\u00a6\u00be\u00e0\u00a6\u00b8',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e0\u00a6\u008f\u00e0\u00a6\u0095 \u00e0\u00a6\u00ac\u00e0\u00a6\u009b\u00e0\u00a6\u00b0',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00e0\u00a7\u00a8 \u00e0\u00a6\u00ac\u00e0\u00a6\u009b\u00e0\u00a6\u00b0',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00e0\u00a6\u008f\u00e0\u00a6\u0095 \u00e0\u00a6\u00ac\u00e0\u00a6\u009b\u00e0\u00a6\u00b0',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '\u00e0\u00a7\u00ab \u00e0\u00a6\u00ac\u00e0\u00a6\u009b\u00e0\u00a6\u00b0',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e0\u00a6\u0095\u00e0\u00a7\u009f\u00e0\u00a7\u0087\u00e0\u00a6\u0095 \u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u0095\u00e0\u00a7\u0087\u00e0\u00a6\u00a8\u00e0\u00a7\u008d\u00e0\u00a6\u00a1 \u00e0\u00a6\u00aa\u00e0\u00a6\u00b0\u00e0\u00a7\u0087',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e0\u00a6\u0095\u00e0\u00a7\u009f\u00e0\u00a7\u0087\u00e0\u00a6\u0095 \u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u0095\u00e0\u00a7\u0087\u00e0\u00a6\u00a8\u00e0\u00a7\u008d\u00e0\u00a6\u00a1 \u00e0\u00a6\u0086\u00e0\u00a6\u0097\u00e0\u00a7\u0087', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e0\u00a6\u0095\u00e0\u00a7\u009f\u00e0\u00a7\u0087\u00e0\u00a6\u0095 \u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u0095\u00e0\u00a7\u0087\u00e0\u00a6\u00a8\u00e0\u00a7\u008d\u00e0\u00a6\u00a1 \u00e0\u00a6\u0086\u00e0\u00a6\u0097\u00e0\u00a7\u0087',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e0\u00a6\u0095\u00e0\u00a7\u009f\u00e0\u00a7\u0087\u00e0\u00a6\u0095 \u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u0095\u00e0\u00a7\u0087\u00e0\u00a6\u00a8\u00e0\u00a7\u008d\u00e0\u00a6\u00a1 \u00e0\u00a6\u00aa\u00e0\u00a6\u00b0\u00e0\u00a7\u0087', '\u00e0\u00a6\u0095\u00e0\u00a7\u009f\u00e0\u00a7\u0087\u00e0\u00a6\u0095 \u00e0\u00a6\u00b8\u00e0\u00a7\u0087\u00e0\u00a6\u0095\u00e0\u00a7\u0087\u00e0\u00a6\u00a8\u00e0\u00a7\u008d\u00e0\u00a6\u00a1 \u00e0\u00a6\u00aa\u00e0\u00a6\u00b0\u00e0\u00a7\u0087');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00e0\u00a7\u00ab \u00e0\u00a6\u00a6\u00e0\u00a6\u00bf\u00e0\u00a6\u00a8 \u00e0\u00a6\u00aa\u00e0\u00a6\u00b0\u00e0\u00a7\u0087', '\u00e0\u00a7\u00ab \u00e0\u00a6\u00a6\u00e0\u00a6\u00bf\u00e0\u00a6\u00a8 \u00e0\u00a6\u00aa\u00e0\u00a6\u00b0\u00e0\u00a7\u0087');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e0\u00a6\u0086\u00e0\u00a6\u009c \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a7\u00e0\u00a7\u00a8:\u00e0\u00a7\u00a6\u00e0\u00a7\u00a6 \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f',       'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e0\u00a6\u0086\u00e0\u00a6\u009c \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a7\u00e0\u00a7\u00a8:\u00e0\u00a7\u00a8\u00e0\u00a7\u00ab \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f',       'Now plus 25 min');\n        assert.equal(moment(a).add({h: 3}).calendar(),       '\u00e0\u00a6\u0086\u00e0\u00a6\u009c \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a9:\u00e0\u00a7\u00a6\u00e0\u00a7\u00a6 \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f',        'Now plus 3 hours');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e0\u00a6\u0086\u00e0\u00a6\u0097\u00e0\u00a6\u00be\u00e0\u00a6\u00ae\u00e0\u00a7\u0080\u00e0\u00a6\u0095\u00e0\u00a6\u00be\u00e0\u00a6\u00b2 \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a7\u00e0\u00a7\u00a8:\u00e0\u00a7\u00a6\u00e0\u00a7\u00a6 \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f', 'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e0\u00a6\u0086\u00e0\u00a6\u009c \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a7\u00e0\u00a7\u00a7:\u00e0\u00a7\u00a6\u00e0\u00a7\u00a6 \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f',       'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e0\u00a6\u0097\u00e0\u00a6\u00a4\u00e0\u00a6\u0095\u00e0\u00a6\u00be\u00e0\u00a6\u00b2 \u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0 \u00e0\u00a7\u00a7\u00e0\u00a7\u00a8:\u00e0\u00a7\u00a6\u00e0\u00a7\u00a6 \u00e0\u00a6\u00b8\u00e0\u00a6\u00ae\u00e0\u00a7\u009f',    'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a6\u0097\u00e0\u00a6\u00a4] dddd[,] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a6\u0097\u00e0\u00a6\u00a4] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a6\u0097\u00e0\u00a6\u00a4] dddd[,] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('meridiem', function (assert) {\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '\u00e0\u00a6\u00b0\u00e0\u00a6\u00be\u00e0\u00a6\u00a4', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '\u00e0\u00a6\u00b8\u00e0\u00a6\u0095\u00e0\u00a6\u00be\u00e0\u00a6\u00b2', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '\u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0', 'during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '\u00e0\u00a6\u00ac\u00e0\u00a6\u00bf\u00e0\u00a6\u0095\u00e0\u00a6\u00be\u00e0\u00a6\u00b2', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '\u00e0\u00a6\u00ac\u00e0\u00a6\u00bf\u00e0\u00a6\u0095\u00e0\u00a6\u00be\u00e0\u00a6\u00b2', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '\u00e0\u00a6\u00b0\u00e0\u00a6\u00be\u00e0\u00a6\u00a4', 'night');\n\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '\u00e0\u00a6\u00b0\u00e0\u00a6\u00be\u00e0\u00a6\u00a4', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '\u00e0\u00a6\u00b8\u00e0\u00a6\u0095\u00e0\u00a6\u00be\u00e0\u00a6\u00b2', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '\u00e0\u00a6\u00a6\u00e0\u00a7\u0081\u00e0\u00a6\u00aa\u00e0\u00a7\u0081\u00e0\u00a6\u00b0', ' during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '\u00e0\u00a6\u00ac\u00e0\u00a6\u00bf\u00e0\u00a6\u0095\u00e0\u00a6\u00be\u00e0\u00a6\u00b2', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '\u00e0\u00a6\u00ac\u00e0\u00a6\u00bf\u00e0\u00a6\u0095\u00e0\u00a6\u00be\u00e0\u00a6\u00b2', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '\u00e0\u00a6\u00b0\u00e0\u00a6\u00be\u00e0\u00a6\u00a4', 'night');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '\u00e0\u00a7\u00a7 \u00e0\u00a7\u00a6\u00e0\u00a7\u00a7 \u00e0\u00a7\u00a7', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '\u00e0\u00a7\u00a7 \u00e0\u00a7\u00a6\u00e0\u00a7\u00a7 \u00e0\u00a7\u00a7', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '\u00e0\u00a7\u00a8 \u00e0\u00a7\u00a6\u00e0\u00a7\u00a8 \u00e0\u00a7\u00a8', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '\u00e0\u00a7\u00a8 \u00e0\u00a7\u00a6\u00e0\u00a7\u00a8 \u00e0\u00a7\u00a8', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '\u00e0\u00a7\u00a9 \u00e0\u00a7\u00a6\u00e0\u00a7\u00a9 \u00e0\u00a7\u00a9', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('bo');\n\n    test('parse', function (assert) {\n        var tests = '\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0084\u00e0\u00bc\u008b\u00e0\u00bd\u0094\u00e0\u00bd\u00bc \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0084\u00e0\u00bc\u008b\u00e0\u00bd\u0094\u00e0\u00bd\u00bc._\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00a6\u00e0\u00bd\u00b4\u00e0\u00bd\u0098\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00a6\u00e0\u00bd\u00b4\u00e0\u00bd\u0098\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u009e\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u009e\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u00a3\u00e0\u00be\u0094\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u00a3\u00e0\u00be\u0094\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00be\u00b2\u00e0\u00bd\u00b4\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00be\u00b2\u00e0\u00bd\u00b4\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0091\u00e0\u00bd\u00b4\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0091\u00e0\u00bd\u00b4\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u00a2\u00e0\u00be\u0092\u00e0\u00be\u00b1\u00e0\u00bd\u0091\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u00a2\u00e0\u00be\u0092\u00e0\u00be\u00b1\u00e0\u00bd\u0091\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0085\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0085\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0085\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0085\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0085\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0085\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, a h:mm:ss \u00e0\u00bd\u00a3\u00e0\u00bc\u008b',  '\u00e0\u00bd\u0082\u00e0\u00bd\u009f\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bc\u008b, \u00e0\u00bc\u00a1\u00e0\u00bc\u00a4 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bc\u00a2\u00e0\u00bc\u00a0\u00e0\u00bc\u00a1\u00e0\u00bc\u00a0, \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a3:\u00e0\u00bc\u00a2\u00e0\u00bc\u00a5:\u00e0\u00bc\u00a5\u00e0\u00bc\u00a0 \u00e0\u00bd\u00a3\u00e0\u00bc\u008b'],\n                ['ddd, a h \u00e0\u00bd\u00a3\u00e0\u00bc\u008b',                       '\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bc\u008b, \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a3 \u00e0\u00bd\u00a3\u00e0\u00bc\u008b'],\n                ['M Mo MM MMMM MMM',                   '\u00e0\u00bc\u00a2 \u00e0\u00bc\u00a2 \u00e0\u00bc\u00a0\u00e0\u00bc\u00a2 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094'],\n                ['YYYY YY',                            '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a0\u00e0\u00bc\u00a1\u00e0\u00bc\u00a0 \u00e0\u00bc\u00a1\u00e0\u00bc\u00a0'],\n                ['D Do DD',                            '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a4 \u00e0\u00bc\u00a1\u00e0\u00bc\u00a4 \u00e0\u00bc\u00a1\u00e0\u00bc\u00a4'],\n                ['d do dddd ddd dd',                   '\u00e0\u00bc\u00a0 \u00e0\u00bc\u00a0 \u00e0\u00bd\u0082\u00e0\u00bd\u009f\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bc\u008b \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bc\u008b \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bc\u008b'],\n                ['DDD DDDo DDDD',                      '\u00e0\u00bc\u00a4\u00e0\u00bc\u00a5 \u00e0\u00bc\u00a4\u00e0\u00bc\u00a5 \u00e0\u00bc\u00a0\u00e0\u00bc\u00a4\u00e0\u00bc\u00a5'],\n                ['w wo ww',                            '\u00e0\u00bc\u00a8 \u00e0\u00bc\u00a8 \u00e0\u00bc\u00a0\u00e0\u00bc\u00a8'],\n                ['h hh',                               '\u00e0\u00bc\u00a3 \u00e0\u00bc\u00a0\u00e0\u00bc\u00a3'],\n                ['H HH',                               '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a5 \u00e0\u00bc\u00a1\u00e0\u00bc\u00a5'],\n                ['m mm',                               '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a5 \u00e0\u00bc\u00a2\u00e0\u00bc\u00a5'],\n                ['s ss',                               '\u00e0\u00bc\u00a5\u00e0\u00bc\u00a0 \u00e0\u00bc\u00a5\u00e0\u00bc\u00a0'],\n                ['a A',                                '\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084'],\n                ['LT',                                 '\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a3:\u00e0\u00bc\u00a2\u00e0\u00bc\u00a5'],\n                ['LTS',                                '\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a3:\u00e0\u00bc\u00a2\u00e0\u00bc\u00a5:\u00e0\u00bc\u00a5\u00e0\u00bc\u00a0'],\n                ['L',                                  '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a4/\u00e0\u00bc\u00a0\u00e0\u00bc\u00a2/\u00e0\u00bc\u00a2\u00e0\u00bc\u00a0\u00e0\u00bc\u00a1\u00e0\u00bc\u00a0'],\n                ['LL',                                 '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a4 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bc\u00a2\u00e0\u00bc\u00a0\u00e0\u00bc\u00a1\u00e0\u00bc\u00a0'],\n                ['LLL',                                '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a4 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bc\u00a2\u00e0\u00bc\u00a0\u00e0\u00bc\u00a1\u00e0\u00bc\u00a0, \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a3:\u00e0\u00bc\u00a2\u00e0\u00bc\u00a5'],\n                ['LLLL',                               '\u00e0\u00bd\u0082\u00e0\u00bd\u009f\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bc\u008b, \u00e0\u00bc\u00a1\u00e0\u00bc\u00a4 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bc\u00a2\u00e0\u00bc\u00a0\u00e0\u00bc\u00a1\u00e0\u00bc\u00a0, \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a3:\u00e0\u00bc\u00a2\u00e0\u00bc\u00a5'],\n                ['l',                                  '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a4/\u00e0\u00bc\u00a2/\u00e0\u00bc\u00a2\u00e0\u00bc\u00a0\u00e0\u00bc\u00a1\u00e0\u00bc\u00a0'],\n                ['ll',                                 '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a4 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bc\u00a2\u00e0\u00bc\u00a0\u00e0\u00bc\u00a1\u00e0\u00bc\u00a0'],\n                ['lll',                                '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a4 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bc\u00a2\u00e0\u00bc\u00a0\u00e0\u00bc\u00a1\u00e0\u00bc\u00a0, \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a3:\u00e0\u00bc\u00a2\u00e0\u00bc\u00a5'],\n                ['llll',                               '\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bc\u008b, \u00e0\u00bc\u00a1\u00e0\u00bc\u00a4 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bc\u00a2\u00e0\u00bc\u00a0\u00e0\u00bc\u00a1\u00e0\u00bc\u00a0, \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a3:\u00e0\u00bc\u00a2\u00e0\u00bc\u00a5']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '\u00e0\u00bc\u00a1', '\u00e0\u00bc\u00a1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '\u00e0\u00bc\u00a2', '\u00e0\u00bc\u00a2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '\u00e0\u00bc\u00a3', '\u00e0\u00bc\u00a3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '\u00e0\u00bc\u00a4', '\u00e0\u00bc\u00a4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '\u00e0\u00bc\u00a5', '\u00e0\u00bc\u00a5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '\u00e0\u00bc\u00a6', '\u00e0\u00bc\u00a6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '\u00e0\u00bc\u00a7', '\u00e0\u00bc\u00a7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '\u00e0\u00bc\u00a8', '\u00e0\u00bc\u00a8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '\u00e0\u00bc\u00a9', '\u00e0\u00bc\u00a9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a0', '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a0');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a1', '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a1');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a2', '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a2');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a3', '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a3');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a4', '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a4');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a5', '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a5');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a6', '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a6');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a7', '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a7');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a8', '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a8');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a9', '\u00e0\u00bc\u00a1\u00e0\u00bc\u00a9');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a0', '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a0');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a1', '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a1');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a2', '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a2');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a3', '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a3');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a4', '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a4');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a5', '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a5');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a6', '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a6');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a7', '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a7');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a8', '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a8');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a9', '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a9');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '\u00e0\u00bc\u00a3\u00e0\u00bc\u00a0', '\u00e0\u00bc\u00a3\u00e0\u00bc\u00a0');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '\u00e0\u00bc\u00a3\u00e0\u00bc\u00a1', '\u00e0\u00bc\u00a3\u00e0\u00bc\u00a1');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0084\u00e0\u00bc\u008b\u00e0\u00bd\u0094\u00e0\u00bd\u00bc \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0084\u00e0\u00bc\u008b\u00e0\u00bd\u0094\u00e0\u00bd\u00bc_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00a6\u00e0\u00bd\u00b4\u00e0\u00bd\u0098\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00a6\u00e0\u00bd\u00b4\u00e0\u00bd\u0098\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u009e\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u009e\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u00a3\u00e0\u00be\u0094\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u00a3\u00e0\u00be\u0094\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00be\u00b2\u00e0\u00bd\u00b4\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00be\u00b2\u00e0\u00bd\u00b4\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0091\u00e0\u00bd\u00b4\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0091\u00e0\u00bd\u00b4\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u00a2\u00e0\u00be\u0092\u00e0\u00be\u00b1\u00e0\u00bd\u0091\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u00a2\u00e0\u00be\u0092\u00e0\u00be\u00b1\u00e0\u00bd\u0091\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0085\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0085\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0085\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0085\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0094_\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0085\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u0085\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0094'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e0\u00bd\u0082\u00e0\u00bd\u009f\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bc\u008b \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bc\u008b \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bc\u008b_\u00e0\u00bd\u0082\u00e0\u00bd\u009f\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b_\u00e0\u00bd\u0082\u00e0\u00bd\u009f\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bd\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0098\u00e0\u00bd\u00a2\u00e0\u00bc\u008b \u00e0\u00bd\u0098\u00e0\u00bd\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0098\u00e0\u00bd\u00a2\u00e0\u00bc\u008b \u00e0\u00bd\u0098\u00e0\u00bd\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0098\u00e0\u00bd\u00a2\u00e0\u00bc\u008b_\u00e0\u00bd\u0082\u00e0\u00bd\u009f\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u00a3\u00e0\u00be\u00b7\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0094\u00e0\u00bc\u008b \u00e0\u00bd\u00a3\u00e0\u00be\u00b7\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0094\u00e0\u00bc\u008b \u00e0\u00bd\u00a3\u00e0\u00be\u00b7\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0094\u00e0\u00bc\u008b_\u00e0\u00bd\u0082\u00e0\u00bd\u009f\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u0095\u00e0\u00bd\u00b4\u00e0\u00bd\u00a2\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u00b4 \u00e0\u00bd\u0095\u00e0\u00bd\u00b4\u00e0\u00bd\u00a2\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u00b4 \u00e0\u00bd\u0095\u00e0\u00bd\u00b4\u00e0\u00bd\u00a2\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bd\u00b4_\u00e0\u00bd\u0082\u00e0\u00bd\u009f\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u0094\u00e0\u00bc\u008b\u00e0\u00bd\u00a6\u00e0\u00bd\u0084\u00e0\u00bd\u00a6\u00e0\u00bc\u008b \u00e0\u00bd\u0094\u00e0\u00bc\u008b\u00e0\u00bd\u00a6\u00e0\u00bd\u0084\u00e0\u00bd\u00a6\u00e0\u00bc\u008b \u00e0\u00bd\u0094\u00e0\u00bc\u008b\u00e0\u00bd\u00a6\u00e0\u00bd\u0084\u00e0\u00bd\u00a6\u00e0\u00bc\u008b_\u00e0\u00bd\u0082\u00e0\u00bd\u009f\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u00a6\u00e0\u00be\u00a4\u00e0\u00bd\u00ba\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0094\u00e0\u00bc\u008b \u00e0\u00bd\u00a6\u00e0\u00be\u00a4\u00e0\u00bd\u00ba\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0094\u00e0\u00bc\u008b \u00e0\u00bd\u00a6\u00e0\u00be\u00a4\u00e0\u00bd\u00ba\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0094\u00e0\u00bc\u008b'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e0\u00bd\u00a3\u00e0\u00bd\u0098\u00e0\u00bc\u008b\u00e0\u00bd\u00a6\u00e0\u00bd\u0084', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00e0\u00bd\u00a6\u00e0\u00be\u0090\u00e0\u00bd\u00a2\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00e0\u00bd\u00a6\u00e0\u00be\u0090\u00e0\u00bd\u00a2\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '\u00e0\u00bc\u00a2 \u00e0\u00bd\u00a6\u00e0\u00be\u0090\u00e0\u00bd\u00a2\u00e0\u00bc\u008b\u00e0\u00bd\u0098',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '\u00e0\u00bc\u00a4\u00e0\u00bc\u00a4 \u00e0\u00bd\u00a6\u00e0\u00be\u0090\u00e0\u00bd\u00a2\u00e0\u00bc\u008b\u00e0\u00bd\u0098',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00e0\u00bd\u0086\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u009a\u00e0\u00bd\u00bc\u00e0\u00bd\u0091\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00e0\u00bd\u0086\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u009a\u00e0\u00bd\u00bc\u00e0\u00bd\u0091\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00e0\u00bc\u00a2 \u00e0\u00bd\u0086\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u009a\u00e0\u00bd\u00bc\u00e0\u00bd\u0091',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '\u00e0\u00bc\u00a5 \u00e0\u00bd\u0086\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u009a\u00e0\u00bd\u00bc\u00e0\u00bd\u0091',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a1 \u00e0\u00bd\u0086\u00e0\u00bd\u00b4\u00e0\u00bc\u008b\u00e0\u00bd\u009a\u00e0\u00bd\u00bc\u00e0\u00bd\u0091',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00e0\u00bc\u00a2 \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '\u00e0\u00bc\u00a5 \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '\u00e0\u00bc\u00a2\u00e0\u00bc\u00a5 \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '\u00e0\u00bc\u00a2 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '\u00e0\u00bc\u00a2 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '\u00e0\u00bc\u00a3 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '\u00e0\u00bc\u00a5 \u00e0\u00bd\u009f\u00e0\u00be\u00b3\u00e0\u00bc\u008b\u00e0\u00bd\u0096',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e0\u00bd\u00a3\u00e0\u00bd\u00bc\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00e0\u00bc\u00a2 \u00e0\u00bd\u00a3\u00e0\u00bd\u00bc',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00e0\u00bd\u00a3\u00e0\u00bd\u00bc\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u0085\u00e0\u00bd\u00b2\u00e0\u00bd\u0082',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '\u00e0\u00bc\u00a5 \u00e0\u00bd\u00a3\u00e0\u00bd\u00bc',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e0\u00bd\u00a3\u00e0\u00bd\u0098\u00e0\u00bc\u008b\u00e0\u00bd\u00a6\u00e0\u00bd\u0084 \u00e0\u00bd\u00a3\u00e0\u00bc\u008b',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e0\u00bd\u00a3\u00e0\u00bd\u0098\u00e0\u00bc\u008b\u00e0\u00bd\u00a6\u00e0\u00bd\u0084 \u00e0\u00bd\u00a6\u00e0\u00be\u0094\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u00a3', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e0\u00bd\u00a3\u00e0\u00bd\u0098\u00e0\u00bc\u008b\u00e0\u00bd\u00a6\u00e0\u00bd\u0084 \u00e0\u00bd\u00a6\u00e0\u00be\u0094\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u00a3',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e0\u00bd\u00a3\u00e0\u00bd\u0098\u00e0\u00bc\u008b\u00e0\u00bd\u00a6\u00e0\u00bd\u0084 \u00e0\u00bd\u00a3\u00e0\u00bc\u008b', '\u00e0\u00bd\u00a3\u00e0\u00bd\u0098\u00e0\u00bc\u008b\u00e0\u00bd\u00a6\u00e0\u00bd\u0084 \u00e0\u00bd\u00a3\u00e0\u00bc\u008b');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00e0\u00bc\u00a5 \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b \u00e0\u00bd\u00a3\u00e0\u00bc\u008b', '\u00e0\u00bc\u00a5 \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b \u00e0\u00bd\u00a3\u00e0\u00bc\u008b');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e0\u00bd\u0091\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u00a2\u00e0\u00bd\u00b2\u00e0\u00bd\u0084 \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a1\u00e0\u00bc\u00a2:\u00e0\u00bc\u00a0\u00e0\u00bc\u00a0',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e0\u00bd\u0091\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u00a2\u00e0\u00bd\u00b2\u00e0\u00bd\u0084 \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a1\u00e0\u00bc\u00a2:\u00e0\u00bc\u00a2\u00e0\u00bc\u00a5',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 3}).calendar(),       '\u00e0\u00bd\u0091\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u00a2\u00e0\u00bd\u00b2\u00e0\u00bd\u0084 \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a3:\u00e0\u00bc\u00a0\u00e0\u00bc\u00a0',   'Now plus 3 hours');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e0\u00bd\u00a6\u00e0\u00bd\u0084\u00e0\u00bc\u008b\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093 \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a1\u00e0\u00bc\u00a2:\u00e0\u00bc\u00a0\u00e0\u00bc\u00a0',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e0\u00bd\u0091\u00e0\u00bd\u00b2\u00e0\u00bc\u008b\u00e0\u00bd\u00a2\u00e0\u00bd\u00b2\u00e0\u00bd\u0084 \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a1\u00e0\u00bc\u00a1:\u00e0\u00bc\u00a0\u00e0\u00bc\u00a0',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e0\u00bd\u0081\u00e0\u00bc\u008b\u00e0\u00bd\u00a6\u00e0\u00bd\u0084 \u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084 \u00e0\u00bc\u00a1\u00e0\u00bc\u00a2:\u00e0\u00bc\u00a0\u00e0\u00bc\u00a0',    'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00bd\u0096\u00e0\u00bd\u0091\u00e0\u00bd\u00b4\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0095\u00e0\u00be\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u00a2\u00e0\u00be\u0097\u00e0\u00bd\u00ba\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0098][,] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00bd\u0096\u00e0\u00bd\u0091\u00e0\u00bd\u00b4\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0095\u00e0\u00be\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u00a2\u00e0\u00be\u0097\u00e0\u00bd\u00ba\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0098][,] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00bd\u0096\u00e0\u00bd\u0091\u00e0\u00bd\u00b4\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0095\u00e0\u00be\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u00a2\u00e0\u00be\u0097\u00e0\u00bd\u00ba\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0098][,] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00bd\u0096\u00e0\u00bd\u0091\u00e0\u00bd\u00b4\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0095\u00e0\u00be\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bd\u0090\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u0098] dddd[,] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00bd\u0096\u00e0\u00bd\u0091\u00e0\u00bd\u00b4\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0095\u00e0\u00be\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bd\u0090\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u0098] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00bd\u0096\u00e0\u00bd\u0091\u00e0\u00bd\u00b4\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0095\u00e0\u00be\u00b2\u00e0\u00bd\u0082\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bd\u0090\u00e0\u00bd\u00a0\u00e0\u00bc\u008b\u00e0\u00bd\u0098] dddd[,] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('meridiem', function (assert) {\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '\u00e0\u00bd\u0098\u00e0\u00bd\u009a\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bd\u00bc', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '\u00e0\u00bd\u009e\u00e0\u00bd\u00bc\u00e0\u00bd\u0082\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0080\u00e0\u00bd\u00a6', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084', 'during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '\u00e0\u00bd\u0091\u00e0\u00bd\u0082\u00e0\u00bd\u00bc\u00e0\u00bd\u0084\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0082', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '\u00e0\u00bd\u0091\u00e0\u00bd\u0082\u00e0\u00bd\u00bc\u00e0\u00bd\u0084\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0082', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '\u00e0\u00bd\u0098\u00e0\u00bd\u009a\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bd\u00bc', 'night');\n\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '\u00e0\u00bd\u0098\u00e0\u00bd\u009a\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bd\u00bc', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '\u00e0\u00bd\u009e\u00e0\u00bd\u00bc\u00e0\u00bd\u0082\u00e0\u00bd\u00a6\u00e0\u00bc\u008b\u00e0\u00bd\u0080\u00e0\u00bd\u00a6', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '\u00e0\u00bd\u0089\u00e0\u00bd\u00b2\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0082\u00e0\u00bd\u00b4\u00e0\u00bd\u0084', ' during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '\u00e0\u00bd\u0091\u00e0\u00bd\u0082\u00e0\u00bd\u00bc\u00e0\u00bd\u0084\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0082', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '\u00e0\u00bd\u0091\u00e0\u00bd\u0082\u00e0\u00bd\u00bc\u00e0\u00bd\u0084\u00e0\u00bc\u008b\u00e0\u00bd\u0091\u00e0\u00bd\u0082', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '\u00e0\u00bd\u0098\u00e0\u00bd\u009a\u00e0\u00bd\u0093\u00e0\u00bc\u008b\u00e0\u00bd\u0098\u00e0\u00bd\u00bc', 'night');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '\u00e0\u00bc\u00a1 \u00e0\u00bc\u00a0\u00e0\u00bc\u00a1 \u00e0\u00bc\u00a1', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '\u00e0\u00bc\u00a1 \u00e0\u00bc\u00a0\u00e0\u00bc\u00a1 \u00e0\u00bc\u00a1', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '\u00e0\u00bc\u00a2 \u00e0\u00bc\u00a0\u00e0\u00bc\u00a2 \u00e0\u00bc\u00a2', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '\u00e0\u00bc\u00a2 \u00e0\u00bc\u00a0\u00e0\u00bc\u00a2 \u00e0\u00bc\u00a2', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '\u00e0\u00bc\u00a3 \u00e0\u00bc\u00a0\u00e0\u00bc\u00a3 \u00e0\u00bc\u00a3', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('br');\n\n    test('parse', function (assert) {\n        var tests = 'Genver Gen_C\\'hwevrer C\\'hwe_Meurzh Meu_Ebrel Ebr_Mae Mae_Mezheven Eve_Gouere Gou_Eost Eos_Gwengolo Gwe_Here Her_Du Du_Kerzu Ker'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        moment.locale('br');\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sul, C\\'hwevrer 14vet 2010, 3:25:50 pm'],\n                ['ddd, h A',                            'Sul, 3 PM'],\n                ['M Mo MM MMMM MMM',                   '2 2vet 02 C\\'hwevrer C\\'hwe'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14vet 14'],\n                ['d do dddd ddd dd',                   '0 0vet Sul Sul Su'],\n                ['DDD DDDo DDDD',                      '45 45vet 045'],\n                ['w wo ww',                            '6 6vet 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['DDDo [devezh] [ar] [vloaz]',       '45vet devezh ar vloaz'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 a viz C\\'hwevrer 2010'],\n                ['LLL',                                '14 a viz C\\'hwevrer 2010 3e25 PM'],\n                ['LLLL',                               'Sul, 14 a viz C\\'hwevrer 2010 3e25 PM']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        moment.locale('br');\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1a\u00c3\u00b1', '1a\u00c3\u00b1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2vet', '2vet');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3vet', '3vet');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4vet', '4vet');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5vet', '5vet');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6vet', '6vet');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7vet', '7vet');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8vet', '8vet');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9vet', '9vet');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10vet', '10vet');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11vet', '11vet');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12vet', '12vet');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13vet', '13vet');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14vet', '14vet');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15vet', '15vet');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16vet', '16vet');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17vet', '17vet');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18vet', '18vet');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19vet', '19vet');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20vet', '20vet');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21vet', '21vet');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22vet', '22vet');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23vet', '23vet');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24vet', '24vet');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25vet', '25vet');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26vet', '26vet');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27vet', '27vet');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28vet', '28vet');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29vet', '29vet');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30vet', '30vet');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31vet', '31vet');\n    });\n\n    test('format month', function (assert) {\n        moment.locale('br');\n        var expected = 'Genver Gen_C\\'hwevrer C\\'hwe_Meurzh Meu_Ebrel Ebr_Mae Mae_Mezheven Eve_Gouere Gou_Eost Eos_Gwengolo Gwe_Here Her_Du Du_Kerzu Ker'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        moment.locale('br');\n        var expected = 'Sul Sul Su_Lun Lun Lu_Meurzh Meu Me_Merc\\'her Mer Mer_Yaou Yao Ya_Gwener Gwe Gw_Sadorn Sad Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        moment.locale('br');\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'un nebeud segondenno\u00c3\u00b9', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ur vunutenn',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ur vunutenn',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 vunutenn',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 munutenn',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'un eur',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'un eur',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 eur',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 eur',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 eur',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un devezh',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un devezh',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 zevezh',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un devezh',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 devezh',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 devezh',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ur miz',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ur miz',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ur miz',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 viz',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 viz',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 miz',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ur miz',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 miz',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ur bloaz',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 vloaz',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ur bloaz',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 bloaz',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        moment.locale('br');\n        assert.equal(moment(30000).from(0), 'a-benn un nebeud segondenno\u00c3\u00b9',  'prefix');\n        assert.equal(moment(0).from(30000), 'un nebeud segondenno\u00c3\u00b9 \\'zo', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        moment.locale('br');\n        assert.equal(moment().fromNow(), 'un nebeud segondenno\u00c3\u00b9 \\'zo',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        moment.locale('br');\n        assert.equal(moment().add({s: 30}).fromNow(), 'a-benn un nebeud segondenno\u00c3\u00b9', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'a-benn 5 devezh', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        moment.locale('br');\n\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Hiziv da 12e00 PM',        'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Hiziv da 12e25 PM',        'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Hiziv da 1e00 PM',         'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Warc\\'hoazh da 12e00 PM',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hiziv da 11e00 AM',        'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Dec\\'h da 12e00 PM',       'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        moment.locale('br');\n\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [da] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [da] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [da] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        moment.locale('br');\n\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [paset da] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [paset da] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [paset da] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        moment.locale('br');\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('special mutations for years', function (assert) {\n        moment.locale('br');\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'ur bloaz', 'mutation 1 year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 2}), true), '2 vloaz', 'mutation 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 3}), true), '3 bloaz', 'mutation 3 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 4}), true), '4 bloaz', 'mutation 4 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 bloaz', 'mutation 5 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 9}), true), '9 bloaz', 'mutation 9 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 10}), true), '10 vloaz', 'mutation 10 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 21}), true), '21 bloaz', 'mutation 21 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 22}), true), '22 vloaz', 'mutation 22 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 133}), true), '133 bloaz', 'mutation 133 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 148}), true), '148 vloaz', 'mutation 148 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 261}), true), '261 bloaz', 'mutation 261 years');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('bs');\n\n    test('parse', function (assert) {\n        var tests = 'januar jan._februar feb._mart mar._april apr._maj maj._juni jun._juli jul._august aug._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' inp ' + mmm);\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedjelja, 14. februar 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'ned., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. nedjelja ned. ne'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '7 7. 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14. 02. 2010'],\n                ['LL',                                 '14. februar 2010'],\n                ['LLL',                                '14. februar 2010 15:25'],\n                ['LLLL',                               'nedjelja, 14. februar 2010 15:25'],\n                ['l',                                  '14. 2. 2010'],\n                ['ll',                                 '14. feb. 2010'],\n                ['lll',                                '14. feb. 2010 15:25'],\n                ['llll',                               'ned., 14. feb. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'januar jan._februar feb._mart mar._april apr._maj maj._juni jun._juli jul._august aug._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'nedjelja ned. ne_ponedjeljak pon. po_utorak uto. ut_srijeda sri. sr_\u00c4\u008detvrtak \u00c4\u008det. \u00c4\u008de_petak pet. pe_subota sub. su'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'par sekundi', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedna minuta',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedna minuta',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mjesec',     '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mjesec',     '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mjesec',     '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mjeseca',     '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mjeseca',     '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mjeseca',     '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mjesec',     '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mjeseci',    '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'za par sekundi',  'prefix');\n        assert.equal(moment(0).from(30000), 'prije par sekundi', 'prefix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'prije par sekundi',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'za par sekundi', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'danas u 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'sutra u 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ju\u00c4\u008der u 12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n                return '[u] [nedjelju] [u] LT';\n            case 3:\n                return '[u] [srijedu] [u] LT';\n            case 6:\n                return '[u] [subotu] [u] LT';\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n                return '[u] dddd [u] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n            case 3:\n                return '[pro\u00c5\u00a1lu] dddd [u] LT';\n            case 6:\n                return '[pro\u00c5\u00a1le] [subote] [u] LT';\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n                return '[pro\u00c5\u00a1li] dddd [u] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ca');\n\n    test('parse', function (assert) {\n        var tests = 'gener gen._febrer febr._mar\u00c3\u00a7 mar._abril abr._maig mai._juny jun._juliol jul._agost ag._setembre set._octubre oct._novembre nov._desembre des.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a',      'diumenge, 14\u00c3\u00a8 febrer 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'dg., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2n 02 febrer febr.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\u00c3\u00a8 14'],\n                ['d do dddd ddd dd',                   '0 0\u00c3\u00a8 diumenge dg. Dg'],\n                ['DDD DDDo DDDD',                      '45 45\u00c3\u00a8 045'],\n                ['w wo ww',                            '6 6a 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45\u00c3\u00a8 day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 febrer 2010'],\n                ['LLL',                                '14 febrer 2010 15:25'],\n                ['LLLL',                               'diumenge 14 febrer 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 febr. 2010'],\n                ['lll',                                '14 febr. 2010 15:25'],\n                ['llll',                               'dg. 14 febr. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1r', '1r');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2n', '2n');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3r', '3r');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4t', '4t');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\u00c3\u00a8', '5\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\u00c3\u00a8', '6\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\u00c3\u00a8', '7\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\u00c3\u00a8', '8\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\u00c3\u00a8', '9\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\u00c3\u00a8', '10\u00c3\u00a8');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\u00c3\u00a8', '11\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\u00c3\u00a8', '12\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\u00c3\u00a8', '13\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\u00c3\u00a8', '14\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\u00c3\u00a8', '15\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\u00c3\u00a8', '16\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\u00c3\u00a8', '17\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\u00c3\u00a8', '18\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\u00c3\u00a8', '19\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\u00c3\u00a8', '20\u00c3\u00a8');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\u00c3\u00a8', '21\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\u00c3\u00a8', '22\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\u00c3\u00a8', '23\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\u00c3\u00a8', '24\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\u00c3\u00a8', '25\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\u00c3\u00a8', '26\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\u00c3\u00a8', '27\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\u00c3\u00a8', '28\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\u00c3\u00a8', '29\u00c3\u00a8');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\u00c3\u00a8', '30\u00c3\u00a8');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\u00c3\u00a8', '31\u00c3\u00a8');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'gener gen._febrer febr._mar\u00c3\u00a7 mar._abril abr._maig mai._juny jun._juliol jul._agost ag._setembre set._octubre oct._novembre nov._desembre des.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'diumenge dg. Dg_dilluns dl. Dl_dimarts dt. Dt_dimecres dc. Dc_dijous dj. Dj_divendres dv. Dv_dissabte ds. Ds'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'uns segons', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minut',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minut',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuts',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuts',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'una hora',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'una hora',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hores',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hores',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hores',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un dia',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un dia',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dies',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un dia',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dies',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dies',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mes',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mes',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mes',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesos',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesos',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesos',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mes',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesos',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un any',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anys',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un any',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anys',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'en uns segons',  'prefix');\n        assert.equal(moment(0).from(30000), 'fa uns segons', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'fa uns segons',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'en uns segons', 'en uns segons');\n        assert.equal(moment().add({d: 5}).fromNow(), 'en 5 dies', 'en 5 dies');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                       'avui a les 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),          'avui a les 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),           'avui a les 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),           'dem\u00c3\u00a0 a les 12:00',     'tomorrow at the same time');\n        assert.equal(moment(a).add({d: 1, h : -1}).calendar(),   'dem\u00c3\u00a0 a les 11:00',     'tomorrow minus 1 hour');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),      'avui a les 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),      'ahir a les 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[el] dddd [passat a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[el] dddd [passat a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[el] dddd [passat a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52a', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1a', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1a', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2a', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2a', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('cs');\n\n    test('parse', function (assert) {\n        var tests = 'leden led_\u00c3\u00banor \u00c3\u00bano_b\u00c5\u0099ezen b\u00c5\u0099e_duben dub_kv\u00c4\u009bten kv\u00c4\u009b_\u00c4\u008derven \u00c4\u008dvn_\u00c4\u008dervenec \u00c4\u008dvc_srpen srp_z\u00c3\u00a1\u00c5\u0099\u00c3\u00ad z\u00c3\u00a1\u00c5\u0099_\u00c5\u0099\u00c3\u00adjen \u00c5\u0099\u00c3\u00adj_listopad lis_prosinec pro'.split('_'), i;\n        function equalTest(input, mmm, monthIndex) {\n            assert.equal(moment(input, mmm).month(), monthIndex, input + ' ' + mmm + ' should be month ' + (monthIndex + 1));\n        }\n        function equalTestStrict(input, mmm, monthIndex) {\n            assert.equal(moment(input, mmm, true).month(), monthIndex, input + ' ' + mmm + ' should be strict month ' + (monthIndex + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n\n            equalTestStrict(tests[i][1], 'MMM', i);\n            equalTestStrict(tests[i][0], 'MMMM', i);\n            equalTestStrict(tests[i][1].toLocaleLowerCase(), 'MMM', i);\n            equalTestStrict(tests[i][1].toLocaleUpperCase(), 'MMM', i);\n            equalTestStrict(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTestStrict(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss',  'ned\u00c4\u009ble, \u00c3\u00banor 14. 2010, 3:25:50'],\n                ['ddd, h',                       'ne, 3'],\n                ['M Mo MM MMMM MMM',             '2 2. 02 \u00c3\u00banor \u00c3\u00bano'],\n                ['YYYY YY',                      '2010 10'],\n                ['D Do DD',                      '14 14. 14'],\n                ['d do dddd ddd dd',             '0 0. ned\u00c4\u009ble ne ne'],\n                ['DDD DDDo DDDD',                '45 45. 045'],\n                ['w wo ww',                      '6 6. 06'],\n                ['h hh',                         '3 03'],\n                ['H HH',                         '15 15'],\n                ['m mm',                         '25 25'],\n                ['s ss',                         '50 50'],\n                ['a A',                          'pm PM'],\n                ['DDDo [den v roce]',            '45. den v roce'],\n                ['LTS',                          '15:25:50'],\n                ['L',                            '14.02.2010'],\n                ['LL',                           '14. \u00c3\u00banor 2010'],\n                ['LLL',                          '14. \u00c3\u00banor 2010 15:25'],\n                ['LLLL',                         'ned\u00c4\u009ble 14. \u00c3\u00banor 2010 15:25'],\n                ['l',                            '14.2.2010'],\n                ['ll',                           '14. \u00c3\u00bano 2010'],\n                ['lll',                          '14. \u00c3\u00bano 2010 15:25'],\n                ['llll',                         'ne 14. \u00c3\u00bano 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'leden led_\u00c3\u00banor \u00c3\u00bano_b\u00c5\u0099ezen b\u00c5\u0099e_duben dub_kv\u00c4\u009bten kv\u00c4\u009b_\u00c4\u008derven \u00c4\u008dvn_\u00c4\u008dervenec \u00c4\u008dvc_srpen srp_z\u00c3\u00a1\u00c5\u0099\u00c3\u00ad z\u00c3\u00a1\u00c5\u0099_\u00c5\u0099\u00c3\u00adjen \u00c5\u0099\u00c3\u00adj_listopad lis_prosinec pro'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'ned\u00c4\u009ble ne ne_pond\u00c4\u009bl\u00c3\u00ad po po_\u00c3\u00bater\u00c3\u00bd \u00c3\u00bat \u00c3\u00bat_st\u00c5\u0099eda st st_\u00c4\u008dtvrtek \u00c4\u008dt \u00c4\u008dt_p\u00c3\u00a1tek p\u00c3\u00a1 p\u00c3\u00a1_sobota so so'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'p\u00c3\u00a1r sekund',  '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuta',        '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuta',        '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuty',      '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minut',     '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'hodina',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'hodina',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hodiny',     '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hodin',      '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hodin',     '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'den',       '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'den',       '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dny',         '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'den',       '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dn\u00c3\u00ad',         '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dn\u00c3\u00ad',        '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'm\u00c4\u009bs\u00c3\u00adc',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'm\u00c4\u009bs\u00c3\u00adc',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'm\u00c4\u009bs\u00c3\u00adc',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m\u00c4\u009bs\u00c3\u00adce',    '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m\u00c4\u009bs\u00c3\u00adce',    '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m\u00c4\u009bs\u00c3\u00adce',    '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'm\u00c4\u009bs\u00c3\u00adc',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m\u00c4\u009bs\u00c3\u00adc\u00c5\u00af',    '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'rok',           '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 roky',        '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'rok',           '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 let',         '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'za p\u00c3\u00a1r sekund',  'prefix');\n        assert.equal(moment(0).from(30000), 'p\u00c5\u0099ed p\u00c3\u00a1r sekundami', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'p\u00c5\u0099ed p\u00c3\u00a1r sekundami',  'now from now should display as in the past');\n    });\n\n    test('fromNow (future)', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'za p\u00c3\u00a1r sekund', 'in a few seconds');\n        assert.equal(moment().add({m: 1}).fromNow(), 'za minutu', 'in a minute');\n        assert.equal(moment().add({m: 3}).fromNow(), 'za 3 minuty', 'in 3 minutes');\n        assert.equal(moment().add({m: 10}).fromNow(), 'za 10 minut', 'in 10 minutes');\n        assert.equal(moment().add({h: 1}).fromNow(), 'za hodinu', 'in an hour');\n        assert.equal(moment().add({h: 3}).fromNow(), 'za 3 hodiny', 'in 3 hours');\n        assert.equal(moment().add({h: 10}).fromNow(), 'za 10 hodin', 'in 10 hours');\n        assert.equal(moment().add({d: 1}).fromNow(), 'za den', 'in a day');\n        assert.equal(moment().add({d: 3}).fromNow(), 'za 3 dny', 'in 3 days');\n        assert.equal(moment().add({d: 10}).fromNow(), 'za 10 dn\u00c3\u00ad', 'in 10 days');\n        assert.equal(moment().add({M: 1}).fromNow(), 'za m\u00c4\u009bs\u00c3\u00adc', 'in a month');\n        assert.equal(moment().add({M: 3}).fromNow(), 'za 3 m\u00c4\u009bs\u00c3\u00adce', 'in 3 months');\n        assert.equal(moment().add({M: 10}).fromNow(), 'za 10 m\u00c4\u009bs\u00c3\u00adc\u00c5\u00af', 'in 10 months');\n        assert.equal(moment().add({y: 1}).fromNow(), 'za rok', 'in a year');\n        assert.equal(moment().add({y: 3}).fromNow(), 'za 3 roky', 'in 3 years');\n        assert.equal(moment().add({y: 10}).fromNow(), 'za 10 let', 'in 10 years');\n    });\n\n    test('fromNow (past)', function (assert) {\n        assert.equal(moment().subtract({s: 30}).fromNow(), 'p\u00c5\u0099ed p\u00c3\u00a1r sekundami', 'a few seconds ago');\n        assert.equal(moment().subtract({m: 1}).fromNow(), 'p\u00c5\u0099ed minutou', 'a minute ago');\n        assert.equal(moment().subtract({m: 3}).fromNow(), 'p\u00c5\u0099ed 3 minutami', '3 minutes ago');\n        assert.equal(moment().subtract({m: 10}).fromNow(), 'p\u00c5\u0099ed 10 minutami', '10 minutes ago');\n        assert.equal(moment().subtract({h: 1}).fromNow(), 'p\u00c5\u0099ed hodinou', 'an hour ago');\n        assert.equal(moment().subtract({h: 3}).fromNow(), 'p\u00c5\u0099ed 3 hodinami', '3 hours ago');\n        assert.equal(moment().subtract({h: 10}).fromNow(), 'p\u00c5\u0099ed 10 hodinami', '10 hours ago');\n        assert.equal(moment().subtract({d: 1}).fromNow(), 'p\u00c5\u0099ed dnem', 'a day ago');\n        assert.equal(moment().subtract({d: 3}).fromNow(), 'p\u00c5\u0099ed 3 dny', '3 days ago');\n        assert.equal(moment().subtract({d: 10}).fromNow(), 'p\u00c5\u0099ed 10 dny', '10 days ago');\n        assert.equal(moment().subtract({M: 1}).fromNow(), 'p\u00c5\u0099ed m\u00c4\u009bs\u00c3\u00adcem', 'a month ago');\n        assert.equal(moment().subtract({M: 3}).fromNow(), 'p\u00c5\u0099ed 3 m\u00c4\u009bs\u00c3\u00adci', '3 months ago');\n        assert.equal(moment().subtract({M: 10}).fromNow(), 'p\u00c5\u0099ed 10 m\u00c4\u009bs\u00c3\u00adci', '10 months ago');\n        assert.equal(moment().subtract({y: 1}).fromNow(), 'p\u00c5\u0099ed rokem', 'a year ago');\n        assert.equal(moment().subtract({y: 3}).fromNow(), 'p\u00c5\u0099ed 3 lety', '3 years ago');\n        assert.equal(moment().subtract({y: 10}).fromNow(), 'p\u00c5\u0099ed 10 lety', '10 years ago');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'dnes v 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'dnes v 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'dnes v 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'z\u00c3\u00adtra v 12:00',    'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'dnes v 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'v\u00c4\u008dera v 12:00',    'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m, nextDay;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            nextDay = '';\n            switch (m.day()) {\n            case 0:\n                nextDay = 'v ned\u00c4\u009bli';\n                break;\n            case 1:\n                nextDay = 'v pond\u00c4\u009bl\u00c3\u00ad';\n                break;\n            case 2:\n                nextDay = 'v \u00c3\u00bater\u00c3\u00bd';\n                break;\n            case 3:\n                nextDay = 've st\u00c5\u0099edu';\n                break;\n            case 4:\n                nextDay = 've \u00c4\u008dtvrtek';\n                break;\n            case 5:\n                nextDay = 'v p\u00c3\u00a1tek';\n                break;\n            case 6:\n                nextDay = 'v sobotu';\n                break;\n            }\n            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [v] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [v] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [v] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m, lastDay;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            lastDay = '';\n            switch (m.day()) {\n            case 0:\n                lastDay = 'minulou ned\u00c4\u009bli';\n                break;\n            case 1:\n                lastDay = 'minul\u00c3\u00a9 pond\u00c4\u009bl\u00c3\u00ad';\n                break;\n            case 2:\n                lastDay = 'minul\u00c3\u00a9 \u00c3\u00bater\u00c3\u00bd';\n                break;\n            case 3:\n                lastDay = 'minulou st\u00c5\u0099edu';\n                break;\n            case 4:\n                lastDay = 'minul\u00c3\u00bd \u00c4\u008dtvrtek';\n                break;\n            case 5:\n                lastDay = 'minul\u00c3\u00bd p\u00c3\u00a1tek';\n                break;\n            case 6:\n                lastDay = 'minulou sobotu';\n                break;\n            }\n            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [v] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [v] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [v] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('humanize duration', function (assert) {\n        assert.equal(moment.duration(1, 'minutes').humanize(), 'minuta', 'a minute (future)');\n        assert.equal(moment.duration(1, 'minutes').humanize(true), 'za minutu', 'in a minute');\n        assert.equal(moment.duration(-1, 'minutes').humanize(), 'minuta', 'a minute (past)');\n        assert.equal(moment.duration(-1, 'minutes').humanize(true), 'p\u00c5\u0099ed minutou', 'a minute ago');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('cv');\n\n    test('parse', function (assert) {\n        var tests = '\u00d0\u00ba\u00d3\u0091\u00d1\u0080\u00d0\u00bb\u00d0\u00b0\u00d1\u0087 \u00d0\u00ba\u00d3\u0091\u00d1\u0080_\u00d0\u00bd\u00d0\u00b0\u00d1\u0080\u00d3\u0091\u00d1\u0081 \u00d0\u00bd\u00d0\u00b0\u00d1\u0080_\u00d0\u00bf\u00d1\u0083\u00d1\u0088 \u00d0\u00bf\u00d1\u0083\u00d1\u0088_\u00d0\u00b0\u00d0\u00ba\u00d0\u00b0 \u00d0\u00b0\u00d0\u00ba\u00d0\u00b0_\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9 \u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d2\u00ab\u00d3\u0097\u00d1\u0080\u00d1\u0082\u00d0\u00bc\u00d0\u00b5 \u00d2\u00ab\u00d3\u0097\u00d1\u0080_\u00d1\u0083\u00d1\u0082\u00d3\u0091 \u00d1\u0083\u00d1\u0082\u00d3\u0091_\u00d2\u00ab\u00d1\u0083\u00d1\u0080\u00d0\u00bb\u00d0\u00b0 \u00d2\u00ab\u00d1\u0083\u00d1\u0080_\u00d0\u00b0\u00d0\u00b2\u00d3\u0091\u00d0\u00bd \u00d0\u00b0\u00d0\u00b2\u00d0\u00bd_\u00d1\u008e\u00d0\u00bf\u00d0\u00b0 \u00d1\u008e\u00d0\u00bf\u00d0\u00b0_\u00d1\u0087\u00d3\u00b3\u00d0\u00ba \u00d1\u0087\u00d3\u00b3\u00d0\u00ba_\u00d1\u0080\u00d0\u00b0\u00d1\u0088\u00d1\u0082\u00d0\u00b0\u00d0\u00b2 \u00d1\u0080\u00d0\u00b0\u00d1\u0088'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      '\u00d0\u00b2\u00d1\u008b\u00d1\u0080\u00d1\u0081\u00d0\u00b0\u00d1\u0080\u00d0\u00bd\u00d0\u00b8\u00d0\u00ba\u00d1\u0083\u00d0\u00bd, \u00d0\u00bd\u00d0\u00b0\u00d1\u0080\u00d3\u0091\u00d1\u0081 14-\u00d0\u00bc\u00d3\u0097\u00d1\u0088 2010, 3:25:50 pm'],\n                ['ddd, hA',                            '\u00d0\u00b2\u00d1\u008b\u00d1\u0080, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2-\u00d0\u00bc\u00d3\u0097\u00d1\u0088 02 \u00d0\u00bd\u00d0\u00b0\u00d1\u0080\u00d3\u0091\u00d1\u0081 \u00d0\u00bd\u00d0\u00b0\u00d1\u0080'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14-\u00d0\u00bc\u00d3\u0097\u00d1\u0088 14'],\n                ['d do dddd ddd dd',                   '0 0-\u00d0\u00bc\u00d3\u0097\u00d1\u0088 \u00d0\u00b2\u00d1\u008b\u00d1\u0080\u00d1\u0081\u00d0\u00b0\u00d1\u0080\u00d0\u00bd\u00d0\u00b8\u00d0\u00ba\u00d1\u0083\u00d0\u00bd \u00d0\u00b2\u00d1\u008b\u00d1\u0080 \u00d0\u00b2\u00d1\u0080'],\n                ['DDD DDDo DDDD',                      '45 45-\u00d0\u00bc\u00d3\u0097\u00d1\u0088 045'],\n                ['w wo ww',                            '7 7-\u00d0\u00bc\u00d3\u0097\u00d1\u0088 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['\u00d2\u00aa\u00d1\u0083\u00d0\u00bb\u00d3\u0091\u00d0\u00bd DDDo \u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d3\u0097',                    '\u00d2\u00aa\u00d1\u0083\u00d0\u00bb\u00d3\u0091\u00d0\u00bd 45-\u00d0\u00bc\u00d3\u0097\u00d1\u0088 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d3\u0097'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14-02-2010'],\n                ['LL',                                 '2010 \u00d2\u00ab\u00d1\u0083\u00d0\u00bb\u00d1\u0085\u00d0\u00b8 \u00d0\u00bd\u00d0\u00b0\u00d1\u0080\u00d3\u0091\u00d1\u0081 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085\u00d3\u0097\u00d0\u00bd 14-\u00d0\u00bc\u00d3\u0097\u00d1\u0088\u00d3\u0097'],\n                ['LLL',                                '2010 \u00d2\u00ab\u00d1\u0083\u00d0\u00bb\u00d1\u0085\u00d0\u00b8 \u00d0\u00bd\u00d0\u00b0\u00d1\u0080\u00d3\u0091\u00d1\u0081 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085\u00d3\u0097\u00d0\u00bd 14-\u00d0\u00bc\u00d3\u0097\u00d1\u0088\u00d3\u0097, 15:25'],\n                ['LLLL',                               '\u00d0\u00b2\u00d1\u008b\u00d1\u0080\u00d1\u0081\u00d0\u00b0\u00d1\u0080\u00d0\u00bd\u00d0\u00b8\u00d0\u00ba\u00d1\u0083\u00d0\u00bd, 2010 \u00d2\u00ab\u00d1\u0083\u00d0\u00bb\u00d1\u0085\u00d0\u00b8 \u00d0\u00bd\u00d0\u00b0\u00d1\u0080\u00d3\u0091\u00d1\u0081 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085\u00d3\u0097\u00d0\u00bd 14-\u00d0\u00bc\u00d3\u0097\u00d1\u0088\u00d3\u0097, 15:25'],\n                ['l',                                  '14-2-2010'],\n                ['ll',                                 '2010 \u00d2\u00ab\u00d1\u0083\u00d0\u00bb\u00d1\u0085\u00d0\u00b8 \u00d0\u00bd\u00d0\u00b0\u00d1\u0080 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085\u00d3\u0097\u00d0\u00bd 14-\u00d0\u00bc\u00d3\u0097\u00d1\u0088\u00d3\u0097'],\n                ['lll',                                '2010 \u00d2\u00ab\u00d1\u0083\u00d0\u00bb\u00d1\u0085\u00d0\u00b8 \u00d0\u00bd\u00d0\u00b0\u00d1\u0080 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085\u00d3\u0097\u00d0\u00bd 14-\u00d0\u00bc\u00d3\u0097\u00d1\u0088\u00d3\u0097, 15:25'],\n                ['llll',                               '\u00d0\u00b2\u00d1\u008b\u00d1\u0080, 2010 \u00d2\u00ab\u00d1\u0083\u00d0\u00bb\u00d1\u0085\u00d0\u00b8 \u00d0\u00bd\u00d0\u00b0\u00d1\u0080 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085\u00d3\u0097\u00d0\u00bd 14-\u00d0\u00bc\u00d3\u0097\u00d1\u0088\u00d3\u0097, 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '1-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '2-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '3-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '4-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '5-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '6-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '7-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '8-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '9-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '10-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '11-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '12-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '13-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '14-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '15-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '16-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '17-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '18-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '19-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '20-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '21-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '22-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '23-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '24-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '25-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '26-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '27-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '28-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '29-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '30-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', '31-\u00d0\u00bc\u00d3\u0097\u00d1\u0088');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d0\u00ba\u00d3\u0091\u00d1\u0080\u00d0\u00bb\u00d0\u00b0\u00d1\u0087 \u00d0\u00ba\u00d3\u0091\u00d1\u0080_\u00d0\u00bd\u00d0\u00b0\u00d1\u0080\u00d3\u0091\u00d1\u0081 \u00d0\u00bd\u00d0\u00b0\u00d1\u0080_\u00d0\u00bf\u00d1\u0083\u00d1\u0088 \u00d0\u00bf\u00d1\u0083\u00d1\u0088_\u00d0\u00b0\u00d0\u00ba\u00d0\u00b0 \u00d0\u00b0\u00d0\u00ba\u00d0\u00b0_\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9 \u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d2\u00ab\u00d3\u0097\u00d1\u0080\u00d1\u0082\u00d0\u00bc\u00d0\u00b5 \u00d2\u00ab\u00d3\u0097\u00d1\u0080_\u00d1\u0083\u00d1\u0082\u00d3\u0091 \u00d1\u0083\u00d1\u0082\u00d3\u0091_\u00d2\u00ab\u00d1\u0083\u00d1\u0080\u00d0\u00bb\u00d0\u00b0 \u00d2\u00ab\u00d1\u0083\u00d1\u0080_\u00d0\u00b0\u00d0\u00b2\u00d3\u0091\u00d0\u00bd \u00d0\u00b0\u00d0\u00b2\u00d0\u00bd_\u00d1\u008e\u00d0\u00bf\u00d0\u00b0 \u00d1\u008e\u00d0\u00bf\u00d0\u00b0_\u00d1\u0087\u00d3\u00b3\u00d0\u00ba \u00d1\u0087\u00d3\u00b3\u00d0\u00ba_\u00d1\u0080\u00d0\u00b0\u00d1\u0088\u00d1\u0082\u00d0\u00b0\u00d0\u00b2 \u00d1\u0080\u00d0\u00b0\u00d1\u0088'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d0\u00b2\u00d1\u008b\u00d1\u0080\u00d1\u0081\u00d0\u00b0\u00d1\u0080\u00d0\u00bd\u00d0\u00b8\u00d0\u00ba\u00d1\u0083\u00d0\u00bd \u00d0\u00b2\u00d1\u008b\u00d1\u0080 \u00d0\u00b2\u00d1\u0080_\u00d1\u0082\u00d1\u0083\u00d0\u00bd\u00d1\u0082\u00d0\u00b8\u00d0\u00ba\u00d1\u0083\u00d0\u00bd \u00d1\u0082\u00d1\u0083\u00d0\u00bd \u00d1\u0082\u00d0\u00bd_\u00d1\u008b\u00d1\u0082\u00d0\u00bb\u00d0\u00b0\u00d1\u0080\u00d0\u00b8\u00d0\u00ba\u00d1\u0083\u00d0\u00bd \u00d1\u008b\u00d1\u0082\u00d0\u00bb \u00d1\u008b\u00d1\u0082_\u00d1\u008e\u00d0\u00bd\u00d0\u00ba\u00d1\u0083\u00d0\u00bd \u00d1\u008e\u00d0\u00bd \u00d1\u008e\u00d0\u00bd_\u00d0\u00ba\u00d3\u0097\u00d2\u00ab\u00d0\u00bd\u00d0\u00b5\u00d1\u0080\u00d0\u00bd\u00d0\u00b8\u00d0\u00ba\u00d1\u0083\u00d0\u00bd \u00d0\u00ba\u00d3\u0097\u00d2\u00ab \u00d0\u00ba\u00d2\u00ab_\u00d1\u008d\u00d1\u0080\u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd \u00d1\u008d\u00d1\u0080\u00d0\u00bd \u00d1\u008d\u00d1\u0080_\u00d1\u0088\u00d3\u0091\u00d0\u00bc\u00d0\u00b0\u00d1\u0082\u00d0\u00ba\u00d1\u0083\u00d0\u00bd \u00d1\u0088\u00d3\u0091\u00d0\u00bc \u00d1\u0088\u00d0\u00bc'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d0\u00bf\u00d3\u0097\u00d1\u0080-\u00d0\u00b8\u00d0\u00ba \u00d2\u00ab\u00d0\u00b5\u00d0\u00ba\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d1\u0082', '44 sekunder = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d1\u0083\u00d0\u00b9\u00d3\u0091\u00d1\u0085',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d2\u00ab\u00d1\u0083\u00d0\u00bb',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00d2\u00ab\u00d1\u0083\u00d0\u00bb',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d0\u00bf\u00d3\u0097\u00d1\u0080 \u00d2\u00ab\u00d1\u0083\u00d0\u00bb',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d2\u00ab\u00d1\u0083\u00d0\u00bb',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d0\u00bf\u00d3\u0097\u00d1\u0080-\u00d0\u00b8\u00d0\u00ba \u00d2\u00ab\u00d0\u00b5\u00d0\u00ba\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00bd',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00d0\u00bf\u00d3\u0097\u00d1\u0080-\u00d0\u00b8\u00d0\u00ba \u00d2\u00ab\u00d0\u00b5\u00d0\u00ba\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d1\u0082 \u00d0\u00ba\u00d0\u00b0\u00d1\u008f\u00d0\u00bb\u00d0\u00bb\u00d0\u00b0', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00d0\u00bf\u00d3\u0097\u00d1\u0080-\u00d0\u00b8\u00d0\u00ba \u00d2\u00ab\u00d0\u00b5\u00d0\u00ba\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d1\u0082 \u00d0\u00ba\u00d0\u00b0\u00d1\u008f\u00d0\u00bb\u00d0\u00bb\u00d0\u00b0',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d0\u00bf\u00d3\u0097\u00d1\u0080-\u00d0\u00b8\u00d0\u00ba \u00d2\u00ab\u00d0\u00b5\u00d0\u00ba\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00bd', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d1\u0080\u00d0\u00b0\u00d0\u00bd', 'in 5 days');\n        assert.equal(moment().add({h: 2}).fromNow(), '2 \u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5\u00d0\u00bd', 'in 2 hours, the right suffix!');\n        assert.equal(moment().add({y: 3}).fromNow(), '3 \u00d2\u00ab\u00d1\u0083\u00d0\u00bb\u00d1\u0082\u00d0\u00b0\u00d0\u00bd', 'in 3 years, the right suffix!');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n        assert.equal(moment(a).calendar(),                   '\u00d0\u009f\u00d0\u00b0\u00d1\u008f\u00d0\u00bd 12:00 \u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d0\u009f\u00d0\u00b0\u00d1\u008f\u00d0\u00bd 12:25 \u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d0\u009f\u00d0\u00b0\u00d1\u008f\u00d0\u00bd 13:00 \u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d0\u00ab\u00d1\u0080\u00d0\u00b0\u00d0\u00bd 12:00 \u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d0\u009f\u00d0\u00b0\u00d1\u008f\u00d0\u00bd 11:00 \u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d3\u0096\u00d0\u00bd\u00d0\u00b5\u00d1\u0080 12:00 \u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00d2\u00aa\u00d0\u00b8\u00d1\u0082\u00d0\u00b5\u00d1\u0081] dddd LT [\u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5]'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00d2\u00aa\u00d0\u00b8\u00d1\u0082\u00d0\u00b5\u00d1\u0081] dddd LT [\u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5]'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00d2\u00aa\u00d0\u00b8\u00d1\u0082\u00d0\u00b5\u00d1\u0081] dddd LT [\u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5]'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00d0\u0098\u00d1\u0080\u00d1\u0082\u00d0\u00bd\u00d3\u0097] dddd LT [\u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5]'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00d0\u0098\u00d1\u0080\u00d1\u0082\u00d0\u00bd\u00d3\u0097] dddd LT [\u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5]'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00d0\u0098\u00d1\u0080\u00d1\u0082\u00d0\u00bd\u00d3\u0097] dddd LT [\u00d1\u0081\u00d0\u00b5\u00d1\u0085\u00d0\u00b5\u00d1\u0082\u00d1\u0080\u00d0\u00b5]'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    // Monday is the first day of the week.\n    // The week that contains Jan 1st is the first week of the year.\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-\u00d0\u00bc\u00d3\u0097\u00d1\u0088', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('cy');\n\n    test('parse', function (assert) {\n        var tests = 'Ionawr Ion_Chwefror Chwe_Mawrth Maw_Ebrill Ebr_Mai Mai_Mehefin Meh_Gorffennaf Gor_Awst Aws_Medi Med_Hydref Hyd_Tachwedd Tach_Rhagfyr Rhag'.split('_'),\n            i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Dydd Sul, Chwefror 14eg 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Sul, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2il 02 Chwefror Chwe'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14eg 14'],\n                ['d do dddd ddd dd',                   '0 0 Dydd Sul Sul Su'],\n                ['DDD DDDo DDDD',                      '45 45ain 045'],\n                ['w wo ww',                            '6 6ed 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45ain day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 Chwefror 2010'],\n                ['LLL',                                '14 Chwefror 2010 15:25'],\n                ['LLLL',                               'Dydd Sul, 14 Chwefror 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Chwe 2010'],\n                ['lll',                                '14 Chwe 2010 15:25'],\n                ['llll',                               'Sul, 14 Chwe 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1af', '1af');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2il', '2il');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3ydd', '3ydd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4ydd', '4ydd');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5ed', '5ed');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6ed', '6ed');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7ed', '7ed');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8fed', '8fed');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9fed', '9fed');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10fed', '10fed');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11eg', '11eg');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12fed', '12fed');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13eg', '13eg');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14eg', '14eg');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15fed', '15fed');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16eg', '16eg');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17eg', '17eg');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18fed', '18fed');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19eg', '19eg');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20fed', '20fed');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ain', '21ain');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ain', '22ain');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ain', '23ain');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ain', '24ain');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ain', '25ain');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ain', '26ain');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ain', '27ain');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ain', '28ain');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ain', '29ain');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ain', '30ain');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ain', '31ain');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Ionawr Ion_Chwefror Chwe_Mawrth Maw_Ebrill Ebr_Mai Mai_Mehefin Meh_Gorffennaf Gor_Awst Aws_Medi Med_Hydref Hyd_Tachwedd Tach_Rhagfyr Rhag'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Dydd Sul Sul Su_Dydd Llun Llun Ll_Dydd Mawrth Maw Ma_Dydd Mercher Mer Me_Dydd Iau Iau Ia_Dydd Gwener Gwe Gw_Dydd Sadwrn Sad Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ychydig eiliadau', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'munud',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'munud',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 munud',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 munud', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'awr',    '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'awr',    '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 awr',    '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 awr',    '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 awr',   '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'diwrnod',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'diwrnod',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 diwrnod',     '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'diwrnod',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 diwrnod',     '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 diwrnod',    '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mis',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mis',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mis',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mis',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mis',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mis',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mis',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mis',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'blwyddyn',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 flynedd',    '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'blwyddyn',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 flynedd',    '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'mewn ychydig eiliadau', 'prefix');\n        assert.equal(moment(0).from(30000), 'ychydig eiliadau yn \u00c3\u00b4l', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'mewn ychydig eiliadau', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'mewn 5 diwrnod', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Heddiw am 12:00',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Heddiw am 12:25',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Heddiw am 13:00',    'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Yfory am 12:00',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Heddiw am 11:00',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ddoe am 12:00',      'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [am] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [am] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [am] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [diwethaf am] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [diwethaf am] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [diwethaf am] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ain', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1af', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1af', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2il', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2il', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('da');\n\n    test('parse', function (assert) {\n        var tests = 'januar jan_februar feb_marts mar_april apr_maj maj_juni jun_juli jul_august aug_september sep_oktober okt_november nov_december dec'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd [den] Do MMMM YYYY, h:mm:ss a', 's\u00c3\u00b8ndag den 14. februar 2010, 3:25:50 pm'],\n                ['ddd hA',                             's\u00c3\u00b8n 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. s\u00c3\u00b8ndag s\u00c3\u00b8n s\u00c3\u00b8'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[den] DDDo [dag p\u00c3\u00a5 \u00c3\u00a5ret]',           'den 45. dag p\u00c3\u00a5 \u00c3\u00a5ret'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14. februar 2010'],\n                ['LLL',                                '14. februar 2010 15:25'],\n                ['LLLL',                               's\u00c3\u00b8ndag d. 14. februar 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14. feb 2010'],\n                ['lll',                                '14. feb 2010 15:25'],\n                ['llll',                               's\u00c3\u00b8n d. 14. feb 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'januar jan_februar feb_marts mar_april apr_maj maj_juni jun_juli jul_august aug_september sep_oktober okt_november nov_december dec'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 's\u00c3\u00b8ndag s\u00c3\u00b8n s\u00c3\u00b8_mandag man ma_tirsdag tir ti_onsdag ons on_torsdag tor to_fredag fre fr_l\u00c3\u00b8rdag l\u00c3\u00b8r l\u00c3\u00b8'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'f\u00c3\u00a5 sekunder', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'et minut',    '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'et minut',    '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutter',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutter', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'en time',     '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'en time',     '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timer',     '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timer',     '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timer',    '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dag',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dag',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dage',      '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dag',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dage',      '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dage',     '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en m\u00c3\u00a5ned',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en m\u00c3\u00a5ned',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en m\u00c3\u00a5ned',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m\u00c3\u00a5neder',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m\u00c3\u00a5neder',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m\u00c3\u00a5neder',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en m\u00c3\u00a5ned',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m\u00c3\u00a5neder',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'et \u00c3\u00a5r',       '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00c3\u00a5r',        '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'et \u00c3\u00a5r',       '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00c3\u00a5r',        '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'om f\u00c3\u00a5 sekunder',  'prefix');\n        assert.equal(moment(0).from(30000), 'f\u00c3\u00a5 sekunder siden', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'f\u00c3\u00a5 sekunder siden',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'om f\u00c3\u00a5 sekunder', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dage', 'in 5 days');\n    });\n\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'I dag kl. 12:00',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'I dag kl. 12:25',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'I dag kl. 13:00',    'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'I morgen kl. 12:00', 'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'I dag kl. 11:00',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'I g\u00c3\u00a5r kl. 12:00',    'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[sidste] dddd [kl] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[sidste] dddd [kl] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[sidste] dddd [kl] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('de-at');\n\n    test('parse', function (assert) {\n        var tests = 'J\u00c3\u00a4nner J\u00c3\u00a4n._Februar Febr._M\u00c3\u00a4rz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a', 'Sonntag, 14. Februar 2010, 3:25:50 pm'],\n                ['ddd, hA', 'So., 3PM'],\n                ['M Mo MM MMMM MMM', '2 2. 02 Februar Febr.'],\n                ['YYYY YY', '2010 10'],\n                ['D Do DD', '14 14. 14'],\n                ['d do dddd ddd dd', '0 0. Sonntag So. So'],\n                ['DDD DDDo DDDD', '45 45. 045'],\n                ['w wo ww', '6 6. 06'],\n                ['h hh', '3 03'],\n                ['H HH', '15 15'],\n                ['m mm', '25 25'],\n                ['s ss', '50 50'],\n                ['a A', 'pm PM'],\n                ['[the] DDDo [day of the year]', 'the 45. day of the year'],\n                ['LTS', '15:25:50'],\n                ['L', '14.02.2010'],\n                ['LL', '14. Februar 2010'],\n                ['LLL', '14. Februar 2010 15:25'],\n                ['LLLL', 'Sonntag, 14. Februar 2010 15:25'],\n                ['l', '14.2.2010'],\n                ['ll', '14. Febr. 2010'],\n                ['lll', '14. Febr. 2010 15:25'],\n                ['llll', 'So., 14. Febr. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'J\u00c3\u00a4nner J\u00c3\u00a4n._Februar Febr._M\u00c3\u00a4rz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Sonntag So. So_Montag Mo. Mo_Dienstag Di. Di_Mittwoch Mi. Mi_Donnerstag Do. Do_Freitag Fr. Fr_Samstag Sa. Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), 'ein paar Sekunden', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), 'eine Minute', '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), 'eine Minute', '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 Minuten', '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 Minuten', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), 'eine Stunde', '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), 'eine Stunde', '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 Stunden', '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 Stunden', '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 Stunden', '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), 'ein Tag', '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), 'ein Tag', '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 Tage', '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), 'ein Tag', '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 Tage', '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 Tage', '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), 'ein Monat', '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), 'ein Monat', '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 Monate', '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 Monate', '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 Monate', '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), 'ein Monat', '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 Monate', '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ein Jahr', '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Jahre', '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'ein Jahr', '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 Jahre', '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'in ein paar Sekunden', 'prefix');\n        assert.equal(moment(0).from(30000), 'vor ein paar Sekunden', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'in ein paar Sekunden', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 Tagen', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                  'heute um 12:00 Uhr',   'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),     'heute um 12:25 Uhr',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),      'heute um 13:00 Uhr',   'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),      'morgen um 12:00 Uhr',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(), 'heute um 11:00 Uhr',   'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(), 'gestern um 12:00 Uhr', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(), m.format('dddd [um] LT [Uhr]'), 'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format('dddd [um] LT [Uhr]'), 'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format('dddd [um] LT [Uhr]'), 'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(), m.format('[letzten] dddd [um] LT [Uhr]'), 'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format('[letzten] dddd [um] LT [Uhr]'), 'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format('[letzten] dddd [um] LT [Uhr]'), 'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');\n        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('de');\n\n    test('parse', function (assert) {\n        var tests = 'Januar Jan._Februar Febr._M\u00c3\u00a4rz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a',      'Sonntag, 14. Februar 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'So., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 Februar Febr.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. Sonntag So. So'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14. Februar 2010'],\n                ['LLL',                                '14. Februar 2010 15:25'],\n                ['LLLL',                               'Sonntag, 14. Februar 2010 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14. Febr. 2010'],\n                ['lll',                                '14. Febr. 2010 15:25'],\n                ['llll',                               'So., 14. Febr. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Januar Jan._Februar Febr._M\u00c3\u00a4rz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Sonntag So. So_Montag Mo. Mo_Dienstag Di. Di_Mittwoch Mi. Mi_Donnerstag Do. Do_Freitag Fr. Fr_Samstag Sa. Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ein paar Sekunden',  '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'eine Minute',       '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'eine Minute',       '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Minuten',          '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Minuten',         '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'eine Stunde',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'eine Stunde',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 Stunden',          '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 Stunden',          '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 Stunden',         '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ein Tag',          '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ein Tag',          '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Tage',            '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ein Tag',          '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Tage',            '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Tage',           '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ein Monat',        '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ein Monat',        '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ein Monat',        '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Monate',          '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Monate',          '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Monate',          '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ein Monat',        '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Monate',          '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ein Jahr',         '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Jahre',           '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ein Jahr',         '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Jahre',           '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'in ein paar Sekunden', 'prefix');\n        assert.equal(moment(0).from(30000), 'vor ein paar Sekunden', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'in ein paar Sekunden', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 Tagen', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'heute um 12:00 Uhr',   'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'heute um 12:25 Uhr',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'heute um 13:00 Uhr',   'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'morgen um 12:00 Uhr',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'heute um 11:00 Uhr',   'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'gestern um 12:00 Uhr', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [um] LT [Uhr]'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [um] LT [Uhr]'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [um] LT [Uhr]'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[letzten] dddd [um] LT [Uhr]'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[letzten] dddd [um] LT [Uhr]'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[letzten] dddd [um] LT [Uhr]'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('dv');\n\n    test('parse', function (assert) {\n        var i,\n            tests = [\n                '\u00de\u0096\u00de\u00ac\u00de\u0082\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9',\n                '\u00de\u008a\u00de\u00ac\u00de\u0084\u00de\u00b0\u00de\u0083\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9',\n                '\u00de\u0089\u00de\u00a7\u00de\u0083\u00de\u00a8\u00de\u0097\u00de\u00aa',\n                '\u00de\u0087\u00de\u00ad\u00de\u0095\u00de\u00b0\u00de\u0083\u00de\u00a9\u00de\u008d\u00de\u00aa',\n                '\u00de\u0089\u00de\u00ad',\n                '\u00de\u0096\u00de\u00ab\u00de\u0082\u00de\u00b0',\n                '\u00de\u0096\u00de\u00aa\u00de\u008d\u00de\u00a6\u00de\u0087\u00de\u00a8',\n                '\u00de\u0087\u00de\u00af\u00de\u008e\u00de\u00a6\u00de\u0090\u00de\u00b0\u00de\u0093\u00de\u00aa',\n                '\u00de\u0090\u00de\u00ac\u00de\u0095\u00de\u00b0\u00de\u0093\u00de\u00ac\u00de\u0089\u00de\u00b0\u00de\u0084\u00de\u00a6\u00de\u0083\u00de\u00aa',\n                '\u00de\u0087\u00de\u00ae\u00de\u0086\u00de\u00b0\u00de\u0093\u00de\u00af\u00de\u0084\u00de\u00a6\u00de\u0083\u00de\u00aa',\n                '\u00de\u0082\u00de\u00ae\u00de\u0088\u00de\u00ac\u00de\u0089\u00de\u00b0\u00de\u0084\u00de\u00a6\u00de\u0083\u00de\u00aa',\n                '\u00de\u0091\u00de\u00a8\u00de\u0090\u00de\u00ac\u00de\u0089\u00de\u00b0\u00de\u0084\u00de\u00a6\u00de\u0083\u00de\u00aa'\n            ];\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            equalTest(tests[i], 'MMM', i);\n            equalTest(tests[i], 'MMMM', i);\n            equalTest(tests[i].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      '\u00de\u0087\u00de\u00a7\u00de\u008b\u00de\u00a8\u00de\u0087\u00de\u00b0\u00de\u008c\u00de\u00a6\u00d8\u008c \u00de\u008a\u00de\u00ac\u00de\u0084\u00de\u00b0\u00de\u0083\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9 14 2010\u00d8\u008c 3:25:50 \u00de\u0089\u00de\u008a'],\n                ['ddd, hA',                            '\u00de\u0087\u00de\u00a7\u00de\u008b\u00de\u00a8\u00de\u0087\u00de\u00b0\u00de\u008c\u00de\u00a6\u00d8\u008c 3\u00de\u0089\u00de\u008a'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 \u00de\u008a\u00de\u00ac\u00de\u0084\u00de\u00b0\u00de\u0083\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9 \u00de\u008a\u00de\u00ac\u00de\u0084\u00de\u00b0\u00de\u0083\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 \u00de\u0087\u00de\u00a7\u00de\u008b\u00de\u00a8\u00de\u0087\u00de\u00b0\u00de\u008c\u00de\u00a6 \u00de\u0087\u00de\u00a7\u00de\u008b\u00de\u00a8\u00de\u0087\u00de\u00b0\u00de\u008c\u00de\u00a6 \u00de\u0087\u00de\u00a7\u00de\u008b\u00de\u00a8'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '8 8 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00de\u0089\u00de\u008a \u00de\u0089\u00de\u008a'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/2/2010'],\n                ['LL',                                 '14 \u00de\u008a\u00de\u00ac\u00de\u0084\u00de\u00b0\u00de\u0083\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9 2010'],\n                ['LLL',                                '14 \u00de\u008a\u00de\u00ac\u00de\u0084\u00de\u00b0\u00de\u0083\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9 2010 15:25'],\n                ['LLLL',                               '\u00de\u0087\u00de\u00a7\u00de\u008b\u00de\u00a8\u00de\u0087\u00de\u00b0\u00de\u008c\u00de\u00a6 14 \u00de\u008a\u00de\u00ac\u00de\u0084\u00de\u00b0\u00de\u0083\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 \u00de\u008a\u00de\u00ac\u00de\u0084\u00de\u00b0\u00de\u0083\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9 2010'],\n                ['lll',                                '14 \u00de\u008a\u00de\u00ac\u00de\u0084\u00de\u00b0\u00de\u0083\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9 2010 15:25'],\n                ['llll',                               '\u00de\u0087\u00de\u00a7\u00de\u008b\u00de\u00a8\u00de\u0087\u00de\u00b0\u00de\u008c\u00de\u00a6 14 \u00de\u008a\u00de\u00ac\u00de\u0084\u00de\u00b0\u00de\u0083\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format month', function (assert) {\n        var i,\n            expected = [\n                '\u00de\u0096\u00de\u00ac\u00de\u0082\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9',\n                '\u00de\u008a\u00de\u00ac\u00de\u0084\u00de\u00b0\u00de\u0083\u00de\u00aa\u00de\u0087\u00de\u00a6\u00de\u0083\u00de\u00a9',\n                '\u00de\u0089\u00de\u00a7\u00de\u0083\u00de\u00a8\u00de\u0097\u00de\u00aa',\n                '\u00de\u0087\u00de\u00ad\u00de\u0095\u00de\u00b0\u00de\u0083\u00de\u00a9\u00de\u008d\u00de\u00aa',\n                '\u00de\u0089\u00de\u00ad',\n                '\u00de\u0096\u00de\u00ab\u00de\u0082\u00de\u00b0',\n                '\u00de\u0096\u00de\u00aa\u00de\u008d\u00de\u00a6\u00de\u0087\u00de\u00a8',\n                '\u00de\u0087\u00de\u00af\u00de\u008e\u00de\u00a6\u00de\u0090\u00de\u00b0\u00de\u0093\u00de\u00aa',\n                '\u00de\u0090\u00de\u00ac\u00de\u0095\u00de\u00b0\u00de\u0093\u00de\u00ac\u00de\u0089\u00de\u00b0\u00de\u0084\u00de\u00a6\u00de\u0083\u00de\u00aa',\n                '\u00de\u0087\u00de\u00ae\u00de\u0086\u00de\u00b0\u00de\u0093\u00de\u00af\u00de\u0084\u00de\u00a6\u00de\u0083\u00de\u00aa',\n                '\u00de\u0082\u00de\u00ae\u00de\u0088\u00de\u00ac\u00de\u0089\u00de\u00b0\u00de\u0084\u00de\u00a6\u00de\u0083\u00de\u00aa',\n                '\u00de\u0091\u00de\u00a8\u00de\u0090\u00de\u00ac\u00de\u0089\u00de\u00b0\u00de\u0084\u00de\u00a6\u00de\u0083\u00de\u00aa'\n            ];\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM'), expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var i,\n            expected = [\n                '\u00de\u0087\u00de\u00a7\u00de\u008b\u00de\u00a8\u00de\u0087\u00de\u00b0\u00de\u008c\u00de\u00a6',\n                '\u00de\u0080\u00de\u00af\u00de\u0089\u00de\u00a6',\n                '\u00de\u0087\u00de\u00a6\u00de\u0082\u00de\u00b0\u00de\u008e\u00de\u00a7\u00de\u0083\u00de\u00a6',\n                '\u00de\u0084\u00de\u00aa\u00de\u008b\u00de\u00a6',\n                '\u00de\u0084\u00de\u00aa\u00de\u0083\u00de\u00a7\u00de\u0090\u00de\u00b0\u00de\u008a\u00de\u00a6\u00de\u008c\u00de\u00a8',\n                '\u00de\u0080\u00de\u00aa\u00de\u0086\u00de\u00aa\u00de\u0083\u00de\u00aa',\n                '\u00de\u0080\u00de\u00ae\u00de\u0082\u00de\u00a8\u00de\u0080\u00de\u00a8\u00de\u0083\u00de\u00aa'\n            ];\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd'), expected[i]);\n        }\n    });\n\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00de\u0090\u00de\u00a8\u00de\u0086\u00de\u00aa\u00de\u0082\u00de\u00b0\u00de\u008c\u00de\u00aa\u00de\u0086\u00de\u00ae\u00de\u0085\u00de\u00ac\u00de\u0087\u00de\u00b0',  '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00de\u0089\u00de\u00a8\u00de\u0082\u00de\u00a8\u00de\u0093\u00de\u00ac\u00de\u0087\u00de\u00b0',        '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00de\u0089\u00de\u00a8\u00de\u0082\u00de\u00a8\u00de\u0093\u00de\u00ac\u00de\u0087\u00de\u00b0',        '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '\u00de\u0089\u00de\u00a8\u00de\u0082\u00de\u00a8\u00de\u0093\u00de\u00aa 2',        '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '\u00de\u0089\u00de\u00a8\u00de\u0082\u00de\u00a8\u00de\u0093\u00de\u00aa 44',       '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00de\u008e\u00de\u00a6\u00de\u0091\u00de\u00a8\u00de\u0087\u00de\u00a8\u00de\u0083\u00de\u00ac\u00de\u0087\u00de\u00b0',      '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00de\u008e\u00de\u00a6\u00de\u0091\u00de\u00a8\u00de\u0087\u00de\u00a8\u00de\u0083\u00de\u00ac\u00de\u0087\u00de\u00b0',      '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00de\u008e\u00de\u00a6\u00de\u0091\u00de\u00a8\u00de\u0087\u00de\u00a8\u00de\u0083\u00de\u00aa 2',      '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '\u00de\u008e\u00de\u00a6\u00de\u0091\u00de\u00a8\u00de\u0087\u00de\u00a8\u00de\u0083\u00de\u00aa 5',      '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '\u00de\u008e\u00de\u00a6\u00de\u0091\u00de\u00a8\u00de\u0087\u00de\u00a8\u00de\u0083\u00de\u00aa 21',     '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00de\u008b\u00de\u00aa\u00de\u0088\u00de\u00a6\u00de\u0080\u00de\u00ac\u00de\u0087\u00de\u00b0',        '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00de\u008b\u00de\u00aa\u00de\u0088\u00de\u00a6\u00de\u0080\u00de\u00ac\u00de\u0087\u00de\u00b0',        '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00de\u008b\u00de\u00aa\u00de\u0088\u00de\u00a6\u00de\u0090\u00de\u00b0 2',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00de\u008b\u00de\u00aa\u00de\u0088\u00de\u00a6\u00de\u0080\u00de\u00ac\u00de\u0087\u00de\u00b0',        '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '\u00de\u008b\u00de\u00aa\u00de\u0088\u00de\u00a6\u00de\u0090\u00de\u00b0 5',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '\u00de\u008b\u00de\u00aa\u00de\u0088\u00de\u00a6\u00de\u0090\u00de\u00b0 25',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00de\u0089\u00de\u00a6\u00de\u0080\u00de\u00ac\u00de\u0087\u00de\u00b0',          '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00de\u0089\u00de\u00a6\u00de\u0080\u00de\u00ac\u00de\u0087\u00de\u00b0',          '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00de\u0089\u00de\u00a6\u00de\u0080\u00de\u00ac\u00de\u0087\u00de\u00b0',          '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '\u00de\u0089\u00de\u00a6\u00de\u0090\u00de\u00b0 2',          '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '\u00de\u0089\u00de\u00a6\u00de\u0090\u00de\u00b0 2',          '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '\u00de\u0089\u00de\u00a6\u00de\u0090\u00de\u00b0 3',          '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00de\u0089\u00de\u00a6\u00de\u0080\u00de\u00ac\u00de\u0087\u00de\u00b0',          '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '\u00de\u0089\u00de\u00a6\u00de\u0090\u00de\u00b0 5',          '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00de\u0087\u00de\u00a6\u00de\u0080\u00de\u00a6\u00de\u0083\u00de\u00ac\u00de\u0087\u00de\u00b0',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00de\u0087\u00de\u00a6\u00de\u0080\u00de\u00a6\u00de\u0083\u00de\u00aa 2',        '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00de\u0087\u00de\u00a6\u00de\u0080\u00de\u00a6\u00de\u0083\u00de\u00ac\u00de\u0087\u00de\u00b0',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '\u00de\u0087\u00de\u00a6\u00de\u0080\u00de\u00a6\u00de\u0083\u00de\u00aa 5',        '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00de\u008c\u00de\u00ac\u00de\u0083\u00de\u00ad\u00de\u008e\u00de\u00a6\u00de\u0087\u00de\u00a8 \u00de\u0090\u00de\u00a8\u00de\u0086\u00de\u00aa\u00de\u0082\u00de\u00b0\u00de\u008c\u00de\u00aa\u00de\u0086\u00de\u00ae\u00de\u0085\u00de\u00ac\u00de\u0087\u00de\u00b0', 'prefix');\n        assert.equal(moment(0).from(30000), '\u00de\u0086\u00de\u00aa\u00de\u0083\u00de\u00a8\u00de\u0082\u00de\u00b0 \u00de\u0090\u00de\u00a8\u00de\u0086\u00de\u00aa\u00de\u0082\u00de\u00b0\u00de\u008c\u00de\u00aa\u00de\u0086\u00de\u00ae\u00de\u0085\u00de\u00ac\u00de\u0087\u00de\u00b0', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00de\u008c\u00de\u00ac\u00de\u0083\u00de\u00ad\u00de\u008e\u00de\u00a6\u00de\u0087\u00de\u00a8 \u00de\u0090\u00de\u00a8\u00de\u0086\u00de\u00aa\u00de\u0082\u00de\u00b0\u00de\u008c\u00de\u00aa\u00de\u0086\u00de\u00ae\u00de\u0085\u00de\u00ac\u00de\u0087\u00de\u00b0', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00de\u008c\u00de\u00ac\u00de\u0083\u00de\u00ad\u00de\u008e\u00de\u00a6\u00de\u0087\u00de\u00a8 \u00de\u008b\u00de\u00aa\u00de\u0088\u00de\u00a6\u00de\u0090\u00de\u00b0 5', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00de\u0089\u00de\u00a8\u00de\u0087\u00de\u00a6\u00de\u008b\u00de\u00aa 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00de\u0089\u00de\u00a8\u00de\u0087\u00de\u00a6\u00de\u008b\u00de\u00aa 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00de\u0089\u00de\u00a8\u00de\u0087\u00de\u00a6\u00de\u008b\u00de\u00aa 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00de\u0089\u00de\u00a7\u00de\u008b\u00de\u00a6\u00de\u0089\u00de\u00a7 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00de\u0089\u00de\u00a8\u00de\u0087\u00de\u00a6\u00de\u008b\u00de\u00aa 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00de\u0087\u00de\u00a8\u00de\u0087\u00de\u00b0\u00de\u0094\u00de\u00ac 12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00de\u008a\u00de\u00a7\u00de\u0087\u00de\u00a8\u00de\u008c\u00de\u00aa\u00de\u0088\u00de\u00a8] dddd LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00de\u008a\u00de\u00a7\u00de\u0087\u00de\u00a8\u00de\u008c\u00de\u00aa\u00de\u0088\u00de\u00a8] dddd LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00de\u008a\u00de\u00a7\u00de\u0087\u00de\u00a8\u00de\u008c\u00de\u00aa\u00de\u0088\u00de\u00a8] dddd LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'),   '1 01 1', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '2 02 2', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '3 03 3', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('el');\n\n    test('parse', function (assert) {\n        var i,\n            tests = '\u00ce\u0099\u00ce\u00b1\u00ce\u00bd\u00ce\u00bf\u00cf\u0085\u00ce\u00ac\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u0099\u00ce\u00b1\u00ce\u00bd_\u00ce\u00a6\u00ce\u00b5\u00ce\u00b2\u00cf\u0081\u00ce\u00bf\u00cf\u0085\u00ce\u00ac\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2_\u00ce\u009c\u00ce\u00ac\u00cf\u0081\u00cf\u0084\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u009c\u00ce\u00b1\u00cf\u0081_\u00ce\u0091\u00cf\u0080\u00cf\u0081\u00ce\u00af\u00ce\u00bb\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u0091\u00cf\u0080\u00cf\u0081_\u00ce\u009c\u00ce\u00ac\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u009c\u00ce\u00b1\u00cf\u008a_\u00ce\u0099\u00ce\u00bf\u00cf\u008d\u00ce\u00bd\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u0099\u00ce\u00bf\u00cf\u0085\u00ce\u00bd_\u00ce\u0099\u00ce\u00bf\u00cf\u008d\u00ce\u00bb\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u0099\u00ce\u00bf\u00cf\u0085\u00ce\u00bb_\u00ce\u0091\u00cf\u008d\u00ce\u00b3\u00ce\u00bf\u00cf\u0085\u00cf\u0083\u00cf\u0084\u00ce\u00bf\u00cf\u0082 \u00ce\u0091\u00cf\u0085\u00ce\u00b3_\u00ce\u00a3\u00ce\u00b5\u00cf\u0080\u00cf\u0084\u00ce\u00ad\u00ce\u00bc\u00ce\u00b2\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u00a3\u00ce\u00b5\u00cf\u0080_\u00ce\u009f\u00ce\u00ba\u00cf\u0084\u00cf\u008e\u00ce\u00b2\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u009f\u00ce\u00ba\u00cf\u0084_\u00ce\u009d\u00ce\u00bf\u00ce\u00ad\u00ce\u00bc\u00ce\u00b2\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u009d\u00ce\u00bf\u00ce\u00b5_\u00ce\u0094\u00ce\u00b5\u00ce\u00ba\u00ce\u00ad\u00ce\u00bc\u00ce\u00b2\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u0094\u00ce\u00b5\u00ce\u00ba'.split('_');\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('parse meridiem', function (assert) {\n        var i,\n            b = moment(),\n            meridiemTests = [\n                // h a patterns, expected hours, isValid\n                ['10 \u00cf\u0080\u00ce\u00bc',   10, true],\n                ['10 \u00ce\u00bc\u00ce\u00bc',   22, true],\n                ['10 \u00cf\u0080.\u00ce\u00bc.', 10, true],\n                ['10 \u00ce\u00bc.\u00ce\u00bc.', 22, true],\n                ['10 \u00cf\u0080',    10, true],\n                ['10 \u00ce\u00bc',    22, true],\n                ['10 \u00ce\u00a0\u00ce\u009c',   10, true],\n                ['10 \u00ce\u009c\u00ce\u009c',   22, true],\n                ['10 \u00ce\u00a0.\u00ce\u009c.', 10, true],\n                ['10 \u00ce\u009c.\u00ce\u009c.', 22, true],\n                ['10 \u00ce\u00a0',    10, true],\n                ['10 \u00ce\u009c',    22, true],\n                ['10 am',   10, false],\n                ['10 pm',   10, false]\n            ],\n            parsed;\n\n        // test that a formatted moment including meridiem string can be parsed back to the same moment\n        assert.ok(b.isSame(moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'el', true), 'seconds'), b.format('h:mm:ss a') + ' should be equal to ' + moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'el', true).format('h:mm:ss a'));\n\n        // test that a formatted moment having a meridiem string can be parsed with strict flag\n        assert.ok(moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'el', true).isValid(), b.format('h:mm:ss a') + ' should be parsed as valid');\n\n        for (i = 0; i < meridiemTests.length; i++) {\n            parsed = moment(meridiemTests[i][0], 'h a', 'el', true);\n            assert.equal(parsed.isValid(), meridiemTests[i][2], 'validity for ' + meridiemTests[i][0]);\n            if (parsed.isValid()) {\n                assert.equal(parsed.hours(), meridiemTests[i][1], 'hours for ' + meridiemTests[i][0]);\n            }\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      '\u00ce\u009a\u00cf\u0085\u00cf\u0081\u00ce\u00b9\u00ce\u00b1\u00ce\u00ba\u00ce\u00ae, \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2\u00cf\u0081\u00ce\u00bf\u00cf\u0085\u00ce\u00ac\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 14\u00ce\u00b7 2010, 3:25:50 \u00ce\u00bc\u00ce\u00bc'],\n                ['dddd, D MMMM YYYY, h:mm:ss a',       '\u00ce\u009a\u00cf\u0085\u00cf\u0081\u00ce\u00b9\u00ce\u00b1\u00ce\u00ba\u00ce\u00ae, 14 \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2\u00cf\u0081\u00ce\u00bf\u00cf\u0085\u00ce\u00b1\u00cf\u0081\u00ce\u00af\u00ce\u00bf\u00cf\u0085 2010, 3:25:50 \u00ce\u00bc\u00ce\u00bc'],\n                ['ddd, hA',                            '\u00ce\u009a\u00cf\u0085\u00cf\u0081, 3\u00ce\u009c\u00ce\u009c'],\n                ['dddd, MMMM YYYY',                    '\u00ce\u009a\u00cf\u0085\u00cf\u0081\u00ce\u00b9\u00ce\u00b1\u00ce\u00ba\u00ce\u00ae, \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2\u00cf\u0081\u00ce\u00bf\u00cf\u0085\u00ce\u00ac\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 2010'],\n                ['M Mo MM MMMM MMM',                   '2 2\u00ce\u00b7 02 \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2\u00cf\u0081\u00ce\u00bf\u00cf\u0085\u00ce\u00ac\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\u00ce\u00b7 14'],\n                ['d do dddd ddd dd',                   '0 0\u00ce\u00b7 \u00ce\u009a\u00cf\u0085\u00cf\u0081\u00ce\u00b9\u00ce\u00b1\u00ce\u00ba\u00ce\u00ae \u00ce\u009a\u00cf\u0085\u00cf\u0081 \u00ce\u009a\u00cf\u0085'],\n                ['DDD DDDo DDDD',                      '45 45\u00ce\u00b7 045'],\n                ['w wo ww',                            '6 6\u00ce\u00b7 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00ce\u00bc\u00ce\u00bc \u00ce\u009c\u00ce\u009c'],\n                ['[the] DDDo [day of the year]',       'the 45\u00ce\u00b7 day of the year'],\n                ['LTS',                                '3:25:50 \u00ce\u009c\u00ce\u009c'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2\u00cf\u0081\u00ce\u00bf\u00cf\u0085\u00ce\u00b1\u00cf\u0081\u00ce\u00af\u00ce\u00bf\u00cf\u0085 2010'],\n                ['LLL',                                '14 \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2\u00cf\u0081\u00ce\u00bf\u00cf\u0085\u00ce\u00b1\u00cf\u0081\u00ce\u00af\u00ce\u00bf\u00cf\u0085 2010 3:25 \u00ce\u009c\u00ce\u009c'],\n                ['LLLL',                               '\u00ce\u009a\u00cf\u0085\u00cf\u0081\u00ce\u00b9\u00ce\u00b1\u00ce\u00ba\u00ce\u00ae, 14 \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2\u00cf\u0081\u00ce\u00bf\u00cf\u0085\u00ce\u00b1\u00cf\u0081\u00ce\u00af\u00ce\u00bf\u00cf\u0085 2010 3:25 \u00ce\u009c\u00ce\u009c'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2 2010'],\n                ['lll',                                '14 \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2 2010 3:25 \u00ce\u009c\u00ce\u009c'],\n                ['llll',                               '\u00ce\u009a\u00cf\u0085\u00cf\u0081, 14 \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2 2010 3:25 \u00ce\u009c\u00ce\u009c']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1\u00ce\u00b7', '1\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2\u00ce\u00b7', '2\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3\u00ce\u00b7', '3\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4\u00ce\u00b7', '4\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\u00ce\u00b7', '5\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\u00ce\u00b7', '6\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\u00ce\u00b7', '7\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\u00ce\u00b7', '8\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\u00ce\u00b7', '9\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\u00ce\u00b7', '10\u00ce\u00b7');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\u00ce\u00b7', '11\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\u00ce\u00b7', '12\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\u00ce\u00b7', '13\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\u00ce\u00b7', '14\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\u00ce\u00b7', '15\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\u00ce\u00b7', '16\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\u00ce\u00b7', '17\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\u00ce\u00b7', '18\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\u00ce\u00b7', '19\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\u00ce\u00b7', '20\u00ce\u00b7');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\u00ce\u00b7', '21\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\u00ce\u00b7', '22\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\u00ce\u00b7', '23\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\u00ce\u00b7', '24\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\u00ce\u00b7', '25\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\u00ce\u00b7', '26\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\u00ce\u00b7', '27\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\u00ce\u00b7', '28\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\u00ce\u00b7', '29\u00ce\u00b7');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\u00ce\u00b7', '30\u00ce\u00b7');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\u00ce\u00b7', '31\u00ce\u00b7');\n    });\n\n    test('format month', function (assert) {\n        var i,\n            expected = '\u00ce\u0099\u00ce\u00b1\u00ce\u00bd\u00ce\u00bf\u00cf\u0085\u00ce\u00ac\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u0099\u00ce\u00b1\u00ce\u00bd_\u00ce\u00a6\u00ce\u00b5\u00ce\u00b2\u00cf\u0081\u00ce\u00bf\u00cf\u0085\u00ce\u00ac\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u00a6\u00ce\u00b5\u00ce\u00b2_\u00ce\u009c\u00ce\u00ac\u00cf\u0081\u00cf\u0084\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u009c\u00ce\u00b1\u00cf\u0081_\u00ce\u0091\u00cf\u0080\u00cf\u0081\u00ce\u00af\u00ce\u00bb\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u0091\u00cf\u0080\u00cf\u0081_\u00ce\u009c\u00ce\u00ac\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u009c\u00ce\u00b1\u00cf\u008a_\u00ce\u0099\u00ce\u00bf\u00cf\u008d\u00ce\u00bd\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u0099\u00ce\u00bf\u00cf\u0085\u00ce\u00bd_\u00ce\u0099\u00ce\u00bf\u00cf\u008d\u00ce\u00bb\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u0099\u00ce\u00bf\u00cf\u0085\u00ce\u00bb_\u00ce\u0091\u00cf\u008d\u00ce\u00b3\u00ce\u00bf\u00cf\u0085\u00cf\u0083\u00cf\u0084\u00ce\u00bf\u00cf\u0082 \u00ce\u0091\u00cf\u0085\u00ce\u00b3_\u00ce\u00a3\u00ce\u00b5\u00cf\u0080\u00cf\u0084\u00ce\u00ad\u00ce\u00bc\u00ce\u00b2\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u00a3\u00ce\u00b5\u00cf\u0080_\u00ce\u009f\u00ce\u00ba\u00cf\u0084\u00cf\u008e\u00ce\u00b2\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u009f\u00ce\u00ba\u00cf\u0084_\u00ce\u009d\u00ce\u00bf\u00ce\u00ad\u00ce\u00bc\u00ce\u00b2\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u009d\u00ce\u00bf\u00ce\u00b5_\u00ce\u0094\u00ce\u00b5\u00ce\u00ba\u00ce\u00ad\u00ce\u00bc\u00ce\u00b2\u00cf\u0081\u00ce\u00b9\u00ce\u00bf\u00cf\u0082 \u00ce\u0094\u00ce\u00b5\u00ce\u00ba'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var i,\n            expected = '\u00ce\u009a\u00cf\u0085\u00cf\u0081\u00ce\u00b9\u00ce\u00b1\u00ce\u00ba\u00ce\u00ae \u00ce\u009a\u00cf\u0085\u00cf\u0081 \u00ce\u009a\u00cf\u0085_\u00ce\u0094\u00ce\u00b5\u00cf\u0085\u00cf\u0084\u00ce\u00ad\u00cf\u0081\u00ce\u00b1 \u00ce\u0094\u00ce\u00b5\u00cf\u0085 \u00ce\u0094\u00ce\u00b5_\u00ce\u00a4\u00cf\u0081\u00ce\u00af\u00cf\u0084\u00ce\u00b7 \u00ce\u00a4\u00cf\u0081\u00ce\u00b9 \u00ce\u00a4\u00cf\u0081_\u00ce\u00a4\u00ce\u00b5\u00cf\u0084\u00ce\u00ac\u00cf\u0081\u00cf\u0084\u00ce\u00b7 \u00ce\u00a4\u00ce\u00b5\u00cf\u0084 \u00ce\u00a4\u00ce\u00b5_\u00ce\u00a0\u00ce\u00ad\u00ce\u00bc\u00cf\u0080\u00cf\u0084\u00ce\u00b7 \u00ce\u00a0\u00ce\u00b5\u00ce\u00bc \u00ce\u00a0\u00ce\u00b5_\u00ce\u00a0\u00ce\u00b1\u00cf\u0081\u00ce\u00b1\u00cf\u0083\u00ce\u00ba\u00ce\u00b5\u00cf\u0085\u00ce\u00ae \u00ce\u00a0\u00ce\u00b1\u00cf\u0081 \u00ce\u00a0\u00ce\u00b1_\u00ce\u00a3\u00ce\u00ac\u00ce\u00b2\u00ce\u00b2\u00ce\u00b1\u00cf\u0084\u00ce\u00bf \u00ce\u00a3\u00ce\u00b1\u00ce\u00b2 \u00ce\u00a3\u00ce\u00b1'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00ce\u00bb\u00ce\u00af\u00ce\u00b3\u00ce\u00b1 \u00ce\u00b4\u00ce\u00b5\u00cf\u0085\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00cf\u008c\u00ce\u00bb\u00ce\u00b5\u00cf\u0080\u00cf\u0084\u00ce\u00b1',   '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00ce\u00ad\u00ce\u00bd\u00ce\u00b1 \u00ce\u00bb\u00ce\u00b5\u00cf\u0080\u00cf\u0084\u00cf\u008c',           '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00ce\u00ad\u00ce\u00bd\u00ce\u00b1 \u00ce\u00bb\u00ce\u00b5\u00cf\u0080\u00cf\u0084\u00cf\u008c',           '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00ce\u00bb\u00ce\u00b5\u00cf\u0080\u00cf\u0084\u00ce\u00ac',             '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00ce\u00bb\u00ce\u00b5\u00cf\u0080\u00cf\u0084\u00ce\u00ac',            '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00ce\u00bc\u00ce\u00af\u00ce\u00b1 \u00cf\u008e\u00cf\u0081\u00ce\u00b1',             '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00ce\u00bc\u00ce\u00af\u00ce\u00b1 \u00cf\u008e\u00cf\u0081\u00ce\u00b1',             '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00cf\u008e\u00cf\u0081\u00ce\u00b5\u00cf\u0082',              '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00cf\u008e\u00cf\u0081\u00ce\u00b5\u00cf\u0082',              '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00cf\u008e\u00cf\u0081\u00ce\u00b5\u00cf\u0082',             '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00ce\u00bc\u00ce\u00af\u00ce\u00b1 \u00ce\u00bc\u00ce\u00ad\u00cf\u0081\u00ce\u00b1',            '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00ce\u00bc\u00ce\u00af\u00ce\u00b1 \u00ce\u00bc\u00ce\u00ad\u00cf\u0081\u00ce\u00b1',            '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00ce\u00bc\u00ce\u00ad\u00cf\u0081\u00ce\u00b5\u00cf\u0082',             '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00ce\u00bc\u00ce\u00af\u00ce\u00b1 \u00ce\u00bc\u00ce\u00ad\u00cf\u0081\u00ce\u00b1',            '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00ce\u00bc\u00ce\u00ad\u00cf\u0081\u00ce\u00b5\u00cf\u0082',             '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00ce\u00bc\u00ce\u00ad\u00cf\u0081\u00ce\u00b5\u00cf\u0082',            '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00ce\u00ad\u00ce\u00bd\u00ce\u00b1\u00cf\u0082 \u00ce\u00bc\u00ce\u00ae\u00ce\u00bd\u00ce\u00b1\u00cf\u0082',          '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00ce\u00ad\u00ce\u00bd\u00ce\u00b1\u00cf\u0082 \u00ce\u00bc\u00ce\u00ae\u00ce\u00bd\u00ce\u00b1\u00cf\u0082',          '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00ce\u00ad\u00ce\u00bd\u00ce\u00b1\u00cf\u0082 \u00ce\u00bc\u00ce\u00ae\u00ce\u00bd\u00ce\u00b1\u00cf\u0082',          '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00ce\u00bc\u00ce\u00ae\u00ce\u00bd\u00ce\u00b5\u00cf\u0082',             '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00ce\u00bc\u00ce\u00ae\u00ce\u00bd\u00ce\u00b5\u00cf\u0082',             '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00ce\u00bc\u00ce\u00ae\u00ce\u00bd\u00ce\u00b5\u00cf\u0082',             '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00ce\u00ad\u00ce\u00bd\u00ce\u00b1\u00cf\u0082 \u00ce\u00bc\u00ce\u00ae\u00ce\u00bd\u00ce\u00b1\u00cf\u0082',          '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00ce\u00bc\u00ce\u00ae\u00ce\u00bd\u00ce\u00b5\u00cf\u0082',             '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00ce\u00ad\u00ce\u00bd\u00ce\u00b1\u00cf\u0082 \u00cf\u0087\u00cf\u0081\u00cf\u008c\u00ce\u00bd\u00ce\u00bf\u00cf\u0082',         '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00cf\u0087\u00cf\u0081\u00cf\u008c\u00ce\u00bd\u00ce\u00b9\u00ce\u00b1',            '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00ce\u00ad\u00ce\u00bd\u00ce\u00b1\u00cf\u0082 \u00cf\u0087\u00cf\u0081\u00cf\u008c\u00ce\u00bd\u00ce\u00bf\u00cf\u0082',         '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00cf\u0087\u00cf\u0081\u00cf\u008c\u00ce\u00bd\u00ce\u00b9\u00ce\u00b1',            '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00cf\u0083\u00ce\u00b5 \u00ce\u00bb\u00ce\u00af\u00ce\u00b3\u00ce\u00b1 \u00ce\u00b4\u00ce\u00b5\u00cf\u0085\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00cf\u008c\u00ce\u00bb\u00ce\u00b5\u00cf\u0080\u00cf\u0084\u00ce\u00b1',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00ce\u00bb\u00ce\u00af\u00ce\u00b3\u00ce\u00b1 \u00ce\u00b4\u00ce\u00b5\u00cf\u0085\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00cf\u008c\u00ce\u00bb\u00ce\u00b5\u00cf\u0080\u00cf\u0084\u00ce\u00b1 \u00cf\u0080\u00cf\u0081\u00ce\u00b9\u00ce\u00bd', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00ce\u00bb\u00ce\u00af\u00ce\u00b3\u00ce\u00b1 \u00ce\u00b4\u00ce\u00b5\u00cf\u0085\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00cf\u008c\u00ce\u00bb\u00ce\u00b5\u00cf\u0080\u00cf\u0084\u00ce\u00b1 \u00cf\u0080\u00cf\u0081\u00ce\u00b9\u00ce\u00bd',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00cf\u0083\u00ce\u00b5 \u00ce\u00bb\u00ce\u00af\u00ce\u00b3\u00ce\u00b1 \u00ce\u00b4\u00ce\u00b5\u00cf\u0085\u00cf\u0084\u00ce\u00b5\u00cf\u0081\u00cf\u008c\u00ce\u00bb\u00ce\u00b5\u00cf\u0080\u00cf\u0084\u00ce\u00b1', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00cf\u0083\u00ce\u00b5 5 \u00ce\u00bc\u00ce\u00ad\u00cf\u0081\u00ce\u00b5\u00cf\u0082', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00ce\u00a3\u00ce\u00ae\u00ce\u00bc\u00ce\u00b5\u00cf\u0081\u00ce\u00b1 \u00cf\u0083\u00cf\u0084\u00ce\u00b9\u00cf\u0082 12:00 \u00ce\u009c\u00ce\u009c',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00ce\u00a3\u00ce\u00ae\u00ce\u00bc\u00ce\u00b5\u00cf\u0081\u00ce\u00b1 \u00cf\u0083\u00cf\u0084\u00ce\u00b9\u00cf\u0082 12:25 \u00ce\u009c\u00ce\u009c',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00ce\u00a3\u00ce\u00ae\u00ce\u00bc\u00ce\u00b5\u00cf\u0081\u00ce\u00b1 \u00cf\u0083\u00cf\u0084\u00ce\u00b7 1:00 \u00ce\u009c\u00ce\u009c',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00ce\u0091\u00cf\u008d\u00cf\u0081\u00ce\u00b9\u00ce\u00bf \u00cf\u0083\u00cf\u0084\u00ce\u00b9\u00cf\u0082 12:00 \u00ce\u009c\u00ce\u009c',      'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00ce\u00a3\u00ce\u00ae\u00ce\u00bc\u00ce\u00b5\u00cf\u0081\u00ce\u00b1 \u00cf\u0083\u00cf\u0084\u00ce\u00b9\u00cf\u0082 11:00 \u00ce\u00a0\u00ce\u009c',      'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00ce\u00a7\u00ce\u00b8\u00ce\u00b5\u00cf\u0082 \u00cf\u0083\u00cf\u0084\u00ce\u00b9\u00cf\u0082 12:00 \u00ce\u009c\u00ce\u009c',       'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [' + (m.hours() % 12 === 1 ? '\u00cf\u0083\u00cf\u0084\u00ce\u00b7' : '\u00cf\u0083\u00cf\u0084\u00ce\u00b9\u00cf\u0082') + '] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00cf\u0083\u00cf\u0084\u00ce\u00b9\u00cf\u0082] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00cf\u0083\u00cf\u0084\u00ce\u00b9\u00cf\u0082] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m, dayString;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            dayString = m.day() === 6 ? '[\u00cf\u0084\u00ce\u00bf \u00cf\u0080\u00cf\u0081\u00ce\u00bf\u00ce\u00b7\u00ce\u00b3\u00ce\u00bf\u00cf\u008d\u00ce\u00bc\u00ce\u00b5\u00ce\u00bd\u00ce\u00bf \u00ce\u00a3\u00ce\u00ac\u00ce\u00b2\u00ce\u00b2\u00ce\u00b1\u00cf\u0084\u00ce\u00bf]' : '[\u00cf\u0084\u00ce\u00b7\u00ce\u00bd \u00cf\u0080\u00cf\u0081\u00ce\u00bf\u00ce\u00b7\u00ce\u00b3\u00ce\u00bf\u00cf\u008d\u00ce\u00bc\u00ce\u00b5\u00ce\u00bd\u00ce\u00b7] dddd';\n            assert.equal(m.calendar(),       m.format(dayString + ' [' + (m.hours() % 12 === 1 ? '\u00cf\u0083\u00cf\u0084\u00ce\u00b7' : '\u00cf\u0083\u00cf\u0084\u00ce\u00b9\u00cf\u0082') + '] LT'),  'Today - ' + i + ' days current time');\n            m.hours(1).minutes(30).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(dayString + ' [\u00cf\u0083\u00cf\u0084\u00ce\u00b7] LT'),  'Today - ' + i + ' days one o clock');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(dayString + ' [\u00cf\u0083\u00cf\u0084\u00ce\u00b9\u00cf\u0082] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(dayString + ' [\u00cf\u0083\u00cf\u0084\u00ce\u00b9\u00cf\u0082] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52\u00ce\u00b7', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'),   '1 01 1\u00ce\u00b7', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1\u00ce\u00b7', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'),   '2 02 2\u00ce\u00b7', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2\u00ce\u00b7', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('en-au');\n\n    test('parse', function (assert) {\n        var tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Sun, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14th 14'],\n                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],\n                ['DDD DDDo DDDD',                      '45 45th 045'],\n                ['w wo ww',                            '6 6th 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45th day of the year'],\n                ['LTS',                                '3:25:50 PM'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 February 2010'],\n                ['LLL',                                '14 February 2010 3:25 PM'],\n                ['LLLL',                               'Sunday, 14 February 2010 3:25 PM'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Feb 2010'],\n                ['lll',                                '14 Feb 2010 3:25 PM'],\n                ['llll',                               'Sun, 14 Feb 2010 3:25 PM']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');\n        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Today at 12:00 PM',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 12:25 PM',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 1:00 PM',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 12:00 PM',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 11:00 AM',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 12:00 PM', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('en-ca');\n\n    test('parse', function (assert) {\n        var i,\n            tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Sun, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14th 14'],\n                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],\n                ['DDD DDDo DDDD',                      '45 45th 045'],\n                ['w wo ww',                            '8 8th 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45th day of the year'],\n                ['L',                                  '2010-02-14'],\n                ['LTS',                                '3:25:50 PM'],\n                ['LL',                                 'February 14, 2010'],\n                ['LLL',                                'February 14, 2010 3:25 PM'],\n                ['LLLL',                               'Sunday, February 14, 2010 3:25 PM'],\n                ['l',                                  '2010-2-14'],\n                ['ll',                                 'Feb 14, 2010'],\n                ['lll',                                'Feb 14, 2010 3:25 PM'],\n                ['llll',                               'Sun, Feb 14, 2010 3:25 PM']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');\n    });\n\n    test('format month', function (assert) {\n        var i,\n            expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var i,\n            expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');\n        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Today at 12:00 PM',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 12:25 PM',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 1:00 PM',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 12:00 PM',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 11:00 AM',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 12:00 PM', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1st', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1st', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2nd', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2nd', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3rd', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('en-gb');\n\n    test('parse', function (assert) {\n        var tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Sun, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14th 14'],\n                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],\n                ['DDD DDDo DDDD',                      '45 45th 045'],\n                ['w wo ww',                            '6 6th 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45th day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 February 2010'],\n                ['LLL',                                '14 February 2010 15:25'],\n                ['LLLL',                               'Sunday, 14 February 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Feb 2010'],\n                ['lll',                                '14 Feb 2010 15:25'],\n                ['llll',                               'Sun, 14 Feb 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');\n        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Today at 12:00',      'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 12:25',      'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 13:00',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 12:00',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 11:00',      'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('en-ie');\n\n    test('parse', function (assert) {\n        var tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Sun, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14th 14'],\n                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],\n                ['DDD DDDo DDDD',                      '45 45th 045'],\n                ['w wo ww',                            '6 6th 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45th day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14-02-2010'],\n                ['LL',                                 '14 February 2010'],\n                ['LLL',                                '14 February 2010 15:25'],\n                ['LLLL',                               'Sunday 14 February 2010 15:25'],\n                ['l',                                  '14-2-2010'],\n                ['ll',                                 '14 Feb 2010'],\n                ['lll',                                '14 Feb 2010 15:25'],\n                ['llll',                               'Sun 14 Feb 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');\n        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Today at 12:00',      'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 12:25',      'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 13:00',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 12:00',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 11:00',      'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('en-nz');\n\n    test('parse', function (assert) {\n        var tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Sun, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14th 14'],\n                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],\n                ['DDD DDDo DDDD',                      '45 45th 045'],\n                ['w wo ww',                            '6 6th 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45th day of the year'],\n                ['LTS',                                '3:25:50 PM'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 February 2010'],\n                ['LLL',                                '14 February 2010 3:25 PM'],\n                ['LLLL',                               'Sunday, 14 February 2010 3:25 PM'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Feb 2010'],\n                ['lll',                                '14 Feb 2010 3:25 PM'],\n                ['llll',                               'Sun, 14 Feb 2010 3:25 PM']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');\n        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Today at 12:00 PM',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 12:25 PM',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 1:00 PM',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 12:00 PM',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 11:00 AM',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 12:00 PM', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('en');\n\n    test('parse', function (assert) {\n        var i,\n            tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Sun, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14th 14'],\n                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],\n                ['DDD DDDo DDDD',                      '45 45th 045'],\n                ['w wo ww',                            '8 8th 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45th day of the year'],\n                ['LTS',                                '3:25:50 PM'],\n                ['L',                                  '02/14/2010'],\n                ['LL',                                 'February 14, 2010'],\n                ['LLL',                                'February 14, 2010 3:25 PM'],\n                ['LLLL',                               'Sunday, February 14, 2010 3:25 PM'],\n                ['l',                                  '2/14/2010'],\n                ['ll',                                 'Feb 14, 2010'],\n                ['lll',                                'Feb 14, 2010 3:25 PM'],\n                ['llll',                               'Sun, Feb 14, 2010 3:25 PM']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');\n    });\n\n    test('format month', function (assert) {\n        var i,\n            expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var i,\n            expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');\n        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Today at 12:00 PM',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 12:25 PM',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 1:00 PM',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 12:00 PM',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 11:00 AM',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 12:00 PM', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1st', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1st', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2nd', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2nd', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3rd', 'Jan 15 2012 should be week 3');\n    });\n\n    test('weekdays strict parsing', function (assert) {\n        var m = moment('2015-01-01T12', moment.ISO_8601, true),\n            enLocale = moment.localeData('en');\n\n        for (var i = 0; i < 7; ++i) {\n            assert.equal(moment(enLocale.weekdays(m.day(i), ''), 'dddd', true).isValid(), true, 'parse weekday ' + i);\n            assert.equal(moment(enLocale.weekdaysShort(m.day(i), ''), 'ddd', true).isValid(), true, 'parse short weekday ' + i);\n            assert.equal(moment(enLocale.weekdaysMin(m.day(i), ''), 'dd', true).isValid(), true, 'parse min weekday ' + i);\n\n            // negative tests\n            assert.equal(moment(enLocale.weekdaysMin(m.day(i), ''), 'ddd', true).isValid(), false, 'parse short weekday ' + i);\n            assert.equal(moment(enLocale.weekdaysShort(m.day(i), ''), 'dd', true).isValid(), false, 'parse min weekday ' + i);\n        }\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('eo');\n\n    test('parse', function (assert) {\n        var tests = 'januaro jan_februaro feb_marto mar_aprilo apr_majo maj_junio jun_julio jul_a\u00c5\u00adgusto a\u00c5\u00adg_septembro sep_oktobro okt_novembro nov_decembro dec'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Diman\u00c4\u0089o, februaro 14a 2010, 3:25:50 p.t.m.'],\n                ['ddd, hA',                            'Dim, 3P.T.M.'],\n                ['M Mo MM MMMM MMM',                   '2 2a 02 februaro feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14a 14'],\n                ['d do dddd ddd dd',                   '0 0a Diman\u00c4\u0089o Dim Di'],\n                ['DDD DDDo DDDD',                      '45 45a 045'],\n                ['w wo ww',                            '7 7a 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'p.t.m. P.T.M.'],\n                ['[la] DDDo [tago] [de] [la] [jaro]',  'la 45a tago de la jaro'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '2010-02-14'],\n                ['LL',                                 '14-an de februaro, 2010'],\n                ['LLL',                                '14-an de februaro, 2010 15:25'],\n                ['LLLL',                               'Diman\u00c4\u0089o, la 14-an de februaro, 2010 15:25'],\n                ['l',                                  '2010-2-14'],\n                ['ll',                                 '14-an de feb, 2010'],\n                ['lll',                                '14-an de feb, 2010 15:25'],\n                ['llll',                               'Dim, la 14-an de feb, 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1a', '1a');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2a', '2a');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3a', '3a');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4a', '4a');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5a', '5a');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6a', '6a');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7a', '7a');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8a', '8a');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9a', '9a');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10a', '10a');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11a', '11a');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12a', '12a');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13a', '13a');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14a', '14a');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15a', '15a');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16a', '16a');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17a', '17a');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18a', '18a');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19a', '19a');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20a', '20a');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21a', '21a');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22a', '22a');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23a', '23a');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24a', '24a');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25a', '25a');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26a', '26a');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27a', '27a');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28a', '28a');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29a', '29a');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30a', '30a');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31a', '31a');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'januaro jan_februaro feb_marto mar_aprilo apr_majo maj_junio jun_julio jul_a\u00c5\u00adgusto a\u00c5\u00adg_septembro sep_oktobro okt_novembro nov_decembro dec'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Diman\u00c4\u0089o Dim Di_Lundo Lun Lu_Mardo Mard Ma_Merkredo Merk Me_\u00c4\u00b4a\u00c5\u00addo \u00c4\u00b4a\u00c5\u00ad \u00c4\u00b4a_Vendredo Ven Ve_Sabato Sab Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'sekundoj', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuto',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuto',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutoj',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutoj',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'horo',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'horo',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horoj',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horoj',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horoj',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'tago',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'tago',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 tagoj',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'tago',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 tagoj',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 tagoj',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'monato',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'monato',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'monato',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 monatoj',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 monatoj',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 monatoj',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'monato',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 monatoj',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'jaro',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jaroj',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'jaro',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jaroj',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'je sekundoj',  'je prefix');\n        assert.equal(moment(0).from(30000), 'anta\u00c5\u00ad sekundoj', 'anta\u00c5\u00ad prefix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'anta\u00c5\u00ad sekundoj',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'je sekundoj', 'je sekundoj');\n        assert.equal(moment().add({d: 5}).fromNow(), 'je 5 tagoj', 'je 5 tagoj');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Hodia\u00c5\u00ad je 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Hodia\u00c5\u00ad je 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Hodia\u00c5\u00ad je 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Morga\u00c5\u00ad je 12:00',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hodia\u00c5\u00ad je 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hiera\u00c5\u00ad je 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [je] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [je] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [je] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[pasinta] dddd [je] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[pasinta] dddd [je] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[pasinta] dddd [je] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1a', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1a', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2a', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2a', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3a', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('es');\n\n    test('parse', function (assert) {\n        var tests = 'enero ene._febrero feb._marzo mar._abril abr._mayo may._junio jun._julio jul._agosto ago._septiembre sep._octubre oct._noviembre nov._diciembre dic.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'domingo, febrero 14\u00c2\u00ba 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'dom., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2\u00c2\u00ba 02 febrero feb.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\u00c2\u00ba 14'],\n                ['d do dddd ddd dd',                   '0 0\u00c2\u00ba domingo dom. do'],\n                ['DDD DDDo DDDD',                      '45 45\u00c2\u00ba 045'],\n                ['w wo ww',                            '6 6\u00c2\u00ba 06'],\n                ['YYYY-MMM-DD',                        '2010-feb-14'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45\u00c2\u00ba day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 de febrero de 2010'],\n                ['LLL',                                '14 de febrero de 2010 15:25'],\n                ['LLLL',                               'domingo, 14 de febrero de 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 de feb. de 2010'],\n                ['lll',                                '14 de feb. de 2010 15:25'],\n                ['llll',                               'dom., 14 de feb. de 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1\u00c2\u00ba', '1\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2\u00c2\u00ba', '2\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3\u00c2\u00ba', '3\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4\u00c2\u00ba', '4\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\u00c2\u00ba', '5\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\u00c2\u00ba', '6\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\u00c2\u00ba', '7\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\u00c2\u00ba', '8\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\u00c2\u00ba', '9\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\u00c2\u00ba', '10\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\u00c2\u00ba', '11\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\u00c2\u00ba', '12\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\u00c2\u00ba', '13\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\u00c2\u00ba', '14\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\u00c2\u00ba', '15\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\u00c2\u00ba', '16\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\u00c2\u00ba', '17\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\u00c2\u00ba', '18\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\u00c2\u00ba', '19\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\u00c2\u00ba', '20\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\u00c2\u00ba', '21\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\u00c2\u00ba', '22\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\u00c2\u00ba', '23\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\u00c2\u00ba', '24\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\u00c2\u00ba', '25\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\u00c2\u00ba', '26\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\u00c2\u00ba', '27\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\u00c2\u00ba', '28\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\u00c2\u00ba', '29\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\u00c2\u00ba', '30\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\u00c2\u00ba', '31\u00c2\u00ba');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'enero ene._febrero feb._marzo mar._abril abr._mayo may._junio jun._julio jul._agosto ago._septiembre sep._octubre oct._noviembre nov._diciembre dic.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'domingo dom. do_lunes lun. lu_martes mar. ma_mi\u00c3\u00a9rcoles mi\u00c3\u00a9. mi_jueves jue. ju_viernes vie. vi_s\u00c3\u00a1bado s\u00c3\u00a1b. s\u00c3\u00a1'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'unos segundos', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minuto',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minuto',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'una hora',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'una hora',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un d\u00c3\u00ada',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un d\u00c3\u00ada',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 d\u00c3\u00adas',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un d\u00c3\u00ada',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 d\u00c3\u00adas',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 d\u00c3\u00adas',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mes',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mes',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mes',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mes',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un a\u00c3\u00b1o',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 a\u00c3\u00b1os',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un a\u00c3\u00b1o',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 a\u00c3\u00b1os',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'en unos segundos',  'prefix');\n        assert.equal(moment(0).from(30000), 'hace unos segundos', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'hace unos segundos',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'en unos segundos', 'en unos segundos');\n        assert.equal(moment().add({d: 5}).fromNow(), 'en 5 d\u00c3\u00adas', 'en 5 d\u00c3\u00adas');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                       'hoy a las 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),          'hoy a las 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),           'hoy a las 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),           'ma\u00c3\u00b1ana a las 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).add({d: 1, h : -1}).calendar(),   'ma\u00c3\u00b1ana a las 11:00',   'tomorrow minus 1 hour');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),      'hoy a las 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),      'ayer a las 12:00',    'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[el] dddd [pasado a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[el] dddd [pasado a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[el] dddd [pasado a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52\u00c2\u00ba', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1\u00c2\u00ba', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1\u00c2\u00ba', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2\u00c2\u00ba', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2\u00c2\u00ba', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('et');\n\n    test('parse', function (assert) {\n        var tests = 'jaanuar jaan_veebruar veebr_m\u00c3\u00a4rts m\u00c3\u00a4rts_aprill apr_mai mai_juuni juuni_juuli juuli_august aug_september sept_oktoober okt_november nov_detsember dets'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' peaks olema kuu ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, H:mm:ss',      'p\u00c3\u00bchap\u00c3\u00a4ev, 14. veebruar 2010, 15:25:50'],\n                ['ddd, h',                           'P, 3'],\n                ['M Mo MM MMMM MMM',                 '2 2. 02 veebruar veebr'],\n                ['YYYY YY',                          '2010 10'],\n                ['D Do DD',                          '14 14. 14'],\n                ['d do dddd ddd dd',                 '0 0. p\u00c3\u00bchap\u00c3\u00a4ev P P'],\n                ['DDD DDDo DDDD',                    '45 45. 045'],\n                ['w wo ww',                          '6 6. 06'],\n                ['h hh',                             '3 03'],\n                ['H HH',                             '15 15'],\n                ['m mm',                             '25 25'],\n                ['s ss',                             '50 50'],\n                ['a A',                              'pm PM'],\n                ['[aasta] DDDo [p\u00c3\u00a4ev]',              'aasta 45. p\u00c3\u00a4ev'],\n                ['LTS',                              '15:25:50'],\n                ['L',                                '14.02.2010'],\n                ['LL',                               '14. veebruar 2010'],\n                ['LLL',                              '14. veebruar 2010 15:25'],\n                ['LLLL',                             'p\u00c3\u00bchap\u00c3\u00a4ev, 14. veebruar 2010 15:25'],\n                ['l',                                '14.2.2010'],\n                ['ll',                               '14. veebr 2010'],\n                ['lll',                              '14. veebr 2010 15:25'],\n                ['llll',                             'P, 14. veebr 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'jaanuar jaan_veebruar veebr_m\u00c3\u00a4rts m\u00c3\u00a4rts_aprill apr_mai mai_juuni juuni_juuli juuli_august aug_september sept_oktoober okt_november nov_detsember dets'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'p\u00c3\u00bchap\u00c3\u00a4ev P P_esmasp\u00c3\u00a4ev E E_teisip\u00c3\u00a4ev T T_kolmap\u00c3\u00a4ev K K_neljap\u00c3\u00a4ev N N_reede R R_laup\u00c3\u00a4ev L L'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'paar sekundit',  '44 seconds = paar sekundit');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00c3\u00bcks minut',      '45 seconds = \u00c3\u00bcks minut');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00c3\u00bcks minut',      '89 seconds = \u00c3\u00bcks minut');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutit',      '90 seconds = 2 minutit');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutit',     '44 minutes = 44 minutit');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00c3\u00bcks tund',       '45 minutes = tund aega');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00c3\u00bcks tund',       '89 minutes = \u00c3\u00bcks tund');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 tundi',        '90 minutes = 2 tundi');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 tundi',        '5 hours = 5 tundi');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tundi',       '21 hours = 21 tundi');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00c3\u00bcks p\u00c3\u00a4ev',       '22 hours = \u00c3\u00bcks p\u00c3\u00a4ev');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00c3\u00bcks p\u00c3\u00a4ev',       '35 hours = \u00c3\u00bcks p\u00c3\u00a4ev');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 p\u00c3\u00a4eva',        '36 hours = 2 p\u00c3\u00a4eva');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00c3\u00bcks p\u00c3\u00a4ev',       '1 day = \u00c3\u00bcks p\u00c3\u00a4ev');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 p\u00c3\u00a4eva',        '5 days = 5 p\u00c3\u00a4eva');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 p\u00c3\u00a4eva',       '25 days = 25 p\u00c3\u00a4eva');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00c3\u00bcks kuu',        '26 days = \u00c3\u00bcks kuu');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00c3\u00bcks kuu',        '30 days = \u00c3\u00bcks kuu');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00c3\u00bcks kuu',        '43 days = \u00c3\u00bcks kuu');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 kuud',         '46 days = 2 kuud');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 kuud',         '75 days = 2 kuud');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 kuud',         '76 days = 3 kuud');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00c3\u00bcks kuu',        '1 month = \u00c3\u00bcks kuu');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 kuud',         '5 months = 5 kuud');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00c3\u00bcks aasta',      '345 days = \u00c3\u00bcks aasta');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 aastat',       '548 days = 2 aastat');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00c3\u00bcks aasta',      '1 year = \u00c3\u00bcks aasta');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 aastat',       '5 years = 5 aastat');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'm\u00c3\u00b5ne sekundi p\u00c3\u00a4rast',  'prefix');\n        assert.equal(moment(0).from(30000), 'm\u00c3\u00b5ni sekund tagasi', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'm\u00c3\u00b5ni sekund tagasi',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'm\u00c3\u00b5ne sekundi p\u00c3\u00a4rast', 'in a few seconds');\n        assert.equal(moment().subtract({s: 30}).fromNow(), 'm\u00c3\u00b5ni sekund tagasi', 'a few seconds ago');\n\n        assert.equal(moment().add({m: 1}).fromNow(), '\u00c3\u00bche minuti p\u00c3\u00a4rast', 'in a minute');\n        assert.equal(moment().subtract({m: 1}).fromNow(), '\u00c3\u00bcks minut tagasi', 'a minute ago');\n\n        assert.equal(moment().add({m: 5}).fromNow(), '5 minuti p\u00c3\u00a4rast', 'in 5 minutes');\n        assert.equal(moment().subtract({m: 5}).fromNow(), '5 minutit tagasi', '5 minutes ago');\n\n        assert.equal(moment().add({d: 1}).fromNow(), '\u00c3\u00bche p\u00c3\u00a4eva p\u00c3\u00a4rast', 'in one day');\n        assert.equal(moment().subtract({d: 1}).fromNow(), '\u00c3\u00bcks p\u00c3\u00a4ev tagasi', 'one day ago');\n\n        assert.equal(moment().add({d: 5}).fromNow(), '5 p\u00c3\u00a4eva p\u00c3\u00a4rast', 'in 5 days');\n        assert.equal(moment().subtract({d: 5}).fromNow(), '5 p\u00c3\u00a4eva tagasi', '5 days ago');\n\n        assert.equal(moment().add({M: 1}).fromNow(), 'kuu aja p\u00c3\u00a4rast', 'in a month');\n        assert.equal(moment().subtract({M: 1}).fromNow(), 'kuu aega tagasi', 'a month ago');\n\n        assert.equal(moment().add({M: 5}).fromNow(), '5 kuu p\u00c3\u00a4rast', 'in 5 months');\n        assert.equal(moment().subtract({M: 5}).fromNow(), '5 kuud tagasi', '5 months ago');\n\n        assert.equal(moment().add({y: 1}).fromNow(), '\u00c3\u00bche aasta p\u00c3\u00a4rast', 'in a year');\n        assert.equal(moment().subtract({y: 1}).fromNow(), 'aasta tagasi', 'a year ago');\n\n        assert.equal(moment().add({y: 5}).fromNow(), '5 aasta p\u00c3\u00a4rast', 'in 5 years');\n        assert.equal(moment().subtract({y: 5}).fromNow(), '5 aastat tagasi', '5 years ago');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'T\u00c3\u00a4na, 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'T\u00c3\u00a4na, 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'T\u00c3\u00a4na, 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Homme, 12:00',    'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'T\u00c3\u00a4na, 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Eile, 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[J\u00c3\u00a4rgmine] dddd LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[J\u00c3\u00a4rgmine] dddd LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[J\u00c3\u00a4rgmine] dddd LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[Eelmine] dddd LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[Eelmine] dddd LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[Eelmine] dddd LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 n\u00c3\u00a4dal tagasi');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '1 n\u00c3\u00a4dala p\u00c3\u00a4rast');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 n\u00c3\u00a4dalat tagasi');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '2 n\u00c3\u00a4dala p\u00c3\u00a4rast');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('eu');\n\n    test('parse', function (assert) {\n        var tests = 'urtarrila urt._otsaila ots._martxoa mar._apirila api._maiatza mai._ekaina eka._uztaila uzt._abuztua abu._iraila ira._urria urr._azaroa aza._abendua abe.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'igandea, otsaila 14. 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'ig., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 otsaila ots.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. igandea ig. ig'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '7 7. 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '2010-02-14'],\n                ['LL',                                 '2010ko otsailaren 14a'],\n                ['LLL',                                '2010ko otsailaren 14a 15:25'],\n                ['LLLL',                               'igandea, 2010ko otsailaren 14a 15:25'],\n                ['l',                                  '2010-2-14'],\n                ['ll',                                 '2010ko ots. 14a'],\n                ['lll',                                '2010ko ots. 14a 15:25'],\n                ['llll',                               'ig., 2010ko ots. 14a 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'urtarrila urt._otsaila ots._martxoa mar._apirila api._maiatza mai._ekaina eka._uztaila uzt._abuztua abu._iraila ira._urria urr._azaroa aza._abendua abe.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'igandea ig. ig_astelehena al. al_asteartea ar. ar_asteazkena az. az_osteguna og. og_ostirala ol. ol_larunbata lr. lr'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'segundo batzuk', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minutu bat',     '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minutu bat',     '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutu',       '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutu',      '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ordu bat',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ordu bat',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ordu',         '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ordu',         '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ordu',        '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'egun bat',       '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'egun bat',       '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 egun',         '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'egun bat',       '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 egun',         '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 egun',        '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'hilabete bat',   '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'hilabete bat',   '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'hilabete bat',   '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 hilabete',     '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 hilabete',     '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 hilabete',     '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'hilabete bat',   '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 hilabete',     '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'urte bat',       '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 urte',         '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'urte bat',       '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 urte',         '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'segundo batzuk barru',  'prefix');\n        assert.equal(moment(0).from(30000), 'duela segundo batzuk', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'duela segundo batzuk',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'segundo batzuk barru', 'in seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 egun barru', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'gaur 12:00etan',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'gaur 12:25etan',  'now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'gaur 13:00etan',  'now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'bihar 12:00etan', 'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'gaur 11:00etan',  'now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'atzo 12:00etan',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd LT[etan]'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd LT[etan]'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd LT[etan]'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[aurreko] dddd LT[etan]'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[aurreko] dddd LT[etan]'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[aurreko] dddd LT[etan]'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('fa');\n\n    test('parse', function (assert) {\n        var tests = '\u00da\u0098\u00d8\u00a7\u00d9\u0086\u00d9\u0088\u00db\u008c\u00d9\u0087_\u00d9\u0081\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0087_\u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3_\u00d8\u00a2\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0084_\u00d9\u0085\u00d9\u0087_\u00da\u0098\u00d9\u0088\u00d8\u00a6\u00d9\u0086_\u00da\u0098\u00d9\u0088\u00d8\u00a6\u00db\u008c\u00d9\u0087_\u00d8\u00a7\u00d9\u0088\u00d8\u00aa_\u00d8\u00b3\u00d9\u00be\u00d8\u00aa\u00d8\u00a7\u00d9\u0085\u00d8\u00a8\u00d8\u00b1_\u00d8\u00a7\u00da\u00a9\u00d8\u00aa\u00d8\u00a8\u00d8\u00b1_\u00d9\u0086\u00d9\u0088\u00d8\u00a7\u00d9\u0085\u00d8\u00a8\u00d8\u00b1_\u00d8\u00af\u00d8\u00b3\u00d8\u00a7\u00d9\u0085\u00d8\u00a8\u00d8\u00b1'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' instead is month ' + moment(input, mmm).month());\n        }\n        for (i = 0; i < 12; i++) {\n            equalTest(tests[i], 'MMM', i);\n            equalTest(tests[i], 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      '\u00db\u008c\u00da\u00a9\\u200c\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087\u00d8\u008c \u00d9\u0081\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0087 \u00db\u00b1\u00db\u00b4\u00d9\u0085 \u00db\u00b2\u00db\u00b0\u00db\u00b1\u00db\u00b0\u00d8\u008c \u00db\u00b3:\u00db\u00b2\u00db\u00b5:\u00db\u00b5\u00db\u00b0 \u00d8\u00a8\u00d8\u00b9\u00d8\u00af \u00d8\u00a7\u00d8\u00b2 \u00d8\u00b8\u00d9\u0087\u00d8\u00b1'],\n                ['ddd, hA',                            '\u00db\u008c\u00da\u00a9\\u200c\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087\u00d8\u008c \u00db\u00b3\u00d8\u00a8\u00d8\u00b9\u00d8\u00af \u00d8\u00a7\u00d8\u00b2 \u00d8\u00b8\u00d9\u0087\u00d8\u00b1'],\n                ['M Mo MM MMMM MMM',                   '\u00db\u00b2 \u00db\u00b2\u00d9\u0085 \u00db\u00b0\u00db\u00b2 \u00d9\u0081\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0087 \u00d9\u0081\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0087'],\n                ['YYYY YY',                            '\u00db\u00b2\u00db\u00b0\u00db\u00b1\u00db\u00b0 \u00db\u00b1\u00db\u00b0'],\n                ['D Do DD',                            '\u00db\u00b1\u00db\u00b4 \u00db\u00b1\u00db\u00b4\u00d9\u0085 \u00db\u00b1\u00db\u00b4'],\n                ['d do dddd ddd dd',                   '\u00db\u00b0 \u00db\u00b0\u00d9\u0085 \u00db\u008c\u00da\u00a9\\u200c\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00db\u008c\u00da\u00a9\\u200c\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00db\u008c'],\n                ['DDD DDDo DDDD',                      '\u00db\u00b4\u00db\u00b5 \u00db\u00b4\u00db\u00b5\u00d9\u0085 \u00db\u00b0\u00db\u00b4\u00db\u00b5'],\n                ['w wo ww',                            '\u00db\u00b8 \u00db\u00b8\u00d9\u0085 \u00db\u00b0\u00db\u00b8'],\n                ['h hh',                               '\u00db\u00b3 \u00db\u00b0\u00db\u00b3'],\n                ['H HH',                               '\u00db\u00b1\u00db\u00b5 \u00db\u00b1\u00db\u00b5'],\n                ['m mm',                               '\u00db\u00b2\u00db\u00b5 \u00db\u00b2\u00db\u00b5'],\n                ['s ss',                               '\u00db\u00b5\u00db\u00b0 \u00db\u00b5\u00db\u00b0'],\n                ['a A',                                '\u00d8\u00a8\u00d8\u00b9\u00d8\u00af \u00d8\u00a7\u00d8\u00b2 \u00d8\u00b8\u00d9\u0087\u00d8\u00b1 \u00d8\u00a8\u00d8\u00b9\u00d8\u00af \u00d8\u00a7\u00d8\u00b2 \u00d8\u00b8\u00d9\u0087\u00d8\u00b1'],\n                ['DDDo [\u00d8\u00b1\u00d9\u0088\u00d8\u00b2 \u00d8\u00b3\u00d8\u00a7\u00d9\u0084]',             '\u00db\u00b4\u00db\u00b5\u00d9\u0085 \u00d8\u00b1\u00d9\u0088\u00d8\u00b2 \u00d8\u00b3\u00d8\u00a7\u00d9\u0084'],\n                ['LTS',                                '\u00db\u00b1\u00db\u00b5:\u00db\u00b2\u00db\u00b5:\u00db\u00b5\u00db\u00b0'],\n                ['L',                                  '\u00db\u00b1\u00db\u00b4/\u00db\u00b0\u00db\u00b2/\u00db\u00b2\u00db\u00b0\u00db\u00b1\u00db\u00b0'],\n                ['LL',                                 '\u00db\u00b1\u00db\u00b4 \u00d9\u0081\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0087 \u00db\u00b2\u00db\u00b0\u00db\u00b1\u00db\u00b0'],\n                ['LLL',                                '\u00db\u00b1\u00db\u00b4 \u00d9\u0081\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0087 \u00db\u00b2\u00db\u00b0\u00db\u00b1\u00db\u00b0 \u00db\u00b1\u00db\u00b5:\u00db\u00b2\u00db\u00b5'],\n                ['LLLL',                               '\u00db\u008c\u00da\u00a9\\u200c\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087\u00d8\u008c \u00db\u00b1\u00db\u00b4 \u00d9\u0081\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0087 \u00db\u00b2\u00db\u00b0\u00db\u00b1\u00db\u00b0 \u00db\u00b1\u00db\u00b5:\u00db\u00b2\u00db\u00b5'],\n                ['l',                                  '\u00db\u00b1\u00db\u00b4/\u00db\u00b2/\u00db\u00b2\u00db\u00b0\u00db\u00b1\u00db\u00b0'],\n                ['ll',                                 '\u00db\u00b1\u00db\u00b4 \u00d9\u0081\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0087 \u00db\u00b2\u00db\u00b0\u00db\u00b1\u00db\u00b0'],\n                ['lll',                                '\u00db\u00b1\u00db\u00b4 \u00d9\u0081\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0087 \u00db\u00b2\u00db\u00b0\u00db\u00b1\u00db\u00b0 \u00db\u00b1\u00db\u00b5:\u00db\u00b2\u00db\u00b5'],\n                ['llll',                               '\u00db\u008c\u00da\u00a9\\u200c\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087\u00d8\u008c \u00db\u00b1\u00db\u00b4 \u00d9\u0081\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0087 \u00db\u00b2\u00db\u00b0\u00db\u00b1\u00db\u00b0 \u00db\u00b1\u00db\u00b5:\u00db\u00b2\u00db\u00b5']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '\u00db\u00b1\u00d9\u0085', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '\u00db\u00b2\u00d9\u0085', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '\u00db\u00b3\u00d9\u0085', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '\u00db\u00b4\u00d9\u0085', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '\u00db\u00b5\u00d9\u0085', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '\u00db\u00b6\u00d9\u0085', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '\u00db\u00b7\u00d9\u0085', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '\u00db\u00b8\u00d9\u0085', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '\u00db\u00b9\u00d9\u0085', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00db\u00b1\u00db\u00b0\u00d9\u0085', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00db\u00b1\u00db\u00b1\u00d9\u0085', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00db\u00b1\u00db\u00b2\u00d9\u0085', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00db\u00b1\u00db\u00b3\u00d9\u0085', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00db\u00b1\u00db\u00b4\u00d9\u0085', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00db\u00b1\u00db\u00b5\u00d9\u0085', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00db\u00b1\u00db\u00b6\u00d9\u0085', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00db\u00b1\u00db\u00b7\u00d9\u0085', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00db\u00b1\u00db\u00b8\u00d9\u0085', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00db\u00b1\u00db\u00b9\u00d9\u0085', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00db\u00b2\u00db\u00b0\u00d9\u0085', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '\u00db\u00b2\u00db\u00b1\u00d9\u0085', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '\u00db\u00b2\u00db\u00b2\u00d9\u0085', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '\u00db\u00b2\u00db\u00b3\u00d9\u0085', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '\u00db\u00b2\u00db\u00b4\u00d9\u0085', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '\u00db\u00b2\u00db\u00b5\u00d9\u0085', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '\u00db\u00b2\u00db\u00b6\u00d9\u0085', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '\u00db\u00b2\u00db\u00b7\u00d9\u0085', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '\u00db\u00b2\u00db\u00b8\u00d9\u0085', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '\u00db\u00b2\u00db\u00b9\u00d9\u0085', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '\u00db\u00b3\u00db\u00b0\u00d9\u0085', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '\u00db\u00b3\u00db\u00b1\u00d9\u0085', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00da\u0098\u00d8\u00a7\u00d9\u0086\u00d9\u0088\u00db\u008c\u00d9\u0087 \u00da\u0098\u00d8\u00a7\u00d9\u0086\u00d9\u0088\u00db\u008c\u00d9\u0087_\u00d9\u0081\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0087 \u00d9\u0081\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0087_\u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3 \u00d9\u0085\u00d8\u00a7\u00d8\u00b1\u00d8\u00b3_\u00d8\u00a2\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0084 \u00d8\u00a2\u00d9\u0088\u00d8\u00b1\u00db\u008c\u00d9\u0084_\u00d9\u0085\u00d9\u0087 \u00d9\u0085\u00d9\u0087_\u00da\u0098\u00d9\u0088\u00d8\u00a6\u00d9\u0086 \u00da\u0098\u00d9\u0088\u00d8\u00a6\u00d9\u0086_\u00da\u0098\u00d9\u0088\u00d8\u00a6\u00db\u008c\u00d9\u0087 \u00da\u0098\u00d9\u0088\u00d8\u00a6\u00db\u008c\u00d9\u0087_\u00d8\u00a7\u00d9\u0088\u00d8\u00aa \u00d8\u00a7\u00d9\u0088\u00d8\u00aa_\u00d8\u00b3\u00d9\u00be\u00d8\u00aa\u00d8\u00a7\u00d9\u0085\u00d8\u00a8\u00d8\u00b1 \u00d8\u00b3\u00d9\u00be\u00d8\u00aa\u00d8\u00a7\u00d9\u0085\u00d8\u00a8\u00d8\u00b1_\u00d8\u00a7\u00da\u00a9\u00d8\u00aa\u00d8\u00a8\u00d8\u00b1 \u00d8\u00a7\u00da\u00a9\u00d8\u00aa\u00d8\u00a8\u00d8\u00b1_\u00d9\u0086\u00d9\u0088\u00d8\u00a7\u00d9\u0085\u00d8\u00a8\u00d8\u00b1 \u00d9\u0086\u00d9\u0088\u00d8\u00a7\u00d9\u0085\u00d8\u00a8\u00d8\u00b1_\u00d8\u00af\u00d8\u00b3\u00d8\u00a7\u00d9\u0085\u00d8\u00a8\u00d8\u00b1 \u00d8\u00af\u00d8\u00b3\u00d8\u00a7\u00d9\u0085\u00d8\u00a8\u00d8\u00b1'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00db\u008c\u00da\u00a9\\u200c\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00db\u008c\u00da\u00a9\\u200c\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00db\u008c_\u00d8\u00af\u00d9\u0088\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00d8\u00af\u00d9\u0088\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00d8\u00af_\u00d8\u00b3\u00d9\u0087\\u200c\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00d8\u00b3\u00d9\u0087\\u200c\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00d8\u00b3_\u00da\u0086\u00d9\u0087\u00d8\u00a7\u00d8\u00b1\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00da\u0086\u00d9\u0087\u00d8\u00a7\u00d8\u00b1\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00da\u0086_\u00d9\u00be\u00d9\u0086\u00d8\u00ac\\u200c\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00d9\u00be\u00d9\u0086\u00d8\u00ac\\u200c\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00d9\u00be_\u00d8\u00ac\u00d9\u0085\u00d8\u00b9\u00d9\u0087 \u00d8\u00ac\u00d9\u0085\u00d8\u00b9\u00d9\u0087 \u00d8\u00ac_\u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00d8\u00b4\u00d9\u0086\u00d8\u00a8\u00d9\u0087 \u00d8\u00b4'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00da\u0086\u00d9\u0086\u00d8\u00af\u00db\u008c\u00d9\u0086 \u00d8\u00ab\u00d8\u00a7\u00d9\u0086\u00db\u008c\u00d9\u0087', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00db\u008c\u00da\u00a9 \u00d8\u00af\u00d9\u0082\u00db\u008c\u00d9\u0082\u00d9\u0087',       '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00db\u008c\u00da\u00a9 \u00d8\u00af\u00d9\u0082\u00db\u008c\u00d9\u0082\u00d9\u0087',       '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '\u00db\u00b2 \u00d8\u00af\u00d9\u0082\u00db\u008c\u00d9\u0082\u00d9\u0087',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '\u00db\u00b4\u00db\u00b4 \u00d8\u00af\u00d9\u0082\u00db\u008c\u00d9\u0082\u00d9\u0087',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00db\u008c\u00da\u00a9 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa',     '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00db\u008c\u00da\u00a9 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa',     '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00db\u00b2 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa',      '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '\u00db\u00b5 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa',      '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '\u00db\u00b2\u00db\u00b1 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa',     '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00db\u008c\u00da\u00a9 \u00d8\u00b1\u00d9\u0088\u00d8\u00b2',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00db\u008c\u00da\u00a9 \u00d8\u00b1\u00d9\u0088\u00d8\u00b2',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00db\u00b2 \u00d8\u00b1\u00d9\u0088\u00d8\u00b2',       '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00db\u008c\u00da\u00a9 \u00d8\u00b1\u00d9\u0088\u00d8\u00b2',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '\u00db\u00b5 \u00d8\u00b1\u00d9\u0088\u00d8\u00b2',       '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '\u00db\u00b2\u00db\u00b5 \u00d8\u00b1\u00d9\u0088\u00d8\u00b2',      '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00db\u008c\u00da\u00a9 \u00d9\u0085\u00d8\u00a7\u00d9\u0087',      '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00db\u008c\u00da\u00a9 \u00d9\u0085\u00d8\u00a7\u00d9\u0087',      '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00db\u008c\u00da\u00a9 \u00d9\u0085\u00d8\u00a7\u00d9\u0087',      '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '\u00db\u00b2 \u00d9\u0085\u00d8\u00a7\u00d9\u0087',       '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '\u00db\u00b2 \u00d9\u0085\u00d8\u00a7\u00d9\u0087',       '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '\u00db\u00b3 \u00d9\u0085\u00d8\u00a7\u00d9\u0087',       '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00db\u008c\u00da\u00a9 \u00d9\u0085\u00d8\u00a7\u00d9\u0087',      '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '\u00db\u00b5 \u00d9\u0085\u00d8\u00a7\u00d9\u0087',       '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00db\u008c\u00da\u00a9 \u00d8\u00b3\u00d8\u00a7\u00d9\u0084',      '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00db\u00b2 \u00d8\u00b3\u00d8\u00a7\u00d9\u0084',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00db\u008c\u00da\u00a9 \u00d8\u00b3\u00d8\u00a7\u00d9\u0084',      '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '\u00db\u00b5 \u00d8\u00b3\u00d8\u00a7\u00d9\u0084',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d8\u00af\u00d8\u00b1 \u00da\u0086\u00d9\u0086\u00d8\u00af\u00db\u008c\u00d9\u0086 \u00d8\u00ab\u00d8\u00a7\u00d9\u0086\u00db\u008c\u00d9\u0087', 'prefix');\n        assert.equal(moment(0).from(30000), '\u00da\u0086\u00d9\u0086\u00d8\u00af\u00db\u008c\u00d9\u0086 \u00d8\u00ab\u00d8\u00a7\u00d9\u0086\u00db\u008c\u00d9\u0087 \u00d9\u00be\u00db\u008c\u00d8\u00b4', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00da\u0086\u00d9\u0086\u00d8\u00af\u00db\u008c\u00d9\u0086 \u00d8\u00ab\u00d8\u00a7\u00d9\u0086\u00db\u008c\u00d9\u0087 \u00d9\u00be\u00db\u008c\u00d8\u00b4',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d8\u00af\u00d8\u00b1 \u00da\u0086\u00d9\u0086\u00d8\u00af\u00db\u008c\u00d9\u0086 \u00d8\u00ab\u00d8\u00a7\u00d9\u0086\u00db\u008c\u00d9\u0087', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00d8\u00af\u00d8\u00b1 \u00db\u00b5 \u00d8\u00b1\u00d9\u0088\u00d8\u00b2', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d8\u00a7\u00d9\u0085\u00d8\u00b1\u00d9\u0088\u00d8\u00b2 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa \u00db\u00b1\u00db\u00b2:\u00db\u00b0\u00db\u00b0', 'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d8\u00a7\u00d9\u0085\u00d8\u00b1\u00d9\u0088\u00d8\u00b2 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa \u00db\u00b1\u00db\u00b2:\u00db\u00b2\u00db\u00b5', 'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d8\u00a7\u00d9\u0085\u00d8\u00b1\u00d9\u0088\u00d8\u00b2 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa \u00db\u00b1\u00db\u00b3:\u00db\u00b0\u00db\u00b0', 'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d9\u0081\u00d8\u00b1\u00d8\u00af\u00d8\u00a7 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa \u00db\u00b1\u00db\u00b2:\u00db\u00b0\u00db\u00b0', 'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d8\u00a7\u00d9\u0085\u00d8\u00b1\u00d9\u0088\u00d8\u00b2 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa \u00db\u00b1\u00db\u00b1:\u00db\u00b0\u00db\u00b0', 'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d8\u00af\u00db\u008c\u00d8\u00b1\u00d9\u0088\u00d8\u00b2 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa \u00db\u00b1\u00db\u00b2:\u00db\u00b0\u00db\u00b0', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d9\u00be\u00db\u008c\u00d8\u00b4 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d9\u00be\u00db\u008c\u00d8\u00b4 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d9\u00be\u00db\u008c\u00d8\u00b4 \u00d8\u00b3\u00d8\u00a7\u00d8\u00b9\u00d8\u00aa] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '\u00db\u00b1 \u00db\u00b0\u00db\u00b1 \u00db\u00b1\u00d9\u0085', 'Dec 31 2011 should be week 1');\n        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '\u00db\u00b1 \u00db\u00b0\u00db\u00b1 \u00db\u00b1\u00d9\u0085', 'Jan  6 2012 should be week 1');\n        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '\u00db\u00b2 \u00db\u00b0\u00db\u00b2 \u00db\u00b2\u00d9\u0085', 'Jan  7 2012 should be week 2');\n        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '\u00db\u00b2 \u00db\u00b0\u00db\u00b2 \u00db\u00b2\u00d9\u0085', 'Jan 13 2012 should be week 2');\n        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '\u00db\u00b3 \u00db\u00b0\u00db\u00b3 \u00db\u00b3\u00d9\u0085', 'Jan 14 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('fi');\n\n    test('parse', function (assert) {\n        var tests = 'tammikuu tammi_helmikuu helmi_maaliskuu maalis_huhtikuu huhti_toukokuu touko_kes\u00c3\u00a4kuu kes\u00c3\u00a4_hein\u00c3\u00a4kuu hein\u00c3\u00a4_elokuu elo_syyskuu syys_lokakuu loka_marraskuu marras_joulukuu joulu'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sunnuntai, helmikuu 14. 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'su, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 helmikuu helmi'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. sunnuntai su su'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[vuoden] DDDo [p\u00c3\u00a4iv\u00c3\u00a4]',              'vuoden 45. p\u00c3\u00a4iv\u00c3\u00a4'],\n                ['LTS',                                '15.25.50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14. helmikuuta 2010'],\n                ['LLL',                                '14. helmikuuta 2010, klo 15.25'],\n                ['LLLL',                               'sunnuntai, 14. helmikuuta 2010, klo 15.25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14. helmi 2010'],\n                ['lll',                                '14. helmi 2010, klo 15.25'],\n                ['llll',                               'su, 14. helmi 2010, klo 15.25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21st');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22nd');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23rd');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31st');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'tammikuu tammi_helmikuu helmi_maaliskuu maalis_huhtikuu huhti_toukokuu touko_kes\u00c3\u00a4kuu kes\u00c3\u00a4_hein\u00c3\u00a4kuu hein\u00c3\u00a4_elokuu elo_syyskuu syys_lokakuu loka_marraskuu marras_joulukuu joulu'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'sunnuntai su su_maanantai ma ma_tiistai ti ti_keskiviikko ke ke_torstai to to_perjantai pe pe_lauantai la la'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'muutama sekunti', '44 seconds = few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuutti',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuutti',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'kaksi minuuttia',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuuttia',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'tunti',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'tunti',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'kaksi tuntia',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'viisi tuntia',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tuntia',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'p\u00c3\u00a4iv\u00c3\u00a4',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'p\u00c3\u00a4iv\u00c3\u00a4',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'kaksi p\u00c3\u00a4iv\u00c3\u00a4\u00c3\u00a4',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'p\u00c3\u00a4iv\u00c3\u00a4',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'viisi p\u00c3\u00a4iv\u00c3\u00a4\u00c3\u00a4',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 p\u00c3\u00a4iv\u00c3\u00a4\u00c3\u00a4',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'kuukausi',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'kuukausi',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'kuukausi',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'kaksi kuukautta',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'kaksi kuukautta',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'kolme kuukautta',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'kuukausi',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'viisi kuukautta',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'vuosi',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'kaksi vuotta',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'vuosi',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'viisi vuotta',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'muutaman sekunnin p\u00c3\u00a4\u00c3\u00a4st\u00c3\u00a4',  'prefix');\n        assert.equal(moment(0).from(30000), 'muutama sekunti sitten', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'muutama sekunti sitten',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'muutaman sekunnin p\u00c3\u00a4\u00c3\u00a4st\u00c3\u00a4', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'viiden p\u00c3\u00a4iv\u00c3\u00a4n p\u00c3\u00a4\u00c3\u00a4st\u00c3\u00a4', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   't\u00c3\u00a4n\u00c3\u00a4\u00c3\u00a4n klo 12.00',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      't\u00c3\u00a4n\u00c3\u00a4\u00c3\u00a4n klo 12.25',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       't\u00c3\u00a4n\u00c3\u00a4\u00c3\u00a4n klo 13.00',    'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'huomenna klo 12.00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  't\u00c3\u00a4n\u00c3\u00a4\u00c3\u00a4n klo 11.00',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'eilen klo 12.00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [klo] LT'),  'today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [klo] LT'),  'today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [klo] LT'),  'today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[viime] dddd[na] [klo] LT'),  'today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[viime] dddd[na] [klo] LT'),  'today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[viime] dddd[na] [klo] LT'),  'today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'yksi viikko sitten');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'yhden viikon p\u00c3\u00a4\u00c3\u00a4st\u00c3\u00a4');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'kaksi viikkoa sitten');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'kaden viikon p\u00c3\u00a4\u00c3\u00a4st\u00c3\u00a4');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('fo');\n\n    test('parse', function (assert) {\n        var tests = 'januar jan_februar feb_mars mar_apr\u00c3\u00adl apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd [tann] Do MMMM YYYY, h:mm:ss a', 'sunnudagur tann 14. februar 2010, 3:25:50 pm'],\n                ['ddd hA',                             'sun 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. sunnudagur sun su'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[tann] DDDo [dagin \u00c3\u00a1 \u00c3\u00a1rinum]',       'tann 45. dagin \u00c3\u00a1 \u00c3\u00a1rinum'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 februar 2010'],\n                ['LLL',                                '14 februar 2010 15:25'],\n                ['LLLL',                               'sunnudagur 14. februar, 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 feb 2010'],\n                ['lll',                                '14 feb 2010 15:25'],\n                ['llll',                               'sun 14. feb, 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'januar jan_februar feb_mars mar_apr\u00c3\u00adl apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'sunnudagur sun su_m\u00c3\u00a1nadagur m\u00c3\u00a1n m\u00c3\u00a1_t\u00c3\u00bdsdagur t\u00c3\u00bds t\u00c3\u00bd_mikudagur mik mi_h\u00c3\u00b3sdagur h\u00c3\u00b3s h\u00c3\u00b3_fr\u00c3\u00adggjadagur fr\u00c3\u00ad fr_leygardagur ley le'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'f\u00c3\u00a1 sekund', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ein minutt',    '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ein minutt',    '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuttir',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuttir', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ein t\u00c3\u00admi',     '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ein t\u00c3\u00admi',     '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 t\u00c3\u00admar',     '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 t\u00c3\u00admar',     '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 t\u00c3\u00admar',    '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ein dagur',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ein dagur',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',      '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ein dagur',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',      '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',     '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ein m\u00c3\u00a1na\u00c3\u00b0i',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ein m\u00c3\u00a1na\u00c3\u00b0i',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ein m\u00c3\u00a1na\u00c3\u00b0i',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m\u00c3\u00a1na\u00c3\u00b0ir',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m\u00c3\u00a1na\u00c3\u00b0ir',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m\u00c3\u00a1na\u00c3\u00b0ir',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ein m\u00c3\u00a1na\u00c3\u00b0i',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m\u00c3\u00a1na\u00c3\u00b0ir',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'eitt \u00c3\u00a1r',       '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00c3\u00a1r',        '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'eitt \u00c3\u00a1r',       '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00c3\u00a1r',        '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'um f\u00c3\u00a1 sekund',  'prefix');\n        assert.equal(moment(0).from(30000), 'f\u00c3\u00a1 sekund s\u00c3\u00ad\u00c3\u00b0ani', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'f\u00c3\u00a1 sekund s\u00c3\u00ad\u00c3\u00b0ani',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'um f\u00c3\u00a1 sekund', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'um 5 dagar', 'in 5 days');\n    });\n\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00c3\u008d dag kl. 12:00',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00c3\u008d dag kl. 12:25',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00c3\u008d dag kl. 13:00',    'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00c3\u008d morgin kl. 12:00', 'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00c3\u008d dag kl. 11:00',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00c3\u008d gj\u00c3\u00a1r kl. 12:00',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[s\u00c3\u00ad\u00c3\u00b0stu] dddd [kl] LT'),  'today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[s\u00c3\u00ad\u00c3\u00b0stu] dddd [kl] LT'),  'today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[s\u00c3\u00ad\u00c3\u00b0stu] dddd [kl] LT'),  'today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'yksi viikko sitten');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'yhden viikon p\u00c3\u00a4\u00c3\u00a4st\u00c3\u00a4');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'kaksi viikkoa sitten');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'kaden viikon p\u00c3\u00a4\u00c3\u00a4st\u00c3\u00a4');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('fr-ca');\n\n    test('parse', function (assert) {\n        var i,\n            tests = 'janvier janv._f\u00c3\u00a9vrier f\u00c3\u00a9vr._mars mars_avril avr._mai mai_juin juin_juillet juil._ao\u00c3\u00bbt ao\u00c3\u00bbt_septembre sept._octobre oct._novembre nov._d\u00c3\u00a9cembre d\u00c3\u00a9c.'.split('_');\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'dimanche, f\u00c3\u00a9vrier 14e 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'dim., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2e 02 f\u00c3\u00a9vrier f\u00c3\u00a9vr.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14e 14'],\n                ['d do dddd ddd dd',                   '0 0e dimanche dim. Di'],\n                ['DDD DDDo DDDD',                      '45 45e 045'],\n                ['w wo ww',                            '8 8e 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45e day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '2010-02-14'],\n                ['LL',                                 '14 f\u00c3\u00a9vrier 2010'],\n                ['LLL',                                '14 f\u00c3\u00a9vrier 2010 15:25'],\n                ['LLLL',                               'dimanche 14 f\u00c3\u00a9vrier 2010 15:25'],\n                ['l',                                  '2010-2-14'],\n                ['ll',                                 '14 f\u00c3\u00a9vr. 2010'],\n                ['lll',                                '14 f\u00c3\u00a9vr. 2010 15:25'],\n                ['llll',                               'dim. 14 f\u00c3\u00a9vr. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1er', '1er');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2e', '2e');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3e', '3e');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4e', '4e');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5e', '5e');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6e', '6e');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7e', '7e');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8e', '8e');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9e', '9e');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10e', '10e');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11e', '11e');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12e', '12e');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13e', '13e');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14e', '14e');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15e', '15e');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16e', '16e');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17e', '17e');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18e', '18e');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19e', '19e');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20e', '20e');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21e', '21e');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22e', '22e');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23e', '23e');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24e', '24e');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25e', '25e');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26e', '26e');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27e', '27e');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28e', '28e');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29e', '29e');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30e', '30e');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31e', '31e');\n    });\n\n    test('format month', function (assert) {\n        var i,\n            expected = 'janvier janv._f\u00c3\u00a9vrier f\u00c3\u00a9vr._mars mars_avril avr._mai mai_juin juin_juillet juil._ao\u00c3\u00bbt ao\u00c3\u00bbt_septembre sept._octobre oct._novembre nov._d\u00c3\u00a9cembre d\u00c3\u00a9c.'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var i,\n            expected = 'dimanche dim. Di_lundi lun. Lu_mardi mar. Ma_mercredi mer. Me_jeudi jeu. Je_vendredi ven. Ve_samedi sam. Sa'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'quelques secondes', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'une minute',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'une minute',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'une heure',    '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'une heure',    '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 heures',    '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 heures',    '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 heures',   '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un jour',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un jour',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 jours',     '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un jour',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 jours',     '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 jours',    '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mois',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mois',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mois',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mois',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mois',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mois',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mois',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mois',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ans',    '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ans',    '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'dans quelques secondes', 'prefix');\n        assert.equal(moment(0).from(30000), 'il y a quelques secondes', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'dans quelques secondes', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'dans 5 jours', 'in 5 days');\n    });\n\n    test('same day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Aujourd\\'hui \u00c3\u00a0 12:00',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Aujourd\\'hui \u00c3\u00a0 12:25',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Aujourd\\'hui \u00c3\u00a0 13:00',    'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Demain \u00c3\u00a0 12:00',          'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Aujourd\\'hui \u00c3\u00a0 11:00',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hier \u00c3\u00a0 12:00',            'yesterday at the same time');\n    });\n\n    test('same next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('same last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [dernier \u00c3\u00a0] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [dernier \u00c3\u00a0] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [dernier \u00c3\u00a0] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('same all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1er', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1er', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2e', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2e', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3e', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('fr-ch');\n\n    test('parse', function (assert) {\n        var i,\n            tests = 'janvier janv._f\u00c3\u00a9vrier f\u00c3\u00a9vr._mars mars_avril avr._mai mai_juin juin_juillet juil._ao\u00c3\u00bbt ao\u00c3\u00bbt_septembre sept._octobre oct._novembre nov._d\u00c3\u00a9cembre d\u00c3\u00a9c.'.split('_');\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'dimanche, f\u00c3\u00a9vrier 14e 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'dim., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2e 02 f\u00c3\u00a9vrier f\u00c3\u00a9vr.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14e 14'],\n                ['d do dddd ddd dd',                   '0 0e dimanche dim. Di'],\n                ['DDD DDDo DDDD',                      '45 45e 045'],\n                ['w wo ww',                            '6 6e 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45e day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 f\u00c3\u00a9vrier 2010'],\n                ['LLL',                                '14 f\u00c3\u00a9vrier 2010 15:25'],\n                ['LLLL',                               'dimanche 14 f\u00c3\u00a9vrier 2010 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 f\u00c3\u00a9vr. 2010'],\n                ['lll',                                '14 f\u00c3\u00a9vr. 2010 15:25'],\n                ['llll',                               'dim. 14 f\u00c3\u00a9vr. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1er', '1er');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2e', '2e');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3e', '3e');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4e', '4e');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5e', '5e');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6e', '6e');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7e', '7e');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8e', '8e');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9e', '9e');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10e', '10e');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11e', '11e');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12e', '12e');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13e', '13e');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14e', '14e');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15e', '15e');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16e', '16e');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17e', '17e');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18e', '18e');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19e', '19e');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20e', '20e');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21e', '21e');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22e', '22e');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23e', '23e');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24e', '24e');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25e', '25e');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26e', '26e');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27e', '27e');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28e', '28e');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29e', '29e');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30e', '30e');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31e', '31e');\n    });\n\n    test('format month', function (assert) {\n        var i,\n            expected = 'janvier janv._f\u00c3\u00a9vrier f\u00c3\u00a9vr._mars mars_avril avr._mai mai_juin juin_juillet juil._ao\u00c3\u00bbt ao\u00c3\u00bbt_septembre sept._octobre oct._novembre nov._d\u00c3\u00a9cembre d\u00c3\u00a9c.'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var i,\n            expected = 'dimanche dim. Di_lundi lun. Lu_mardi mar. Ma_mercredi mer. Me_jeudi jeu. Je_vendredi ven. Ve_samedi sam. Sa'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'quelques secondes', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'une minute',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'une minute',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'une heure',    '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'une heure',    '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 heures',    '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 heures',    '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 heures',   '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un jour',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un jour',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 jours',     '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un jour',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 jours',     '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 jours',    '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mois',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mois',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mois',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mois',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mois',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mois',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mois',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mois',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ans',    '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ans',    '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'dans quelques secondes', 'prefix');\n        assert.equal(moment(0).from(30000), 'il y a quelques secondes', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'dans quelques secondes', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'dans 5 jours', 'in 5 days');\n    });\n\n    test('same day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Aujourd\\'hui \u00c3\u00a0 12:00',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Aujourd\\'hui \u00c3\u00a0 12:25',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Aujourd\\'hui \u00c3\u00a0 13:00',    'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Demain \u00c3\u00a0 12:00',          'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Aujourd\\'hui \u00c3\u00a0 11:00',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hier \u00c3\u00a0 12:00',            'yesterday at the same time');\n    });\n\n    test('same next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('same last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [dernier \u00c3\u00a0] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [dernier \u00c3\u00a0] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [dernier \u00c3\u00a0] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('same all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52e', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1er', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1er', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2e', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2e', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('fr');\n\n    test('parse', function (assert) {\n        var tests = 'janvier janv._f\u00c3\u00a9vrier f\u00c3\u00a9vr._mars mars_avril avr._mai mai_juin juin_juillet juil._ao\u00c3\u00bbt ao\u00c3\u00bbt_septembre sept._octobre oct._novembre nov._d\u00c3\u00a9cembre d\u00c3\u00a9c.'.split('_'),\n            i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'dimanche, f\u00c3\u00a9vrier 14 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'dim., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 f\u00c3\u00a9vrier f\u00c3\u00a9vr.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 dimanche dim. Di'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '6 6 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45 day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 f\u00c3\u00a9vrier 2010'],\n                ['LLL',                                '14 f\u00c3\u00a9vrier 2010 15:25'],\n                ['LLLL',                               'dimanche 14 f\u00c3\u00a9vrier 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 f\u00c3\u00a9vr. 2010'],\n                ['lll',                                '14 f\u00c3\u00a9vr. 2010 15:25'],\n                ['llll',                               'dim. 14 f\u00c3\u00a9vr. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1er', '1er');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'janvier janv._f\u00c3\u00a9vrier f\u00c3\u00a9vr._mars mars_avril avr._mai mai_juin juin_juillet juil._ao\u00c3\u00bbt ao\u00c3\u00bbt_septembre sept._octobre oct._novembre nov._d\u00c3\u00a9cembre d\u00c3\u00a9c.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'dimanche dim. Di_lundi lun. Lu_mardi mar. Ma_mercredi mer. Me_jeudi jeu. Je_vendredi ven. Ve_samedi sam. Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'quelques secondes', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'une minute',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'une minute',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'une heure',    '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'une heure',    '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 heures',    '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 heures',    '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 heures',   '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un jour',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un jour',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 jours',     '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un jour',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 jours',     '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 jours',    '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mois',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mois',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mois',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mois',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mois',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mois',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mois',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mois',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ans',    '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ans',    '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'dans quelques secondes', 'prefix');\n        assert.equal(moment(0).from(30000), 'il y a quelques secondes', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'dans quelques secondes', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'dans 5 jours', 'in 5 days');\n    });\n\n    test('same day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Aujourd\\'hui \u00c3\u00a0 12:00',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Aujourd\\'hui \u00c3\u00a0 12:25',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Aujourd\\'hui \u00c3\u00a0 13:00',    'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Demain \u00c3\u00a0 12:00',          'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Aujourd\\'hui \u00c3\u00a0 11:00',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hier \u00c3\u00a0 12:00',            'yesterday at the same time');\n    });\n\n    test('same next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('same last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [dernier \u00c3\u00a0] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [dernier \u00c3\u00a0] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [dernier \u00c3\u00a0] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('same all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1er', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1er', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('fy');\n\n    test('parse', function (assert) {\n        var tests = 'jannewaris jan._febrewaris feb._maart mrt._april apr._maaie mai._juny jun._july jul._augustus aug._septimber sep._oktober okt._novimber nov._desimber des.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, HH:mm:ss',       'snein, febrewaris 14de 2010, 15:25:50'],\n                ['ddd, HH',                            'si., 15'],\n                ['M Mo MM MMMM MMM',                   '2 2de 02 febrewaris feb.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14de 14'],\n                ['d do dddd ddd dd',                   '0 0de snein si. Si'],\n                ['DDD DDDo DDDD',                      '45 45ste 045'],\n                ['w wo ww',                            '6 6de 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45ste day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14-02-2010'],\n                ['LL',                                 '14 febrewaris 2010'],\n                ['LLL',                                '14 febrewaris 2010 15:25'],\n                ['LLLL',                               'snein 14 febrewaris 2010 15:25'],\n                ['l',                                  '14-2-2010'],\n                ['ll',                                 '14 feb. 2010'],\n                ['lll',                                '14 feb. 2010 15:25'],\n                ['llll',                               'si. 14 feb. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ste', '1ste');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2de', '2de');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3de', '3de');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4de', '4de');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5de', '5de');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6de', '6de');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7de', '7de');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ste', '8ste');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9de', '9de');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10de', '10de');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11de', '11de');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12de', '12de');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13de', '13de');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14de', '14de');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15de', '15de');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16de', '16de');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17de', '17de');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18de', '18de');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19de', '19de');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ste', '20ste');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ste', '21ste');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ste', '22ste');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ste', '23ste');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ste', '24ste');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ste', '25ste');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ste', '26ste');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ste', '27ste');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ste', '28ste');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ste', '29ste');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ste', '30ste');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ste', '31ste');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'jannewaris jan._febrewaris feb._maart mrt._april apr._maaie mai_juny jun._july jul._augustus aug._septimber sep._oktober okt._novimber nov._desimber des.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'snein si. Si_moandei mo. Mo_tiisdei ti. Ti_woansdei wo. Wo_tongersdei to. To_freed fr. Fr_sneon so. So'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'in pear sekonden', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ien min\u00c3\u00bat',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ien min\u00c3\u00bat',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuten',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuten',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ien oere',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ien oere',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 oeren',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 oeren',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 oeren',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ien dei',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ien dei',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagen',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ien dei',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagen',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagen',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ien moanne',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ien moanne',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ien moanne',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 moannen',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 moannen',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 moannen',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ien moanne',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 moannen',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ien jier',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jierren',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ien jier',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jierren',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'oer in pear sekonden',  'prefix');\n        assert.equal(moment(0).from(30000), 'in pear sekonden lyn', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'in pear sekonden lyn',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'oer in pear sekonden', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'oer 5 dagen', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'hjoed om 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'hjoed om 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'hjoed om 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'moarn om 12:00',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'hjoed om 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juster om 12:00',    'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00c3\u00b4fr\u00c3\u00bbne] dddd [om] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00c3\u00b4fr\u00c3\u00bbne] dddd [om] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00c3\u00b4fr\u00c3\u00bbne] dddd [om] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('month abbreviation', function (assert) {\n        assert.equal(moment([2012, 5, 23]).format('D-MMM-YYYY'), '23-jun-2012', 'format month abbreviation surrounded by dashes should not include a dot');\n        assert.equal(moment([2012, 5, 23]).format('D MMM YYYY'), '23 jun. 2012', 'format month abbreviation not surrounded by dashes should include a dot');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ste', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1ste', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1ste', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),    '2 02 2de', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),    '2 02 2de', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('gd');\n\n    var months = [\n        'Am Faoilleach,Faoi',\n        'An Gearran,Gear',\n        'Am M\u00c3\u00a0rt,M\u00c3\u00a0rt',\n        'An Giblean,Gibl',\n        'An C\u00c3\u00a8itean,C\u00c3\u00a8it',\n        'An t-\u00c3\u0092gmhios,\u00c3\u0092gmh',\n        'An t-Iuchar,Iuch',\n        'An L\u00c3\u00b9nastal,L\u00c3\u00b9n',\n        'An t-Sultain,Sult',\n        'An D\u00c3\u00a0mhair,D\u00c3\u00a0mh',\n        'An t-Samhain,Samh',\n        'An D\u00c3\u00b9bhlachd,D\u00c3\u00b9bh'\n    ];\n\n    test('parse', function (assert) {\n        function equalTest(monthName, monthFormat, monthNum) {\n            assert.equal(moment(monthName, monthFormat).month(), monthNum, monthName + ' should be month ' + (monthNum + 1));\n        }\n\n        for (var i = 0; i < 12; i++) {\n            var testMonth = months[i].split(',');\n            equalTest(testMonth[0], 'MMM', i);\n            equalTest(testMonth[1], 'MMM', i);\n            equalTest(testMonth[0], 'MMMM', i);\n            equalTest(testMonth[1], 'MMMM', i);\n            equalTest(testMonth[0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(testMonth[1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(testMonth[0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(testMonth[1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n            ['dddd, MMMM Do YYYY, h:mm:ss a', 'Did\u00c3\u00b2mhnaich, An Gearran 14mh 2010, 3:25:50 pm'],\n            ['ddd, hA', 'Did, 3PM'],\n            ['M Mo MM MMMM MMM', '2 2na 02 An Gearran Gear'],\n            ['YYYY YY', '2010 10'],\n            ['D Do DD', '14 14mh 14'],\n            ['d do dddd ddd dd', '0 0mh Did\u00c3\u00b2mhnaich Did D\u00c3\u00b2'],\n            ['DDD DDDo DDDD', '45 45mh 045'],\n            ['w wo ww', '6 6mh 06'],\n            ['h hh', '3 03'],\n            ['H HH', '15 15'],\n            ['m mm', '25 25'],\n            ['s ss', '50 50'],\n            ['a A', 'pm PM'],\n            ['[an] DDDo [latha den bhliadhna]', 'an 45mh latha den bhliadhna'],\n            ['LTS', '15:25:50'],\n            ['L', '14/02/2010'],\n            ['LL', '14 An Gearran 2010'],\n            ['LLL', '14 An Gearran 2010 15:25'],\n            ['LLLL', 'Did\u00c3\u00b2mhnaich, 14 An Gearran 2010 15:25'],\n            ['l', '14/2/2010'],\n            ['ll', '14 Gear 2010'],\n            ['lll', '14 Gear 2010 15:25'],\n            ['llll', 'Did, 14 Gear 2010 15:25']\n        ],\n        b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n        i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1d', '1d');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2na', '2na');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3mh', '3mh');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4mh', '4mh');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5mh', '5mh');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6mh', '6mh');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7mh', '7mh');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8mh', '8mh');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9mh', '9mh');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10mh', '10mh');\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11mh', '11mh');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12na', '12na');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13mh', '13mh');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14mh', '14mh');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15mh', '15mh');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16mh', '16mh');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17mh', '17mh');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18mh', '18mh');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19mh', '19mh');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20mh', '20mh');\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21mh', '21mh');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22na', '22na');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23mh', '23mh');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24mh', '24mh');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25mh', '25mh');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26mh', '26mh');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27mh', '27mh');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28mh', '28mh');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29mh', '29mh');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30mh', '30mh');\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31mh', '31mh');\n    });\n\n    test('format month', function (assert) {\n        var expected = months;\n        for (var i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM,MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = ['Did\u00c3\u00b2mhnaich Did D\u00c3\u00b2', 'Diluain Dil Lu', 'Dim\u00c3\u00a0irt Dim M\u00c3\u00a0', 'Diciadain Dic Ci', 'Diardaoin Dia Ar', 'Dihaoine Dih Ha', 'Disathairne Dis Sa'];\n        for (var i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), 'beagan diogan', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), 'mionaid', '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), 'mionaid', '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 mionaidean', '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 mionaidean', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), 'uair', '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), 'uair', '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 uairean', '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 uairean', '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 uairean', '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), 'latha', '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), 'latha', '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 latha', '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), 'latha', '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 latha', '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 latha', '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), 'm\u00c3\u00acos', '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), 'm\u00c3\u00acos', '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), 'm\u00c3\u00acos', '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 m\u00c3\u00acosan', '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 m\u00c3\u00acosan', '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 m\u00c3\u00acosan', '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), 'm\u00c3\u00acos', '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 m\u00c3\u00acosan', '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'bliadhna', '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 bliadhna', '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'bliadhna', '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 bliadhna', '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'ann an beagan diogan', 'prefix');\n        assert.equal(moment(0).from(30000), 'bho chionn beagan diogan', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'bho chionn beagan diogan', 'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'ann an beagan diogan', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'ann an 5 latha', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                  'An-diugh aig 12:00',   'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),     'An-diugh aig 12:25',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),      'An-diugh aig 13:00',   'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),      'A-m\u00c3\u00a0ireach aig 12:00', 'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(), 'An-diugh aig 11:00',   'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(), 'An-d\u00c3\u00a8 aig 12:00',      'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(), m.format('dddd [aig] LT'), 'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format('dddd [aig] LT'), 'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format('dddd [aig] LT'), 'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(), m.format('dddd [seo chaidh] [aig] LT'), 'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format('dddd [seo chaidh] [aig] LT'), 'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format('dddd [seo chaidh] [aig] LT'), 'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n           weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');\n        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '52 52 52na', 'Faoi  1 2012 should be week 52');\n        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '1 01 1d', 'Faoi  2 2012 should be week 1');\n        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '1 01 1d', 'Faoi  8 2012 should be week 1');\n        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '2 02 2na', 'Faoi  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '2 02 2na', 'Faoi 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('gl');\n\n    test('parse', function (assert) {\n        var tests = 'Xaneiro Xan._Febreiro Feb._Marzo Mar._Abril Abr._Maio Mai._Xu\u00c3\u00b1o Xu\u00c3\u00b1._Xullo Xul._Agosto Ago._Setembro Set._Outubro Out._Novembro Nov._Decembro Dec.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Febreiro 14\u00c2\u00ba 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Dom., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2\u00c2\u00ba 02 Febreiro Feb.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\u00c2\u00ba 14'],\n                ['d do dddd ddd dd',                   '0 0\u00c2\u00ba Domingo Dom. Do'],\n                ['DDD DDDo DDDD',                      '45 45\u00c2\u00ba 045'],\n                ['w wo ww',                            '7 7\u00c2\u00ba 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45\u00c2\u00ba day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 Febreiro 2010'],\n                ['LLL',                                '14 Febreiro 2010 15:25'],\n                ['LLLL',                               'Domingo 14 Febreiro 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Feb. 2010'],\n                ['lll',                                '14 Feb. 2010 15:25'],\n                ['llll',                               'Dom. 14 Feb. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1\u00c2\u00ba', '1\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2\u00c2\u00ba', '2\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3\u00c2\u00ba', '3\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4\u00c2\u00ba', '4\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\u00c2\u00ba', '5\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\u00c2\u00ba', '6\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\u00c2\u00ba', '7\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\u00c2\u00ba', '8\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\u00c2\u00ba', '9\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\u00c2\u00ba', '10\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\u00c2\u00ba', '11\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\u00c2\u00ba', '12\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\u00c2\u00ba', '13\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\u00c2\u00ba', '14\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\u00c2\u00ba', '15\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\u00c2\u00ba', '16\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\u00c2\u00ba', '17\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\u00c2\u00ba', '18\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\u00c2\u00ba', '19\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\u00c2\u00ba', '20\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\u00c2\u00ba', '21\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\u00c2\u00ba', '22\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\u00c2\u00ba', '23\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\u00c2\u00ba', '24\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\u00c2\u00ba', '25\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\u00c2\u00ba', '26\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\u00c2\u00ba', '27\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\u00c2\u00ba', '28\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\u00c2\u00ba', '29\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\u00c2\u00ba', '30\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\u00c2\u00ba', '31\u00c2\u00ba');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Xaneiro Xan._Febreiro Feb._Marzo Mar._Abril Abr._Maio Mai._Xu\u00c3\u00b1o Xu\u00c3\u00b1._Xullo Xul._Agosto Ago._Setembro Set._Outubro Out._Novembro Nov._Decembro Dec.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Domingo Dom. Do_Luns Lun. Lu_Martes Mar. Ma_M\u00c3\u00a9rcores M\u00c3\u00a9r. M\u00c3\u00a9_Xoves Xov. Xo_Venres Ven. Ve_S\u00c3\u00a1bado S\u00c3\u00a1b. S\u00c3\u00a1'.split('_'),\n        i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'uns segundos', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minuto',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minuto',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'unha hora',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'unha hora',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un d\u00c3\u00ada',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un d\u00c3\u00ada',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 d\u00c3\u00adas',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un d\u00c3\u00ada',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 d\u00c3\u00adas',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 d\u00c3\u00adas',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mes',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mes',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mes',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mes',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un ano',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anos',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un ano',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anos',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'nuns segundos',  'prefix');\n        assert.equal(moment(0).from(30000), 'hai uns segundos', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'hai uns segundos',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'nuns segundos', 'en unos segundos');\n        assert.equal(moment().add({d: 5}).fromNow(), 'en 5 d\u00c3\u00adas', 'en 5 d\u00c3\u00adas');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                       'hoxe \u00c3\u00a1s 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),          'hoxe \u00c3\u00a1s 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),           'hoxe \u00c3\u00a1s 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),           'ma\u00c3\u00b1\u00c3\u00a1 \u00c3\u00a1s 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).add({d: 1, h : -1}).calendar(),   'ma\u00c3\u00b1\u00c3\u00a1 \u00c3\u00a1s 11:00',   'tomorrow minus 1 hour');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),      'hoxe \u00c3\u00a1s 11:00',   'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),      'onte \u00c3\u00a1 12:00',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [' + ((m.hours() !== 1) ? '\u00c3\u00a1s' : 'a') + '] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [' + ((m.hours() !== 1) ? '\u00c3\u00a1s' : 'a') + '] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [' + ((m.hours() !== 1) ? '\u00c3\u00a1s' : 'a') + '] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[o] dddd [pasado ' + ((m.hours() !== 1) ? '\u00c3\u00a1s' : 'a') + '] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[o] dddd [pasado ' + ((m.hours() !== 1) ? '\u00c3\u00a1s' : 'a') + '] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[o] dddd [pasado ' + ((m.hours() !== 1) ? '\u00c3\u00a1s' : 'a') + '] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('regression tests', function (assert) {\n        var lastWeek = moment().subtract({d: 4}).hours(1);\n        assert.equal(lastWeek.calendar(), lastWeek.format('[o] dddd [pasado a] LT'), '1 o\\'clock bug');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1\u00c2\u00ba', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1\u00c2\u00ba', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2\u00c2\u00ba', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2\u00c2\u00ba', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3\u00c2\u00ba', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('he');\n\n    test('parse', function (assert) {\n        var tests = '\u00d7\u0099\u00d7\u00a0\u00d7\u0095\u00d7\u0090\u00d7\u00a8 \u00d7\u0099\u00d7\u00a0\u00d7\u0095\u00d7\u00b3_\u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u0095\u00d7\u0090\u00d7\u00a8 \u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u00b3_\u00d7\u009e\u00d7\u00a8\u00d7\u00a5 \u00d7\u009e\u00d7\u00a8\u00d7\u00a5_\u00d7\u0090\u00d7\u00a4\u00d7\u00a8\u00d7\u0099\u00d7\u009c \u00d7\u0090\u00d7\u00a4\u00d7\u00a8\u00d7\u00b3_\u00d7\u009e\u00d7\u0090\u00d7\u0099 \u00d7\u009e\u00d7\u0090\u00d7\u0099_\u00d7\u0099\u00d7\u0095\u00d7\u00a0\u00d7\u0099 \u00d7\u0099\u00d7\u0095\u00d7\u00a0\u00d7\u0099_\u00d7\u0099\u00d7\u0095\u00d7\u009c\u00d7\u0099 \u00d7\u0099\u00d7\u0095\u00d7\u009c\u00d7\u0099_\u00d7\u0090\u00d7\u0095\u00d7\u0092\u00d7\u0095\u00d7\u00a1\u00d7\u0098 \u00d7\u0090\u00d7\u0095\u00d7\u0092\u00d7\u00b3_\u00d7\u00a1\u00d7\u00a4\u00d7\u0098\u00d7\u009e\u00d7\u0091\u00d7\u00a8 \u00d7\u00a1\u00d7\u00a4\u00d7\u0098\u00d7\u00b3_\u00d7\u0090\u00d7\u0095\u00d7\u00a7\u00d7\u0098\u00d7\u0095\u00d7\u0091\u00d7\u00a8 \u00d7\u0090\u00d7\u0095\u00d7\u00a7\u00d7\u00b3_\u00d7\u00a0\u00d7\u0095\u00d7\u0091\u00d7\u009e\u00d7\u0091\u00d7\u00a8 \u00d7\u00a0\u00d7\u0095\u00d7\u0091\u00d7\u00b3_\u00d7\u0093\u00d7\u00a6\u00d7\u009e\u00d7\u0091\u00d7\u00a8 \u00d7\u0093\u00d7\u00a6\u00d7\u009e\u00d7\u00b3'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      '\u00d7\u00a8\u00d7\u0090\u00d7\u00a9\u00d7\u0095\u00d7\u009f, \u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u0095\u00d7\u0090\u00d7\u00a8 14 2010, 3:25:50 \u00d7\u0090\u00d7\u0097\u00d7\u0094\"\u00d7\u00a6'],\n                ['ddd, h A',                           '\u00d7\u0090\u00d7\u00b3, 3 \u00d7\u0090\u00d7\u0097\u00d7\u00a8\u00d7\u0099 \u00d7\u0094\u00d7\u00a6\u00d7\u0094\u00d7\u00a8\u00d7\u0099\u00d7\u0099\u00d7\u009d'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 \u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u0095\u00d7\u0090\u00d7\u00a8 \u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u00b3'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 \u00d7\u00a8\u00d7\u0090\u00d7\u00a9\u00d7\u0095\u00d7\u009f \u00d7\u0090\u00d7\u00b3 \u00d7\u0090'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '8 8 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00d7\u0090\u00d7\u0097\u00d7\u0094\"\u00d7\u00a6 \u00d7\u0090\u00d7\u0097\u00d7\u00a8\u00d7\u0099 \u00d7\u0094\u00d7\u00a6\u00d7\u0094\u00d7\u00a8\u00d7\u0099\u00d7\u0099\u00d7\u009d'],\n                ['[the] DDDo [day of the year]',       'the 45 day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 \u00d7\u0091\u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u0095\u00d7\u0090\u00d7\u00a8 2010'],\n                ['LLL',                                '14 \u00d7\u0091\u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u0095\u00d7\u0090\u00d7\u00a8 2010 15:25'],\n                ['LLLL',                               '\u00d7\u00a8\u00d7\u0090\u00d7\u00a9\u00d7\u0095\u00d7\u009f, 14 \u00d7\u0091\u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u0095\u00d7\u0090\u00d7\u00a8 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 \u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u00b3 2010'],\n                ['lll',                                '14 \u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u00b3 2010 15:25'],\n                ['llll',                               '\u00d7\u0090\u00d7\u00b3, 14 \u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u00b3 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d7\u0099\u00d7\u00a0\u00d7\u0095\u00d7\u0090\u00d7\u00a8 \u00d7\u0099\u00d7\u00a0\u00d7\u0095\u00d7\u00b3_\u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u0095\u00d7\u0090\u00d7\u00a8 \u00d7\u00a4\u00d7\u0091\u00d7\u00a8\u00d7\u00b3_\u00d7\u009e\u00d7\u00a8\u00d7\u00a5 \u00d7\u009e\u00d7\u00a8\u00d7\u00a5_\u00d7\u0090\u00d7\u00a4\u00d7\u00a8\u00d7\u0099\u00d7\u009c \u00d7\u0090\u00d7\u00a4\u00d7\u00a8\u00d7\u00b3_\u00d7\u009e\u00d7\u0090\u00d7\u0099 \u00d7\u009e\u00d7\u0090\u00d7\u0099_\u00d7\u0099\u00d7\u0095\u00d7\u00a0\u00d7\u0099 \u00d7\u0099\u00d7\u0095\u00d7\u00a0\u00d7\u0099_\u00d7\u0099\u00d7\u0095\u00d7\u009c\u00d7\u0099 \u00d7\u0099\u00d7\u0095\u00d7\u009c\u00d7\u0099_\u00d7\u0090\u00d7\u0095\u00d7\u0092\u00d7\u0095\u00d7\u00a1\u00d7\u0098 \u00d7\u0090\u00d7\u0095\u00d7\u0092\u00d7\u00b3_\u00d7\u00a1\u00d7\u00a4\u00d7\u0098\u00d7\u009e\u00d7\u0091\u00d7\u00a8 \u00d7\u00a1\u00d7\u00a4\u00d7\u0098\u00d7\u00b3_\u00d7\u0090\u00d7\u0095\u00d7\u00a7\u00d7\u0098\u00d7\u0095\u00d7\u0091\u00d7\u00a8 \u00d7\u0090\u00d7\u0095\u00d7\u00a7\u00d7\u00b3_\u00d7\u00a0\u00d7\u0095\u00d7\u0091\u00d7\u009e\u00d7\u0091\u00d7\u00a8 \u00d7\u00a0\u00d7\u0095\u00d7\u0091\u00d7\u00b3_\u00d7\u0093\u00d7\u00a6\u00d7\u009e\u00d7\u0091\u00d7\u00a8 \u00d7\u0093\u00d7\u00a6\u00d7\u009e\u00d7\u00b3'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d7\u00a8\u00d7\u0090\u00d7\u00a9\u00d7\u0095\u00d7\u009f \u00d7\u0090\u00d7\u00b3 \u00d7\u0090|\u00d7\u00a9\u00d7\u00a0\u00d7\u0099 \u00d7\u0091\u00d7\u00b3 \u00d7\u0091|\u00d7\u00a9\u00d7\u009c\u00d7\u0099\u00d7\u00a9\u00d7\u0099 \u00d7\u0092\u00d7\u00b3 \u00d7\u0092|\u00d7\u00a8\u00d7\u0091\u00d7\u0099\u00d7\u00a2\u00d7\u0099 \u00d7\u0093\u00d7\u00b3 \u00d7\u0093|\u00d7\u0097\u00d7\u009e\u00d7\u0099\u00d7\u00a9\u00d7\u0099 \u00d7\u0094\u00d7\u00b3 \u00d7\u0094|\u00d7\u00a9\u00d7\u0099\u00d7\u00a9\u00d7\u0099 \u00d7\u0095\u00d7\u00b3 \u00d7\u0095|\u00d7\u00a9\u00d7\u0091\u00d7\u00aa \u00d7\u00a9\u00d7\u00b3 \u00d7\u00a9'.split('|'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d7\u009e\u00d7\u00a1\u00d7\u00a4\u00d7\u00a8 \u00d7\u00a9\u00d7\u00a0\u00d7\u0099\u00d7\u0095\u00d7\u00aa', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d7\u0093\u00d7\u00a7\u00d7\u0094',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d7\u0093\u00d7\u00a7\u00d7\u0094',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d7\u0093\u00d7\u00a7\u00d7\u0095\u00d7\u00aa',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d7\u0093\u00d7\u00a7\u00d7\u0095\u00d7\u00aa',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d7\u00a9\u00d7\u00a2\u00d7\u0094',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d7\u00a9\u00d7\u00a2\u00d7\u0094',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00d7\u00a9\u00d7\u00a2\u00d7\u00aa\u00d7\u0099\u00d7\u0099\u00d7\u009d',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d7\u00a9\u00d7\u00a2\u00d7\u0095\u00d7\u00aa',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d7\u00a9\u00d7\u00a2\u00d7\u0095\u00d7\u00aa',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d7\u0099\u00d7\u0095\u00d7\u009d',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d7\u0099\u00d7\u0095\u00d7\u009d',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00d7\u0099\u00d7\u0095\u00d7\u009e\u00d7\u0099\u00d7\u0099\u00d7\u009d',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d7\u0099\u00d7\u0095\u00d7\u009d',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d7\u0099\u00d7\u009e\u00d7\u0099\u00d7\u009d',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d7\u0099\u00d7\u009e\u00d7\u0099\u00d7\u009d',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d7\u0097\u00d7\u0095\u00d7\u0093\u00d7\u00a9',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d7\u0097\u00d7\u0095\u00d7\u0093\u00d7\u00a9',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d7\u0097\u00d7\u0095\u00d7\u0093\u00d7\u00a9',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '\u00d7\u0097\u00d7\u0095\u00d7\u0093\u00d7\u00a9\u00d7\u0099\u00d7\u0099\u00d7\u009d',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '\u00d7\u0097\u00d7\u0095\u00d7\u0093\u00d7\u00a9\u00d7\u0099\u00d7\u0099\u00d7\u009d',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d7\u0097\u00d7\u0095\u00d7\u0093\u00d7\u00a9\u00d7\u0099\u00d7\u009d',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d7\u0097\u00d7\u0095\u00d7\u0093\u00d7\u00a9',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d7\u0097\u00d7\u0095\u00d7\u0093\u00d7\u00a9\u00d7\u0099\u00d7\u009d',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d7\u00a9\u00d7\u00a0\u00d7\u0094',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00d7\u00a9\u00d7\u00a0\u00d7\u00aa\u00d7\u0099\u00d7\u0099\u00d7\u009d',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 3699}), true), '10 \u00d7\u00a9\u00d7\u00a0\u00d7\u0099\u00d7\u009d',        '345 days = 10 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 7340}), true), '20 \u00d7\u00a9\u00d7\u00a0\u00d7\u0094',       '548 days = 20 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d7\u00a9\u00d7\u00a0\u00d7\u0094',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d7\u00a9\u00d7\u00a0\u00d7\u0099\u00d7\u009d',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d7\u0091\u00d7\u00a2\u00d7\u0095\u00d7\u0093 \u00d7\u009e\u00d7\u00a1\u00d7\u00a4\u00d7\u00a8 \u00d7\u00a9\u00d7\u00a0\u00d7\u0099\u00d7\u0095\u00d7\u00aa',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00d7\u009c\u00d7\u00a4\u00d7\u00a0\u00d7\u0099 \u00d7\u009e\u00d7\u00a1\u00d7\u00a4\u00d7\u00a8 \u00d7\u00a9\u00d7\u00a0\u00d7\u0099\u00d7\u0095\u00d7\u00aa', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00d7\u009c\u00d7\u00a4\u00d7\u00a0\u00d7\u0099 \u00d7\u009e\u00d7\u00a1\u00d7\u00a4\u00d7\u00a8 \u00d7\u00a9\u00d7\u00a0\u00d7\u0099\u00d7\u0095\u00d7\u00aa',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d7\u0091\u00d7\u00a2\u00d7\u0095\u00d7\u0093 \u00d7\u009e\u00d7\u00a1\u00d7\u00a4\u00d7\u00a8 \u00d7\u00a9\u00d7\u00a0\u00d7\u0099\u00d7\u0095\u00d7\u00aa', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00d7\u0091\u00d7\u00a2\u00d7\u0095\u00d7\u0093 5 \u00d7\u0099\u00d7\u009e\u00d7\u0099\u00d7\u009d', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d7\u0094\u00d7\u0099\u00d7\u0095\u00d7\u009d \u00d7\u0091\u00d6\u00be12:00',   'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d7\u0094\u00d7\u0099\u00d7\u0095\u00d7\u009d \u00d7\u0091\u00d6\u00be12:25',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d7\u0094\u00d7\u0099\u00d7\u0095\u00d7\u009d \u00d7\u0091\u00d6\u00be13:00',   'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d7\u009e\u00d7\u0097\u00d7\u00a8 \u00d7\u0091\u00d6\u00be12:00',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d7\u0094\u00d7\u0099\u00d7\u0095\u00d7\u009d \u00d7\u0091\u00d6\u00be11:00',   'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d7\u0090\u00d7\u00aa\u00d7\u009e\u00d7\u0095\u00d7\u009c \u00d7\u0091\u00d6\u00be12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d7\u0091\u00d7\u00a9\u00d7\u00a2\u00d7\u0094] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d7\u0091\u00d7\u00a9\u00d7\u00a2\u00d7\u0094] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d7\u0091\u00d7\u00a9\u00d7\u00a2\u00d7\u0094] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00d7\u0091\u00d7\u0099\u00d7\u0095\u00d7\u009d] dddd [\u00d7\u0094\u00d7\u0090\u00d7\u0097\u00d7\u00a8\u00d7\u0095\u00d7\u009f \u00d7\u0091\u00d7\u00a9\u00d7\u00a2\u00d7\u0094] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00d7\u0091\u00d7\u0099\u00d7\u0095\u00d7\u009d] dddd [\u00d7\u0094\u00d7\u0090\u00d7\u0097\u00d7\u00a8\u00d7\u0095\u00d7\u009f \u00d7\u0091\u00d7\u00a9\u00d7\u00a2\u00d7\u0094] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00d7\u0091\u00d7\u0099\u00d7\u0095\u00d7\u009d] dddd [\u00d7\u0094\u00d7\u0090\u00d7\u0097\u00d7\u00a8\u00d7\u0095\u00d7\u009f \u00d7\u0091\u00d7\u00a9\u00d7\u00a2\u00d7\u0094] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('hi');\n\n    test('parse', function (assert) {\n        var tests = '\u00e0\u00a4\u009c\u00e0\u00a4\u00a8\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u009c\u00e0\u00a4\u00a8._\u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0._\u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u009a \u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u009a_\u00e0\u00a4\u0085\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0088\u00e0\u00a4\u00b2 \u00e0\u00a4\u0085\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0088._\u00e0\u00a4\u00ae\u00e0\u00a4\u0088 \u00e0\u00a4\u00ae\u00e0\u00a4\u0088_\u00e0\u00a4\u009c\u00e0\u00a5\u0082\u00e0\u00a4\u00a8 \u00e0\u00a4\u009c\u00e0\u00a5\u0082\u00e0\u00a4\u00a8_\u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00b2\u00e0\u00a4\u00be\u00e0\u00a4\u0088 \u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00b2._\u00e0\u00a4\u0085\u00e0\u00a4\u0097\u00e0\u00a4\u00b8\u00e0\u00a5\u008d\u00e0\u00a4\u00a4 \u00e0\u00a4\u0085\u00e0\u00a4\u0097._\u00e0\u00a4\u00b8\u00e0\u00a4\u00bf\u00e0\u00a4\u00a4\u00e0\u00a4\u00ae\u00e0\u00a5\u008d\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b8\u00e0\u00a4\u00bf\u00e0\u00a4\u00a4._\u00e0\u00a4\u0085\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u0082\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u0085\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u0082._\u00e0\u00a4\u00a8\u00e0\u00a4\u00b5\u00e0\u00a4\u00ae\u00e0\u00a5\u008d\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a8\u00e0\u00a4\u00b5._\u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00b8\u00e0\u00a4\u00ae\u00e0\u00a5\u008d\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00b8.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, a h:mm:ss \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',  '\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0, \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab:\u00e0\u00a5\u00ab\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087'],\n                ['ddd, a h \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',                       '\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf, \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a9 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087'],\n                ['M Mo MM MMMM MMM',                   '\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a8 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0.'],\n                ['YYYY YY',                            '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['D Do DD',                            '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa'],\n                ['d do dddd ddd dd',                   '\u00e0\u00a5\u00a6 \u00e0\u00a5\u00a6 \u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf \u00e0\u00a4\u00b0'],\n                ['DDD DDDo DDDD',                      '\u00e0\u00a5\u00aa\u00e0\u00a5\u00ab \u00e0\u00a5\u00aa\u00e0\u00a5\u00ab \u00e0\u00a5\u00a6\u00e0\u00a5\u00aa\u00e0\u00a5\u00ab'],\n                ['w wo ww',                            '\u00e0\u00a5\u00ae \u00e0\u00a5\u00ae \u00e0\u00a5\u00a6\u00e0\u00a5\u00ae'],\n                ['h hh',                               '\u00e0\u00a5\u00a9 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a9'],\n                ['H HH',                               '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ab \u00e0\u00a5\u00a7\u00e0\u00a5\u00ab'],\n                ['m mm',                               '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a5\u00a8\u00e0\u00a5\u00ab'],\n                ['s ss',                               '\u00e0\u00a5\u00ab\u00e0\u00a5\u00a6 \u00e0\u00a5\u00ab\u00e0\u00a5\u00a6'],\n                ['a A',                                '\u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0'],\n                ['LTS',                                '\u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab:\u00e0\u00a5\u00ab\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087'],\n                ['L',                                  '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa/\u00e0\u00a5\u00a6\u00e0\u00a5\u00a8/\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['LL',                                 '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['LLL',                                '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087'],\n                ['LLLL',                               '\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0, \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087'],\n                ['l',                                  '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa/\u00e0\u00a5\u00a8/\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['ll',                                 '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0. \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['lll',                                '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0. \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087'],\n                ['llll',                               '\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf, \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0. \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '\u00e0\u00a5\u00a7', '\u00e0\u00a5\u00a7');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '\u00e0\u00a5\u00a8', '\u00e0\u00a5\u00a8');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '\u00e0\u00a5\u00a9', '\u00e0\u00a5\u00a9');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '\u00e0\u00a5\u00aa', '\u00e0\u00a5\u00aa');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '\u00e0\u00a5\u00ab', '\u00e0\u00a5\u00ab');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '\u00e0\u00a5\u00ac', '\u00e0\u00a5\u00ac');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '\u00e0\u00a5\u00ad', '\u00e0\u00a5\u00ad');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '\u00e0\u00a5\u00ae', '\u00e0\u00a5\u00ae');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '\u00e0\u00a5\u00af', '\u00e0\u00a5\u00af');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a7', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a7');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a8', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a8');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a9', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a9');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ab', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ab');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ac', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ac');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ad', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ad');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ae', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ae');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00af', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00af');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a7', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a7');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a8', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a8');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a9', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a9');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00aa', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00aa');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ac', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ac');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ad', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ad');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ae', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ae');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00af', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00af');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '\u00e0\u00a5\u00a9\u00e0\u00a5\u00a6', '\u00e0\u00a5\u00a9\u00e0\u00a5\u00a6');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '\u00e0\u00a5\u00a9\u00e0\u00a5\u00a7', '\u00e0\u00a5\u00a9\u00e0\u00a5\u00a7');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e0\u00a4\u009c\u00e0\u00a4\u00a8\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u009c\u00e0\u00a4\u00a8._\u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u00ab\u00e0\u00a4\u00bc\u00e0\u00a4\u00b0._\u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u009a \u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u009a_\u00e0\u00a4\u0085\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0088\u00e0\u00a4\u00b2 \u00e0\u00a4\u0085\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0088._\u00e0\u00a4\u00ae\u00e0\u00a4\u0088 \u00e0\u00a4\u00ae\u00e0\u00a4\u0088_\u00e0\u00a4\u009c\u00e0\u00a5\u0082\u00e0\u00a4\u00a8 \u00e0\u00a4\u009c\u00e0\u00a5\u0082\u00e0\u00a4\u00a8_\u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00b2\u00e0\u00a4\u00be\u00e0\u00a4\u0088 \u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00b2._\u00e0\u00a4\u0085\u00e0\u00a4\u0097\u00e0\u00a4\u00b8\u00e0\u00a5\u008d\u00e0\u00a4\u00a4 \u00e0\u00a4\u0085\u00e0\u00a4\u0097._\u00e0\u00a4\u00b8\u00e0\u00a4\u00bf\u00e0\u00a4\u00a4\u00e0\u00a4\u00ae\u00e0\u00a5\u008d\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b8\u00e0\u00a4\u00bf\u00e0\u00a4\u00a4._\u00e0\u00a4\u0085\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u0082\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u0085\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u0082._\u00e0\u00a4\u00a8\u00e0\u00a4\u00b5\u00e0\u00a4\u00ae\u00e0\u00a5\u008d\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a8\u00e0\u00a4\u00b5._\u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00b8\u00e0\u00a4\u00ae\u00e0\u00a5\u008d\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00b8.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf \u00e0\u00a4\u00b0_\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u00ae\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u00ae \u00e0\u00a4\u00b8\u00e0\u00a5\u008b_\u00e0\u00a4\u00ae\u00e0\u00a4\u0082\u00e0\u00a4\u0097\u00e0\u00a4\u00b2\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00ae\u00e0\u00a4\u0082\u00e0\u00a4\u0097\u00e0\u00a4\u00b2 \u00e0\u00a4\u00ae\u00e0\u00a4\u0082_\u00e0\u00a4\u00ac\u00e0\u00a5\u0081\u00e0\u00a4\u00a7\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00ac\u00e0\u00a5\u0081\u00e0\u00a4\u00a7 \u00e0\u00a4\u00ac\u00e0\u00a5\u0081_\u00e0\u00a4\u0097\u00e0\u00a5\u0081\u00e0\u00a4\u00b0\u00e0\u00a5\u0082\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u0097\u00e0\u00a5\u0081\u00e0\u00a4\u00b0\u00e0\u00a5\u0082 \u00e0\u00a4\u0097\u00e0\u00a5\u0081_\u00e0\u00a4\u00b6\u00e0\u00a5\u0081\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b6\u00e0\u00a5\u0081\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b6\u00e0\u00a5\u0081_\u00e0\u00a4\u00b6\u00e0\u00a4\u00a8\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b6\u00e0\u00a4\u00a8\u00e0\u00a4\u00bf \u00e0\u00a4\u00b6'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e0\u00a4\u0095\u00e0\u00a5\u0081\u00e0\u00a4\u009b \u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a4\u00a3', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u009f',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u009f',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ae\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u009f',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '\u00e0\u00a5\u00aa\u00e0\u00a5\u00aa \u00e0\u00a4\u00ae\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u009f',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u0098\u00e0\u00a4\u0082\u00e0\u00a4\u009f\u00e0\u00a4\u00be',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u0098\u00e0\u00a4\u0082\u00e0\u00a4\u009f\u00e0\u00a4\u00be',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u0098\u00e0\u00a4\u0082\u00e0\u00a4\u009f\u00e0\u00a5\u0087',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '\u00e0\u00a5\u00ab \u00e0\u00a4\u0098\u00e0\u00a4\u0082\u00e0\u00a4\u009f\u00e0\u00a5\u0087',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a7 \u00e0\u00a4\u0098\u00e0\u00a4\u0082\u00e0\u00a4\u009f\u00e0\u00a5\u0087',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '\u00e0\u00a5\u00ab \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a5\u0080\u00e0\u00a4\u00a8\u00e0\u00a5\u0087',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a5\u0080\u00e0\u00a4\u00a8\u00e0\u00a5\u0087',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a5\u0080\u00e0\u00a4\u00a8\u00e0\u00a5\u0087',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a5\u0080\u00e0\u00a4\u00a8\u00e0\u00a5\u0087',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a5\u0080\u00e0\u00a4\u00a8\u00e0\u00a5\u0087',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '\u00e0\u00a5\u00a9 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a5\u0080\u00e0\u00a4\u00a8\u00e0\u00a5\u0087',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a5\u0080\u00e0\u00a4\u00a8\u00e0\u00a5\u0087',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '\u00e0\u00a5\u00ab \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a5\u0080\u00e0\u00a4\u00a8\u00e0\u00a5\u0087',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b7',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b7',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b7',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '\u00e0\u00a5\u00ab \u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b7',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e0\u00a4\u0095\u00e0\u00a5\u0081\u00e0\u00a4\u009b \u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a4\u00a3 \u00e0\u00a4\u00ae\u00e0\u00a5\u0087\u00e0\u00a4\u0082',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e0\u00a4\u0095\u00e0\u00a5\u0081\u00e0\u00a4\u009b \u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a4\u00a3 \u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b2\u00e0\u00a5\u0087', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e0\u00a4\u0095\u00e0\u00a5\u0081\u00e0\u00a4\u009b \u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a4\u00a3 \u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b2\u00e0\u00a5\u0087',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e0\u00a4\u0095\u00e0\u00a5\u0081\u00e0\u00a4\u009b \u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a4\u00a3 \u00e0\u00a4\u00ae\u00e0\u00a5\u0087\u00e0\u00a4\u0082', '\u00e0\u00a4\u0095\u00e0\u00a5\u0081\u00e0\u00a4\u009b \u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a4\u00a3 \u00e0\u00a4\u00ae\u00e0\u00a5\u0087\u00e0\u00a4\u0082');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00e0\u00a5\u00ab \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8 \u00e0\u00a4\u00ae\u00e0\u00a5\u0087\u00e0\u00a4\u0082', '\u00e0\u00a5\u00ab \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8 \u00e0\u00a4\u00ae\u00e0\u00a5\u0087\u00e0\u00a4\u0082');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e0\u00a4\u0086\u00e0\u00a4\u009c \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a8:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e0\u00a4\u0086\u00e0\u00a4\u009c \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a8:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 3}).calendar(),       '\u00e0\u00a4\u0086\u00e0\u00a4\u009c \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',     'Now plus 3 hours');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e0\u00a4\u0095\u00e0\u00a4\u00b2 \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a8:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',    'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e0\u00a4\u0086\u00e0\u00a4\u009c \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a7:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e0\u00a4\u0095\u00e0\u00a4\u00b2 \u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a8:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',    'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a4\u00aa\u00e0\u00a4\u00bf\u00e0\u00a4\u009b\u00e0\u00a4\u00b2\u00e0\u00a5\u0087] dddd[,] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a4\u00aa\u00e0\u00a4\u00bf\u00e0\u00a4\u009b\u00e0\u00a4\u00b2\u00e0\u00a5\u0087] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a4\u00aa\u00e0\u00a4\u00bf\u00e0\u00a4\u009b\u00e0\u00a4\u00b2\u00e0\u00a5\u0087] dddd[,] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('meridiem', function (assert) {\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '\u00e0\u00a4\u00b0\u00e0\u00a4\u00be\u00e0\u00a4\u00a4', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '\u00e0\u00a4\u00b8\u00e0\u00a5\u0081\u00e0\u00a4\u00ac\u00e0\u00a4\u00b9', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '\u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0', 'during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '\u00e0\u00a4\u00b6\u00e0\u00a4\u00be\u00e0\u00a4\u00ae', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '\u00e0\u00a4\u00b6\u00e0\u00a4\u00be\u00e0\u00a4\u00ae', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '\u00e0\u00a4\u00b0\u00e0\u00a4\u00be\u00e0\u00a4\u00a4', 'night');\n\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '\u00e0\u00a4\u00b0\u00e0\u00a4\u00be\u00e0\u00a4\u00a4', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '\u00e0\u00a4\u00b8\u00e0\u00a5\u0081\u00e0\u00a4\u00ac\u00e0\u00a4\u00b9', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '\u00e0\u00a4\u00a6\u00e0\u00a5\u008b\u00e0\u00a4\u00aa\u00e0\u00a4\u00b9\u00e0\u00a4\u00b0', ' during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '\u00e0\u00a4\u00b6\u00e0\u00a4\u00be\u00e0\u00a4\u00ae', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '\u00e0\u00a4\u00b6\u00e0\u00a4\u00be\u00e0\u00a4\u00ae', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '\u00e0\u00a4\u00b0\u00e0\u00a4\u00be\u00e0\u00a4\u00a4', 'night');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '\u00e0\u00a5\u00a7 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a7 \u00e0\u00a5\u00a7', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '\u00e0\u00a5\u00a7 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a7 \u00e0\u00a5\u00a7', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a8', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a8', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '\u00e0\u00a5\u00a9 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a9 \u00e0\u00a5\u00a9', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('hr');\n\n    test('parse', function (assert) {\n        var tests = 'sije\u00c4\u008danj sij._velja\u00c4\u008da velj._o\u00c5\u00beujak o\u00c5\u00beu._travanj tra._svibanj svi._lipanj lip._srpanj srp._kolovoz kol._rujan ruj._listopad lis._studeni stu._prosinac pro.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedjelja, 14. velja\u00c4\u008de 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'ned., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 velja\u00c4\u008da velj.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. nedjelja ned. ne'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '7 7. 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14. 02. 2010'],\n                ['LL',                                 '14. velja\u00c4\u008da 2010'],\n                ['LLL',                                '14. velja\u00c4\u008da 2010 15:25'],\n                ['LLLL',                               'nedjelja, 14. velja\u00c4\u008da 2010 15:25'],\n                ['l',                                  '14. 2. 2010'],\n                ['ll',                                 '14. velj. 2010'],\n                ['lll',                                '14. velj. 2010 15:25'],\n                ['llll',                               'ned., 14. velj. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'sije\u00c4\u008danj sij._velja\u00c4\u008da velj._o\u00c5\u00beujak o\u00c5\u00beu._travanj tra._svibanj svi._lipanj lip._srpanj srp._kolovoz kol._rujan ruj._listopad lis._studeni stu._prosinac pro.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'nedjelja ned. ne_ponedjeljak pon. po_utorak uto. ut_srijeda sri. sr_\u00c4\u008detvrtak \u00c4\u008det. \u00c4\u008de_petak pet. pe_subota sub. su'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'par sekundi', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedna minuta',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedna minuta',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mjesec',     '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mjesec',     '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mjesec',     '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mjeseca',     '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mjeseca',     '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mjeseca',     '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mjesec',     '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mjeseci',    '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'za par sekundi',  'prefix');\n        assert.equal(moment(0).from(30000), 'prije par sekundi', 'prefix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'prije par sekundi',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'za par sekundi', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'danas u 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'sutra u 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ju\u00c4\u008der u 12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n                return '[u] [nedjelju] [u] LT';\n            case 3:\n                return '[u] [srijedu] [u] LT';\n            case 6:\n                return '[u] [subotu] [u] LT';\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n                return '[u] dddd [u] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n            case 3:\n                return '[pro\u00c5\u00a1lu] dddd [u] LT';\n            case 6:\n                return '[pro\u00c5\u00a1le] [subote] [u] LT';\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n                return '[pro\u00c5\u00a1li] dddd [u] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('hu');\n\n    test('parse', function (assert) {\n        var tests = 'janu\u00c3\u00a1r jan_febru\u00c3\u00a1r feb_m\u00c3\u00a1rcius m\u00c3\u00a1rc_\u00c3\u00a1prilis \u00c3\u00a1pr_m\u00c3\u00a1jus m\u00c3\u00a1j_j\u00c3\u00banius j\u00c3\u00ban_j\u00c3\u00balius j\u00c3\u00bal_augusztus aug_szeptember szept_okt\u00c3\u00b3ber okt_november nov_december dec'.split('_'),\n            i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, HH:mm:ss',      'vas\u00c3\u00a1rnap, febru\u00c3\u00a1r 14. 2010, 15:25:50'],\n                ['ddd, HH',                            'vas, 15'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 febru\u00c3\u00a1r feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. vas\u00c3\u00a1rnap vas v'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '7 7. 07'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['[az \u00c3\u00a9v] DDDo [napja]',               'az \u00c3\u00a9v 45. napja'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '2010.02.14.'],\n                ['LL',                                 '2010. febru\u00c3\u00a1r 14.'],\n                ['LLL',                                '2010. febru\u00c3\u00a1r 14. 15:25'],\n                ['LLLL',                               '2010. febru\u00c3\u00a1r 14., vas\u00c3\u00a1rnap 15:25'],\n                ['l',                                  '2010.2.14.'],\n                ['ll',                                 '2010. feb 14.'],\n                ['lll',                                '2010. feb 14. 15:25'],\n                ['llll',                               '2010. feb 14., vas 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('meridiem', function (assert) {\n        assert.equal(moment([2011, 2, 23,  0,  0]).format('a'), 'de', 'am');\n        assert.equal(moment([2011, 2, 23, 11, 59]).format('a'), 'de', 'am');\n        assert.equal(moment([2011, 2, 23, 12,  0]).format('a'), 'du', 'pm');\n        assert.equal(moment([2011, 2, 23, 23, 59]).format('a'), 'du', 'pm');\n\n        assert.equal(moment([2011, 2, 23,  0,  0]).format('A'), 'DE', 'AM');\n        assert.equal(moment([2011, 2, 23, 11, 59]).format('A'), 'DE', 'AM');\n        assert.equal(moment([2011, 2, 23, 12,  0]).format('A'), 'DU', 'PM');\n        assert.equal(moment([2011, 2, 23, 23, 59]).format('A'), 'DU', 'PM');\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'janu\u00c3\u00a1r jan_febru\u00c3\u00a1r feb_m\u00c3\u00a1rcius m\u00c3\u00a1rc_\u00c3\u00a1prilis \u00c3\u00a1pr_m\u00c3\u00a1jus m\u00c3\u00a1j_j\u00c3\u00banius j\u00c3\u00ban_j\u00c3\u00balius j\u00c3\u00bal_augusztus aug_szeptember szept_okt\u00c3\u00b3ber okt_november nov_december dec'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'vas\u00c3\u00a1rnap vas_h\u00c3\u00a9tf\u00c5\u0091 h\u00c3\u00a9t_kedd kedd_szerda sze_cs\u00c3\u00bct\u00c3\u00b6rt\u00c3\u00b6k cs\u00c3\u00bct_p\u00c3\u00a9ntek p\u00c3\u00a9n_szombat szo'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'n\u00c3\u00a9h\u00c3\u00a1ny m\u00c3\u00a1sodperc', '44 m\u00c3\u00a1sodperc = n\u00c3\u00a9h\u00c3\u00a1ny m\u00c3\u00a1sodperc');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'egy perc',         '45 m\u00c3\u00a1sodperc = egy perc');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'egy perc',         '89 m\u00c3\u00a1sodperc = egy perc');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 perc',           '90 m\u00c3\u00a1sodperc = 2 perc');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 perc',          '44 perc = 44 perc');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'egy \u00c3\u00b3ra',          '45 perc = egy \u00c3\u00b3ra');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'egy \u00c3\u00b3ra',          '89 perc = egy \u00c3\u00b3ra');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00c3\u00b3ra',            '90 perc = 2 \u00c3\u00b3ra');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00c3\u00b3ra',            '5 \u00c3\u00b3ra = 5 \u00c3\u00b3ra');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00c3\u00b3ra',           '21 \u00c3\u00b3ra = 21 \u00c3\u00b3ra');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'egy nap',          '22 \u00c3\u00b3ra = egy nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'egy nap',          '35 \u00c3\u00b3ra = egy nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 nap',            '36 \u00c3\u00b3ra = 2 nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'egy nap',          '1 nap = egy nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 nap',            '5 nap = 5 nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 nap',           '25 nap = 25 nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'egy h\u00c3\u00b3nap',        '26 nap = egy h\u00c3\u00b3nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'egy h\u00c3\u00b3nap',        '30 nap = egy h\u00c3\u00b3nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'egy h\u00c3\u00b3nap',        '45 nap = egy h\u00c3\u00b3nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 h\u00c3\u00b3nap',          '46 nap = 2 h\u00c3\u00b3nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 h\u00c3\u00b3nap',          '75 nap = 2 h\u00c3\u00b3nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 h\u00c3\u00b3nap',          '76 nap = 3 h\u00c3\u00b3nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'egy h\u00c3\u00b3nap',        '1 h\u00c3\u00b3nap = egy h\u00c3\u00b3nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 h\u00c3\u00b3nap',          '5 h\u00c3\u00b3nap = 5 h\u00c3\u00b3nap');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'egy \u00c3\u00a9v',           '345 nap = egy \u00c3\u00a9v');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00c3\u00a9v',             '548 nap = 2 \u00c3\u00a9v');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'egy \u00c3\u00a9v',           '1 \u00c3\u00a9v = egy \u00c3\u00a9v');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00c3\u00a9v',             '5 \u00c3\u00a9v = 5 \u00c3\u00a9v');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'n\u00c3\u00a9h\u00c3\u00a1ny m\u00c3\u00a1sodperc m\u00c3\u00balva',  'prefix');\n        assert.equal(moment(0).from(30000), 'n\u00c3\u00a9h\u00c3\u00a1ny m\u00c3\u00a1sodperce', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'n\u00c3\u00a9h\u00c3\u00a1ny m\u00c3\u00a1sodperce',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'n\u00c3\u00a9h\u00c3\u00a1ny m\u00c3\u00a1sodperc m\u00c3\u00balva', 'n\u00c3\u00a9h\u00c3\u00a1ny m\u00c3\u00a1sodperc m\u00c3\u00balva');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 nap m\u00c3\u00balva', '5 nap m\u00c3\u00balva');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'ma 12:00-kor',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'ma 12:25-kor',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'ma 13:00-kor',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'holnap 12:00-kor', 'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ma 11:00-kor',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'tegnap 12:00-kor', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m, days = 'vas\u00c3\u00a1rnap_h\u00c3\u00a9tf\u00c5\u0091n_kedden_szerd\u00c3\u00a1n_cs\u00c3\u00bct\u00c3\u00b6rt\u00c3\u00b6k\u00c3\u00b6n_p\u00c3\u00a9nteken_szombaton'.split('_');\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[' + days[m.day()] + '] LT[-kor]'),  'today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[' + days[m.day()] + '] LT[-kor]'),  'today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[' + days[m.day()] + '] LT[-kor]'),  'today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m, days = 'vas\u00c3\u00a1rnap_h\u00c3\u00a9tf\u00c5\u0091n_kedden_szerd\u00c3\u00a1n_cs\u00c3\u00bct\u00c3\u00b6rt\u00c3\u00b6k\u00c3\u00b6n_p\u00c3\u00a9nteken_szombaton'.split('_');\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[m\u00c3\u00balt ' + days[m.day()] + '] LT[-kor]'),  'today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[m\u00c3\u00balt ' + days[m.day()] + '] LT[-kor]'),  'today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[m\u00c3\u00balt ' + days[m.day()] + '] LT[-kor]'),  'today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'egy h\u00c3\u00a9te');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'egy h\u00c3\u00a9t m\u00c3\u00balva');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 hete');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '2 h\u00c3\u00a9t m\u00c3\u00balva');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('hy-am');\n\n    test('parse', function (assert) {\n        var tests = '\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00b6\u00d5\u00be\u00d5\u00a1\u00d6\u0080 \u00d5\u00b0\u00d5\u00b6\u00d5\u00be_\u00d6\u0083\u00d5\u00a5\u00d5\u00bf\u00d6\u0080\u00d5\u00be\u00d5\u00a1\u00d6\u0080 \u00d6\u0083\u00d5\u00bf\u00d6\u0080_\u00d5\u00b4\u00d5\u00a1\u00d6\u0080\u00d5\u00bf \u00d5\u00b4\u00d6\u0080\u00d5\u00bf_\u00d5\u00a1\u00d5\u00ba\u00d6\u0080\u00d5\u00ab\u00d5\u00ac \u00d5\u00a1\u00d5\u00ba\u00d6\u0080_\u00d5\u00b4\u00d5\u00a1\u00d5\u00b5\u00d5\u00ab\u00d5\u00bd \u00d5\u00b4\u00d5\u00b5\u00d5\u00bd_\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00b6\u00d5\u00ab\u00d5\u00bd \u00d5\u00b0\u00d5\u00b6\u00d5\u00bd_\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00ac\u00d5\u00ab\u00d5\u00bd \u00d5\u00b0\u00d5\u00ac\u00d5\u00bd_\u00d6\u0085\u00d5\u00a3\u00d5\u00b8\u00d5\u00bd\u00d5\u00bf\u00d5\u00b8\u00d5\u00bd \u00d6\u0085\u00d5\u00a3\u00d5\u00bd_\u00d5\u00bd\u00d5\u00a5\u00d5\u00ba\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080 \u00d5\u00bd\u00d5\u00ba\u00d5\u00bf_\u00d5\u00b0\u00d5\u00b8\u00d5\u00af\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080 \u00d5\u00b0\u00d5\u00af\u00d5\u00bf_\u00d5\u00b6\u00d5\u00b8\u00d5\u00b5\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080 \u00d5\u00b6\u00d5\u00b4\u00d5\u00a2_\u00d5\u00a4\u00d5\u00a5\u00d5\u00af\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080 \u00d5\u00a4\u00d5\u00af\u00d5\u00bf'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('parse exceptional case', function (assert) {\n        assert.equal(moment('11 \u00d5\u00b4\u00d5\u00a1\u00d5\u00b5\u00d5\u00ab\u00d5\u00bd\u00d5\u00ab 1989', ['DD MMMM YYYY']).format('DD-MM-YYYY'), '11-05-1989');\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, HH:mm:ss',       '\u00d5\u00af\u00d5\u00ab\u00d6\u0080\u00d5\u00a1\u00d5\u00af\u00d5\u00ab, 14 \u00d6\u0083\u00d5\u00a5\u00d5\u00bf\u00d6\u0080\u00d5\u00be\u00d5\u00a1\u00d6\u0080\u00d5\u00ab 2010, 15:25:50'],\n                ['ddd, h A',                           '\u00d5\u00af\u00d6\u0080\u00d5\u00af, 3 \u00d6\u0081\u00d5\u00a5\u00d6\u0080\u00d5\u00a5\u00d5\u00af\u00d5\u00be\u00d5\u00a1'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 \u00d6\u0083\u00d5\u00a5\u00d5\u00bf\u00d6\u0080\u00d5\u00be\u00d5\u00a1\u00d6\u0080 \u00d6\u0083\u00d5\u00bf\u00d6\u0080'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 \u00d5\u00af\u00d5\u00ab\u00d6\u0080\u00d5\u00a1\u00d5\u00af\u00d5\u00ab \u00d5\u00af\u00d6\u0080\u00d5\u00af \u00d5\u00af\u00d6\u0080\u00d5\u00af'],\n                ['DDD DDDo DDDD',                      '45 45-\u00d6\u0080\u00d5\u00a4 045'],\n                ['w wo ww',                            '7 7-\u00d6\u0080\u00d5\u00a4 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00d6\u0081\u00d5\u00a5\u00d6\u0080\u00d5\u00a5\u00d5\u00af\u00d5\u00be\u00d5\u00a1 \u00d6\u0081\u00d5\u00a5\u00d6\u0080\u00d5\u00a5\u00d5\u00af\u00d5\u00be\u00d5\u00a1'],\n                ['[\u00d5\u00bf\u00d5\u00a1\u00d6\u0080\u00d5\u00be\u00d5\u00a1] DDDo [\u00d6\u0085\u00d6\u0080\u00d5\u00a8]',                 '\u00d5\u00bf\u00d5\u00a1\u00d6\u0080\u00d5\u00be\u00d5\u00a1 45-\u00d6\u0080\u00d5\u00a4 \u00d6\u0085\u00d6\u0080\u00d5\u00a8'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 \u00d6\u0083\u00d5\u00a5\u00d5\u00bf\u00d6\u0080\u00d5\u00be\u00d5\u00a1\u00d6\u0080\u00d5\u00ab 2010 \u00d5\u00a9.'],\n                ['LLL',                                '14 \u00d6\u0083\u00d5\u00a5\u00d5\u00bf\u00d6\u0080\u00d5\u00be\u00d5\u00a1\u00d6\u0080\u00d5\u00ab 2010 \u00d5\u00a9., 15:25'],\n                ['LLLL',                               '\u00d5\u00af\u00d5\u00ab\u00d6\u0080\u00d5\u00a1\u00d5\u00af\u00d5\u00ab, 14 \u00d6\u0083\u00d5\u00a5\u00d5\u00bf\u00d6\u0080\u00d5\u00be\u00d5\u00a1\u00d6\u0080\u00d5\u00ab 2010 \u00d5\u00a9., 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 \u00d6\u0083\u00d5\u00bf\u00d6\u0080 2010 \u00d5\u00a9.'],\n                ['lll',                                '14 \u00d6\u0083\u00d5\u00bf\u00d6\u0080 2010 \u00d5\u00a9., 15:25'],\n                ['llll',                               '\u00d5\u00af\u00d6\u0080\u00d5\u00af, 14 \u00d6\u0083\u00d5\u00bf\u00d6\u0080 2010 \u00d5\u00a9., 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format meridiem', function (assert) {\n        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), '\u00d5\u00a3\u00d5\u00ab\u00d5\u00b7\u00d5\u00a5\u00d6\u0080\u00d5\u00be\u00d5\u00a1', 'night');\n        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), '\u00d5\u00a3\u00d5\u00ab\u00d5\u00b7\u00d5\u00a5\u00d6\u0080\u00d5\u00be\u00d5\u00a1', 'night');\n        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), '\u00d5\u00a1\u00d5\u00bc\u00d5\u00a1\u00d5\u00be\u00d5\u00b8\u00d5\u00bf\u00d5\u00be\u00d5\u00a1', 'morning');\n        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), '\u00d5\u00a1\u00d5\u00bc\u00d5\u00a1\u00d5\u00be\u00d5\u00b8\u00d5\u00bf\u00d5\u00be\u00d5\u00a1', 'morning');\n        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), '\u00d6\u0081\u00d5\u00a5\u00d6\u0080\u00d5\u00a5\u00d5\u00af\u00d5\u00be\u00d5\u00a1', 'afternoon');\n        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), '\u00d6\u0081\u00d5\u00a5\u00d6\u0080\u00d5\u00a5\u00d5\u00af\u00d5\u00be\u00d5\u00a1', 'afternoon');\n        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), '\u00d5\u00a5\u00d6\u0080\u00d5\u00a5\u00d5\u00af\u00d5\u00b8\u00d5\u00b5\u00d5\u00a1\u00d5\u00b6', 'evening');\n        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), '\u00d5\u00a5\u00d6\u0080\u00d5\u00a5\u00d5\u00af\u00d5\u00b8\u00d5\u00b5\u00d5\u00a1\u00d5\u00b6', 'evening');\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-\u00d5\u00ab\u00d5\u00b6', '1-\u00d5\u00ab\u00d5\u00b6');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-\u00d6\u0080\u00d5\u00a4', '2-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-\u00d6\u0080\u00d5\u00a4', '3-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-\u00d6\u0080\u00d5\u00a4', '4-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-\u00d6\u0080\u00d5\u00a4', '5-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-\u00d6\u0080\u00d5\u00a4', '6-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-\u00d6\u0080\u00d5\u00a4', '7-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-\u00d6\u0080\u00d5\u00a4', '8-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-\u00d6\u0080\u00d5\u00a4', '9-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-\u00d6\u0080\u00d5\u00a4', '10-\u00d6\u0080\u00d5\u00a4');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-\u00d6\u0080\u00d5\u00a4', '11-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-\u00d6\u0080\u00d5\u00a4', '12-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-\u00d6\u0080\u00d5\u00a4', '13-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-\u00d6\u0080\u00d5\u00a4', '14-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-\u00d6\u0080\u00d5\u00a4', '15-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-\u00d6\u0080\u00d5\u00a4', '16-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-\u00d6\u0080\u00d5\u00a4', '17-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-\u00d6\u0080\u00d5\u00a4', '18-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-\u00d6\u0080\u00d5\u00a4', '19-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-\u00d6\u0080\u00d5\u00a4', '20-\u00d6\u0080\u00d5\u00a4');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-\u00d6\u0080\u00d5\u00a4', '21-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-\u00d6\u0080\u00d5\u00a4', '22-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-\u00d6\u0080\u00d5\u00a4', '23-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-\u00d6\u0080\u00d5\u00a4', '24-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-\u00d6\u0080\u00d5\u00a4', '25-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-\u00d6\u0080\u00d5\u00a4', '26-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-\u00d6\u0080\u00d5\u00a4', '27-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-\u00d6\u0080\u00d5\u00a4', '28-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-\u00d6\u0080\u00d5\u00a4', '29-\u00d6\u0080\u00d5\u00a4');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-\u00d6\u0080\u00d5\u00a4', '30-\u00d6\u0080\u00d5\u00a4');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-\u00d6\u0080\u00d5\u00a4', '31-\u00d6\u0080\u00d5\u00a4');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00b6\u00d5\u00be\u00d5\u00a1\u00d6\u0080 \u00d5\u00b0\u00d5\u00b6\u00d5\u00be_\u00d6\u0083\u00d5\u00a5\u00d5\u00bf\u00d6\u0080\u00d5\u00be\u00d5\u00a1\u00d6\u0080 \u00d6\u0083\u00d5\u00bf\u00d6\u0080_\u00d5\u00b4\u00d5\u00a1\u00d6\u0080\u00d5\u00bf \u00d5\u00b4\u00d6\u0080\u00d5\u00bf_\u00d5\u00a1\u00d5\u00ba\u00d6\u0080\u00d5\u00ab\u00d5\u00ac \u00d5\u00a1\u00d5\u00ba\u00d6\u0080_\u00d5\u00b4\u00d5\u00a1\u00d5\u00b5\u00d5\u00ab\u00d5\u00bd \u00d5\u00b4\u00d5\u00b5\u00d5\u00bd_\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00b6\u00d5\u00ab\u00d5\u00bd \u00d5\u00b0\u00d5\u00b6\u00d5\u00bd_\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00ac\u00d5\u00ab\u00d5\u00bd \u00d5\u00b0\u00d5\u00ac\u00d5\u00bd_\u00d6\u0085\u00d5\u00a3\u00d5\u00b8\u00d5\u00bd\u00d5\u00bf\u00d5\u00b8\u00d5\u00bd \u00d6\u0085\u00d5\u00a3\u00d5\u00bd_\u00d5\u00bd\u00d5\u00a5\u00d5\u00ba\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080 \u00d5\u00bd\u00d5\u00ba\u00d5\u00bf_\u00d5\u00b0\u00d5\u00b8\u00d5\u00af\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080 \u00d5\u00b0\u00d5\u00af\u00d5\u00bf_\u00d5\u00b6\u00d5\u00b8\u00d5\u00b5\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080 \u00d5\u00b6\u00d5\u00b4\u00d5\u00a2_\u00d5\u00a4\u00d5\u00a5\u00d5\u00af\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080 \u00d5\u00a4\u00d5\u00af\u00d5\u00bf'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format month case', function (assert) {\n        var months = {\n            'nominative': '\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00b6\u00d5\u00be\u00d5\u00a1\u00d6\u0080_\u00d6\u0083\u00d5\u00a5\u00d5\u00bf\u00d6\u0080\u00d5\u00be\u00d5\u00a1\u00d6\u0080_\u00d5\u00b4\u00d5\u00a1\u00d6\u0080\u00d5\u00bf_\u00d5\u00a1\u00d5\u00ba\u00d6\u0080\u00d5\u00ab\u00d5\u00ac_\u00d5\u00b4\u00d5\u00a1\u00d5\u00b5\u00d5\u00ab\u00d5\u00bd_\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00b6\u00d5\u00ab\u00d5\u00bd_\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00ac\u00d5\u00ab\u00d5\u00bd_\u00d6\u0085\u00d5\u00a3\u00d5\u00b8\u00d5\u00bd\u00d5\u00bf\u00d5\u00b8\u00d5\u00bd_\u00d5\u00bd\u00d5\u00a5\u00d5\u00ba\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080_\u00d5\u00b0\u00d5\u00b8\u00d5\u00af\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080_\u00d5\u00b6\u00d5\u00b8\u00d5\u00b5\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080_\u00d5\u00a4\u00d5\u00a5\u00d5\u00af\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080'.split('_'),\n            'accusative': '\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00b6\u00d5\u00be\u00d5\u00a1\u00d6\u0080\u00d5\u00ab_\u00d6\u0083\u00d5\u00a5\u00d5\u00bf\u00d6\u0080\u00d5\u00be\u00d5\u00a1\u00d6\u0080\u00d5\u00ab_\u00d5\u00b4\u00d5\u00a1\u00d6\u0080\u00d5\u00bf\u00d5\u00ab_\u00d5\u00a1\u00d5\u00ba\u00d6\u0080\u00d5\u00ab\u00d5\u00ac\u00d5\u00ab_\u00d5\u00b4\u00d5\u00a1\u00d5\u00b5\u00d5\u00ab\u00d5\u00bd\u00d5\u00ab_\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00b6\u00d5\u00ab\u00d5\u00bd\u00d5\u00ab_\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00ac\u00d5\u00ab\u00d5\u00bd\u00d5\u00ab_\u00d6\u0085\u00d5\u00a3\u00d5\u00b8\u00d5\u00bd\u00d5\u00bf\u00d5\u00b8\u00d5\u00bd\u00d5\u00ab_\u00d5\u00bd\u00d5\u00a5\u00d5\u00ba\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080\u00d5\u00ab_\u00d5\u00b0\u00d5\u00b8\u00d5\u00af\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080\u00d5\u00ab_\u00d5\u00b6\u00d5\u00b8\u00d5\u00b5\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080\u00d5\u00ab_\u00d5\u00a4\u00d5\u00a5\u00d5\u00af\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080\u00d5\u00ab'.split('_')\n        }, i;\n        for (i = 0; i < 12; i++) {\n            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);\n            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);\n        }\n    });\n\n    test('format month short case', function (assert) {\n        var monthsShort = {\n            'nominative': '\u00d5\u00b0\u00d5\u00b6\u00d5\u00be_\u00d6\u0083\u00d5\u00bf\u00d6\u0080_\u00d5\u00b4\u00d6\u0080\u00d5\u00bf_\u00d5\u00a1\u00d5\u00ba\u00d6\u0080_\u00d5\u00b4\u00d5\u00b5\u00d5\u00bd_\u00d5\u00b0\u00d5\u00b6\u00d5\u00bd_\u00d5\u00b0\u00d5\u00ac\u00d5\u00bd_\u00d6\u0085\u00d5\u00a3\u00d5\u00bd_\u00d5\u00bd\u00d5\u00ba\u00d5\u00bf_\u00d5\u00b0\u00d5\u00af\u00d5\u00bf_\u00d5\u00b6\u00d5\u00b4\u00d5\u00a2_\u00d5\u00a4\u00d5\u00af\u00d5\u00bf'.split('_'),\n            'accusative': '\u00d5\u00b0\u00d5\u00b6\u00d5\u00be_\u00d6\u0083\u00d5\u00bf\u00d6\u0080_\u00d5\u00b4\u00d6\u0080\u00d5\u00bf_\u00d5\u00a1\u00d5\u00ba\u00d6\u0080_\u00d5\u00b4\u00d5\u00b5\u00d5\u00bd_\u00d5\u00b0\u00d5\u00b6\u00d5\u00bd_\u00d5\u00b0\u00d5\u00ac\u00d5\u00bd_\u00d6\u0085\u00d5\u00a3\u00d5\u00bd_\u00d5\u00bd\u00d5\u00ba\u00d5\u00bf_\u00d5\u00b0\u00d5\u00af\u00d5\u00bf_\u00d5\u00b6\u00d5\u00b4\u00d5\u00a2_\u00d5\u00a4\u00d5\u00af\u00d5\u00bf'.split('_')\n        }, i;\n        for (i = 0; i < 12; i++) {\n            assert.equal(moment([2011, i, 1]).format('D MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);\n            assert.equal(moment([2011, i, 1]).format('MMM'), monthsShort.nominative[i], '1 ' + monthsShort.nominative[i]);\n        }\n    });\n\n    test('format month case with escaped symbols', function (assert) {\n        var months = {\n            'nominative': '\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00b6\u00d5\u00be\u00d5\u00a1\u00d6\u0080_\u00d6\u0083\u00d5\u00a5\u00d5\u00bf\u00d6\u0080\u00d5\u00be\u00d5\u00a1\u00d6\u0080_\u00d5\u00b4\u00d5\u00a1\u00d6\u0080\u00d5\u00bf_\u00d5\u00a1\u00d5\u00ba\u00d6\u0080\u00d5\u00ab\u00d5\u00ac_\u00d5\u00b4\u00d5\u00a1\u00d5\u00b5\u00d5\u00ab\u00d5\u00bd_\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00b6\u00d5\u00ab\u00d5\u00bd_\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00ac\u00d5\u00ab\u00d5\u00bd_\u00d6\u0085\u00d5\u00a3\u00d5\u00b8\u00d5\u00bd\u00d5\u00bf\u00d5\u00b8\u00d5\u00bd_\u00d5\u00bd\u00d5\u00a5\u00d5\u00ba\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080_\u00d5\u00b0\u00d5\u00b8\u00d5\u00af\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080_\u00d5\u00b6\u00d5\u00b8\u00d5\u00b5\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080_\u00d5\u00a4\u00d5\u00a5\u00d5\u00af\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080'.split('_'),\n            'accusative': '\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00b6\u00d5\u00be\u00d5\u00a1\u00d6\u0080\u00d5\u00ab_\u00d6\u0083\u00d5\u00a5\u00d5\u00bf\u00d6\u0080\u00d5\u00be\u00d5\u00a1\u00d6\u0080\u00d5\u00ab_\u00d5\u00b4\u00d5\u00a1\u00d6\u0080\u00d5\u00bf\u00d5\u00ab_\u00d5\u00a1\u00d5\u00ba\u00d6\u0080\u00d5\u00ab\u00d5\u00ac\u00d5\u00ab_\u00d5\u00b4\u00d5\u00a1\u00d5\u00b5\u00d5\u00ab\u00d5\u00bd\u00d5\u00ab_\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00b6\u00d5\u00ab\u00d5\u00bd\u00d5\u00ab_\u00d5\u00b0\u00d5\u00b8\u00d6\u0082\u00d5\u00ac\u00d5\u00ab\u00d5\u00bd\u00d5\u00ab_\u00d6\u0085\u00d5\u00a3\u00d5\u00b8\u00d5\u00bd\u00d5\u00bf\u00d5\u00b8\u00d5\u00bd\u00d5\u00ab_\u00d5\u00bd\u00d5\u00a5\u00d5\u00ba\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080\u00d5\u00ab_\u00d5\u00b0\u00d5\u00b8\u00d5\u00af\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080\u00d5\u00ab_\u00d5\u00b6\u00d5\u00b8\u00d5\u00b5\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080\u00d5\u00ab_\u00d5\u00a4\u00d5\u00a5\u00d5\u00af\u00d5\u00bf\u00d5\u00a5\u00d5\u00b4\u00d5\u00a2\u00d5\u00a5\u00d6\u0080\u00d5\u00ab'.split('_')\n        }, i;\n        for (i = 0; i < 12; i++) {\n            assert.equal(moment([2013, i, 1]).format('D[] MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);\n            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMMM[</b>]'), '<i>1</i> <b>' + months.accusative[i] + '</b>', '1 <b>' + months.accusative[i] + '</b>');\n            assert.equal(moment([2013, i, 1]).format('D[-\u00d5\u00ab\u00d5\u00b6 \u00d6\u0085\u00d6\u0080\u00d5\u00a8] MMMM'), '1-\u00d5\u00ab\u00d5\u00b6 \u00d6\u0085\u00d6\u0080\u00d5\u00a8 ' + months.accusative[i], '1-\u00d5\u00ab\u00d5\u00b6 \u00d6\u0085\u00d6\u0080\u00d5\u00a8 ' + months.accusative[i]);\n            assert.equal(moment([2013, i, 1]).format('D, MMMM'), '1, ' + months.nominative[i], '1, ' + months.nominative[i]);\n        }\n    });\n\n    test('format month short case with escaped symbols', function (assert) {\n        var monthsShort = {\n            'nominative': '\u00d5\u00b0\u00d5\u00b6\u00d5\u00be_\u00d6\u0083\u00d5\u00bf\u00d6\u0080_\u00d5\u00b4\u00d6\u0080\u00d5\u00bf_\u00d5\u00a1\u00d5\u00ba\u00d6\u0080_\u00d5\u00b4\u00d5\u00b5\u00d5\u00bd_\u00d5\u00b0\u00d5\u00b6\u00d5\u00bd_\u00d5\u00b0\u00d5\u00ac\u00d5\u00bd_\u00d6\u0085\u00d5\u00a3\u00d5\u00bd_\u00d5\u00bd\u00d5\u00ba\u00d5\u00bf_\u00d5\u00b0\u00d5\u00af\u00d5\u00bf_\u00d5\u00b6\u00d5\u00b4\u00d5\u00a2_\u00d5\u00a4\u00d5\u00af\u00d5\u00bf'.split('_'),\n            'accusative': '\u00d5\u00b0\u00d5\u00b6\u00d5\u00be_\u00d6\u0083\u00d5\u00bf\u00d6\u0080_\u00d5\u00b4\u00d6\u0080\u00d5\u00bf_\u00d5\u00a1\u00d5\u00ba\u00d6\u0080_\u00d5\u00b4\u00d5\u00b5\u00d5\u00bd_\u00d5\u00b0\u00d5\u00b6\u00d5\u00bd_\u00d5\u00b0\u00d5\u00ac\u00d5\u00bd_\u00d6\u0085\u00d5\u00a3\u00d5\u00bd_\u00d5\u00bd\u00d5\u00ba\u00d5\u00bf_\u00d5\u00b0\u00d5\u00af\u00d5\u00bf_\u00d5\u00b6\u00d5\u00b4\u00d5\u00a2_\u00d5\u00a4\u00d5\u00af\u00d5\u00bf'.split('_')\n        }, i;\n        for (i = 0; i < 12; i++) {\n            assert.equal(moment([2013, i, 1]).format('D[] MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);\n            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMM[</b>]'), '<i>1</i> <b>' + monthsShort.accusative[i] + '</b>', '1 <b>' + monthsShort.accusative[i] + '</b>');\n            assert.equal(moment([2013, i, 1]).format('D[-\u00d5\u00ab\u00d5\u00b6 \u00d6\u0085\u00d6\u0080\u00d5\u00a8] MMM'), '1-\u00d5\u00ab\u00d5\u00b6 \u00d6\u0085\u00d6\u0080\u00d5\u00a8 ' + monthsShort.accusative[i], '1-\u00d5\u00ab\u00d5\u00b6 \u00d6\u0085\u00d6\u0080\u00d5\u00a8 ' + monthsShort.accusative[i]);\n            assert.equal(moment([2013, i, 1]).format('D, MMM'), '1, ' + monthsShort.nominative[i], '1, ' + monthsShort.nominative[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d5\u00af\u00d5\u00ab\u00d6\u0080\u00d5\u00a1\u00d5\u00af\u00d5\u00ab \u00d5\u00af\u00d6\u0080\u00d5\u00af \u00d5\u00af\u00d6\u0080\u00d5\u00af_\u00d5\u00a5\u00d6\u0080\u00d5\u00af\u00d5\u00b8\u00d6\u0082\u00d5\u00b7\u00d5\u00a1\u00d5\u00a2\u00d5\u00a9\u00d5\u00ab \u00d5\u00a5\u00d6\u0080\u00d5\u00af \u00d5\u00a5\u00d6\u0080\u00d5\u00af_\u00d5\u00a5\u00d6\u0080\u00d5\u00a5\u00d6\u0084\u00d5\u00b7\u00d5\u00a1\u00d5\u00a2\u00d5\u00a9\u00d5\u00ab \u00d5\u00a5\u00d6\u0080\u00d6\u0084 \u00d5\u00a5\u00d6\u0080\u00d6\u0084_\u00d5\u00b9\u00d5\u00b8\u00d6\u0080\u00d5\u00a5\u00d6\u0084\u00d5\u00b7\u00d5\u00a1\u00d5\u00a2\u00d5\u00a9\u00d5\u00ab \u00d5\u00b9\u00d6\u0080\u00d6\u0084 \u00d5\u00b9\u00d6\u0080\u00d6\u0084_\u00d5\u00b0\u00d5\u00ab\u00d5\u00b6\u00d5\u00a3\u00d5\u00b7\u00d5\u00a1\u00d5\u00a2\u00d5\u00a9\u00d5\u00ab \u00d5\u00b0\u00d5\u00b6\u00d5\u00a3 \u00d5\u00b0\u00d5\u00b6\u00d5\u00a3_\u00d5\u00b8\u00d6\u0082\u00d6\u0080\u00d5\u00a2\u00d5\u00a1\u00d5\u00a9 \u00d5\u00b8\u00d6\u0082\u00d6\u0080\u00d5\u00a2 \u00d5\u00b8\u00d6\u0082\u00d6\u0080\u00d5\u00a2_\u00d5\u00b7\u00d5\u00a1\u00d5\u00a2\u00d5\u00a1\u00d5\u00a9 \u00d5\u00b7\u00d5\u00a2\u00d5\u00a9 \u00d5\u00b7\u00d5\u00a2\u00d5\u00a9'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d5\u00b4\u00d5\u00ab \u00d6\u0084\u00d5\u00a1\u00d5\u00b6\u00d5\u00ab \u00d5\u00be\u00d5\u00a1\u00d5\u00b5\u00d6\u0080\u00d5\u00af\u00d5\u00b5\u00d5\u00a1\u00d5\u00b6',    '44 seconds = seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d6\u0080\u00d5\u00b8\u00d5\u00ba\u00d5\u00a5',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d6\u0080\u00d5\u00b8\u00d5\u00ba\u00d5\u00a5',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d6\u0080\u00d5\u00b8\u00d5\u00ba\u00d5\u00a5',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d6\u0080\u00d5\u00b8\u00d5\u00ba\u00d5\u00a5', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d5\u00aa\u00d5\u00a1\u00d5\u00b4',    '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d5\u00aa\u00d5\u00a1\u00d5\u00b4',    '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00d5\u00aa\u00d5\u00a1\u00d5\u00b4',    '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d5\u00aa\u00d5\u00a1\u00d5\u00b4',    '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d5\u00aa\u00d5\u00a1\u00d5\u00b4',   '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d6\u0085\u00d6\u0080',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d6\u0085\u00d6\u0080',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00d6\u0085\u00d6\u0080',     '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d6\u0085\u00d6\u0080',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d6\u0085\u00d6\u0080',     '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 \u00d6\u0085\u00d6\u0080',     '11 days = 11 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 \u00d6\u0085\u00d6\u0080',     '21 days = 21 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d6\u0085\u00d6\u0080',    '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d5\u00a1\u00d5\u00b4\u00d5\u00ab\u00d5\u00bd',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d5\u00a1\u00d5\u00b4\u00d5\u00ab\u00d5\u00bd',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d5\u00a1\u00d5\u00b4\u00d5\u00ab\u00d5\u00bd',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00d5\u00a1\u00d5\u00b4\u00d5\u00ab\u00d5\u00bd',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00d5\u00a1\u00d5\u00b4\u00d5\u00ab\u00d5\u00bd',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d5\u00a1\u00d5\u00b4\u00d5\u00ab\u00d5\u00bd',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d5\u00a1\u00d5\u00b4\u00d5\u00ab\u00d5\u00bd',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d5\u00a1\u00d5\u00b4\u00d5\u00ab\u00d5\u00bd',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d5\u00bf\u00d5\u00a1\u00d6\u0080\u00d5\u00ab',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00d5\u00bf\u00d5\u00a1\u00d6\u0080\u00d5\u00ab',    '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d5\u00bf\u00d5\u00a1\u00d6\u0080\u00d5\u00ab',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d5\u00bf\u00d5\u00a1\u00d6\u0080\u00d5\u00ab',    '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d5\u00b4\u00d5\u00ab \u00d6\u0084\u00d5\u00a1\u00d5\u00b6\u00d5\u00ab \u00d5\u00be\u00d5\u00a1\u00d5\u00b5\u00d6\u0080\u00d5\u00af\u00d5\u00b5\u00d5\u00a1\u00d5\u00b6 \u00d5\u00b0\u00d5\u00a5\u00d5\u00bf\u00d5\u00b8', 'prefix');\n        assert.equal(moment(0).from(30000), '\u00d5\u00b4\u00d5\u00ab \u00d6\u0084\u00d5\u00a1\u00d5\u00b6\u00d5\u00ab \u00d5\u00be\u00d5\u00a1\u00d5\u00b5\u00d6\u0080\u00d5\u00af\u00d5\u00b5\u00d5\u00a1\u00d5\u00b6 \u00d5\u00a1\u00d5\u00bc\u00d5\u00a1\u00d5\u00bb', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d5\u00b4\u00d5\u00ab \u00d6\u0084\u00d5\u00a1\u00d5\u00b6\u00d5\u00ab \u00d5\u00be\u00d5\u00a1\u00d5\u00b5\u00d6\u0080\u00d5\u00af\u00d5\u00b5\u00d5\u00a1\u00d5\u00b6 \u00d5\u00b0\u00d5\u00a5\u00d5\u00bf\u00d5\u00b8', 'in seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 \u00d6\u0085\u00d6\u0080 \u00d5\u00b0\u00d5\u00a5\u00d5\u00bf\u00d5\u00b8', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d5\u00a1\u00d5\u00b5\u00d5\u00bd\u00d6\u0085\u00d6\u0080 12:00',   'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d5\u00a1\u00d5\u00b5\u00d5\u00bd\u00d6\u0085\u00d6\u0080 12:25',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d5\u00a1\u00d5\u00b5\u00d5\u00bd\u00d6\u0085\u00d6\u0080 13:00',   'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d5\u00be\u00d5\u00a1\u00d5\u00b2\u00d5\u00a8 12:00',    'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d5\u00a1\u00d5\u00b5\u00d5\u00bd\u00d6\u0085\u00d6\u0080 11:00',   'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d5\u00a5\u00d6\u0080\u00d5\u00a5\u00d5\u00af 12:00',    'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        function makeFormat(d) {\n            return 'dddd [\u00d6\u0085\u00d6\u0080\u00d5\u00a8 \u00d5\u00aa\u00d5\u00a1\u00d5\u00b4\u00d5\u00a8] LT';\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            return '[\u00d5\u00a1\u00d5\u00b6\u00d6\u0081\u00d5\u00a1\u00d5\u00ae] dddd [\u00d6\u0085\u00d6\u0080\u00d5\u00a8 \u00d5\u00aa\u00d5\u00a1\u00d5\u00b4\u00d5\u00a8] LT';\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-\u00d5\u00ab\u00d5\u00b6', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-\u00d5\u00ab\u00d5\u00b6', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-\u00d6\u0080\u00d5\u00a4', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-\u00d6\u0080\u00d5\u00a4', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-\u00d6\u0080\u00d5\u00a4', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('id');\n\n    test('parse', function (assert) {\n        var tests = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Minggu, Februari 14 2010, 3:25:50 sore'],\n                ['ddd, hA',                            'Min, 3sore'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 Minggu Min Mg'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '7 7 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'sore sore'],\n                ['[the] DDDo [day of the year]',       'the 45 day of the year'],\n                ['LTS',                                '15.25.50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 Februari 2010'],\n                ['LLL',                                '14 Februari 2010 pukul 15.25'],\n                ['LLLL',                               'Minggu, 14 Februari 2010 pukul 15.25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Feb 2010'],\n                ['lll',                                '14 Feb 2010 pukul 15.25'],\n                ['llll',                               'Min, 14 Feb 2010 pukul 15.25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Minggu Min Mg_Senin Sen Sn_Selasa Sel Sl_Rabu Rab Rb_Kamis Kam Km_Jumat Jum Jm_Sabtu Sab Sb'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'beberapa detik', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'semenit',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'semenit',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 menit',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 menit',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sejam',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sejam',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sehari',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sehari',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 hari',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sehari',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 hari',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 hari',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sebulan',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sebulan',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sebulan',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 bulan',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 bulan',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 bulan',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sebulan',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 bulan',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setahun',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 tahun',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setahun',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 tahun',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'dalam beberapa detik',  'prefix');\n        assert.equal(moment(0).from(30000), 'beberapa detik yang lalu', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'beberapa detik yang lalu',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'dalam beberapa detik', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'dalam 5 hari', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Hari ini pukul 12.00', 'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Hari ini pukul 12.25', 'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Hari ini pukul 13.00', 'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Besok pukul 12.00',    'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hari ini pukul 11.00', 'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kemarin pukul 12.00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [lalu pukul] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [lalu pukul] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [lalu pukul] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('is');\n\n    test('parse', function (assert) {\n        var tests = 'jan\u00c3\u00baar jan_febr\u00c3\u00baar feb_mars mar_apr\u00c3\u00adl apr_ma\u00c3\u00ad ma\u00c3\u00ad_j\u00c3\u00ban\u00c3\u00ad j\u00c3\u00ban_j\u00c3\u00bal\u00c3\u00ad j\u00c3\u00bal_\u00c3\u00a1g\u00c3\u00bast \u00c3\u00a1g\u00c3\u00ba_september sep_okt\u00c3\u00b3ber okt_n\u00c3\u00b3vember n\u00c3\u00b3v_desember des'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a',      'sunnudagur, 14. febr\u00c3\u00baar 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'sun, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 febr\u00c3\u00baar feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. sunnudagur sun Su'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14. febr\u00c3\u00baar 2010'],\n                ['LLL',                                '14. febr\u00c3\u00baar 2010 kl. 15:25'],\n                ['LLLL',                               'sunnudagur, 14. febr\u00c3\u00baar 2010 kl. 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14. feb 2010'],\n                ['lll',                                '14. feb 2010 kl. 15:25'],\n                ['llll',                               'sun, 14. feb 2010 kl. 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'jan\u00c3\u00baar jan_febr\u00c3\u00baar feb_mars mar_apr\u00c3\u00adl apr_ma\u00c3\u00ad ma\u00c3\u00ad_j\u00c3\u00ban\u00c3\u00ad j\u00c3\u00ban_j\u00c3\u00bal\u00c3\u00ad j\u00c3\u00bal_\u00c3\u00a1g\u00c3\u00bast \u00c3\u00a1g\u00c3\u00ba_september sep_okt\u00c3\u00b3ber okt_n\u00c3\u00b3vember n\u00c3\u00b3v_desember des'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'sunnudagur sun Su_m\u00c3\u00a1nudagur m\u00c3\u00a1n M\u00c3\u00a1_\u00c3\u00beri\u00c3\u00b0judagur \u00c3\u00beri \u00c3\u009er_mi\u00c3\u00b0vikudagur mi\u00c3\u00b0 Mi_fimmtudagur fim Fi_f\u00c3\u00b6studagur f\u00c3\u00b6s F\u00c3\u00b6_laugardagur lau La'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nokkrar sek\u00c3\u00bandur', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'm\u00c3\u00adn\u00c3\u00bata',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'm\u00c3\u00adn\u00c3\u00bata',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 m\u00c3\u00adn\u00c3\u00batur',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 m\u00c3\u00adn\u00c3\u00batur',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 21}), true),  '21 m\u00c3\u00adn\u00c3\u00bata',    '21 minutes = 21 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'klukkustund',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'klukkustund',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 klukkustundir',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 klukkustundir',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 klukkustund',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dagur',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dagur',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dagur',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 dagar',       '11 days = 11 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 dagur',       '21 days = 21 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'm\u00c3\u00a1nu\u00c3\u00b0ur',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'm\u00c3\u00a1nu\u00c3\u00b0ur',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'm\u00c3\u00a1nu\u00c3\u00b0ur',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m\u00c3\u00a1nu\u00c3\u00b0ir',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m\u00c3\u00a1nu\u00c3\u00b0ir',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m\u00c3\u00a1nu\u00c3\u00b0ir',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'm\u00c3\u00a1nu\u00c3\u00b0ur',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m\u00c3\u00a1nu\u00c3\u00b0ir',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00c3\u00a1r',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00c3\u00a1r',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00c3\u00a1r',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00c3\u00a1r',       '5 years = 5 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 21}), true),  '21 \u00c3\u00a1r',       '21 years = 21 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'eftir nokkrar sek\u00c3\u00bandur',  'prefix');\n        assert.equal(moment(0).from(30000), 'fyrir nokkrum sek\u00c3\u00bandum s\u00c3\u00ad\u00c3\u00b0an', 'suffix');\n        assert.equal(moment().subtract({m: 1}).fromNow(), 'fyrir m\u00c3\u00adn\u00c3\u00batu s\u00c3\u00ad\u00c3\u00b0an', 'a minute ago');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'fyrir nokkrum sek\u00c3\u00bandum s\u00c3\u00ad\u00c3\u00b0an',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'eftir nokkrar sek\u00c3\u00bandur', 'in a few seconds');\n        assert.equal(moment().add({m: 1}).fromNow(), 'eftir m\u00c3\u00adn\u00c3\u00batu', 'in a minute');\n        assert.equal(moment().add({d: 5}).fromNow(), 'eftir 5 daga', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00c3\u00ad dag kl. 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00c3\u00ad dag kl. 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00c3\u00ad dag kl. 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00c3\u00a1 morgun kl. 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00c3\u00ad dag kl. 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00c3\u00ad g\u00c3\u00a6r kl. 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[s\u00c3\u00ad\u00c3\u00b0asta] dddd [kl.] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[s\u00c3\u00ad\u00c3\u00b0asta] dddd [kl.] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[s\u00c3\u00ad\u00c3\u00b0asta] dddd [kl.] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('it');\n\n    test('parse', function (assert) {\n        var tests = 'gennaio gen_febbraio feb_marzo mar_aprile apr_maggio mag_giugno giu_luglio lug_agosto ago_settembre set_ottobre ott_novembre nov_dicembre dic'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domenica, febbraio 14\u00c2\u00ba 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Dom, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2\u00c2\u00ba 02 febbraio feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\u00c2\u00ba 14'],\n                ['d do dddd ddd dd',                   '0 0\u00c2\u00ba Domenica Dom Do'],\n                ['DDD DDDo DDDD',                      '45 45\u00c2\u00ba 045'],\n                ['w wo ww',                            '6 6\u00c2\u00ba 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45\u00c2\u00ba day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 febbraio 2010'],\n                ['LLL',                                '14 febbraio 2010 15:25'],\n                ['LLLL',                               'Domenica, 14 febbraio 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 feb 2010'],\n                ['lll',                                '14 feb 2010 15:25'],\n                ['llll',                               'Dom, 14 feb 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1\u00c2\u00ba', '1\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2\u00c2\u00ba', '2\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3\u00c2\u00ba', '3\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4\u00c2\u00ba', '4\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\u00c2\u00ba', '5\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\u00c2\u00ba', '6\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\u00c2\u00ba', '7\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\u00c2\u00ba', '8\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\u00c2\u00ba', '9\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\u00c2\u00ba', '10\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\u00c2\u00ba', '11\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\u00c2\u00ba', '12\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\u00c2\u00ba', '13\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\u00c2\u00ba', '14\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\u00c2\u00ba', '15\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\u00c2\u00ba', '16\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\u00c2\u00ba', '17\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\u00c2\u00ba', '18\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\u00c2\u00ba', '19\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\u00c2\u00ba', '20\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\u00c2\u00ba', '21\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\u00c2\u00ba', '22\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\u00c2\u00ba', '23\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\u00c2\u00ba', '24\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\u00c2\u00ba', '25\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\u00c2\u00ba', '26\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\u00c2\u00ba', '27\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\u00c2\u00ba', '28\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\u00c2\u00ba', '29\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\u00c2\u00ba', '30\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\u00c2\u00ba', '31\u00c2\u00ba');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'gennaio gen_febbraio feb_marzo mar_aprile apr_maggio mag_giugno giu_luglio lug_agosto ago_settembre set_ottobre ott_novembre nov_dicembre dic'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Domenica Dom Do_Luned\u00c3\u00ac Lun Lu_Marted\u00c3\u00ac Mar Ma_Mercoled\u00c3\u00ac Mer Me_Gioved\u00c3\u00ac Gio Gi_Venerd\u00c3\u00ac Ven Ve_Sabato Sab Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'alcuni secondi', '44 seconds = seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minuto',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minuto',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuti',       '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuti',      '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'un\\'ora',        '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'un\\'ora',        '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ore',          '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ore',          '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ore',         '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un giorno',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un giorno',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 giorni',       '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un giorno',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 giorni',       '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 giorni',      '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mese',        '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mese',        '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mese',        '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesi',         '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesi',         '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesi',         '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mese',        '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesi',         '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un anno',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anni',         '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un anno',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anni',         '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'in alcuni secondi', 'prefix');\n        assert.equal(moment(0).from(30000), 'alcuni secondi fa', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'in alcuni secondi', 'in seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'tra 5 giorni', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Oggi alle 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Oggi alle 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Oggi alle 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Domani alle 12:00',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Oggi alle 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ieri alle 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [alle] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [alle] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [alle] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m, weekday, datestring;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            // Different date string\n            weekday = parseInt(m.format('d'), 10);\n            datestring = (weekday === 0) ? '[la scorsa] dddd [alle] LT' : '[lo scorso] dddd [alle] LT';\n            assert.equal(m.calendar(), m.format(datestring), 'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format(datestring), 'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format(datestring), 'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52\u00c2\u00ba', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1\u00c2\u00ba', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1\u00c2\u00ba', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2\u00c2\u00ba', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2\u00c2\u00ba', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ja');\n\n    test('parse', function (assert) {\n        var tests = '1\u00e6\u009c\u0088 1\u00e6\u009c\u0088_2\u00e6\u009c\u0088 2\u00e6\u009c\u0088_3\u00e6\u009c\u0088 3\u00e6\u009c\u0088_4\u00e6\u009c\u0088 4\u00e6\u009c\u0088_5\u00e6\u009c\u0088 5\u00e6\u009c\u0088_6\u00e6\u009c\u0088 6\u00e6\u009c\u0088_7\u00e6\u009c\u0088 7\u00e6\u009c\u0088_8\u00e6\u009c\u0088 8\u00e6\u009c\u0088_9\u00e6\u009c\u0088 9\u00e6\u009c\u0088_10\u00e6\u009c\u0088 10\u00e6\u009c\u0088_11\u00e6\u009c\u0088 11\u00e6\u009c\u0088_12\u00e6\u009c\u0088 12\u00e6\u009c\u0088'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, a h:mm:ss',      '\u00e6\u0097\u00a5\u00e6\u009b\u009c\u00e6\u0097\u00a5, 2\u00e6\u009c\u0088 14\u00e6\u0097\u00a5 2010, \u00e5\u008d\u0088\u00e5\u00be\u008c 3:25:50'],\n                ['ddd, Ah',                            '\u00e6\u0097\u00a5, \u00e5\u008d\u0088\u00e5\u00be\u008c3'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 2\u00e6\u009c\u0088 2\u00e6\u009c\u0088'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\u00e6\u0097\u00a5 14'],\n                ['d do dddd ddd dd',                   '0 0\u00e6\u0097\u00a5 \u00e6\u0097\u00a5\u00e6\u009b\u009c\u00e6\u0097\u00a5 \u00e6\u0097\u00a5 \u00e6\u0097\u00a5'],\n                ['DDD DDDo DDDD',                      '45 45\u00e6\u0097\u00a5 045'],\n                ['w wo ww',                            '8 8 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00e5\u008d\u0088\u00e5\u00be\u008c \u00e5\u008d\u0088\u00e5\u00be\u008c'],\n                ['[the] DDDo [day of the year]',       'the 45\u00e6\u0097\u00a5 day of the year'],\n                ['LTS',                                '\u00e5\u008d\u0088\u00e5\u00be\u008c3\u00e6\u0099\u008225\u00e5\u0088\u008650\u00e7\u00a7\u0092'],\n                ['L',                                  '2010/02/14'],\n                ['LL',                                 '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5'],\n                ['LLL',                                '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5\u00e5\u008d\u0088\u00e5\u00be\u008c3\u00e6\u0099\u008225\u00e5\u0088\u0086'],\n                ['LLLL',                               '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5\u00e5\u008d\u0088\u00e5\u00be\u008c3\u00e6\u0099\u008225\u00e5\u0088\u0086 \u00e6\u0097\u00a5\u00e6\u009b\u009c\u00e6\u0097\u00a5'],\n                ['l',                                  '2010/2/14'],\n                ['ll',                                 '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5'],\n                ['lll',                                '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5\u00e5\u008d\u0088\u00e5\u00be\u008c3\u00e6\u0099\u008225\u00e5\u0088\u0086'],\n                ['llll',                               '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5\u00e5\u008d\u0088\u00e5\u00be\u008c3\u00e6\u0099\u008225\u00e5\u0088\u0086 \u00e6\u0097\u00a5']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format month', function (assert) {\n        var expected = '1\u00e6\u009c\u0088 1\u00e6\u009c\u0088_2\u00e6\u009c\u0088 2\u00e6\u009c\u0088_3\u00e6\u009c\u0088 3\u00e6\u009c\u0088_4\u00e6\u009c\u0088 4\u00e6\u009c\u0088_5\u00e6\u009c\u0088 5\u00e6\u009c\u0088_6\u00e6\u009c\u0088 6\u00e6\u009c\u0088_7\u00e6\u009c\u0088 7\u00e6\u009c\u0088_8\u00e6\u009c\u0088 8\u00e6\u009c\u0088_9\u00e6\u009c\u0088 9\u00e6\u009c\u0088_10\u00e6\u009c\u0088 10\u00e6\u009c\u0088_11\u00e6\u009c\u0088 11\u00e6\u009c\u0088_12\u00e6\u009c\u0088 12\u00e6\u009c\u0088'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e6\u0097\u00a5\u00e6\u009b\u009c\u00e6\u0097\u00a5 \u00e6\u0097\u00a5 \u00e6\u0097\u00a5_\u00e6\u009c\u0088\u00e6\u009b\u009c\u00e6\u0097\u00a5 \u00e6\u009c\u0088 \u00e6\u009c\u0088_\u00e7\u0081\u00ab\u00e6\u009b\u009c\u00e6\u0097\u00a5 \u00e7\u0081\u00ab \u00e7\u0081\u00ab_\u00e6\u00b0\u00b4\u00e6\u009b\u009c\u00e6\u0097\u00a5 \u00e6\u00b0\u00b4 \u00e6\u00b0\u00b4_\u00e6\u009c\u00a8\u00e6\u009b\u009c\u00e6\u0097\u00a5 \u00e6\u009c\u00a8 \u00e6\u009c\u00a8_\u00e9\u0087\u0091\u00e6\u009b\u009c\u00e6\u0097\u00a5 \u00e9\u0087\u0091 \u00e9\u0087\u0091_\u00e5\u009c\u009f\u00e6\u009b\u009c\u00e6\u0097\u00a5 \u00e5\u009c\u009f \u00e5\u009c\u009f'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e6\u0095\u00b0\u00e7\u00a7\u0092',   '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1\u00e5\u0088\u0086', '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1\u00e5\u0088\u0086', '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2\u00e5\u0088\u0086',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44\u00e5\u0088\u0086', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1\u00e6\u0099\u0082\u00e9\u0096\u0093', '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1\u00e6\u0099\u0082\u00e9\u0096\u0093', '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2\u00e6\u0099\u0082\u00e9\u0096\u0093',  '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5\u00e6\u0099\u0082\u00e9\u0096\u0093',  '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21\u00e6\u0099\u0082\u00e9\u0096\u0093', '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1\u00e6\u0097\u00a5',   '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1\u00e6\u0097\u00a5',   '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2\u00e6\u0097\u00a5',   '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1\u00e6\u0097\u00a5',   '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5\u00e6\u0097\u00a5',   '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25\u00e6\u0097\u00a5',  '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1\u00e3\u0083\u00b6\u00e6\u009c\u0088', '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1\u00e3\u0083\u00b6\u00e6\u009c\u0088', '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1\u00e3\u0083\u00b6\u00e6\u009c\u0088', '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2\u00e3\u0083\u00b6\u00e6\u009c\u0088',  '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2\u00e3\u0083\u00b6\u00e6\u009c\u0088',  '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3\u00e3\u0083\u00b6\u00e6\u009c\u0088',  '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1\u00e3\u0083\u00b6\u00e6\u009c\u0088', '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5\u00e3\u0083\u00b6\u00e6\u009c\u0088',  '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1\u00e5\u00b9\u00b4',   '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2\u00e5\u00b9\u00b4',   '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1\u00e5\u00b9\u00b4',   '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5\u00e5\u00b9\u00b4',   '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e6\u0095\u00b0\u00e7\u00a7\u0092\u00e5\u00be\u008c',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e6\u0095\u00b0\u00e7\u00a7\u0092\u00e5\u0089\u008d', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e6\u0095\u00b0\u00e7\u00a7\u0092\u00e5\u0089\u008d',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e6\u0095\u00b0\u00e7\u00a7\u0092\u00e5\u00be\u008c', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5\u00e6\u0097\u00a5\u00e5\u00be\u008c', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e4\u00bb\u008a\u00e6\u0097\u00a5 \u00e5\u008d\u0088\u00e5\u00be\u008c12\u00e6\u0099\u00820\u00e5\u0088\u0086',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e4\u00bb\u008a\u00e6\u0097\u00a5 \u00e5\u008d\u0088\u00e5\u00be\u008c12\u00e6\u0099\u008225\u00e5\u0088\u0086',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00e4\u00bb\u008a\u00e6\u0097\u00a5 \u00e5\u008d\u0088\u00e5\u00be\u008c1\u00e6\u0099\u00820\u00e5\u0088\u0086',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e6\u0098\u008e\u00e6\u0097\u00a5 \u00e5\u008d\u0088\u00e5\u00be\u008c12\u00e6\u0099\u00820\u00e5\u0088\u0086',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e4\u00bb\u008a\u00e6\u0097\u00a5 \u00e5\u008d\u0088\u00e5\u0089\u008d11\u00e6\u0099\u00820\u00e5\u0088\u0086',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e6\u0098\u00a8\u00e6\u0097\u00a5 \u00e5\u008d\u0088\u00e5\u00be\u008c12\u00e6\u0099\u00820\u00e5\u0088\u0086',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e6\u009d\u00a5\u00e9\u0080\u00b1]dddd LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e6\u009d\u00a5\u00e9\u0080\u00b1]dddd LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e6\u009d\u00a5\u00e9\u0080\u00b1]dddd LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e5\u0089\u008d\u00e9\u0080\u00b1]dddd LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e5\u0089\u008d\u00e9\u0080\u00b1]dddd LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e5\u0089\u008d\u00e9\u0080\u00b1]dddd LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('jv');\n\n    test('parse', function (assert) {\n        var tests = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_Nopember Nop_Desember Des'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Minggu, Februari 14 2010, 3:25:50 sonten'],\n                ['ddd, hA',                            'Min, 3sonten'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 Minggu Min Mg'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '7 7 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'sonten sonten'],\n                ['[the] DDDo [day of the year]',       'the 45 day of the year'],\n                ['LTS',                                '15.25.50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 Februari 2010'],\n                ['LLL',                                '14 Februari 2010 pukul 15.25'],\n                ['LLLL',                               'Minggu, 14 Februari 2010 pukul 15.25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Feb 2010'],\n                ['lll',                                '14 Feb 2010 pukul 15.25'],\n                ['llll',                               'Min, 14 Feb 2010 pukul 15.25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_Nopember Nop_Desember Des'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Minggu Min Mg_Senen Sen Sn_Seloso Sel Sl_Rebu Reb Rb_Kemis Kem Km_Jemuwah Jem Jm_Septu Sep Sp'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'sawetawis detik', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'setunggal menit',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'setunggal menit',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 menit',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 menit',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'setunggal jam',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'setunggal jam',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sedinten',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sedinten',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dinten',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sedinten',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dinten',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dinten',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sewulan',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sewulan',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sewulan',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 wulan',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 wulan',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 wulan',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sewulan',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 wulan',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setaun',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 taun',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setaun',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 taun',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'wonten ing sawetawis detik',  'prefix');\n        assert.equal(moment(0).from(30000), 'sawetawis detik ingkang kepengker', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'sawetawis detik ingkang kepengker',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'wonten ing sawetawis detik', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'wonten ing 5 dinten', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Dinten puniko pukul 12.00', 'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Dinten puniko pukul 12.25', 'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Dinten puniko pukul 13.00', 'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Mbenjang pukul 12.00',      'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Dinten puniko pukul 11.00', 'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kala wingi pukul 12.00',    'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [kepengker pukul] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [kepengker pukul] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [kepengker pukul] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    // Monday is the first day of the week.\n    // The week that contains Jan 1st is the first week of the year.\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ka');\n\n    test('parse', function (assert) {\n        var i,\n            tests = '\u00e1\u0083\u0098\u00e1\u0083\u0090\u00e1\u0083\u009c\u00e1\u0083\u0095\u00e1\u0083\u0090\u00e1\u0083\u00a0\u00e1\u0083\u0098 \u00e1\u0083\u0098\u00e1\u0083\u0090\u00e1\u0083\u009c_\u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0095\u00e1\u0083\u0090\u00e1\u0083\u009a\u00e1\u0083\u0098 \u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091_\u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u00a0\u00e1\u0083\u00a2\u00e1\u0083\u0098 \u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u00a0_\u00e1\u0083\u0090\u00e1\u0083\u009e\u00e1\u0083\u00a0\u00e1\u0083\u0098\u00e1\u0083\u009a\u00e1\u0083\u0098 \u00e1\u0083\u0090\u00e1\u0083\u009e\u00e1\u0083\u00a0_\u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u0098\u00e1\u0083\u00a1\u00e1\u0083\u0098 \u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u0098_\u00e1\u0083\u0098\u00e1\u0083\u0095\u00e1\u0083\u009c\u00e1\u0083\u0098\u00e1\u0083\u00a1\u00e1\u0083\u0098 \u00e1\u0083\u0098\u00e1\u0083\u0095\u00e1\u0083\u009c_\u00e1\u0083\u0098\u00e1\u0083\u0095\u00e1\u0083\u009a\u00e1\u0083\u0098\u00e1\u0083\u00a1\u00e1\u0083\u0098 \u00e1\u0083\u0098\u00e1\u0083\u0095\u00e1\u0083\u009a_\u00e1\u0083\u0090\u00e1\u0083\u0092\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a1\u00e1\u0083\u00a2\u00e1\u0083\u009d \u00e1\u0083\u0090\u00e1\u0083\u0092\u00e1\u0083\u0095_\u00e1\u0083\u00a1\u00e1\u0083\u0094\u00e1\u0083\u00a5\u00e1\u0083\u00a2\u00e1\u0083\u0094\u00e1\u0083\u009b\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0098 \u00e1\u0083\u00a1\u00e1\u0083\u0094\u00e1\u0083\u00a5_\u00e1\u0083\u009d\u00e1\u0083\u00a5\u00e1\u0083\u00a2\u00e1\u0083\u009d\u00e1\u0083\u009b\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0098 \u00e1\u0083\u009d\u00e1\u0083\u00a5\u00e1\u0083\u00a2_\u00e1\u0083\u009c\u00e1\u0083\u009d\u00e1\u0083\u0094\u00e1\u0083\u009b\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0098 \u00e1\u0083\u009c\u00e1\u0083\u009d\u00e1\u0083\u0094_\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u0099\u00e1\u0083\u0094\u00e1\u0083\u009b\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0098 \u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u0099'.split('_');\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' \u00e1\u0083\u00a3\u00e1\u0083\u009c\u00e1\u0083\u0093\u00e1\u0083\u0090 \u00e1\u0083\u0098\u00e1\u0083\u00a7\u00e1\u0083\u009d\u00e1\u0083\u00a1 \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094 ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a', '\u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0090, \u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0095\u00e1\u0083\u0090\u00e1\u0083\u009a\u00e1\u0083\u0098 \u00e1\u0083\u009b\u00e1\u0083\u0094-14 2010, 3:25:50 pm'],\n                ['ddd, hA',                       '\u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098, 3PM'],\n                ['M Mo MM MMMM MMM',              '2 \u00e1\u0083\u009b\u00e1\u0083\u0094-2 02 \u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0095\u00e1\u0083\u0090\u00e1\u0083\u009a\u00e1\u0083\u0098 \u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091'],\n                ['YYYY YY',                       '2010 10'],\n                ['D Do DD',                       '14 \u00e1\u0083\u009b\u00e1\u0083\u0094-14 14'],\n                ['d do dddd ddd dd',              '0 0 \u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0090 \u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098 \u00e1\u0083\u0099\u00e1\u0083\u0095'],\n                ['DDD DDDo DDDD',                 '45 45-\u00e1\u0083\u0094 045'],\n                ['w wo ww',                       '7 \u00e1\u0083\u009b\u00e1\u0083\u0094-7 07'],\n                ['h hh',                          '3 03'],\n                ['H HH',                          '15 15'],\n                ['m mm',                          '25 25'],\n                ['s ss',                          '50 50'],\n                ['a A',                           'pm PM'],\n                ['\u00e1\u0083\u00ac\u00e1\u0083\u009a\u00e1\u0083\u0098\u00e1\u0083\u00a1 DDDo \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094',                 '\u00e1\u0083\u00ac\u00e1\u0083\u009a\u00e1\u0083\u0098\u00e1\u0083\u00a1 45-\u00e1\u0083\u0094 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094'],\n                ['LTS',                           '3:25:50 PM'],\n                ['L',                             '14/02/2010'],\n                ['LL',                            '14 \u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0095\u00e1\u0083\u0090\u00e1\u0083\u009a\u00e1\u0083\u00a1 2010'],\n                ['LLL',                           '14 \u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0095\u00e1\u0083\u0090\u00e1\u0083\u009a\u00e1\u0083\u00a1 2010 3:25 PM'],\n                ['LLLL',                          '\u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0090, 14 \u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0095\u00e1\u0083\u0090\u00e1\u0083\u009a\u00e1\u0083\u00a1 2010 3:25 PM'],\n                ['l',                             '14/2/2010'],\n                ['ll',                            '14 \u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091 2010'],\n                ['lll',                           '14 \u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091 2010 3:25 PM'],\n                ['llll',                          '\u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098, 14 \u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091 2010 3:25 PM']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'),  '1-\u00e1\u0083\u009a\u00e1\u0083\u0098',  '1-\u00e1\u0083\u009a\u00e1\u0083\u0098');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'),  '\u00e1\u0083\u009b\u00e1\u0083\u0094-2',  '\u00e1\u0083\u009b\u00e1\u0083\u0094-2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'),  '\u00e1\u0083\u009b\u00e1\u0083\u0094-3',  '\u00e1\u0083\u009b\u00e1\u0083\u0094-3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'),  '\u00e1\u0083\u009b\u00e1\u0083\u0094-4',  '\u00e1\u0083\u009b\u00e1\u0083\u0094-4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'),  '\u00e1\u0083\u009b\u00e1\u0083\u0094-5',  '\u00e1\u0083\u009b\u00e1\u0083\u0094-5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'),  '\u00e1\u0083\u009b\u00e1\u0083\u0094-6',  '\u00e1\u0083\u009b\u00e1\u0083\u0094-6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'),  '\u00e1\u0083\u009b\u00e1\u0083\u0094-7',  '\u00e1\u0083\u009b\u00e1\u0083\u0094-7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'),  '\u00e1\u0083\u009b\u00e1\u0083\u0094-8',  '\u00e1\u0083\u009b\u00e1\u0083\u0094-8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'),  '\u00e1\u0083\u009b\u00e1\u0083\u0094-9',  '\u00e1\u0083\u009b\u00e1\u0083\u0094-9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00e1\u0083\u009b\u00e1\u0083\u0094-10', '\u00e1\u0083\u009b\u00e1\u0083\u0094-10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00e1\u0083\u009b\u00e1\u0083\u0094-11', '\u00e1\u0083\u009b\u00e1\u0083\u0094-11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00e1\u0083\u009b\u00e1\u0083\u0094-12', '\u00e1\u0083\u009b\u00e1\u0083\u0094-12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00e1\u0083\u009b\u00e1\u0083\u0094-13', '\u00e1\u0083\u009b\u00e1\u0083\u0094-13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00e1\u0083\u009b\u00e1\u0083\u0094-14', '\u00e1\u0083\u009b\u00e1\u0083\u0094-14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00e1\u0083\u009b\u00e1\u0083\u0094-15', '\u00e1\u0083\u009b\u00e1\u0083\u0094-15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00e1\u0083\u009b\u00e1\u0083\u0094-16', '\u00e1\u0083\u009b\u00e1\u0083\u0094-16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00e1\u0083\u009b\u00e1\u0083\u0094-17', '\u00e1\u0083\u009b\u00e1\u0083\u0094-17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00e1\u0083\u009b\u00e1\u0083\u0094-18', '\u00e1\u0083\u009b\u00e1\u0083\u0094-18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00e1\u0083\u009b\u00e1\u0083\u0094-19', '\u00e1\u0083\u009b\u00e1\u0083\u0094-19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00e1\u0083\u009b\u00e1\u0083\u0094-20', '\u00e1\u0083\u009b\u00e1\u0083\u0094-20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-\u00e1\u0083\u0094', '21-\u00e1\u0083\u0094');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-\u00e1\u0083\u0094', '22-\u00e1\u0083\u0094');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-\u00e1\u0083\u0094', '23-\u00e1\u0083\u0094');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-\u00e1\u0083\u0094', '24-\u00e1\u0083\u0094');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-\u00e1\u0083\u0094', '25-\u00e1\u0083\u0094');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-\u00e1\u0083\u0094', '26-\u00e1\u0083\u0094');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-\u00e1\u0083\u0094', '27-\u00e1\u0083\u0094');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-\u00e1\u0083\u0094', '28-\u00e1\u0083\u0094');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-\u00e1\u0083\u0094', '29-\u00e1\u0083\u0094');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-\u00e1\u0083\u0094', '30-\u00e1\u0083\u0094');\n\n        assert.equal(moment('2011 40', 'YYYY DDD').format('DDDo'),  '\u00e1\u0083\u009b\u00e1\u0083\u0094-40',  '\u00e1\u0083\u009b\u00e1\u0083\u0094-40');\n        assert.equal(moment('2011 50', 'YYYY DDD').format('DDDo'),  '50-\u00e1\u0083\u0094',   '50-\u00e1\u0083\u0094');\n        assert.equal(moment('2011 60', 'YYYY DDD').format('DDDo'),  '\u00e1\u0083\u009b\u00e1\u0083\u0094-60',  '\u00e1\u0083\u009b\u00e1\u0083\u0094-60');\n        assert.equal(moment('2011 100', 'YYYY DDD').format('DDDo'), '\u00e1\u0083\u009b\u00e1\u0083\u0094-100', '\u00e1\u0083\u009b\u00e1\u0083\u0094-100');\n        assert.equal(moment('2011 101', 'YYYY DDD').format('DDDo'), '101-\u00e1\u0083\u0094',  '101-\u00e1\u0083\u0094');\n    });\n\n    test('format month', function (assert) {\n        var i,\n            expected = '\u00e1\u0083\u0098\u00e1\u0083\u0090\u00e1\u0083\u009c\u00e1\u0083\u0095\u00e1\u0083\u0090\u00e1\u0083\u00a0\u00e1\u0083\u0098 \u00e1\u0083\u0098\u00e1\u0083\u0090\u00e1\u0083\u009c_\u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0095\u00e1\u0083\u0090\u00e1\u0083\u009a\u00e1\u0083\u0098 \u00e1\u0083\u0097\u00e1\u0083\u0094\u00e1\u0083\u0091_\u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u00a0\u00e1\u0083\u00a2\u00e1\u0083\u0098 \u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u00a0_\u00e1\u0083\u0090\u00e1\u0083\u009e\u00e1\u0083\u00a0\u00e1\u0083\u0098\u00e1\u0083\u009a\u00e1\u0083\u0098 \u00e1\u0083\u0090\u00e1\u0083\u009e\u00e1\u0083\u00a0_\u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u0098\u00e1\u0083\u00a1\u00e1\u0083\u0098 \u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u0098_\u00e1\u0083\u0098\u00e1\u0083\u0095\u00e1\u0083\u009c\u00e1\u0083\u0098\u00e1\u0083\u00a1\u00e1\u0083\u0098 \u00e1\u0083\u0098\u00e1\u0083\u0095\u00e1\u0083\u009c_\u00e1\u0083\u0098\u00e1\u0083\u0095\u00e1\u0083\u009a\u00e1\u0083\u0098\u00e1\u0083\u00a1\u00e1\u0083\u0098 \u00e1\u0083\u0098\u00e1\u0083\u0095\u00e1\u0083\u009a_\u00e1\u0083\u0090\u00e1\u0083\u0092\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a1\u00e1\u0083\u00a2\u00e1\u0083\u009d \u00e1\u0083\u0090\u00e1\u0083\u0092\u00e1\u0083\u0095_\u00e1\u0083\u00a1\u00e1\u0083\u0094\u00e1\u0083\u00a5\u00e1\u0083\u00a2\u00e1\u0083\u0094\u00e1\u0083\u009b\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0098 \u00e1\u0083\u00a1\u00e1\u0083\u0094\u00e1\u0083\u00a5_\u00e1\u0083\u009d\u00e1\u0083\u00a5\u00e1\u0083\u00a2\u00e1\u0083\u009d\u00e1\u0083\u009b\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0098 \u00e1\u0083\u009d\u00e1\u0083\u00a5\u00e1\u0083\u00a2_\u00e1\u0083\u009c\u00e1\u0083\u009d\u00e1\u0083\u0094\u00e1\u0083\u009b\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0098 \u00e1\u0083\u009c\u00e1\u0083\u009d\u00e1\u0083\u0094_\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u0099\u00e1\u0083\u0094\u00e1\u0083\u009b\u00e1\u0083\u0091\u00e1\u0083\u0094\u00e1\u0083\u00a0\u00e1\u0083\u0098 \u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u0099'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var i,\n            expected = '\u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0090 \u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098 \u00e1\u0083\u0099\u00e1\u0083\u0095_\u00e1\u0083\u009d\u00e1\u0083\u00a0\u00e1\u0083\u00a8\u00e1\u0083\u0090\u00e1\u0083\u0091\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098 \u00e1\u0083\u009d\u00e1\u0083\u00a0\u00e1\u0083\u00a8 \u00e1\u0083\u009d\u00e1\u0083\u00a0_\u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u00a8\u00e1\u0083\u0090\u00e1\u0083\u0091\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u009b \u00e1\u0083\u00a1\u00e1\u0083\u0090_\u00e1\u0083\u009d\u00e1\u0083\u0097\u00e1\u0083\u00ae\u00e1\u0083\u00a8\u00e1\u0083\u0090\u00e1\u0083\u0091\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098 \u00e1\u0083\u009d\u00e1\u0083\u0097\u00e1\u0083\u00ae \u00e1\u0083\u009d\u00e1\u0083\u0097_\u00e1\u0083\u00ae\u00e1\u0083\u00a3\u00e1\u0083\u0097\u00e1\u0083\u00a8\u00e1\u0083\u0090\u00e1\u0083\u0091\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098 \u00e1\u0083\u00ae\u00e1\u0083\u00a3\u00e1\u0083\u0097 \u00e1\u0083\u00ae\u00e1\u0083\u00a3_\u00e1\u0083\u009e\u00e1\u0083\u0090\u00e1\u0083\u00a0\u00e1\u0083\u0090\u00e1\u0083\u00a1\u00e1\u0083\u0099\u00e1\u0083\u0094\u00e1\u0083\u0095\u00e1\u0083\u0098 \u00e1\u0083\u009e\u00e1\u0083\u0090\u00e1\u0083\u00a0 \u00e1\u0083\u009e\u00e1\u0083\u0090_\u00e1\u0083\u00a8\u00e1\u0083\u0090\u00e1\u0083\u0091\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098 \u00e1\u0083\u00a8\u00e1\u0083\u0090\u00e1\u0083\u0091 \u00e1\u0083\u00a8\u00e1\u0083\u0090'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}),  true), '\u00e1\u0083\u00a0\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u009c\u00e1\u0083\u0098\u00e1\u0083\u009b\u00e1\u0083\u0094 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0098', '44 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0098  = \u00e1\u0083\u00a0\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u009c\u00e1\u0083\u0098\u00e1\u0083\u009b\u00e1\u0083\u0094 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}),  true), '\u00e1\u0083\u00ac\u00e1\u0083\u00a3\u00e1\u0083\u0097\u00e1\u0083\u0098',           '45 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0098  = \u00e1\u0083\u00ac\u00e1\u0083\u00a3\u00e1\u0083\u0097\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}),  true), '\u00e1\u0083\u00ac\u00e1\u0083\u00a3\u00e1\u0083\u0097\u00e1\u0083\u0098',           '89 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0098  = \u00e1\u0083\u00ac\u00e1\u0083\u00a3\u00e1\u0083\u0097\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}),  true), '2 \u00e1\u0083\u00ac\u00e1\u0083\u00a3\u00e1\u0083\u0097\u00e1\u0083\u0098',         '90 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0098  = 2 \u00e1\u0083\u00ac\u00e1\u0083\u00a3\u00e1\u0083\u0097\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}),  true), '44 \u00e1\u0083\u00ac\u00e1\u0083\u00a3\u00e1\u0083\u0097\u00e1\u0083\u0098',        '44 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0098  = 44 \u00e1\u0083\u00ac\u00e1\u0083\u00a3\u00e1\u0083\u0097\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}),  true), '\u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098',          '45 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0098  = \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}),  true), '\u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098',          '89 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0098  = \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}),  true), '2 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098',        '90 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0098  = 2 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}),   true), '5 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098',        '5 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098  = 5 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}),  true), '21 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098',       '21 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098 = 21 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}),  true), '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094',            '22 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098 = \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}),  true), '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094',            '35 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098 = \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}),  true), '2 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094',          '36 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098 = 2 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}),   true), '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094',            '1 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094    = \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}),   true), '5 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094',          '5 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094    = 5 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}),  true), '25 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094',         '25 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094   = 25 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}),  true), '\u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094',            '26 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094   = \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}),  true), '\u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094',            '30 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094   = \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}),  true), '\u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094',            '45 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094   = \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}),  true), '2 \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094',          '46 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094   = 2 \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}),  true), '2 \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094',          '75 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094   = 2 \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}),  true), '3 \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094',          '76 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094   = 3 \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}),   true), '\u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094',            '1 \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094    = \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}),   true), '5 \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094',          '5 \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094    = 5 \u00e1\u0083\u0097\u00e1\u0083\u0095\u00e1\u0083\u0094');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e1\u0083\u00ac\u00e1\u0083\u0094\u00e1\u0083\u009a\u00e1\u0083\u0098',           '345 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094  = \u00e1\u0083\u00ac\u00e1\u0083\u0094\u00e1\u0083\u009a\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00e1\u0083\u00ac\u00e1\u0083\u0094\u00e1\u0083\u009a\u00e1\u0083\u0098',         '548 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094  = 2 \u00e1\u0083\u00ac\u00e1\u0083\u0094\u00e1\u0083\u009a\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}),   true), '\u00e1\u0083\u00ac\u00e1\u0083\u0094\u00e1\u0083\u009a\u00e1\u0083\u0098',           '1 \u00e1\u0083\u00ac\u00e1\u0083\u0094\u00e1\u0083\u009a\u00e1\u0083\u0098   = \u00e1\u0083\u00ac\u00e1\u0083\u0094\u00e1\u0083\u009a\u00e1\u0083\u0098');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}),   true), '5 \u00e1\u0083\u00ac\u00e1\u0083\u0094\u00e1\u0083\u009a\u00e1\u0083\u0098',         '5 \u00e1\u0083\u00ac\u00e1\u0083\u0094\u00e1\u0083\u009a\u00e1\u0083\u0098   = 5 \u00e1\u0083\u00ac\u00e1\u0083\u0094\u00e1\u0083\u009a\u00e1\u0083\u0098');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e1\u0083\u00a0\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u009c\u00e1\u0083\u0098\u00e1\u0083\u009b\u00e1\u0083\u0094 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u00a8\u00e1\u0083\u0098',     '\u00e1\u0083\u00a8\u00e1\u0083\u0098 \u00e1\u0083\u00a1\u00e1\u0083\u00a3\u00e1\u0083\u00a4\u00e1\u0083\u0098\u00e1\u0083\u00a5\u00e1\u0083\u00a1\u00e1\u0083\u0098');\n        assert.equal(moment(0).from(30000), '\u00e1\u0083\u00a0\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u009c\u00e1\u0083\u0098\u00e1\u0083\u009b\u00e1\u0083\u0094 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0098\u00e1\u0083\u00a1 \u00e1\u0083\u00ac\u00e1\u0083\u0098\u00e1\u0083\u009c', '\u00e1\u0083\u00ac\u00e1\u0083\u0098\u00e1\u0083\u009c \u00e1\u0083\u00a1\u00e1\u0083\u00a3\u00e1\u0083\u00a4\u00e1\u0083\u0098\u00e1\u0083\u00a5\u00e1\u0083\u00a1\u00e1\u0083\u0098');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e1\u0083\u00a0\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u009c\u00e1\u0083\u0098\u00e1\u0083\u009b\u00e1\u0083\u0094 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0098\u00e1\u0083\u00a1 \u00e1\u0083\u00ac\u00e1\u0083\u0098\u00e1\u0083\u009c', '\u00e1\u0083\u00a3\u00e1\u0083\u009c\u00e1\u0083\u0093\u00e1\u0083\u0090 \u00e1\u0083\u0090\u00e1\u0083\u00a9\u00e1\u0083\u0095\u00e1\u0083\u0094\u00e1\u0083\u009c\u00e1\u0083\u009d\u00e1\u0083\u00a1 \u00e1\u0083\u00a0\u00e1\u0083\u009d\u00e1\u0083\u0092\u00e1\u0083\u009d\u00e1\u0083\u00a0\u00e1\u0083\u00aa \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u00a0\u00e1\u0083\u00a1\u00e1\u0083\u00a3\u00e1\u0083\u009a\u00e1\u0083\u0098');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e1\u0083\u00a0\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u009c\u00e1\u0083\u0098\u00e1\u0083\u009b\u00e1\u0083\u0094 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u00a8\u00e1\u0083\u0098', '\u00e1\u0083\u00a0\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u009c\u00e1\u0083\u0098\u00e1\u0083\u009b\u00e1\u0083\u0094 \u00e1\u0083\u00ac\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u00a8\u00e1\u0083\u0098');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a8\u00e1\u0083\u0098', '5 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a8\u00e1\u0083\u0098');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a1 12:00 PM-\u00e1\u0083\u0096\u00e1\u0083\u0094',  '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a1 \u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u0095\u00e1\u0083\u0094 \u00e1\u0083\u0093\u00e1\u0083\u00a0\u00e1\u0083\u009d\u00e1\u0083\u00a1');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a1 12:25 PM-\u00e1\u0083\u0096\u00e1\u0083\u0094',  '\u00e1\u0083\u0090\u00e1\u0083\u00ae\u00e1\u0083\u009a\u00e1\u0083\u0090\u00e1\u0083\u009c\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u009a \u00e1\u0083\u0093\u00e1\u0083\u00a0\u00e1\u0083\u009d\u00e1\u0083\u00a1 \u00e1\u0083\u0093\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u00a2\u00e1\u0083\u0094\u00e1\u0083\u0091\u00e1\u0083\u00a3\u00e1\u0083\u009a\u00e1\u0083\u0098 25 \u00e1\u0083\u00ac\u00e1\u0083\u00a3\u00e1\u0083\u0097\u00e1\u0083\u0098');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a1 1:00 PM-\u00e1\u0083\u0096\u00e1\u0083\u0094',   '\u00e1\u0083\u0090\u00e1\u0083\u00ae\u00e1\u0083\u009a\u00e1\u0083\u0090\u00e1\u0083\u009c\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u009a \u00e1\u0083\u0093\u00e1\u0083\u00a0\u00e1\u0083\u009d\u00e1\u0083\u00a1 \u00e1\u0083\u0093\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u00a2\u00e1\u0083\u0094\u00e1\u0083\u0091\u00e1\u0083\u00a3\u00e1\u0083\u009a\u00e1\u0083\u0098 1 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e1\u0083\u00ae\u00e1\u0083\u0095\u00e1\u0083\u0090\u00e1\u0083\u009a 12:00 PM-\u00e1\u0083\u0096\u00e1\u0083\u0094',  '\u00e1\u0083\u00ae\u00e1\u0083\u0095\u00e1\u0083\u0090\u00e1\u0083\u009a \u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u0095\u00e1\u0083\u0094 \u00e1\u0083\u0093\u00e1\u0083\u00a0\u00e1\u0083\u009d\u00e1\u0083\u00a1');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a1 11:00 AM-\u00e1\u0083\u0096\u00e1\u0083\u0094',  '\u00e1\u0083\u0090\u00e1\u0083\u00ae\u00e1\u0083\u009a\u00e1\u0083\u0090\u00e1\u0083\u009c\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u009a \u00e1\u0083\u0093\u00e1\u0083\u00a0\u00e1\u0083\u009d\u00e1\u0083\u00a1 \u00e1\u0083\u0092\u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u009d\u00e1\u0083\u0099\u00e1\u0083\u009a\u00e1\u0083\u0094\u00e1\u0083\u0091\u00e1\u0083\u00a3\u00e1\u0083\u009a\u00e1\u0083\u0098 1 \u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u0090\u00e1\u0083\u0097\u00e1\u0083\u0098');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e1\u0083\u0092\u00e1\u0083\u00a3\u00e1\u0083\u00a8\u00e1\u0083\u0098\u00e1\u0083\u009c 12:00 PM-\u00e1\u0083\u0096\u00e1\u0083\u0094', '\u00e1\u0083\u0092\u00e1\u0083\u00a3\u00e1\u0083\u00a8\u00e1\u0083\u0098\u00e1\u0083\u009c \u00e1\u0083\u0090\u00e1\u0083\u009b\u00e1\u0083\u0090\u00e1\u0083\u0095\u00e1\u0083\u0094 \u00e1\u0083\u0093\u00e1\u0083\u00a0\u00e1\u0083\u009d\u00e1\u0083\u00a1');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e1\u0083\u00a8\u00e1\u0083\u0094\u00e1\u0083\u009b\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u0092] dddd LT[-\u00e1\u0083\u0096\u00e1\u0083\u0094]'),  '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a1 + ' + i + ' \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094 \u00e1\u0083\u0090\u00e1\u0083\u00ae\u00e1\u0083\u009a\u00e1\u0083\u0090\u00e1\u0083\u009c\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u009a \u00e1\u0083\u0093\u00e1\u0083\u00a0\u00e1\u0083\u009d\u00e1\u0083\u00a1');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e1\u0083\u00a8\u00e1\u0083\u0094\u00e1\u0083\u009b\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u0092] dddd LT[-\u00e1\u0083\u0096\u00e1\u0083\u0094]'),  '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a1 + ' + i + ' \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0098\u00e1\u0083\u00a1 \u00e1\u0083\u0093\u00e1\u0083\u0090\u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u00ac\u00e1\u0083\u00a7\u00e1\u0083\u0098\u00e1\u0083\u00a1\u00e1\u0083\u00a8\u00e1\u0083\u0098');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e1\u0083\u00a8\u00e1\u0083\u0094\u00e1\u0083\u009b\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u0092] dddd LT[-\u00e1\u0083\u0096\u00e1\u0083\u0094]'),  '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a1 + ' + i + ' \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0098\u00e1\u0083\u00a1 \u00e1\u0083\u0093\u00e1\u0083\u0090\u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u00a1\u00e1\u0083\u00a0\u00e1\u0083\u00a3\u00e1\u0083\u009a\u00e1\u0083\u00a1');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e1\u0083\u00ac\u00e1\u0083\u0098\u00e1\u0083\u009c\u00e1\u0083\u0090] dddd LT[-\u00e1\u0083\u0096\u00e1\u0083\u0094]'),  '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a1 - ' + i + ' \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094 \u00e1\u0083\u0090\u00e1\u0083\u00ae\u00e1\u0083\u009a\u00e1\u0083\u0090\u00e1\u0083\u009c\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u009a \u00e1\u0083\u0093\u00e1\u0083\u00a0\u00e1\u0083\u009d\u00e1\u0083\u00a1');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e1\u0083\u00ac\u00e1\u0083\u0098\u00e1\u0083\u009c\u00e1\u0083\u0090] dddd LT[-\u00e1\u0083\u0096\u00e1\u0083\u0094]'),  '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a1 - ' + i + ' \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0098\u00e1\u0083\u00a1 \u00e1\u0083\u0093\u00e1\u0083\u0090\u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u00ac\u00e1\u0083\u00a7\u00e1\u0083\u0098\u00e1\u0083\u00a1\u00e1\u0083\u00a8\u00e1\u0083\u0098');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e1\u0083\u00ac\u00e1\u0083\u0098\u00e1\u0083\u009c\u00e1\u0083\u0090] dddd LT[-\u00e1\u0083\u0096\u00e1\u0083\u0094]'),  '\u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094\u00e1\u0083\u00a1 - ' + i + ' \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0094 \u00e1\u0083\u0093\u00e1\u0083\u00a6\u00e1\u0083\u0098\u00e1\u0083\u00a1 \u00e1\u0083\u0093\u00e1\u0083\u0090\u00e1\u0083\u00a1\u00e1\u0083\u0090\u00e1\u0083\u00a1\u00e1\u0083\u00a0\u00e1\u0083\u00a3\u00e1\u0083\u009a\u00e1\u0083\u00a1');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 \u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0098\u00e1\u0083\u00a1 \u00e1\u0083\u00ac\u00e1\u0083\u0098\u00e1\u0083\u009c');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '1 \u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0090\u00e1\u0083\u00a8\u00e1\u0083\u0098');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 \u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0098\u00e1\u0083\u00a1 \u00e1\u0083\u00ac\u00e1\u0083\u0098\u00e1\u0083\u009c');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '2 \u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0090\u00e1\u0083\u00a8\u00e1\u0083\u0098');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-\u00e1\u0083\u009a\u00e1\u0083\u0098', '\u00e1\u0083\u0093\u00e1\u0083\u0094\u00e1\u0083\u0099 26 2011 \u00e1\u0083\u00a3\u00e1\u0083\u009c\u00e1\u0083\u0093\u00e1\u0083\u0090 \u00e1\u0083\u0098\u00e1\u0083\u00a7\u00e1\u0083\u009d\u00e1\u0083\u00a1 \u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0090 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-\u00e1\u0083\u009a\u00e1\u0083\u0098', '\u00e1\u0083\u0098\u00e1\u0083\u0090\u00e1\u0083\u009c  1 2012 \u00e1\u0083\u00a3\u00e1\u0083\u009c\u00e1\u0083\u0093\u00e1\u0083\u0090 \u00e1\u0083\u0098\u00e1\u0083\u00a7\u00e1\u0083\u009d\u00e1\u0083\u00a1 \u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0090 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 \u00e1\u0083\u009b\u00e1\u0083\u0094-2', '\u00e1\u0083\u0098\u00e1\u0083\u0090\u00e1\u0083\u009c  2 2012 \u00e1\u0083\u00a3\u00e1\u0083\u009c\u00e1\u0083\u0093\u00e1\u0083\u0090 \u00e1\u0083\u0098\u00e1\u0083\u00a7\u00e1\u0083\u009d\u00e1\u0083\u00a1 \u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0090 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 \u00e1\u0083\u009b\u00e1\u0083\u0094-2', '\u00e1\u0083\u0098\u00e1\u0083\u0090\u00e1\u0083\u009c  8 2012 \u00e1\u0083\u00a3\u00e1\u0083\u009c\u00e1\u0083\u0093\u00e1\u0083\u0090 \u00e1\u0083\u0098\u00e1\u0083\u00a7\u00e1\u0083\u009d\u00e1\u0083\u00a1 \u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0090 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 \u00e1\u0083\u009b\u00e1\u0083\u0094-3', '\u00e1\u0083\u0098\u00e1\u0083\u0090\u00e1\u0083\u009c  9 2012 \u00e1\u0083\u00a3\u00e1\u0083\u009c\u00e1\u0083\u0093\u00e1\u0083\u0090 \u00e1\u0083\u0098\u00e1\u0083\u00a7\u00e1\u0083\u009d\u00e1\u0083\u00a1 \u00e1\u0083\u0099\u00e1\u0083\u0095\u00e1\u0083\u0098\u00e1\u0083\u00a0\u00e1\u0083\u0090 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('kk');\n\n    test('parse', function (assert) {\n        var tests = '\u00d2\u009b\u00d0\u00b0\u00d2\u00a3\u00d1\u0082\u00d0\u00b0\u00d1\u0080 \u00d2\u009b\u00d0\u00b0\u00d2\u00a3_\u00d0\u00b0\u00d2\u009b\u00d0\u00bf\u00d0\u00b0\u00d0\u00bd \u00d0\u00b0\u00d2\u009b\u00d0\u00bf_\u00d0\u00bd\u00d0\u00b0\u00d1\u0083\u00d1\u0080\u00d1\u008b\u00d0\u00b7 \u00d0\u00bd\u00d0\u00b0\u00d1\u0083_\u00d1\u0081\u00d3\u0099\u00d1\u0083\u00d1\u0096\u00d1\u0080 \u00d1\u0081\u00d3\u0099\u00d1\u0083_\u00d0\u00bc\u00d0\u00b0\u00d0\u00bc\u00d1\u008b\u00d1\u0080 \u00d0\u00bc\u00d0\u00b0\u00d0\u00bc_\u00d0\u00bc\u00d0\u00b0\u00d1\u0083\u00d1\u0081\u00d1\u008b\u00d0\u00bc \u00d0\u00bc\u00d0\u00b0\u00d1\u0083_\u00d1\u0088\u00d1\u0096\u00d0\u00bb\u00d0\u00b4\u00d0\u00b5 \u00d1\u0088\u00d1\u0096\u00d0\u00bb_\u00d1\u0082\u00d0\u00b0\u00d0\u00bc\u00d1\u008b\u00d0\u00b7 \u00d1\u0082\u00d0\u00b0\u00d0\u00bc_\u00d2\u009b\u00d1\u008b\u00d1\u0080\u00d0\u00ba\u00d2\u00af\u00d0\u00b9\u00d0\u00b5\u00d0\u00ba \u00d2\u009b\u00d1\u008b\u00d1\u0080_\u00d2\u009b\u00d0\u00b0\u00d0\u00b7\u00d0\u00b0\u00d0\u00bd \u00d2\u009b\u00d0\u00b0\u00d0\u00b7_\u00d2\u009b\u00d0\u00b0\u00d1\u0080\u00d0\u00b0\u00d1\u0088\u00d0\u00b0 \u00d2\u009b\u00d0\u00b0\u00d1\u0080_\u00d0\u00b6\u00d0\u00b5\u00d0\u00bb\u00d1\u0082\u00d0\u00be\u00d2\u009b\u00d1\u0081\u00d0\u00b0\u00d0\u00bd \u00d0\u00b6\u00d0\u00b5\u00d0\u00bb'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, HH:mm:ss',       '\u00d0\u00b6\u00d0\u00b5\u00d0\u00ba\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d0\u00b1\u00d1\u0096, 14-\u00d1\u0088\u00d1\u0096 \u00d0\u00b0\u00d2\u009b\u00d0\u00bf\u00d0\u00b0\u00d0\u00bd 2010, 15:25:50'],\n                ['ddd, hA',                            '\u00d0\u00b6\u00d0\u00b5\u00d0\u00ba, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2-\u00d1\u0088\u00d1\u0096 02 \u00d0\u00b0\u00d2\u009b\u00d0\u00bf\u00d0\u00b0\u00d0\u00bd \u00d0\u00b0\u00d2\u009b\u00d0\u00bf'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14-\u00d1\u0088\u00d1\u0096 14'],\n                ['d do dddd ddd dd',                   '0 0-\u00d1\u0088\u00d1\u0096 \u00d0\u00b6\u00d0\u00b5\u00d0\u00ba\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d0\u00b1\u00d1\u0096 \u00d0\u00b6\u00d0\u00b5\u00d0\u00ba \u00d0\u00b6\u00d0\u00ba'],\n                ['DDD DDDo DDDD',                      '45 45-\u00d1\u0088\u00d1\u0096 045'],\n                ['w wo ww',                            '7 7-\u00d1\u0088\u00d1\u0096 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[\u00d0\u00b6\u00d1\u008b\u00d0\u00bb\u00d0\u00b4\u00d1\u008b\u00d2\u00a3] DDDo [\u00d0\u00ba\u00d2\u00af\u00d0\u00bd\u00d1\u0096]',               '\u00d0\u00b6\u00d1\u008b\u00d0\u00bb\u00d0\u00b4\u00d1\u008b\u00d2\u00a3 45-\u00d1\u0088\u00d1\u0096 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd\u00d1\u0096'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 \u00d0\u00b0\u00d2\u009b\u00d0\u00bf\u00d0\u00b0\u00d0\u00bd 2010'],\n                ['LLL',                                '14 \u00d0\u00b0\u00d2\u009b\u00d0\u00bf\u00d0\u00b0\u00d0\u00bd 2010 15:25'],\n                ['LLLL',                               '\u00d0\u00b6\u00d0\u00b5\u00d0\u00ba\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d0\u00b1\u00d1\u0096, 14 \u00d0\u00b0\u00d2\u009b\u00d0\u00bf\u00d0\u00b0\u00d0\u00bd 2010 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 \u00d0\u00b0\u00d2\u009b\u00d0\u00bf 2010'],\n                ['lll',                                '14 \u00d0\u00b0\u00d2\u009b\u00d0\u00bf 2010 15:25'],\n                ['llll',                               '\u00d0\u00b6\u00d0\u00b5\u00d0\u00ba, 14 \u00d0\u00b0\u00d2\u009b\u00d0\u00bf 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-\u00d1\u0088\u00d1\u0096', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-\u00d1\u0088\u00d1\u0096', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-\u00d1\u0088\u00d1\u0096', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-\u00d1\u0088\u00d1\u0096', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-\u00d1\u0088\u00d1\u0096', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-\u00d1\u0088\u00d1\u008b', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-\u00d1\u0088\u00d1\u0096', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-\u00d1\u0088\u00d1\u0096', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-\u00d1\u0088\u00d1\u008b', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-\u00d1\u0088\u00d1\u008b', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-\u00d1\u0088\u00d1\u0096', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-\u00d1\u0088\u00d1\u0096', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-\u00d1\u0088\u00d1\u0096', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-\u00d1\u0088\u00d1\u0096', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-\u00d1\u0088\u00d1\u0096', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-\u00d1\u0088\u00d1\u008b', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-\u00d1\u0088\u00d1\u0096', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-\u00d1\u0088\u00d1\u0096', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-\u00d1\u0088\u00d1\u008b', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-\u00d1\u0088\u00d1\u008b', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-\u00d1\u0088\u00d1\u0096', '21st');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-\u00d1\u0088\u00d1\u0096', '22nd');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-\u00d1\u0088\u00d1\u0096', '23rd');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-\u00d1\u0088\u00d1\u0096', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-\u00d1\u0088\u00d1\u0096', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-\u00d1\u0088\u00d1\u008b', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-\u00d1\u0088\u00d1\u0096', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-\u00d1\u0088\u00d1\u0096', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-\u00d1\u0088\u00d1\u008b', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-\u00d1\u0088\u00d1\u008b', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-\u00d1\u0088\u00d1\u0096', '31st');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d2\u009b\u00d0\u00b0\u00d2\u00a3\u00d1\u0082\u00d0\u00b0\u00d1\u0080 \u00d2\u009b\u00d0\u00b0\u00d2\u00a3_\u00d0\u00b0\u00d2\u009b\u00d0\u00bf\u00d0\u00b0\u00d0\u00bd \u00d0\u00b0\u00d2\u009b\u00d0\u00bf_\u00d0\u00bd\u00d0\u00b0\u00d1\u0083\u00d1\u0080\u00d1\u008b\u00d0\u00b7 \u00d0\u00bd\u00d0\u00b0\u00d1\u0083_\u00d1\u0081\u00d3\u0099\u00d1\u0083\u00d1\u0096\u00d1\u0080 \u00d1\u0081\u00d3\u0099\u00d1\u0083_\u00d0\u00bc\u00d0\u00b0\u00d0\u00bc\u00d1\u008b\u00d1\u0080 \u00d0\u00bc\u00d0\u00b0\u00d0\u00bc_\u00d0\u00bc\u00d0\u00b0\u00d1\u0083\u00d1\u0081\u00d1\u008b\u00d0\u00bc \u00d0\u00bc\u00d0\u00b0\u00d1\u0083_\u00d1\u0088\u00d1\u0096\u00d0\u00bb\u00d0\u00b4\u00d0\u00b5 \u00d1\u0088\u00d1\u0096\u00d0\u00bb_\u00d1\u0082\u00d0\u00b0\u00d0\u00bc\u00d1\u008b\u00d0\u00b7 \u00d1\u0082\u00d0\u00b0\u00d0\u00bc_\u00d2\u009b\u00d1\u008b\u00d1\u0080\u00d0\u00ba\u00d2\u00af\u00d0\u00b9\u00d0\u00b5\u00d0\u00ba \u00d2\u009b\u00d1\u008b\u00d1\u0080_\u00d2\u009b\u00d0\u00b0\u00d0\u00b7\u00d0\u00b0\u00d0\u00bd \u00d2\u009b\u00d0\u00b0\u00d0\u00b7_\u00d2\u009b\u00d0\u00b0\u00d1\u0080\u00d0\u00b0\u00d1\u0088\u00d0\u00b0 \u00d2\u009b\u00d0\u00b0\u00d1\u0080_\u00d0\u00b6\u00d0\u00b5\u00d0\u00bb\u00d1\u0082\u00d0\u00be\u00d2\u009b\u00d1\u0081\u00d0\u00b0\u00d0\u00bd \u00d0\u00b6\u00d0\u00b5\u00d0\u00bb'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d0\u00b6\u00d0\u00b5\u00d0\u00ba\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d0\u00b1\u00d1\u0096 \u00d0\u00b6\u00d0\u00b5\u00d0\u00ba \u00d0\u00b6\u00d0\u00ba_\u00d0\u00b4\u00d2\u00af\u00d0\u00b9\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d0\u00b1\u00d1\u0096 \u00d0\u00b4\u00d2\u00af\u00d0\u00b9 \u00d0\u00b4\u00d0\u00b9_\u00d1\u0081\u00d0\u00b5\u00d0\u00b9\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d0\u00b1\u00d1\u0096 \u00d1\u0081\u00d0\u00b5\u00d0\u00b9 \u00d1\u0081\u00d0\u00b9_\u00d1\u0081\u00d3\u0099\u00d1\u0080\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d0\u00b1\u00d1\u0096 \u00d1\u0081\u00d3\u0099\u00d1\u0080 \u00d1\u0081\u00d1\u0080_\u00d0\u00b1\u00d0\u00b5\u00d0\u00b9\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d0\u00b1\u00d1\u0096 \u00d0\u00b1\u00d0\u00b5\u00d0\u00b9 \u00d0\u00b1\u00d0\u00b9_\u00d0\u00b6\u00d2\u00b1\u00d0\u00bc\u00d0\u00b0 \u00d0\u00b6\u00d2\u00b1\u00d0\u00bc \u00d0\u00b6\u00d0\u00bc_\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d0\u00b1\u00d1\u0096 \u00d1\u0081\u00d0\u00b5\u00d0\u00bd \u00d1\u0081\u00d0\u00bd'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d0\u00b1\u00d1\u0096\u00d1\u0080\u00d0\u00bd\u00d0\u00b5\u00d1\u0088\u00d0\u00b5 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d0\u00b0\u00d0\u00b9',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d0\u00b0\u00d0\u00b9',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d0\u00b0\u00d0\u00b9',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00d0\u00b0\u00d0\u00b9',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00d0\u00b0\u00d0\u00b9',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d0\u00b0\u00d0\u00b9',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d0\u00b0\u00d0\u00b9',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d0\u00b0\u00d0\u00b9',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d0\u00b6\u00d1\u008b\u00d0\u00bb',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00d0\u00b6\u00d1\u008b\u00d0\u00bb',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d0\u00b1\u00d1\u0096\u00d1\u0080 \u00d0\u00b6\u00d1\u008b\u00d0\u00bb',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d0\u00b6\u00d1\u008b\u00d0\u00bb',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d0\u00b1\u00d1\u0096\u00d1\u0080\u00d0\u00bd\u00d0\u00b5\u00d1\u0088\u00d0\u00b5 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 \u00d1\u0096\u00d1\u0088\u00d1\u0096\u00d0\u00bd\u00d0\u00b4\u00d0\u00b5',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00d0\u00b1\u00d1\u0096\u00d1\u0080\u00d0\u00bd\u00d0\u00b5\u00d1\u0088\u00d0\u00b5 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 \u00d0\u00b1\u00d2\u00b1\u00d1\u0080\u00d1\u008b\u00d0\u00bd', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00d0\u00b1\u00d1\u0096\u00d1\u0080\u00d0\u00bd\u00d0\u00b5\u00d1\u0088\u00d0\u00b5 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 \u00d0\u00b1\u00d2\u00b1\u00d1\u0080\u00d1\u008b\u00d0\u00bd',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d0\u00b1\u00d1\u0096\u00d1\u0080\u00d0\u00bd\u00d0\u00b5\u00d1\u0088\u00d0\u00b5 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 \u00d1\u0096\u00d1\u0088\u00d1\u0096\u00d0\u00bd\u00d0\u00b4\u00d0\u00b5', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd \u00d1\u0096\u00d1\u0088\u00d1\u0096\u00d0\u00bd\u00d0\u00b4\u00d0\u00b5', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d0\u0091\u00d2\u00af\u00d0\u00b3\u00d1\u0096\u00d0\u00bd \u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d0\u0091\u00d2\u00af\u00d0\u00b3\u00d1\u0096\u00d0\u00bd \u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d0\u0091\u00d2\u00af\u00d0\u00b3\u00d1\u0096\u00d0\u00bd \u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d0\u0095\u00d1\u0080\u00d1\u0082\u00d0\u00b5\u00d2\u00a3 \u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d0\u0091\u00d2\u00af\u00d0\u00b3\u00d1\u0096\u00d0\u00bd \u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d0\u009a\u00d0\u00b5\u00d1\u0088\u00d0\u00b5 \u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082 12:00',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00d3\u00a8\u00d1\u0082\u00d0\u00ba\u00d0\u00b5\u00d0\u00bd \u00d0\u00b0\u00d0\u00bf\u00d1\u0082\u00d0\u00b0\u00d0\u00bd\u00d1\u008b\u00d2\u00a3] dddd [\u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00d3\u00a8\u00d1\u0082\u00d0\u00ba\u00d0\u00b5\u00d0\u00bd \u00d0\u00b0\u00d0\u00bf\u00d1\u0082\u00d0\u00b0\u00d0\u00bd\u00d1\u008b\u00d2\u00a3] dddd [\u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00d3\u00a8\u00d1\u0082\u00d0\u00ba\u00d0\u00b5\u00d0\u00bd \u00d0\u00b0\u00d0\u00bf\u00d1\u0082\u00d0\u00b0\u00d0\u00bd\u00d1\u008b\u00d2\u00a3] dddd [\u00d1\u0081\u00d0\u00b0\u00d2\u0093\u00d0\u00b0\u00d1\u0082] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'),   '1 01 1-\u00d1\u0088\u00d1\u0096', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '2 02 2-\u00d1\u0088\u00d1\u0096', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '2 02 2-\u00d1\u0088\u00d1\u0096', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '3 03 3-\u00d1\u0088\u00d1\u0096', 'Jan  9 2012 should be week 3');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '3 03 3-\u00d1\u0088\u00d1\u0096', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('km');\n\n    test('parse', function (assert) {\n        var tests = '\u00e1\u009e\u0098\u00e1\u009e\u0080\u00e1\u009e\u009a\u00e1\u009e\u00b6 \u00e1\u009e\u0098\u00e1\u009e\u0080\u00e1\u009e\u009a\u00e1\u009e\u00b6_\u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088 \u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088_\u00e1\u009e\u0098\u00e1\u009e\u00b8\u00e1\u009e\u0093\u00e1\u009e\u00b6 \u00e1\u009e\u0098\u00e1\u009e\u00b8\u00e1\u009e\u0093\u00e1\u009e\u00b6_\u00e1\u009e\u0098\u00e1\u009f\u0081\u00e1\u009e\u009f\u00e1\u009e\u00b6 \u00e1\u009e\u0098\u00e1\u009f\u0081\u00e1\u009e\u009f\u00e1\u009e\u00b6_\u00e1\u009e\u00a7\u00e1\u009e\u009f\u00e1\u009e\u0097\u00e1\u009e\u00b6 \u00e1\u009e\u00a7\u00e1\u009e\u009f\u00e1\u009e\u0097\u00e1\u009e\u00b6_\u00e1\u009e\u0098\u00e1\u009e\u00b7\u00e1\u009e\u0090\u00e1\u009e\u00bb\u00e1\u009e\u0093\u00e1\u009e\u00b6 \u00e1\u009e\u0098\u00e1\u009e\u00b7\u00e1\u009e\u0090\u00e1\u009e\u00bb\u00e1\u009e\u0093\u00e1\u009e\u00b6_\u00e1\u009e\u0080\u00e1\u009e\u0080\u00e1\u009f\u0092\u00e1\u009e\u0080\u00e1\u009e\u008a\u00e1\u009e\u00b6 \u00e1\u009e\u0080\u00e1\u009e\u0080\u00e1\u009f\u0092\u00e1\u009e\u0080\u00e1\u009e\u008a\u00e1\u009e\u00b6_\u00e1\u009e\u009f\u00e1\u009e\u00b8\u00e1\u009e\u00a0\u00e1\u009e\u00b6 \u00e1\u009e\u009f\u00e1\u009e\u00b8\u00e1\u009e\u00a0\u00e1\u009e\u00b6_\u00e1\u009e\u0080\u00e1\u009e\u0089\u00e1\u009f\u0092\u00e1\u009e\u0089\u00e1\u009e\u00b6 \u00e1\u009e\u0080\u00e1\u009e\u0089\u00e1\u009f\u0092\u00e1\u009e\u0089\u00e1\u009e\u00b6_\u00e1\u009e\u008f\u00e1\u009e\u00bb\u00e1\u009e\u009b\u00e1\u009e\u00b6 \u00e1\u009e\u008f\u00e1\u009e\u00bb\u00e1\u009e\u009b\u00e1\u009e\u00b6_\u00e1\u009e\u009c\u00e1\u009e\u00b7\u00e1\u009e\u0085\u00e1\u009f\u0092\u00e1\u009e\u0086\u00e1\u009e\u00b7\u00e1\u009e\u0080\u00e1\u009e\u00b6 \u00e1\u009e\u009c\u00e1\u009e\u00b7\u00e1\u009e\u0085\u00e1\u009f\u0092\u00e1\u009e\u0086\u00e1\u009e\u00b7\u00e1\u009e\u0080\u00e1\u009e\u00b6_\u00e1\u009e\u0092\u00e1\u009f\u0092\u00e1\u009e\u0093\u00e1\u009e\u00bc \u00e1\u009e\u0092\u00e1\u009f\u0092\u00e1\u009e\u0093\u00e1\u009e\u00bc'.split('_'),\n            i;\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a', '\u00e1\u009e\u00a2\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b7\u00e1\u009e\u008f\u00e1\u009f\u0092\u00e1\u009e\u0099, \u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088 14 2010, 3:25:50 pm'],\n                ['ddd, hA', '\u00e1\u009e\u00a2\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b7\u00e1\u009e\u008f\u00e1\u009f\u0092\u00e1\u009e\u0099, 3PM'],\n                ['M Mo MM MMMM MMM', '2 2 02 \u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088 \u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088'],\n                ['YYYY YY', '2010 10'],\n                ['D Do DD', '14 14 14'],\n                ['d do dddd ddd dd', '0 0 \u00e1\u009e\u00a2\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b7\u00e1\u009e\u008f\u00e1\u009f\u0092\u00e1\u009e\u0099 \u00e1\u009e\u00a2\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b7\u00e1\u009e\u008f\u00e1\u009f\u0092\u00e1\u009e\u0099 \u00e1\u009e\u00a2\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b7\u00e1\u009e\u008f\u00e1\u009f\u0092\u00e1\u009e\u0099'],\n                ['DDD DDDo DDDD', '45 45 045'],\n                ['w wo ww', '6 6 06'],\n                ['h hh', '3 03'],\n                ['H HH', '15 15'],\n                ['m mm', '25 25'],\n                ['s ss', '50 50'],\n                ['a A', 'pm PM'],\n                ['[the] DDDo [day of the year]', 'the 45 day of the year'],\n                ['LTS', '15:25:50'],\n                ['L', '14/02/2010'],\n                ['LL', '14 \u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088 2010'],\n                ['LLL', '14 \u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088 2010 15:25'],\n                ['LLLL', '\u00e1\u009e\u00a2\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b7\u00e1\u009e\u008f\u00e1\u009f\u0092\u00e1\u009e\u0099, 14 \u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088 2010 15:25'],\n                ['l', '14/2/2010'],\n                ['ll', '14 \u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088 2010'],\n                ['lll', '14 \u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088 2010 15:25'],\n                ['llll', '\u00e1\u009e\u00a2\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b7\u00e1\u009e\u008f\u00e1\u009f\u0092\u00e1\u009e\u0099, 14 \u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21st');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22nd');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23rd');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31st');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e1\u009e\u0098\u00e1\u009e\u0080\u00e1\u009e\u009a\u00e1\u009e\u00b6 \u00e1\u009e\u0098\u00e1\u009e\u0080\u00e1\u009e\u009a\u00e1\u009e\u00b6_\u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088 \u00e1\u009e\u0080\u00e1\u009e\u00bb\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u0097\u00e1\u009f\u0088_\u00e1\u009e\u0098\u00e1\u009e\u00b8\u00e1\u009e\u0093\u00e1\u009e\u00b6 \u00e1\u009e\u0098\u00e1\u009e\u00b8\u00e1\u009e\u0093\u00e1\u009e\u00b6_\u00e1\u009e\u0098\u00e1\u009f\u0081\u00e1\u009e\u009f\u00e1\u009e\u00b6 \u00e1\u009e\u0098\u00e1\u009f\u0081\u00e1\u009e\u009f\u00e1\u009e\u00b6_\u00e1\u009e\u00a7\u00e1\u009e\u009f\u00e1\u009e\u0097\u00e1\u009e\u00b6 \u00e1\u009e\u00a7\u00e1\u009e\u009f\u00e1\u009e\u0097\u00e1\u009e\u00b6_\u00e1\u009e\u0098\u00e1\u009e\u00b7\u00e1\u009e\u0090\u00e1\u009e\u00bb\u00e1\u009e\u0093\u00e1\u009e\u00b6 \u00e1\u009e\u0098\u00e1\u009e\u00b7\u00e1\u009e\u0090\u00e1\u009e\u00bb\u00e1\u009e\u0093\u00e1\u009e\u00b6_\u00e1\u009e\u0080\u00e1\u009e\u0080\u00e1\u009f\u0092\u00e1\u009e\u0080\u00e1\u009e\u008a\u00e1\u009e\u00b6 \u00e1\u009e\u0080\u00e1\u009e\u0080\u00e1\u009f\u0092\u00e1\u009e\u0080\u00e1\u009e\u008a\u00e1\u009e\u00b6_\u00e1\u009e\u009f\u00e1\u009e\u00b8\u00e1\u009e\u00a0\u00e1\u009e\u00b6 \u00e1\u009e\u009f\u00e1\u009e\u00b8\u00e1\u009e\u00a0\u00e1\u009e\u00b6_\u00e1\u009e\u0080\u00e1\u009e\u0089\u00e1\u009f\u0092\u00e1\u009e\u0089\u00e1\u009e\u00b6 \u00e1\u009e\u0080\u00e1\u009e\u0089\u00e1\u009f\u0092\u00e1\u009e\u0089\u00e1\u009e\u00b6_\u00e1\u009e\u008f\u00e1\u009e\u00bb\u00e1\u009e\u009b\u00e1\u009e\u00b6 \u00e1\u009e\u008f\u00e1\u009e\u00bb\u00e1\u009e\u009b\u00e1\u009e\u00b6_\u00e1\u009e\u009c\u00e1\u009e\u00b7\u00e1\u009e\u0085\u00e1\u009f\u0092\u00e1\u009e\u0086\u00e1\u009e\u00b7\u00e1\u009e\u0080\u00e1\u009e\u00b6 \u00e1\u009e\u009c\u00e1\u009e\u00b7\u00e1\u009e\u0085\u00e1\u009f\u0092\u00e1\u009e\u0086\u00e1\u009e\u00b7\u00e1\u009e\u0080\u00e1\u009e\u00b6_\u00e1\u009e\u0092\u00e1\u009f\u0092\u00e1\u009e\u0093\u00e1\u009e\u00bc \u00e1\u009e\u0092\u00e1\u009f\u0092\u00e1\u009e\u0093\u00e1\u009e\u00bc'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e1\u009e\u00a2\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b7\u00e1\u009e\u008f\u00e1\u009f\u0092\u00e1\u009e\u0099 \u00e1\u009e\u00a2\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b7\u00e1\u009e\u008f\u00e1\u009f\u0092\u00e1\u009e\u0099 \u00e1\u009e\u00a2\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b7\u00e1\u009e\u008f\u00e1\u009f\u0092\u00e1\u009e\u0099_\u00e1\u009e\u0085\u00e1\u009f\u0090\u00e1\u009e\u0093\u00e1\u009f\u0092\u00e1\u009e\u0091 \u00e1\u009e\u0085\u00e1\u009f\u0090\u00e1\u009e\u0093\u00e1\u009f\u0092\u00e1\u009e\u0091 \u00e1\u009e\u0085\u00e1\u009f\u0090\u00e1\u009e\u0093\u00e1\u009f\u0092\u00e1\u009e\u0091_\u00e1\u009e\u00a2\u00e1\u009e\u0084\u00e1\u009f\u0092\u00e1\u009e\u0082\u00e1\u009e\u00b6\u00e1\u009e\u009a \u00e1\u009e\u00a2\u00e1\u009e\u0084\u00e1\u009f\u0092\u00e1\u009e\u0082\u00e1\u009e\u00b6\u00e1\u009e\u009a \u00e1\u009e\u00a2\u00e1\u009e\u0084\u00e1\u009f\u0092\u00e1\u009e\u0082\u00e1\u009e\u00b6\u00e1\u009e\u009a_\u00e1\u009e\u0096\u00e1\u009e\u00bb\u00e1\u009e\u0092 \u00e1\u009e\u0096\u00e1\u009e\u00bb\u00e1\u009e\u0092 \u00e1\u009e\u0096\u00e1\u009e\u00bb\u00e1\u009e\u0092_\u00e1\u009e\u0096\u00e1\u009f\u0092\u00e1\u009e\u009a\u00e1\u009e\u00a0\u00e1\u009e\u009f\u00e1\u009f\u0092\u00e1\u009e\u0094\u00e1\u009e\u008f\u00e1\u009e\u00b7\u00e1\u009f\u008d \u00e1\u009e\u0096\u00e1\u009f\u0092\u00e1\u009e\u009a\u00e1\u009e\u00a0\u00e1\u009e\u009f\u00e1\u009f\u0092\u00e1\u009e\u0094\u00e1\u009e\u008f\u00e1\u009e\u00b7\u00e1\u009f\u008d \u00e1\u009e\u0096\u00e1\u009f\u0092\u00e1\u009e\u009a\u00e1\u009e\u00a0\u00e1\u009e\u009f\u00e1\u009f\u0092\u00e1\u009e\u0094\u00e1\u009e\u008f\u00e1\u009e\u00b7\u00e1\u009f\u008d_\u00e1\u009e\u009f\u00e1\u009e\u00bb\u00e1\u009e\u0080\u00e1\u009f\u0092\u00e1\u009e\u009a \u00e1\u009e\u009f\u00e1\u009e\u00bb\u00e1\u009e\u0080\u00e1\u009f\u0092\u00e1\u009e\u009a \u00e1\u009e\u009f\u00e1\u009e\u00bb\u00e1\u009e\u0080\u00e1\u009f\u0092\u00e1\u009e\u009a_\u00e1\u009e\u009f\u00e1\u009f\u0085\u00e1\u009e\u009a\u00e1\u009f\u008d \u00e1\u009e\u009f\u00e1\u009f\u0085\u00e1\u009e\u009a\u00e1\u009f\u008d \u00e1\u009e\u009f\u00e1\u009f\u0085\u00e1\u009e\u009a\u00e1\u009f\u008d'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), '\u00e1\u009e\u0094\u00e1\u009f\u0089\u00e1\u009e\u00bb\u00e1\u009e\u0093\u00e1\u009f\u0092\u00e1\u009e\u0098\u00e1\u009e\u00b6\u00e1\u009e\u0093\u00e1\u009e\u009c\u00e1\u009e\u00b7\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8', '44 seconds = \u00e1\u009e\u0094\u00e1\u009f\u0089\u00e1\u009e\u00bb\u00e1\u009e\u0093\u00e1\u009f\u0092\u00e1\u009e\u0098\u00e1\u009e\u00b6\u00e1\u009e\u0093\u00e1\u009e\u009c\u00e1\u009e\u00b7\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8', '45 seconds = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8', '89 seconds = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 \u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8', '90 seconds = 2 \u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 \u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8', '44 minutes = 44 \u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084', '45 minutes = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084', '89 minutes = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 \u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084', '90 minutes = 2 \u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 \u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084', '5 hours = 5 \u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 \u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084', '21 hours = 21 \u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083', '22 hours = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083', '35 hours = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 \u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083', '36 hours = 2 \u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083', '1 day = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 \u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083', '5 days = 5 \u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 \u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083', '25 days = 25 \u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0081\u00e1\u009f\u0082', '26 days = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0081\u00e1\u009f\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0081\u00e1\u009f\u0082', '30 days = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0081\u00e1\u009f\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0081\u00e1\u009f\u0082', '43 days = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0081\u00e1\u009f\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 \u00e1\u009e\u0081\u00e1\u009f\u0082', '46 days = 2 \u00e1\u009e\u0081\u00e1\u009f\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 \u00e1\u009e\u0081\u00e1\u009f\u0082', '75 days = 2 \u00e1\u009e\u0081\u00e1\u009f\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 \u00e1\u009e\u0081\u00e1\u009f\u0082', '76 days = 3 \u00e1\u009e\u0081\u00e1\u009f\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0081\u00e1\u009f\u0082', '1 month = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0081\u00e1\u009f\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 \u00e1\u009e\u0081\u00e1\u009f\u0082', '5 months = 5 \u00e1\u009e\u0081\u00e1\u009f\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0086\u00e1\u009f\u0092\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009f\u0086', '345 days = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0086\u00e1\u009f\u0092\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009f\u0086');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00e1\u009e\u0086\u00e1\u009f\u0092\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009f\u0086', '548 days = 2 \u00e1\u009e\u0086\u00e1\u009f\u0092\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009f\u0086');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), '\u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0086\u00e1\u009f\u0092\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009f\u0086', '1 year = \u00e1\u009e\u0098\u00e1\u009e\u00bd\u00e1\u009e\u0099\u00e1\u009e\u0086\u00e1\u009f\u0092\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009f\u0086');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 \u00e1\u009e\u0086\u00e1\u009f\u0092\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009f\u0086', '5 years = 5 \u00e1\u009e\u0086\u00e1\u009f\u0092\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009f\u0086');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e1\u009e\u0094\u00e1\u009f\u0089\u00e1\u009e\u00bb\u00e1\u009e\u0093\u00e1\u009f\u0092\u00e1\u009e\u0098\u00e1\u009e\u00b6\u00e1\u009e\u0093\u00e1\u009e\u009c\u00e1\u009e\u00b7\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8\u00e1\u009e\u0091\u00e1\u009f\u0080\u00e1\u009e\u008f', 'prefix');\n        assert.equal(moment(0).from(30000), '\u00e1\u009e\u0094\u00e1\u009f\u0089\u00e1\u009e\u00bb\u00e1\u009e\u0093\u00e1\u009f\u0092\u00e1\u009e\u0098\u00e1\u009e\u00b6\u00e1\u009e\u0093\u00e1\u009e\u009c\u00e1\u009e\u00b7\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8\u00e1\u009e\u0098\u00e1\u009e\u00bb\u00e1\u009e\u0093', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e1\u009e\u0094\u00e1\u009f\u0089\u00e1\u009e\u00bb\u00e1\u009e\u0093\u00e1\u009f\u0092\u00e1\u009e\u0098\u00e1\u009e\u00b6\u00e1\u009e\u0093\u00e1\u009e\u009c\u00e1\u009e\u00b7\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8\u00e1\u009e\u0098\u00e1\u009e\u00bb\u00e1\u009e\u0093', 'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({\n            s: 30\n        }).fromNow(), '\u00e1\u009e\u0094\u00e1\u009f\u0089\u00e1\u009e\u00bb\u00e1\u009e\u0093\u00e1\u009f\u0092\u00e1\u009e\u0098\u00e1\u009e\u00b6\u00e1\u009e\u0093\u00e1\u009e\u009c\u00e1\u009e\u00b7\u00e1\u009e\u0093\u00e1\u009e\u00b6\u00e1\u009e\u0091\u00e1\u009e\u00b8\u00e1\u009e\u0091\u00e1\u009f\u0080\u00e1\u009e\u008f', 'in a few seconds');\n        assert.equal(moment().add({\n            d: 5\n        }).fromNow(), '5 \u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083\u00e1\u009e\u0091\u00e1\u009f\u0080\u00e1\u009e\u008f', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                  '\u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083\u00e1\u009e\u0093\u00e1\u009f\u0081\u00e1\u009f\u0087 \u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),     '\u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083\u00e1\u009e\u0093\u00e1\u009f\u0081\u00e1\u009f\u0087 \u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),      '\u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083\u00e1\u009e\u0093\u00e1\u009f\u0081\u00e1\u009f\u0087 \u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),      '\u00e1\u009e\u009f\u00e1\u009f\u0092\u00e1\u009e\u00a2\u00e1\u009f\u0082\u00e1\u009e\u0080 \u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084 12:00',    'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(), '\u00e1\u009e\u0090\u00e1\u009f\u0092\u00e1\u009e\u0084\u00e1\u009f\u0083\u00e1\u009e\u0093\u00e1\u009f\u0081\u00e1\u009f\u0087 \u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(), '\u00e1\u009e\u0098\u00e1\u009f\u0092\u00e1\u009e\u009f\u00e1\u009e\u00b7\u00e1\u009e\u009b\u00e1\u009e\u0098\u00e1\u009e\u00b7\u00e1\u009e\u0089 \u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084 12:00', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({\n                d: i\n            });\n            assert.equal(m.calendar(), m.format('dddd [\u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084] LT'), 'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format('dddd [\u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084] LT'), 'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format('dddd [\u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084] LT'), 'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({\n                d: i\n            });\n            assert.equal(m.calendar(), m.format('dddd [\u00e1\u009e\u009f\u00e1\u009e\u0094\u00e1\u009f\u0092\u00e1\u009e\u008f\u00e1\u009e\u00b6\u00e1\u009e\u00a0\u00e1\u009f\u008d\u00e1\u009e\u0098\u00e1\u009e\u00bb\u00e1\u009e\u0093] [\u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084] LT'), 'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format('dddd [\u00e1\u009e\u009f\u00e1\u009e\u0094\u00e1\u009f\u0092\u00e1\u009e\u008f\u00e1\u009e\u00b6\u00e1\u009e\u00a0\u00e1\u009f\u008d\u00e1\u009e\u0098\u00e1\u009e\u00bb\u00e1\u009e\u0093] [\u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084] LT'), 'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format('dddd [\u00e1\u009e\u009f\u00e1\u009e\u0094\u00e1\u009f\u0092\u00e1\u009e\u008f\u00e1\u009e\u00b6\u00e1\u009e\u00a0\u00e1\u009f\u008d\u00e1\u009e\u0098\u00e1\u009e\u00bb\u00e1\u009e\u0093] [\u00e1\u009e\u0098\u00e1\u009f\u0089\u00e1\u009f\u0084\u00e1\u009e\u0084] LT'), 'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({\n                w: 1\n            }),\n            weeksFromNow = moment().add({\n                w: 1\n            });\n\n        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');\n        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');\n\n        weeksAgo = moment().subtract({\n            w: 2\n        });\n        weeksFromNow = moment().add({\n            w: 2\n        });\n\n        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '1 01 1', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '1 01 1', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '2 02 2', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '2 02 2', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ko');\n\n    test('parse', function (assert) {\n        var tests = '1\u00ec\u009b\u0094 1\u00ec\u009b\u0094_2\u00ec\u009b\u0094 2\u00ec\u009b\u0094_3\u00ec\u009b\u0094 3\u00ec\u009b\u0094_4\u00ec\u009b\u0094 4\u00ec\u009b\u0094_5\u00ec\u009b\u0094 5\u00ec\u009b\u0094_6\u00ec\u009b\u0094 6\u00ec\u009b\u0094_7\u00ec\u009b\u0094 7\u00ec\u009b\u0094_8\u00ec\u009b\u0094 8\u00ec\u009b\u0094_9\u00ec\u009b\u0094 9\u00ec\u009b\u0094_10\u00ec\u009b\u0094 10\u00ec\u009b\u0094_11\u00ec\u009b\u0094 11\u00ec\u009b\u0094_12\u00ec\u009b\u0094 12\u00ec\u009b\u0094'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('parse meridiem', function (assert) {\n        var elements = [{\n            expression : '1981\u00eb\u0085\u0084 9\u00ec\u009b\u0094 8\u00ec\u009d\u00bc \u00ec\u0098\u00a4\u00ed\u009b\u0084 2\u00ec\u008b\u009c 30\u00eb\u00b6\u0084',\n            inputFormat : 'YYYY[\u00eb\u0085\u0084] M[\u00ec\u009b\u0094] D[\u00ec\u009d\u00bc] A h[\u00ec\u008b\u009c] m[\u00eb\u00b6\u0084]',\n            outputFormat : 'A',\n            expected : '\u00ec\u0098\u00a4\u00ed\u009b\u0084'\n        }, {\n            expression : '1981\u00eb\u0085\u0084 9\u00ec\u009b\u0094 8\u00ec\u009d\u00bc \u00ec\u0098\u00a4\u00ec\u00a0\u0084 2\u00ec\u008b\u009c 30\u00eb\u00b6\u0084',\n            inputFormat : 'YYYY[\u00eb\u0085\u0084] M[\u00ec\u009b\u0094] D[\u00ec\u009d\u00bc] A h[\u00ec\u008b\u009c] m[\u00eb\u00b6\u0084]',\n            outputFormat : 'A h\u00ec\u008b\u009c',\n            expected : '\u00ec\u0098\u00a4\u00ec\u00a0\u0084 2\u00ec\u008b\u009c'\n        }, {\n            expression : '14\u00ec\u008b\u009c 30\u00eb\u00b6\u0084',\n            inputFormat : 'H[\u00ec\u008b\u009c] m[\u00eb\u00b6\u0084]',\n            outputFormat : 'A',\n            expected : '\u00ec\u0098\u00a4\u00ed\u009b\u0084'\n        }, {\n            expression : '\u00ec\u0098\u00a4\u00ed\u009b\u0084 4\u00ec\u008b\u009c',\n            inputFormat : 'A h[\u00ec\u008b\u009c]',\n            outputFormat : 'H',\n            expected : '16'\n        }], i, l, it, actual;\n\n        for (i = 0, l = elements.length; i < l; ++i) {\n            it = elements[i];\n            actual = moment(it.expression, it.inputFormat).format(it.outputFormat);\n\n            assert.equal(\n                actual,\n                it.expected,\n                '\\'' + it.outputFormat + '\\' of \\'' + it.expression + '\\' must be \\'' + it.expected + '\\' but was \\'' + actual + '\\'.'\n            );\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['YYYY\u00eb\u0085\u0084 MMMM Do dddd a h:mm:ss',      '2010\u00eb\u0085\u0084 2\u00ec\u009b\u0094 14\u00ec\u009d\u00bc \u00ec\u009d\u00bc\u00ec\u009a\u0094\u00ec\u009d\u00bc \u00ec\u0098\u00a4\u00ed\u009b\u0084 3:25:50'],\n                ['ddd A h',                            '\u00ec\u009d\u00bc \u00ec\u0098\u00a4\u00ed\u009b\u0084 3'],\n                ['M Mo MM MMMM MMM',                   '2 2\u00ec\u009d\u00bc 02 2\u00ec\u009b\u0094 2\u00ec\u009b\u0094'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\u00ec\u009d\u00bc 14'],\n                ['d do dddd ddd dd',                   '0 0\u00ec\u009d\u00bc \u00ec\u009d\u00bc\u00ec\u009a\u0094\u00ec\u009d\u00bc \u00ec\u009d\u00bc \u00ec\u009d\u00bc'],\n                ['DDD DDDo DDDD',                      '45 45\u00ec\u009d\u00bc 045'],\n                ['w wo ww',                            '8 8\u00ec\u009d\u00bc 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00ec\u0098\u00a4\u00ed\u009b\u0084 \u00ec\u0098\u00a4\u00ed\u009b\u0084'],\n                ['\u00ec\u009d\u00bc\u00eb\u0085\u0084 \u00ec\u00a4\u0091 DDDo\u00ec\u00a7\u00b8 \u00eb\u0090\u0098\u00eb\u008a\u0094 \u00eb\u0082\u00a0',                 '\u00ec\u009d\u00bc\u00eb\u0085\u0084 \u00ec\u00a4\u0091 45\u00ec\u009d\u00bc\u00ec\u00a7\u00b8 \u00eb\u0090\u0098\u00eb\u008a\u0094 \u00eb\u0082\u00a0'],\n                ['LTS',                                '\u00ec\u0098\u00a4\u00ed\u009b\u0084 3\u00ec\u008b\u009c 25\u00eb\u00b6\u0084 50\u00ec\u00b4\u0088'],\n                ['L',                                  '2010.02.14'],\n                ['LL',                                 '2010\u00eb\u0085\u0084 2\u00ec\u009b\u0094 14\u00ec\u009d\u00bc'],\n                ['LLL',                                '2010\u00eb\u0085\u0084 2\u00ec\u009b\u0094 14\u00ec\u009d\u00bc \u00ec\u0098\u00a4\u00ed\u009b\u0084 3\u00ec\u008b\u009c 25\u00eb\u00b6\u0084'],\n                ['LLLL',                               '2010\u00eb\u0085\u0084 2\u00ec\u009b\u0094 14\u00ec\u009d\u00bc \u00ec\u009d\u00bc\u00ec\u009a\u0094\u00ec\u009d\u00bc \u00ec\u0098\u00a4\u00ed\u009b\u0084 3\u00ec\u008b\u009c 25\u00eb\u00b6\u0084'],\n                ['l',                                  '2010.2.14'],\n                ['ll',                                 '2010\u00eb\u0085\u0084 2\u00ec\u009b\u0094 14\u00ec\u009d\u00bc'],\n                ['lll',                                '2010\u00eb\u0085\u0084 2\u00ec\u009b\u0094 14\u00ec\u009d\u00bc \u00ec\u0098\u00a4\u00ed\u009b\u0084 3\u00ec\u008b\u009c 25\u00eb\u00b6\u0084'],\n                ['llll',                               '2010\u00eb\u0085\u0084 2\u00ec\u009b\u0094 14\u00ec\u009d\u00bc \u00ec\u009d\u00bc \u00ec\u0098\u00a4\u00ed\u009b\u0084 3\u00ec\u008b\u009c 25\u00eb\u00b6\u0084']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1\u00ec\u009d\u00bc', '1\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2\u00ec\u009d\u00bc', '2\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3\u00ec\u009d\u00bc', '3\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4\u00ec\u009d\u00bc', '4\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\u00ec\u009d\u00bc', '5\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\u00ec\u009d\u00bc', '6\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\u00ec\u009d\u00bc', '7\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\u00ec\u009d\u00bc', '8\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\u00ec\u009d\u00bc', '9\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\u00ec\u009d\u00bc', '10\u00ec\u009d\u00bc');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\u00ec\u009d\u00bc', '11\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\u00ec\u009d\u00bc', '12\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\u00ec\u009d\u00bc', '13\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\u00ec\u009d\u00bc', '14\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\u00ec\u009d\u00bc', '15\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\u00ec\u009d\u00bc', '16\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\u00ec\u009d\u00bc', '17\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\u00ec\u009d\u00bc', '18\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\u00ec\u009d\u00bc', '19\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\u00ec\u009d\u00bc', '20\u00ec\u009d\u00bc');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\u00ec\u009d\u00bc', '21\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\u00ec\u009d\u00bc', '22\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\u00ec\u009d\u00bc', '23\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\u00ec\u009d\u00bc', '24\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\u00ec\u009d\u00bc', '25\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\u00ec\u009d\u00bc', '26\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\u00ec\u009d\u00bc', '27\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\u00ec\u009d\u00bc', '28\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\u00ec\u009d\u00bc', '29\u00ec\u009d\u00bc');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\u00ec\u009d\u00bc', '30\u00ec\u009d\u00bc');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\u00ec\u009d\u00bc', '31\u00ec\u009d\u00bc');\n    });\n\n    test('format month', function (assert) {\n        var expected = '1\u00ec\u009b\u0094 1\u00ec\u009b\u0094_2\u00ec\u009b\u0094 2\u00ec\u009b\u0094_3\u00ec\u009b\u0094 3\u00ec\u009b\u0094_4\u00ec\u009b\u0094 4\u00ec\u009b\u0094_5\u00ec\u009b\u0094 5\u00ec\u009b\u0094_6\u00ec\u009b\u0094 6\u00ec\u009b\u0094_7\u00ec\u009b\u0094 7\u00ec\u009b\u0094_8\u00ec\u009b\u0094 8\u00ec\u009b\u0094_9\u00ec\u009b\u0094 9\u00ec\u009b\u0094_10\u00ec\u009b\u0094 10\u00ec\u009b\u0094_11\u00ec\u009b\u0094 11\u00ec\u009b\u0094_12\u00ec\u009b\u0094 12\u00ec\u009b\u0094'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00ec\u009d\u00bc\u00ec\u009a\u0094\u00ec\u009d\u00bc \u00ec\u009d\u00bc \u00ec\u009d\u00bc_\u00ec\u009b\u0094\u00ec\u009a\u0094\u00ec\u009d\u00bc \u00ec\u009b\u0094 \u00ec\u009b\u0094_\u00ed\u0099\u0094\u00ec\u009a\u0094\u00ec\u009d\u00bc \u00ed\u0099\u0094 \u00ed\u0099\u0094_\u00ec\u0088\u0098\u00ec\u009a\u0094\u00ec\u009d\u00bc \u00ec\u0088\u0098 \u00ec\u0088\u0098_\u00eb\u00aa\u00a9\u00ec\u009a\u0094\u00ec\u009d\u00bc \u00eb\u00aa\u00a9 \u00eb\u00aa\u00a9_\u00ea\u00b8\u0088\u00ec\u009a\u0094\u00ec\u009d\u00bc \u00ea\u00b8\u0088 \u00ea\u00b8\u0088_\u00ed\u0086\u00a0\u00ec\u009a\u0094\u00ec\u009d\u00bc \u00ed\u0086\u00a0 \u00ed\u0086\u00a0'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00eb\u00aa\u0087 \u00ec\u00b4\u0088', '44\u00ec\u00b4\u0088 = \u00eb\u00aa\u0087 \u00ec\u00b4\u0088');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00ec\u009d\u00bc\u00eb\u00b6\u0084',      '45\u00ec\u00b4\u0088 = \u00ec\u009d\u00bc\u00eb\u00b6\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00ec\u009d\u00bc\u00eb\u00b6\u0084',      '89\u00ec\u00b4\u0088 = \u00ec\u009d\u00bc\u00eb\u00b6\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2\u00eb\u00b6\u0084',     '90\u00ec\u00b4\u0088 = 2\u00eb\u00b6\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44\u00eb\u00b6\u0084',    '44\u00eb\u00b6\u0084 = 44\u00eb\u00b6\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00ed\u0095\u009c \u00ec\u008b\u009c\u00ea\u00b0\u0084',       '45\u00eb\u00b6\u0084 = \u00ed\u0095\u009c \u00ec\u008b\u009c\u00ea\u00b0\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00ed\u0095\u009c \u00ec\u008b\u009c\u00ea\u00b0\u0084',       '89\u00eb\u00b6\u0084 = \u00ed\u0095\u009c \u00ec\u008b\u009c\u00ea\u00b0\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2\u00ec\u008b\u009c\u00ea\u00b0\u0084',       '90\u00eb\u00b6\u0084 = 2\u00ec\u008b\u009c\u00ea\u00b0\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5\u00ec\u008b\u009c\u00ea\u00b0\u0084',       '5\u00ec\u008b\u009c\u00ea\u00b0\u0084 = 5\u00ec\u008b\u009c\u00ea\u00b0\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21\u00ec\u008b\u009c\u00ea\u00b0\u0084',      '21\u00ec\u008b\u009c\u00ea\u00b0\u0084 = 21\u00ec\u008b\u009c\u00ea\u00b0\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00ed\u0095\u0098\u00eb\u00a3\u00a8',         '22\u00ec\u008b\u009c\u00ea\u00b0\u0084 = \u00ed\u0095\u0098\u00eb\u00a3\u00a8');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00ed\u0095\u0098\u00eb\u00a3\u00a8',         '35\u00ec\u008b\u009c\u00ea\u00b0\u0084 = \u00ed\u0095\u0098\u00eb\u00a3\u00a8');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2\u00ec\u009d\u00bc',        '36\u00ec\u008b\u009c\u00ea\u00b0\u0084 = 2\u00ec\u009d\u00bc');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00ed\u0095\u0098\u00eb\u00a3\u00a8',         '\u00ed\u0095\u0098\u00eb\u00a3\u00a8 = \u00ed\u0095\u0098\u00eb\u00a3\u00a8');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5\u00ec\u009d\u00bc',        '5\u00ec\u009d\u00bc = 5\u00ec\u009d\u00bc');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25\u00ec\u009d\u00bc',       '25\u00ec\u009d\u00bc = 25\u00ec\u009d\u00bc');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00ed\u0095\u009c \u00eb\u008b\u00ac',       '26\u00ec\u009d\u00bc = \u00ed\u0095\u009c \u00eb\u008b\u00ac');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00ed\u0095\u009c \u00eb\u008b\u00ac',       '30\u00ec\u009d\u00bc = \u00ed\u0095\u009c \u00eb\u008b\u00ac');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00ed\u0095\u009c \u00eb\u008b\u00ac',       '45\u00ec\u009d\u00bc = \u00ed\u0095\u009c \u00eb\u008b\u00ac');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2\u00eb\u008b\u00ac',      '46\u00ec\u009d\u00bc = 2\u00eb\u008b\u00ac');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2\u00eb\u008b\u00ac',      '75\u00ec\u009d\u00bc = 2\u00eb\u008b\u00ac');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3\u00eb\u008b\u00ac',      '76\u00ec\u009d\u00bc = 3\u00eb\u008b\u00ac');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00ed\u0095\u009c \u00eb\u008b\u00ac',       '1\u00eb\u008b\u00ac = \u00ed\u0095\u009c \u00eb\u008b\u00ac');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5\u00eb\u008b\u00ac',      '5\u00eb\u008b\u00ac = 5\u00eb\u008b\u00ac');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00ec\u009d\u00bc \u00eb\u0085\u0084',        '345\u00ec\u009d\u00bc = \u00ec\u009d\u00bc \u00eb\u0085\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2\u00eb\u0085\u0084',       '548\u00ec\u009d\u00bc = 2\u00eb\u0085\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00ec\u009d\u00bc \u00eb\u0085\u0084',        '\u00ec\u009d\u00bc \u00eb\u0085\u0084 = \u00ec\u009d\u00bc \u00eb\u0085\u0084');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5\u00eb\u0085\u0084',       '5\u00eb\u0085\u0084 = 5\u00eb\u0085\u0084');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00eb\u00aa\u0087 \u00ec\u00b4\u0088 \u00ed\u009b\u0084',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00eb\u00aa\u0087 \u00ec\u00b4\u0088 \u00ec\u00a0\u0084', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00eb\u00aa\u0087 \u00ec\u00b4\u0088 \u00ec\u00a0\u0084',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00eb\u00aa\u0087 \u00ec\u00b4\u0088 \u00ed\u009b\u0084', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5\u00ec\u009d\u00bc \u00ed\u009b\u0084', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00ec\u0098\u00a4\u00eb\u008a\u0098 \u00ec\u0098\u00a4\u00ed\u009b\u0084 12\u00ec\u008b\u009c 0\u00eb\u00b6\u0084',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00ec\u0098\u00a4\u00eb\u008a\u0098 \u00ec\u0098\u00a4\u00ed\u009b\u0084 12\u00ec\u008b\u009c 25\u00eb\u00b6\u0084',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00ec\u0098\u00a4\u00eb\u008a\u0098 \u00ec\u0098\u00a4\u00ed\u009b\u0084 1\u00ec\u008b\u009c 0\u00eb\u00b6\u0084',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00eb\u0082\u00b4\u00ec\u009d\u00bc \u00ec\u0098\u00a4\u00ed\u009b\u0084 12\u00ec\u008b\u009c 0\u00eb\u00b6\u0084',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00ec\u0098\u00a4\u00eb\u008a\u0098 \u00ec\u0098\u00a4\u00ec\u00a0\u0084 11\u00ec\u008b\u009c 0\u00eb\u00b6\u0084',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00ec\u0096\u00b4\u00ec\u00a0\u009c \u00ec\u0098\u00a4\u00ed\u009b\u0084 12\u00ec\u008b\u009c 0\u00eb\u00b6\u0084',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('\u00ec\u00a7\u0080\u00eb\u0082\u009c\u00ec\u00a3\u00bc dddd LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('\u00ec\u00a7\u0080\u00eb\u0082\u009c\u00ec\u00a3\u00bc dddd LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('\u00ec\u00a7\u0080\u00eb\u0082\u009c\u00ec\u00a3\u00bc dddd LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1\u00ec\u009d\u00bc', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1\u00ec\u009d\u00bc', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2\u00ec\u009d\u00bc', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2\u00ec\u009d\u00bc', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3\u00ec\u009d\u00bc', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ky');\n\n    test('parse', function (assert) {\n        var tests = '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2\u00d0\u00b0\u00d1\u0080\u00d1\u008c \u00d1\u008f\u00d0\u00bd\u00d0\u00b2_\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008c \u00d1\u0084\u00d0\u00b5\u00d0\u00b2_\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00bb\u00d1\u008c \u00d0\u00b0\u00d0\u00bf\u00d1\u0080_\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9 \u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008c \u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008c_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008c \u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008c_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3_\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d1\u0081\u00d0\u00b5\u00d0\u00bd_\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d0\u00be\u00d0\u00ba\u00d1\u0082_\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d0\u00bd\u00d0\u00be\u00d1\u008f_\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, HH:mm:ss',       '\u00d0\u0096\u00d0\u00b5\u00d0\u00ba\u00d1\u0088\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b8, 14-\u00d1\u0087\u00d2\u00af \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008c 2010, 15:25:50'],\n                ['ddd, hA',                            '\u00d0\u0096\u00d0\u00b5\u00d0\u00ba, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2-\u00d1\u0087\u00d0\u00b8 02 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008c \u00d1\u0084\u00d0\u00b5\u00d0\u00b2'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14-\u00d1\u0087\u00d2\u00af 14'],\n                ['d do dddd ddd dd',                   '0 0-\u00d1\u0087\u00d2\u00af \u00d0\u0096\u00d0\u00b5\u00d0\u00ba\u00d1\u0088\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b8 \u00d0\u0096\u00d0\u00b5\u00d0\u00ba \u00d0\u0096\u00d0\u00ba'],\n                ['DDD DDDo DDDD',                      '45 45-\u00d1\u0087\u00d0\u00b8 045'],\n                ['w wo ww',                            '7 7-\u00d1\u0087\u00d0\u00b8 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[\u00d0\u00b6\u00d1\u008b\u00d0\u00bb\u00d0\u00b4\u00d1\u008b\u00d0\u00bd] DDDo [\u00d0\u00ba\u00d2\u00af\u00d0\u00bd\u00d2\u00af]',               '\u00d0\u00b6\u00d1\u008b\u00d0\u00bb\u00d0\u00b4\u00d1\u008b\u00d0\u00bd 45-\u00d1\u0087\u00d0\u00b8 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd\u00d2\u00af'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008c 2010'],\n                ['LLL',                                '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008c 2010 15:25'],\n                ['LLLL',                               '\u00d0\u0096\u00d0\u00b5\u00d0\u00ba\u00d1\u0088\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b8, 14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008c 2010 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2 2010'],\n                ['lll',                                '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2 2010 15:25'],\n                ['llll',                               '\u00d0\u0096\u00d0\u00b5\u00d0\u00ba, 14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-\u00d1\u0087\u00d0\u00b8', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-\u00d1\u0087\u00d0\u00b8', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-\u00d1\u0087\u00d2\u00af', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-\u00d1\u0087\u00d2\u00af', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-\u00d1\u0087\u00d0\u00b8', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-\u00d1\u0087\u00d1\u008b', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-\u00d1\u0087\u00d0\u00b8', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-\u00d1\u0087\u00d0\u00b8', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-\u00d1\u0087\u00d1\u0083', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-\u00d1\u0087\u00d1\u0083', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-\u00d1\u0087\u00d0\u00b8', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-\u00d1\u0087\u00d0\u00b8', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-\u00d1\u0087\u00d2\u00af', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-\u00d1\u0087\u00d2\u00af', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-\u00d1\u0087\u00d0\u00b8', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-\u00d1\u0087\u00d1\u008b', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-\u00d1\u0087\u00d0\u00b8', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-\u00d1\u0087\u00d0\u00b8', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-\u00d1\u0087\u00d1\u0083', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-\u00d1\u0087\u00d1\u008b', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-\u00d1\u0087\u00d0\u00b8', '21st');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-\u00d1\u0087\u00d0\u00b8', '22nd');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-\u00d1\u0087\u00d2\u00af', '23rd');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-\u00d1\u0087\u00d2\u00af', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-\u00d1\u0087\u00d0\u00b8', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-\u00d1\u0087\u00d1\u008b', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-\u00d1\u0087\u00d0\u00b8', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-\u00d1\u0087\u00d0\u00b8', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-\u00d1\u0087\u00d1\u0083', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-\u00d1\u0087\u00d1\u0083', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-\u00d1\u0087\u00d0\u00b8', '31st');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2\u00d0\u00b0\u00d1\u0080\u00d1\u008c \u00d1\u008f\u00d0\u00bd\u00d0\u00b2_\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008c \u00d1\u0084\u00d0\u00b5\u00d0\u00b2_\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00bb\u00d1\u008c \u00d0\u00b0\u00d0\u00bf\u00d1\u0080_\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9 \u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008c \u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008c_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008c \u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008c_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3_\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d1\u0081\u00d0\u00b5\u00d0\u00bd_\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d0\u00be\u00d0\u00ba\u00d1\u0082_\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d0\u00bd\u00d0\u00be\u00d1\u008f_\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d0\u0096\u00d0\u00b5\u00d0\u00ba\u00d1\u0088\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b8 \u00d0\u0096\u00d0\u00b5\u00d0\u00ba \u00d0\u0096\u00d0\u00ba_\u00d0\u0094\u00d2\u00af\u00d0\u00b9\u00d1\u0088\u00d3\u00a9\u00d0\u00bc\u00d0\u00b1\u00d2\u00af \u00d0\u0094\u00d2\u00af\u00d0\u00b9 \u00d0\u0094\u00d0\u00b9_\u00d0\u00a8\u00d0\u00b5\u00d0\u00b9\u00d1\u0088\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b8 \u00d0\u00a8\u00d0\u00b5\u00d0\u00b9 \u00d0\u00a8\u00d0\u00b9_\u00d0\u00a8\u00d0\u00b0\u00d1\u0080\u00d1\u0088\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b8 \u00d0\u00a8\u00d0\u00b0\u00d1\u0080 \u00d0\u00a8\u00d1\u0080_\u00d0\u0091\u00d0\u00b5\u00d0\u00b9\u00d1\u0088\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b8 \u00d0\u0091\u00d0\u00b5\u00d0\u00b9 \u00d0\u0091\u00d0\u00b9_\u00d0\u0096\u00d1\u0083\u00d0\u00bc\u00d0\u00b0 \u00d0\u0096\u00d1\u0083\u00d0\u00bc \u00d0\u0096\u00d0\u00bc_\u00d0\u0098\u00d1\u0088\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b8 \u00d0\u0098\u00d1\u0088\u00d0\u00b5 \u00d0\u0098\u00d1\u0088'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080\u00d0\u00bd\u00d0\u00b5\u00d1\u0087\u00d0\u00b5 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00bc\u00d2\u00af\u00d0\u00bd\u00d3\u00a9\u00d1\u0082',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00bc\u00d2\u00af\u00d0\u00bd\u00d3\u00a9\u00d1\u0082',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d0\u00bc\u00d2\u00af\u00d0\u00bd\u00d3\u00a9\u00d1\u0082',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d0\u00bc\u00d2\u00af\u00d0\u00bd\u00d3\u00a9\u00d1\u0082',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b0\u00d0\u00b9',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b0\u00d0\u00b9',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b0\u00d0\u00b9',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00d0\u00b0\u00d0\u00b9',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00d0\u00b0\u00d0\u00b9',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d0\u00b0\u00d0\u00b9',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b0\u00d0\u00b9',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d0\u00b0\u00d0\u00b9',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b6\u00d1\u008b\u00d0\u00bb',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00d0\u00b6\u00d1\u008b\u00d0\u00bb',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b6\u00d1\u008b\u00d0\u00bb',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d0\u00b6\u00d1\u008b\u00d0\u00bb',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080\u00d0\u00bd\u00d0\u00b5\u00d1\u0087\u00d0\u00b5 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 \u00d0\u00b8\u00d1\u0087\u00d0\u00b8\u00d0\u00bd\u00d0\u00b4\u00d0\u00b5',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080\u00d0\u00bd\u00d0\u00b5\u00d1\u0087\u00d0\u00b5 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 \u00d0\u00bc\u00d1\u0083\u00d1\u0080\u00d1\u0083\u00d0\u00bd', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080\u00d0\u00bd\u00d0\u00b5\u00d1\u0087\u00d0\u00b5 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 \u00d0\u00bc\u00d1\u0083\u00d1\u0080\u00d1\u0083\u00d0\u00bd',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080\u00d0\u00bd\u00d0\u00b5\u00d1\u0087\u00d0\u00b5 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 \u00d0\u00b8\u00d1\u0087\u00d0\u00b8\u00d0\u00bd\u00d0\u00b4\u00d0\u00b5', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 \u00d0\u00ba\u00d2\u00af\u00d0\u00bd \u00d0\u00b8\u00d1\u0087\u00d0\u00b8\u00d0\u00bd\u00d0\u00b4\u00d0\u00b5', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d0\u0091\u00d2\u00af\u00d0\u00b3\u00d2\u00af\u00d0\u00bd \u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d0\u0091\u00d2\u00af\u00d0\u00b3\u00d2\u00af\u00d0\u00bd \u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d0\u0091\u00d2\u00af\u00d0\u00b3\u00d2\u00af\u00d0\u00bd \u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d0\u00ad\u00d1\u0080\u00d1\u0082\u00d0\u00b5\u00d2\u00a3 \u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d0\u0091\u00d2\u00af\u00d0\u00b3\u00d2\u00af\u00d0\u00bd \u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d0\u009a\u00d0\u00b5\u00d1\u0087\u00d0\u00b5 \u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082 12:00',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00d3\u00a8\u00d1\u0082\u00d0\u00ba\u00d0\u00b5\u00d0\u00bd \u00d0\u00b0\u00d0\u00bf\u00d1\u0082\u00d0\u00b0\u00d0\u00bd\u00d1\u008b\u00d0\u00bd] dddd [\u00d0\u00ba\u00d2\u00af\u00d0\u00bd\u00d2\u00af] [\u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00d3\u00a8\u00d1\u0082\u00d0\u00ba\u00d0\u00b5\u00d0\u00bd \u00d0\u00b0\u00d0\u00bf\u00d1\u0082\u00d0\u00b0\u00d0\u00bd\u00d1\u008b\u00d0\u00bd] dddd [\u00d0\u00ba\u00d2\u00af\u00d0\u00bd\u00d2\u00af] [\u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00d3\u00a8\u00d1\u0082\u00d0\u00ba\u00d0\u00b5\u00d0\u00bd \u00d0\u00b0\u00d0\u00bf\u00d1\u0082\u00d0\u00b0\u00d0\u00bd\u00d1\u008b\u00d0\u00bd] dddd [\u00d0\u00ba\u00d2\u00af\u00d0\u00bd\u00d2\u00af] [\u00d1\u0081\u00d0\u00b0\u00d0\u00b0\u00d1\u0082] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'),   '1 01 1-\u00d1\u0087\u00d0\u00b8', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '2 02 2-\u00d1\u0087\u00d0\u00b8', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '2 02 2-\u00d1\u0087\u00d0\u00b8', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '3 03 3-\u00d1\u0087\u00d2\u00af', 'Jan  9 2012 should be week 3');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '3 03 3-\u00d1\u0087\u00d2\u00af', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('lb');\n\n    test('parse', function (assert) {\n        var tests = 'Januar Jan._Februar Febr._M\u00c3\u00a4erz Mrz._Abr\u00c3\u00abll Abr._Mee Mee_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, HH:mm:ss', 'Sonndeg, 14. Februar 2010, 15:25:50'],\n                ['ddd, HH:mm', 'So., 15:25'],\n                ['M Mo MM MMMM MMM', '2 2. 02 Februar Febr.'],\n                ['YYYY YY', '2010 10'],\n                ['D Do DD', '14 14. 14'],\n                ['d do dddd ddd dd', '0 0. Sonndeg So. So'],\n                ['DDD DDDo DDDD', '45 45. 045'],\n                ['w wo ww', '6 6. 06'],\n                ['h hh', '3 03'],\n                ['H HH', '15 15'],\n                ['m mm', '25 25'],\n                ['s ss', '50 50'],\n                ['a A', 'pm PM'],\n                ['[the] DDDo [day of the year]', 'the 45. day of the year'],\n                ['LTS', '15:25:50 Auer'],\n                ['L', '14.02.2010'],\n                ['LL', '14. Februar 2010'],\n                ['LLL', '14. Februar 2010 15:25 Auer'],\n                ['LLLL', 'Sonndeg, 14. Februar 2010 15:25 Auer'],\n                ['l', '14.2.2010'],\n                ['ll', '14. Febr. 2010'],\n                ['lll', '14. Febr. 2010 15:25 Auer'],\n                ['llll', 'So., 14. Febr. 2010 15:25 Auer']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Januar Jan._Februar Febr._M\u00c3\u00a4erz Mrz._Abr\u00c3\u00abll Abr._Mee Mee_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Sonndeg So. So_M\u00c3\u00a9indeg M\u00c3\u00a9. M\u00c3\u00a9_D\u00c3\u00abnschdeg D\u00c3\u00ab. D\u00c3\u00ab_M\u00c3\u00abttwoch M\u00c3\u00ab. M\u00c3\u00ab_Donneschdeg Do. Do_Freideg Fr. Fr_Samschdeg Sa. Sa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), 'e puer Sekonnen', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), 'eng Minutt', '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), 'eng Minutt', '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 Minutten', '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 Minutten', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), 'eng Stonn', '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), 'eng Stonn', '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 Stonnen', '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 Stonnen', '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 Stonnen', '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), 'een Dag', '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), 'een Dag', '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 Deeg', '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), 'een Dag', '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 Deeg', '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 Deeg', '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), 'ee Mount', '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), 'ee Mount', '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), 'ee Mount', '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 M\u00c3\u00a9int', '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 M\u00c3\u00a9int', '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 M\u00c3\u00a9int', '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), 'ee Mount', '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 M\u00c3\u00a9int', '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ee Joer', '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Joer', '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'ee Joer', '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 Joer', '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'an e puer Sekonnen', 'prefix');\n        assert.equal(moment(0).from(30000), 'virun e puer Sekonnen', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'an e puer Sekonnen', 'in a few seconds');\n        assert.equal(moment().add({d: 1}).fromNow(), 'an engem Dag', 'in one day');\n        assert.equal(moment().add({d: 2}).fromNow(), 'an 2 Deeg', 'in 2 days');\n        assert.equal(moment().add({d: 3}).fromNow(), 'an 3 Deeg', 'in 3 days');\n        assert.equal(moment().add({d: 4}).fromNow(), 'a 4 Deeg', 'in 4 days');\n        assert.equal(moment().add({d: 5}).fromNow(), 'a 5 Deeg', 'in 5 days');\n        assert.equal(moment().add({d: 6}).fromNow(), 'a 6 Deeg', 'in 6 days');\n        assert.equal(moment().add({d: 7}).fromNow(), 'a 7 Deeg', 'in 7 days');\n        assert.equal(moment().add({d: 8}).fromNow(), 'an 8 Deeg', 'in 8 days');\n        assert.equal(moment().add({d: 9}).fromNow(), 'an 9 Deeg', 'in 9 days');\n        assert.equal(moment().add({d: 10}).fromNow(), 'an 10 Deeg', 'in 10 days');\n        assert.equal(moment().add({y: 100}).fromNow(), 'an 100 Joer', 'in 100 years');\n        assert.equal(moment().add({y: 400}).fromNow(), 'a 400 Joer', 'in 400 years');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Haut um 12:00 Auer',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Haut um 12:25 Auer',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Haut um 13:00 Auer',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Muer um 12:00 Auer',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Haut um 11:00 Auer',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'G\u00c3\u00abschter um 12:00 Auer', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [um] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [um] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [um] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m, weekday, datestring;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n\n            // Different date string for 'D\u00c3\u00abnschdeg' (Tuesday) and 'Donneschdeg' (Thursday)\n            weekday = parseInt(m.format('d'), 10);\n            datestring = (weekday === 2 || weekday === 4 ? '[Leschten] dddd [um] LT' : '[Leschte] dddd [um] LT');\n\n            assert.equal(m.calendar(), m.format(datestring), 'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format(datestring), 'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format(datestring), 'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1.',   'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1.',   'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2.',   'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '2 02 2.',   'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('lo');\n\n    test('parse', function (assert) {\n        var tests = '\u00e0\u00ba\u00a1\u00e0\u00ba\u00b1\u00e0\u00ba\u0087\u00e0\u00ba\u0081\u00e0\u00ba\u00ad\u00e0\u00ba\u0099 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b1\u00e0\u00ba\u0087\u00e0\u00ba\u0081\u00e0\u00ba\u00ad\u00e0\u00ba\u0099_\u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2 \u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2_\u00e0\u00ba\u00a1\u00e0\u00ba\u00b5\u00e0\u00ba\u0099\u00e0\u00ba\u00b2 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b5\u00e0\u00ba\u0099\u00e0\u00ba\u00b2_\u00e0\u00bb\u0080\u00e0\u00ba\u00a1\u00e0\u00ba\u00aa\u00e0\u00ba\u00b2 \u00e0\u00bb\u0080\u00e0\u00ba\u00a1\u00e0\u00ba\u00aa\u00e0\u00ba\u00b2_\u00e0\u00ba\u009e\u00e0\u00ba\u00b6\u00e0\u00ba\u0094\u00e0\u00ba\u00aa\u00e0\u00ba\u00b0\u00e0\u00ba\u009e\u00e0\u00ba\u00b2 \u00e0\u00ba\u009e\u00e0\u00ba\u00b6\u00e0\u00ba\u0094\u00e0\u00ba\u00aa\u00e0\u00ba\u00b0\u00e0\u00ba\u009e\u00e0\u00ba\u00b2_\u00e0\u00ba\u00a1\u00e0\u00ba\u00b4\u00e0\u00ba\u0096\u00e0\u00ba\u00b8\u00e0\u00ba\u0099\u00e0\u00ba\u00b2 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b4\u00e0\u00ba\u0096\u00e0\u00ba\u00b8\u00e0\u00ba\u0099\u00e0\u00ba\u00b2_\u00e0\u00ba\u0081\u00e0\u00bb\u008d\u00e0\u00ba\u00a5\u00e0\u00ba\u00b0\u00e0\u00ba\u0081\u00e0\u00ba\u00bb\u00e0\u00ba\u0094 \u00e0\u00ba\u0081\u00e0\u00bb\u008d\u00e0\u00ba\u00a5\u00e0\u00ba\u00b0\u00e0\u00ba\u0081\u00e0\u00ba\u00bb\u00e0\u00ba\u0094_\u00e0\u00ba\u00aa\u00e0\u00ba\u00b4\u00e0\u00ba\u0087\u00e0\u00ba\u00ab\u00e0\u00ba\u00b2 \u00e0\u00ba\u00aa\u00e0\u00ba\u00b4\u00e0\u00ba\u0087\u00e0\u00ba\u00ab\u00e0\u00ba\u00b2_\u00e0\u00ba\u0081\u00e0\u00ba\u00b1\u00e0\u00ba\u0099\u00e0\u00ba\u008d\u00e0\u00ba\u00b2 \u00e0\u00ba\u0081\u00e0\u00ba\u00b1\u00e0\u00ba\u0099\u00e0\u00ba\u008d\u00e0\u00ba\u00b2_\u00e0\u00ba\u0095\u00e0\u00ba\u00b8\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2 \u00e0\u00ba\u0095\u00e0\u00ba\u00b8\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2_\u00e0\u00ba\u009e\u00e0\u00ba\u00b0\u00e0\u00ba\u0088\u00e0\u00ba\u00b4\u00e0\u00ba\u0081 \u00e0\u00ba\u009e\u00e0\u00ba\u00b0\u00e0\u00ba\u0088\u00e0\u00ba\u00b4\u00e0\u00ba\u0081_\u00e0\u00ba\u0097\u00e0\u00ba\u00b1\u00e0\u00ba\u0099\u00e0\u00ba\u00a7\u00e0\u00ba\u00b2 \u00e0\u00ba\u0097\u00e0\u00ba\u00b1\u00e0\u00ba\u0099\u00e0\u00ba\u00a7\u00e0\u00ba\u00b2'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      '\u00e0\u00ba\u00ad\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b4\u00e0\u00ba\u0094, \u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2 \u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008814 2010, 3:25:50 \u00e0\u00ba\u0095\u00e0\u00ba\u00ad\u00e0\u00ba\u0099\u00e0\u00bb\u0081\u00e0\u00ba\u00a5\u00e0\u00ba\u0087'],\n                ['ddd, hA',                            '\u00e0\u00ba\u0097\u00e0\u00ba\u00b4\u00e0\u00ba\u0094, 3\u00e0\u00ba\u0095\u00e0\u00ba\u00ad\u00e0\u00ba\u0099\u00e0\u00bb\u0081\u00e0\u00ba\u00a5\u00e0\u00ba\u0087'],\n                ['M Mo MM MMMM MMM',                   '2 \u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00882 02 \u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2 \u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 \u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008814 14'],\n                ['d do dddd ddd dd',                   '0 \u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00880 \u00e0\u00ba\u00ad\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b4\u00e0\u00ba\u0094 \u00e0\u00ba\u0097\u00e0\u00ba\u00b4\u00e0\u00ba\u0094 \u00e0\u00ba\u0097'],\n                ['DDD DDDo DDDD',                      '45 \u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008845 045'],\n                ['w wo ww',                            '8 \u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00888 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00e0\u00ba\u0095\u00e0\u00ba\u00ad\u00e0\u00ba\u0099\u00e0\u00bb\u0081\u00e0\u00ba\u00a5\u00e0\u00ba\u0087 \u00e0\u00ba\u0095\u00e0\u00ba\u00ad\u00e0\u00ba\u0099\u00e0\u00bb\u0081\u00e0\u00ba\u00a5\u00e0\u00ba\u0087'],\n                ['[\u00e0\u00ba\u00a7\u00e0\u00ba\u00b1\u00e0\u00ba\u0099]DDDo [\u00e0\u00ba\u0082\u00e0\u00ba\u00ad\u00e0\u00ba\u0087\u00e0\u00ba\u009b\u00e0\u00ba\u00b5]',                   '\u00e0\u00ba\u00a7\u00e0\u00ba\u00b1\u00e0\u00ba\u0099\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008845 \u00e0\u00ba\u0082\u00e0\u00ba\u00ad\u00e0\u00ba\u0087\u00e0\u00ba\u009b\u00e0\u00ba\u00b5'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 \u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2 2010'],\n                ['LLL',                                '14 \u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2 2010 15:25'],\n                ['LLLL',                               '\u00e0\u00ba\u00a7\u00e0\u00ba\u00b1\u00e0\u00ba\u0099\u00e0\u00ba\u00ad\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b4\u00e0\u00ba\u0094 14 \u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 \u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2 2010'],\n                ['lll',                                '14 \u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2 2010 15:25'],\n                ['llll',                               '\u00e0\u00ba\u00a7\u00e0\u00ba\u00b1\u00e0\u00ba\u0099\u00e0\u00ba\u0097\u00e0\u00ba\u00b4\u00e0\u00ba\u0094 14 \u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00881', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00881');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00882', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00882');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00883', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00883');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00884', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00884');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00885', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00885');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00886', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00886');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00887', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00887');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00888', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00888');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00889', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00889');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008810', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008810');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008811', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008811');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008812', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008812');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008813', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008813');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008814', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008814');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008815', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008815');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008816', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008816');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008817', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008817');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008818', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008818');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008819', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008819');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008820', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008820');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008821', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008821');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008822', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008822');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008823', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008823');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008824', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008824');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008825', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008825');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008826', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008826');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008827', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008827');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008828', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008828');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008829', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008829');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008830', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008830');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008831', '\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u008831');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e0\u00ba\u00a1\u00e0\u00ba\u00b1\u00e0\u00ba\u0087\u00e0\u00ba\u0081\u00e0\u00ba\u00ad\u00e0\u00ba\u0099 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b1\u00e0\u00ba\u0087\u00e0\u00ba\u0081\u00e0\u00ba\u00ad\u00e0\u00ba\u0099_\u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2 \u00e0\u00ba\u0081\u00e0\u00ba\u00b8\u00e0\u00ba\u00a1\u00e0\u00ba\u009e\u00e0\u00ba\u00b2_\u00e0\u00ba\u00a1\u00e0\u00ba\u00b5\u00e0\u00ba\u0099\u00e0\u00ba\u00b2 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b5\u00e0\u00ba\u0099\u00e0\u00ba\u00b2_\u00e0\u00bb\u0080\u00e0\u00ba\u00a1\u00e0\u00ba\u00aa\u00e0\u00ba\u00b2 \u00e0\u00bb\u0080\u00e0\u00ba\u00a1\u00e0\u00ba\u00aa\u00e0\u00ba\u00b2_\u00e0\u00ba\u009e\u00e0\u00ba\u00b6\u00e0\u00ba\u0094\u00e0\u00ba\u00aa\u00e0\u00ba\u00b0\u00e0\u00ba\u009e\u00e0\u00ba\u00b2 \u00e0\u00ba\u009e\u00e0\u00ba\u00b6\u00e0\u00ba\u0094\u00e0\u00ba\u00aa\u00e0\u00ba\u00b0\u00e0\u00ba\u009e\u00e0\u00ba\u00b2_\u00e0\u00ba\u00a1\u00e0\u00ba\u00b4\u00e0\u00ba\u0096\u00e0\u00ba\u00b8\u00e0\u00ba\u0099\u00e0\u00ba\u00b2 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b4\u00e0\u00ba\u0096\u00e0\u00ba\u00b8\u00e0\u00ba\u0099\u00e0\u00ba\u00b2_\u00e0\u00ba\u0081\u00e0\u00bb\u008d\u00e0\u00ba\u00a5\u00e0\u00ba\u00b0\u00e0\u00ba\u0081\u00e0\u00ba\u00bb\u00e0\u00ba\u0094 \u00e0\u00ba\u0081\u00e0\u00bb\u008d\u00e0\u00ba\u00a5\u00e0\u00ba\u00b0\u00e0\u00ba\u0081\u00e0\u00ba\u00bb\u00e0\u00ba\u0094_\u00e0\u00ba\u00aa\u00e0\u00ba\u00b4\u00e0\u00ba\u0087\u00e0\u00ba\u00ab\u00e0\u00ba\u00b2 \u00e0\u00ba\u00aa\u00e0\u00ba\u00b4\u00e0\u00ba\u0087\u00e0\u00ba\u00ab\u00e0\u00ba\u00b2_\u00e0\u00ba\u0081\u00e0\u00ba\u00b1\u00e0\u00ba\u0099\u00e0\u00ba\u008d\u00e0\u00ba\u00b2 \u00e0\u00ba\u0081\u00e0\u00ba\u00b1\u00e0\u00ba\u0099\u00e0\u00ba\u008d\u00e0\u00ba\u00b2_\u00e0\u00ba\u0095\u00e0\u00ba\u00b8\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2 \u00e0\u00ba\u0095\u00e0\u00ba\u00b8\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2_\u00e0\u00ba\u009e\u00e0\u00ba\u00b0\u00e0\u00ba\u0088\u00e0\u00ba\u00b4\u00e0\u00ba\u0081 \u00e0\u00ba\u009e\u00e0\u00ba\u00b0\u00e0\u00ba\u0088\u00e0\u00ba\u00b4\u00e0\u00ba\u0081_\u00e0\u00ba\u0097\u00e0\u00ba\u00b1\u00e0\u00ba\u0099\u00e0\u00ba\u00a7\u00e0\u00ba\u00b2 \u00e0\u00ba\u0097\u00e0\u00ba\u00b1\u00e0\u00ba\u0099\u00e0\u00ba\u00a7\u00e0\u00ba\u00b2'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e0\u00ba\u00ad\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b4\u00e0\u00ba\u0094 \u00e0\u00ba\u0097\u00e0\u00ba\u00b4\u00e0\u00ba\u0094 \u00e0\u00ba\u0097_\u00e0\u00ba\u0088\u00e0\u00ba\u00b1\u00e0\u00ba\u0099 \u00e0\u00ba\u0088\u00e0\u00ba\u00b1\u00e0\u00ba\u0099 \u00e0\u00ba\u0088_\u00e0\u00ba\u00ad\u00e0\u00ba\u00b1\u00e0\u00ba\u0087\u00e0\u00ba\u0084\u00e0\u00ba\u00b2\u00e0\u00ba\u0099 \u00e0\u00ba\u00ad\u00e0\u00ba\u00b1\u00e0\u00ba\u0087\u00e0\u00ba\u0084\u00e0\u00ba\u00b2\u00e0\u00ba\u0099 \u00e0\u00ba\u00ad\u00e0\u00ba\u0084_\u00e0\u00ba\u009e\u00e0\u00ba\u00b8\u00e0\u00ba\u0094 \u00e0\u00ba\u009e\u00e0\u00ba\u00b8\u00e0\u00ba\u0094 \u00e0\u00ba\u009e_\u00e0\u00ba\u009e\u00e0\u00ba\u00b0\u00e0\u00ba\u00ab\u00e0\u00ba\u00b1\u00e0\u00ba\u0094 \u00e0\u00ba\u009e\u00e0\u00ba\u00b0\u00e0\u00ba\u00ab\u00e0\u00ba\u00b1\u00e0\u00ba\u0094 \u00e0\u00ba\u009e\u00e0\u00ba\u00ab_\u00e0\u00ba\u00aa\u00e0\u00ba\u00b8\u00e0\u00ba\u0081 \u00e0\u00ba\u00aa\u00e0\u00ba\u00b8\u00e0\u00ba\u0081 \u00e0\u00ba\u00aa\u00e0\u00ba\u0081_\u00e0\u00bb\u0080\u00e0\u00ba\u00aa\u00e0\u00ba\u00bb\u00e0\u00ba\u00b2 \u00e0\u00bb\u0080\u00e0\u00ba\u00aa\u00e0\u00ba\u00bb\u00e0\u00ba\u00b2 \u00e0\u00ba\u00aa'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e0\u00ba\u009a\u00e0\u00bb\u008d\u00e0\u00bb\u0088\u00e0\u00bb\u0080\u00e0\u00ba\u0097\u00e0\u00ba\u00bb\u00e0\u00bb\u0088\u00e0\u00ba\u00b2\u00e0\u00bb\u0083\u00e0\u00ba\u0094\u00e0\u00ba\u00a7\u00e0\u00ba\u00b4\u00e0\u00ba\u0099\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b5', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1 \u00e0\u00ba\u0099\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b5',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1 \u00e0\u00ba\u0099\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b5',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00e0\u00ba\u0099\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b5',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00e0\u00ba\u0099\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b5',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1 \u00e0\u00ba\u008a\u00e0\u00ba\u00bb\u00e0\u00bb\u0088\u00e0\u00ba\u00a7\u00e0\u00bb\u0082\u00e0\u00ba\u00a1\u00e0\u00ba\u0087',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1 \u00e0\u00ba\u008a\u00e0\u00ba\u00bb\u00e0\u00bb\u0088\u00e0\u00ba\u00a7\u00e0\u00bb\u0082\u00e0\u00ba\u00a1\u00e0\u00ba\u0087',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00e0\u00ba\u008a\u00e0\u00ba\u00bb\u00e0\u00bb\u0088\u00e0\u00ba\u00a7\u00e0\u00bb\u0082\u00e0\u00ba\u00a1\u00e0\u00ba\u0087',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00e0\u00ba\u008a\u00e0\u00ba\u00bb\u00e0\u00bb\u0088\u00e0\u00ba\u00a7\u00e0\u00bb\u0082\u00e0\u00ba\u00a1\u00e0\u00ba\u0087',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00e0\u00ba\u008a\u00e0\u00ba\u00bb\u00e0\u00bb\u0088\u00e0\u00ba\u00a7\u00e0\u00bb\u0082\u00e0\u00ba\u00a1\u00e0\u00ba\u0087',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1 \u00e0\u00bb\u0080\u00e0\u00ba\u0094\u00e0\u00ba\u00b7\u00e0\u00ba\u00ad\u00e0\u00ba\u0099',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1 \u00e0\u00bb\u0080\u00e0\u00ba\u0094\u00e0\u00ba\u00b7\u00e0\u00ba\u00ad\u00e0\u00ba\u0099',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1 \u00e0\u00bb\u0080\u00e0\u00ba\u0094\u00e0\u00ba\u00b7\u00e0\u00ba\u00ad\u00e0\u00ba\u0099',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00e0\u00bb\u0080\u00e0\u00ba\u0094\u00e0\u00ba\u00b7\u00e0\u00ba\u00ad\u00e0\u00ba\u0099',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00e0\u00bb\u0080\u00e0\u00ba\u0094\u00e0\u00ba\u00b7\u00e0\u00ba\u00ad\u00e0\u00ba\u0099',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00e0\u00bb\u0080\u00e0\u00ba\u0094\u00e0\u00ba\u00b7\u00e0\u00ba\u00ad\u00e0\u00ba\u0099',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1 \u00e0\u00bb\u0080\u00e0\u00ba\u0094\u00e0\u00ba\u00b7\u00e0\u00ba\u00ad\u00e0\u00ba\u0099',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00e0\u00bb\u0080\u00e0\u00ba\u0094\u00e0\u00ba\u00b7\u00e0\u00ba\u00ad\u00e0\u00ba\u0099',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1 \u00e0\u00ba\u009b\u00e0\u00ba\u00b5',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00e0\u00ba\u009b\u00e0\u00ba\u00b5',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1 \u00e0\u00ba\u009b\u00e0\u00ba\u00b5',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00e0\u00ba\u009b\u00e0\u00ba\u00b5',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e0\u00ba\u00ad\u00e0\u00ba\u00b5\u00e0\u00ba\u0081 \u00e0\u00ba\u009a\u00e0\u00bb\u008d\u00e0\u00bb\u0088\u00e0\u00bb\u0080\u00e0\u00ba\u0097\u00e0\u00ba\u00bb\u00e0\u00bb\u0088\u00e0\u00ba\u00b2\u00e0\u00bb\u0083\u00e0\u00ba\u0094\u00e0\u00ba\u00a7\u00e0\u00ba\u00b4\u00e0\u00ba\u0099\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b5',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e0\u00ba\u009a\u00e0\u00bb\u008d\u00e0\u00bb\u0088\u00e0\u00bb\u0080\u00e0\u00ba\u0097\u00e0\u00ba\u00bb\u00e0\u00bb\u0088\u00e0\u00ba\u00b2\u00e0\u00bb\u0083\u00e0\u00ba\u0094\u00e0\u00ba\u00a7\u00e0\u00ba\u00b4\u00e0\u00ba\u0099\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00ba\u009c\u00e0\u00bb\u0088\u00e0\u00ba\u00b2\u00e0\u00ba\u0099\u00e0\u00ba\u00a1\u00e0\u00ba\u00b2', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e0\u00ba\u009a\u00e0\u00bb\u008d\u00e0\u00bb\u0088\u00e0\u00bb\u0080\u00e0\u00ba\u0097\u00e0\u00ba\u00bb\u00e0\u00bb\u0088\u00e0\u00ba\u00b2\u00e0\u00bb\u0083\u00e0\u00ba\u0094\u00e0\u00ba\u00a7\u00e0\u00ba\u00b4\u00e0\u00ba\u0099\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00ba\u009c\u00e0\u00bb\u0088\u00e0\u00ba\u00b2\u00e0\u00ba\u0099\u00e0\u00ba\u00a1\u00e0\u00ba\u00b2',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e0\u00ba\u00ad\u00e0\u00ba\u00b5\u00e0\u00ba\u0081 \u00e0\u00ba\u009a\u00e0\u00bb\u008d\u00e0\u00bb\u0088\u00e0\u00bb\u0080\u00e0\u00ba\u0097\u00e0\u00ba\u00bb\u00e0\u00bb\u0088\u00e0\u00ba\u00b2\u00e0\u00bb\u0083\u00e0\u00ba\u0094\u00e0\u00ba\u00a7\u00e0\u00ba\u00b4\u00e0\u00ba\u0099\u00e0\u00ba\u00b2\u00e0\u00ba\u0097\u00e0\u00ba\u00b5', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00e0\u00ba\u00ad\u00e0\u00ba\u00b5\u00e0\u00ba\u0081 5 \u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089\u00e0\u00ba\u0099\u00e0\u00ba\u00b5\u00e0\u00bb\u0089\u00e0\u00bb\u0080\u00e0\u00ba\u00a7\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2 12:00',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089\u00e0\u00ba\u0099\u00e0\u00ba\u00b5\u00e0\u00bb\u0089\u00e0\u00bb\u0080\u00e0\u00ba\u00a7\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2 12:25',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089\u00e0\u00ba\u0099\u00e0\u00ba\u00b5\u00e0\u00bb\u0089\u00e0\u00bb\u0080\u00e0\u00ba\u00a7\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2 13:00',    'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089\u00e0\u00ba\u00ad\u00e0\u00ba\u00b7\u00e0\u00bb\u0088\u00e0\u00ba\u0099\u00e0\u00bb\u0080\u00e0\u00ba\u00a7\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2 12:00',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089\u00e0\u00ba\u0099\u00e0\u00ba\u00b5\u00e0\u00bb\u0089\u00e0\u00bb\u0080\u00e0\u00ba\u00a7\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2 11:00',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e0\u00ba\u00a1\u00e0\u00ba\u00b7\u00e0\u00bb\u0089\u00e0\u00ba\u00a7\u00e0\u00ba\u00b2\u00e0\u00ba\u0099\u00e0\u00ba\u0099\u00e0\u00ba\u00b5\u00e0\u00bb\u0089\u00e0\u00bb\u0080\u00e0\u00ba\u00a7\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2 12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00ba\u00a7\u00e0\u00ba\u00b1\u00e0\u00ba\u0099]dddd[\u00e0\u00bb\u009c\u00e0\u00bb\u0089\u00e0\u00ba\u00b2\u00e0\u00bb\u0080\u00e0\u00ba\u00a7\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00ba\u00a7\u00e0\u00ba\u00b1\u00e0\u00ba\u0099]dddd[\u00e0\u00bb\u009c\u00e0\u00bb\u0089\u00e0\u00ba\u00b2\u00e0\u00bb\u0080\u00e0\u00ba\u00a7\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00ba\u00a7\u00e0\u00ba\u00b1\u00e0\u00ba\u0099]dddd[\u00e0\u00bb\u009c\u00e0\u00bb\u0089\u00e0\u00ba\u00b2\u00e0\u00bb\u0080\u00e0\u00ba\u00a7\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00ba\u00a7\u00e0\u00ba\u00b1\u00e0\u00ba\u0099]dddd[\u00e0\u00bb\u0081\u00e0\u00ba\u00a5\u00e0\u00bb\u0089\u00e0\u00ba\u00a7\u00e0\u00ba\u0099\u00e0\u00ba\u00b5\u00e0\u00bb\u0089\u00e0\u00bb\u0080\u00e0\u00ba\u00a7\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00ba\u00a7\u00e0\u00ba\u00b1\u00e0\u00ba\u0099]dddd[\u00e0\u00bb\u0081\u00e0\u00ba\u00a5\u00e0\u00bb\u0089\u00e0\u00ba\u00a7\u00e0\u00ba\u0099\u00e0\u00ba\u00b5\u00e0\u00bb\u0089\u00e0\u00bb\u0080\u00e0\u00ba\u00a7\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00ba\u00a7\u00e0\u00ba\u00b1\u00e0\u00ba\u0099]dddd[\u00e0\u00bb\u0081\u00e0\u00ba\u00a5\u00e0\u00bb\u0089\u00e0\u00ba\u00a7\u00e0\u00ba\u0099\u00e0\u00ba\u00b5\u00e0\u00bb\u0089\u00e0\u00bb\u0080\u00e0\u00ba\u00a7\u00e0\u00ba\u00a5\u00e0\u00ba\u00b2] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 \u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00881', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 \u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00881', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 \u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00882', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 \u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00882', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 \u00e0\u00ba\u0097\u00e0\u00ba\u00b5\u00e0\u00bb\u00883', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('lt');\n\n    test('parse', function (assert) {\n        var tests = 'sausis sau_vasaris vas_kovas kov_balandis bal_gegu\u00c5\u00be\u00c4\u0097 geg_bir\u00c5\u00beelis bir_liepa lie_rugpj\u00c5\u00abtis rgp_rugs\u00c4\u0097jis rgs_spalis spa_lapkritis lap_gruodis grd'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a',      'sekmadienis, 14-oji vasario 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Sek, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2-oji 02 vasaris vas'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14-oji 14'],\n                ['d do dddd ddd dd',                   '0 0-oji sekmadienis Sek S'],\n                ['DDD DDDo DDDD',                      '45 45-oji 045'],\n                ['w wo ww',                            '6 6-oji 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['DDDo [met\u00c5\u00b3 diena]',                  '45-oji met\u00c5\u00b3 diena'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '2010-02-14'],\n                ['LL',                                 '2010 m. vasaris 14 d.'],\n                ['LLL',                                '2010 m. vasaris 14 d., 15:25 val.'],\n                ['LLLL',                               '2010 m. vasaris 14 d., sekmadienis, 15:25 val.'],\n                ['l',                                  '2010-02-14'],\n                ['ll',                                 '2010 m. vasaris 14 d.'],\n                ['lll',                                '2010 m. vasaris 14 d., 15:25 val.'],\n                ['llll',                               '2010 m. vasaris 14 d., Sek, 15:25 val.']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-oji', '1-oji');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-oji', '2-oji');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-oji', '3-oji');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-oji', '4-oji');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-oji', '5-oji');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-oji', '6-oji');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-oji', '7-oji');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-oji', '8-oji');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-oji', '9-oji');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-oji', '10-oji');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-oji', '11-oji');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-oji', '12-oji');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-oji', '13-oji');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-oji', '14-oji');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-oji', '15-oji');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-oji', '16-oji');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-oji', '17-oji');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-oji', '18-oji');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-oji', '19-oji');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-oji', '20-oji');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-oji', '21-oji');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-oji', '22-oji');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-oji', '23-oji');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-oji', '24-oji');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-oji', '25-oji');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-oji', '26-oji');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-oji', '27-oji');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-oji', '28-oji');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-oji', '29-oji');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-oji', '30-oji');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-oji', '31-oji');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'sausis sau_vasaris vas_kovas kov_balandis bal_gegu\u00c5\u00be\u00c4\u0097 geg_bir\u00c5\u00beelis bir_liepa lie_rugpj\u00c5\u00abtis rgp_rugs\u00c4\u0097jis rgs_spalis spa_lapkritis lap_gruodis grd'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'sekmadienis Sek S_pirmadienis Pir P_antradienis Ant A_tre\u00c4\u008diadienis Tre T_ketvirtadienis Ket K_penktadienis Pen Pn_\u00c5\u00a1e\u00c5\u00a1tadienis \u00c5\u00a0e\u00c5\u00a1 \u00c5\u00a0'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week on US calendar', function (assert) {\n        // Tests, whether the weekday names are correct, even if the week does not start on Monday\n        moment.updateLocale('lt', {week: {dow: 0, doy: 6}});\n        var expected = 'sekmadienis Sek S_pirmadienis Pir P_antradienis Ant A_tre\u00c4\u008diadienis Tre T_ketvirtadienis Ket K_penktadienis Pen Pn_\u00c5\u00a1e\u00c5\u00a1tadienis \u00c5\u00a0e\u00c5\u00a1 \u00c5\u00a0'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n        moment.updateLocale('lt', null);\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'kelios sekund\u00c4\u0097s', '44 seconds = seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minut\u00c4\u0097',          '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minut\u00c4\u0097',          '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minut\u00c4\u0097s',       '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 10}), true),  '10 minu\u00c4\u008di\u00c5\u00b3',       '10 minutes = 10 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 11}), true),  '11 minu\u00c4\u008di\u00c5\u00b3',       '11 minutes = 11 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 19}), true),  '19 minu\u00c4\u008di\u00c5\u00b3',       '19 minutes = 19 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 20}), true),  '20 minu\u00c4\u008di\u00c5\u00b3',       '20 minutes = 20 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minut\u00c4\u0097s',      '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'valanda',         '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'valanda',         '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 valandos',      '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 valandos',      '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 10}), true),  '10 valand\u00c5\u00b3',      '10 hours = 10 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 valandos',     '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'diena',           '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'diena',           '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dienos',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'diena',           '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dienos',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 10}), true),  '10 dien\u00c5\u00b3',        '10 days = 10 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dienos',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'm\u00c4\u0097nuo',           '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'm\u00c4\u0097nuo',           '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'm\u00c4\u0097nuo',           '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m\u00c4\u0097nesiai',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m\u00c4\u0097nesiai',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m\u00c4\u0097nesiai',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'm\u00c4\u0097nuo',           '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m\u00c4\u0097nesiai',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 10}), true),  '10 m\u00c4\u0097nesi\u00c5\u00b3',      '10 months = 10 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'metai',           '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 metai',         '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'metai',           '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 metai',         '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'po keli\u00c5\u00b3 sekund\u00c5\u00bei\u00c5\u00b3',  'prefix');\n        assert.equal(moment(0).from(30000), 'prie\u00c5\u00a1 kelias sekundes', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'prie\u00c5\u00a1 kelias sekundes',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'po keli\u00c5\u00b3 sekund\u00c5\u00bei\u00c5\u00b3', 'in seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'po 5 dien\u00c5\u00b3', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00c5\u00a0iandien 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00c5\u00a0iandien 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00c5\u00a0iandien 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Rytoj 12:00',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00c5\u00a0iandien 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Vakar 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[Pra\u00c4\u0097jus\u00c4\u00af] dddd LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[Pra\u00c4\u0097jus\u00c4\u00af] dddd LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[Pra\u00c4\u0097jus\u00c4\u00af] dddd LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52-oji', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1-oji', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1-oji', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2-oji', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2-oji', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('lv');\n\n    test('parse', function (assert) {\n        var tests = 'janv\u00c4\u0081ris jan_febru\u00c4\u0081ris feb_marts mar_apr\u00c4\u00ablis apr_maijs mai_j\u00c5\u00abnijs j\u00c5\u00abn_j\u00c5\u00ablijs j\u00c5\u00abl_augusts aug_septembris sep_oktobris okt_novembris nov_decembris dec'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a',      'sv\u00c4\u0093tdiena, 14. febru\u00c4\u0081ris 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Sv, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 febru\u00c4\u0081ris feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. sv\u00c4\u0093tdiena Sv Sv'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010.'],\n                ['LL',                                 '2010. gada 14. febru\u00c4\u0081ris'],\n                ['LLL',                                '2010. gada 14. febru\u00c4\u0081ris, 15:25'],\n                ['LLLL',                               '2010. gada 14. febru\u00c4\u0081ris, sv\u00c4\u0093tdiena, 15:25'],\n                ['l',                                  '14.2.2010.'],\n                ['ll',                                 '2010. gada 14. feb'],\n                ['lll',                                '2010. gada 14. feb, 15:25'],\n                ['llll',                               '2010. gada 14. feb, Sv, 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'janv\u00c4\u0081ris jan_febru\u00c4\u0081ris feb_marts mar_apr\u00c4\u00ablis apr_maijs mai_j\u00c5\u00abnijs j\u00c5\u00abn_j\u00c5\u00ablijs j\u00c5\u00abl_augusts aug_septembris sep_oktobris okt_novembris nov_decembris dec'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'sv\u00c4\u0093tdiena Sv Sv_pirmdiena P P_otrdiena O O_tre\u00c5\u00a1diena T T_ceturtdiena C C_piektdiena Pk Pk_sestdiena S S'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    // Includes testing the cases of withoutSuffix = true and false.\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),   'da\u00c5\u00beas sekundes',       '44 seconds = seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), false),  'pirms da\u00c5\u00be\u00c4\u0081m sekund\u00c4\u0093m', '44 seconds with suffix = seconds ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),   'min\u00c5\u00abte',               '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), false),  'pirms min\u00c5\u00abtes',        '45 seconds with suffix = a minute ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),   'min\u00c5\u00abte',               '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: -89}), false), 'p\u00c4\u0093c min\u00c5\u00abtes',          '89 seconds with suffix/prefix = in a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),   '2 min\u00c5\u00abtes',            '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), false),  'pirms 2 min\u00c5\u00abt\u00c4\u0093m',      '90 seconds with suffix = 2 minutes ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),   '44 min\u00c5\u00abtes',           '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), false),  'pirms 44 min\u00c5\u00abt\u00c4\u0093m',     '44 minutes with suffix = 44 minutes ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),   'stunda',               '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), false),  'pirms stundas',        '45 minutes with suffix = an hour ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),   'stunda',               '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),   '2 stundas',            '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: -90}), false), 'p\u00c4\u0093c 2 stund\u00c4\u0081m',        '90 minutes with suffix = in 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),    '5 stundas',            '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), false),   'pirms 5 stund\u00c4\u0081m',      '5 hours with suffix = 5 hours ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),   '21 stunda',            '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), false),  'pirms 21 stundas',     '21 hours with suffix = 21 hours ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),   'diena',                '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), false),  'pirms dienas',         '22 hours with suffix = a day ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),   'diena',                '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),   '2 dienas',             '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), false),  'pirms 2 dien\u00c4\u0081m',       '36 hours with suffix = 2 days ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),    'diena',                '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),    '5 dienas',             '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), false),   'pirms 5 dien\u00c4\u0081m',       '5 days with suffix = 5 days ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),   '25 dienas',            '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), false),  'pirms 25 dien\u00c4\u0081m',      '25 days with suffix = 25 days ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),   'm\u00c4\u0093nesis',              '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), false),  'pirms m\u00c4\u0093ne\u00c5\u00a1a',         '26 days with suffix = a month ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),   'm\u00c4\u0093nesis',              '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),   'm\u00c4\u0093nesis',              '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),   '2 m\u00c4\u0093ne\u00c5\u00a1i',             '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), false),  'pirms 2 m\u00c4\u0093ne\u00c5\u00a1iem',     '46 days with suffix = 2 months ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),   '2 m\u00c4\u0093ne\u00c5\u00a1i',             '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),   '3 m\u00c4\u0093ne\u00c5\u00a1i',             '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), false),  'pirms 3 m\u00c4\u0093ne\u00c5\u00a1iem',     '76 days with suffix = 3 months ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),    'm\u00c4\u0093nesis',              '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),    '5 m\u00c4\u0093ne\u00c5\u00a1i',             '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), false),   'pirms 5 m\u00c4\u0093ne\u00c5\u00a1iem',     '5 months with suffix = 5 months ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true),  'gads',                 '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), false), 'pirms gada',           '345 days with suffix = a year ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true),  '2 gadi',               '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), false), 'pirms 2 gadiem',       '548 days with suffix = 2 years ago');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),    'gads',                 '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),    '5 gadi',               '5 years = 5 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), false),   'pirms 5 gadiem',       '5 years with suffix = 5 years ago');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'p\u00c4\u0093c da\u00c5\u00be\u00c4\u0081m sekund\u00c4\u0093m',  'prefix');\n        assert.equal(moment(0).from(30000), 'pirms da\u00c5\u00be\u00c4\u0081m sekund\u00c4\u0093m', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'pirms da\u00c5\u00be\u00c4\u0081m sekund\u00c4\u0093m',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'p\u00c4\u0093c da\u00c5\u00be\u00c4\u0081m sekund\u00c4\u0093m', 'in seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'p\u00c4\u0093c 5 dien\u00c4\u0081m', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00c5\u00a0odien pulksten 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00c5\u00a0odien pulksten 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00c5\u00a0odien pulksten 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'R\u00c4\u00abt pulksten 12:00',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00c5\u00a0odien pulksten 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Vakar pulksten 12:00',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [pulksten] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [pulksten] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [pulksten] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[Pag\u00c4\u0081ju\u00c5\u00a1\u00c4\u0081] dddd [pulksten] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[Pag\u00c4\u0081ju\u00c5\u00a1\u00c4\u0081] dddd [pulksten] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[Pag\u00c4\u0081ju\u00c5\u00a1\u00c4\u0081] dddd [pulksten] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('me');\n\n    test('parse', function (assert) {\n        var tests = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),\n            i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedjelja, 14. februar 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'ned., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. nedjelja ned. ne'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '7 7. 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14. 02. 2010'],\n                ['LL',                                 '14. februar 2010'],\n                ['LLL',                                '14. februar 2010 15:25'],\n                ['LLLL',                               'nedjelja, 14. februar 2010 15:25'],\n                ['l',                                  '14. 2. 2010'],\n                ['ll',                                 '14. feb. 2010'],\n                ['lll',                                '14. feb. 2010 15:25'],\n                ['llll',                               'ned., 14. feb. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'nedjelja ned. ne_ponedjeljak pon. po_utorak uto. ut_srijeda sri. sr_\u00c4\u008detvrtak \u00c4\u008det. \u00c4\u008de_petak pet. pe_subota sub. su'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nekoliko sekundi', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedan minut',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedan minut',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuta',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mjesec',     '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mjesec',     '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mjesec',     '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mjeseca',     '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mjeseca',     '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mjeseca',     '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mjesec',     '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mjeseci',    '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'za nekoliko sekundi',  'prefix');\n        assert.equal(moment(0).from(30000), 'prije nekoliko sekundi', 'prefix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'prije nekoliko sekundi',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'za nekoliko sekundi', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'danas u 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'sjutra u 12:00', 'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ju\u00c4\u008de u 12:00',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n                return '[u] [nedjelju] [u] LT';\n            case 3:\n                return '[u] [srijedu] [u] LT';\n            case 6:\n                return '[u] [subotu] [u] LT';\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n                return '[u] dddd [u] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            var lastWeekDay = [\n                    '[pro\u00c5\u00a1le] [nedjelje] [u] LT',\n                    '[pro\u00c5\u00a1log] [ponedjeljka] [u] LT',\n                    '[pro\u00c5\u00a1log] [utorka] [u] LT',\n                    '[pro\u00c5\u00a1le] [srijede] [u] LT',\n                    '[pro\u00c5\u00a1log] [\u00c4\u008detvrtka] [u] LT',\n                    '[pro\u00c5\u00a1log] [petka] [u] LT',\n                    '[pro\u00c5\u00a1le] [subote] [u] LT'\n                ];\n\n            return lastWeekDay[d.day()];\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    // Monday is the first day of the week.\n    // The week that contains Jan 1st is the first week of the year.\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('mk');\n\n    test('parse', function (assert) {\n        var tests = '\u00d1\u0098\u00d0\u00b0\u00d0\u00bd\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 \u00d1\u0098\u00d0\u00b0\u00d0\u00bd_\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2_\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b8\u00d0\u00bb \u00d0\u00b0\u00d0\u00bf\u00d1\u0080_\u00d0\u00bc\u00d0\u00b0\u00d1\u0098 \u00d0\u00bc\u00d0\u00b0\u00d1\u0098_\u00d1\u0098\u00d1\u0083\u00d0\u00bd\u00d0\u00b8 \u00d1\u0098\u00d1\u0083\u00d0\u00bd_\u00d1\u0098\u00d1\u0083\u00d0\u00bb\u00d0\u00b8 \u00d1\u0098\u00d1\u0083\u00d0\u00bb_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3_\u00d1\u0081\u00d0\u00b5\u00d0\u00bf\u00d1\u0082\u00d0\u00b5\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d1\u0081\u00d0\u00b5\u00d0\u00bf_\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d0\u00be\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d0\u00be\u00d0\u00ba\u00d1\u0082_\u00d0\u00bd\u00d0\u00be\u00d0\u00b5\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d0\u00bd\u00d0\u00be\u00d0\u00b5_\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b5\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, H:mm:ss',        '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d0\u00bb\u00d0\u00b0, \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 14-\u00d1\u0082\u00d0\u00b8 2010, 15:25:50'],\n                ['ddd, hA',                            '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2-\u00d1\u0080\u00d0\u00b8 02 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14-\u00d1\u0082\u00d0\u00b8 14'],\n                ['d do dddd ddd dd',                   '0 0-\u00d0\u00b5\u00d0\u00b2 \u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d0\u00bb\u00d0\u00b0 \u00d0\u00bd\u00d0\u00b5\u00d0\u00b4 \u00d0\u00bde'],\n                ['DDD DDDo DDDD',                      '45 45-\u00d1\u0082\u00d0\u00b8 045'],\n                ['w wo ww',                            '7 7-\u00d0\u00bc\u00d0\u00b8 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45-\u00d1\u0082\u00d0\u00b8 day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 2010'],\n                ['LLL',                                '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 2010 15:25'],\n                ['LLLL',                               '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d0\u00bb\u00d0\u00b0, 14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 2010 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2 2010'],\n                ['lll',                                '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2 2010 15:25'],\n                ['llll',                               '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4, 14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-\u00d0\u00b2\u00d0\u00b8', '1-\u00d0\u00b2\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-\u00d1\u0080\u00d0\u00b8', '2-\u00d1\u0080\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-\u00d1\u0082\u00d0\u00b8', '3-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-\u00d1\u0082\u00d0\u00b8', '4-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-\u00d1\u0082\u00d0\u00b8', '5-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-\u00d1\u0082\u00d0\u00b8', '6-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-\u00d0\u00bc\u00d0\u00b8', '7-\u00d0\u00bc\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-\u00d0\u00bc\u00d0\u00b8', '8-\u00d0\u00bc\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-\u00d1\u0082\u00d0\u00b8', '9-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-\u00d1\u0082\u00d0\u00b8', '10-\u00d1\u0082\u00d0\u00b8');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-\u00d1\u0082\u00d0\u00b8', '11-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-\u00d1\u0082\u00d0\u00b8', '12-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-\u00d1\u0082\u00d0\u00b8', '13-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-\u00d1\u0082\u00d0\u00b8', '14-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-\u00d1\u0082\u00d0\u00b8', '15-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-\u00d1\u0082\u00d0\u00b8', '16-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-\u00d1\u0082\u00d0\u00b8', '17-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-\u00d1\u0082\u00d0\u00b8', '18-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-\u00d1\u0082\u00d0\u00b8', '19-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-\u00d1\u0082\u00d0\u00b8', '20-\u00d1\u0082\u00d0\u00b8');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-\u00d0\u00b2\u00d0\u00b8', '21-\u00d0\u00b2\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-\u00d1\u0080\u00d0\u00b8', '22-\u00d1\u0080\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-\u00d1\u0082\u00d0\u00b8', '23-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-\u00d1\u0082\u00d0\u00b8', '24-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-\u00d1\u0082\u00d0\u00b8', '25-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-\u00d1\u0082\u00d0\u00b8', '26-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-\u00d0\u00bc\u00d0\u00b8', '27-\u00d0\u00bc\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-\u00d0\u00bc\u00d0\u00b8', '28-\u00d0\u00bc\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-\u00d1\u0082\u00d0\u00b8', '29-\u00d1\u0082\u00d0\u00b8');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-\u00d1\u0082\u00d0\u00b8', '30-\u00d1\u0082\u00d0\u00b8');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-\u00d0\u00b2\u00d0\u00b8', '31-\u00d0\u00b2\u00d0\u00b8');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d1\u0098\u00d0\u00b0\u00d0\u00bd\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 \u00d1\u0098\u00d0\u00b0\u00d0\u00bd_\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080\u00d0\u00b8 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2_\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b8\u00d0\u00bb \u00d0\u00b0\u00d0\u00bf\u00d1\u0080_\u00d0\u00bc\u00d0\u00b0\u00d1\u0098 \u00d0\u00bc\u00d0\u00b0\u00d1\u0098_\u00d1\u0098\u00d1\u0083\u00d0\u00bd\u00d0\u00b8 \u00d1\u0098\u00d1\u0083\u00d0\u00bd_\u00d1\u0098\u00d1\u0083\u00d0\u00bb\u00d0\u00b8 \u00d1\u0098\u00d1\u0083\u00d0\u00bb_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3_\u00d1\u0081\u00d0\u00b5\u00d0\u00bf\u00d1\u0082\u00d0\u00b5\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d1\u0081\u00d0\u00b5\u00d0\u00bf_\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d0\u00be\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d0\u00be\u00d0\u00ba\u00d1\u0082_\u00d0\u00bd\u00d0\u00be\u00d0\u00b5\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d0\u00bd\u00d0\u00be\u00d0\u00b5_\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b5\u00d0\u00bc\u00d0\u00b2\u00d1\u0080\u00d0\u00b8 \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d0\u00bb\u00d0\u00b0 \u00d0\u00bd\u00d0\u00b5\u00d0\u00b4 \u00d0\u00bde_\u00d0\u00bf\u00d0\u00be\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d0\u00bb\u00d0\u00bd\u00d0\u00b8\u00d0\u00ba \u00d0\u00bf\u00d0\u00be\u00d0\u00bd \u00d0\u00bfo_\u00d0\u00b2\u00d1\u0082\u00d0\u00be\u00d1\u0080\u00d0\u00bd\u00d0\u00b8\u00d0\u00ba \u00d0\u00b2\u00d1\u0082\u00d0\u00be \u00d0\u00b2\u00d1\u0082_\u00d1\u0081\u00d1\u0080\u00d0\u00b5\u00d0\u00b4\u00d0\u00b0 \u00d1\u0081\u00d1\u0080\u00d0\u00b5 \u00d1\u0081\u00d1\u0080_\u00d1\u0087\u00d0\u00b5\u00d1\u0082\u00d0\u00b2\u00d1\u0080\u00d1\u0082\u00d0\u00be\u00d0\u00ba \u00d1\u0087\u00d0\u00b5\u00d1\u0082 \u00d1\u0087\u00d0\u00b5_\u00d0\u00bf\u00d0\u00b5\u00d1\u0082\u00d0\u00be\u00d0\u00ba \u00d0\u00bf\u00d0\u00b5\u00d1\u0082 \u00d0\u00bf\u00d0\u00b5_\u00d1\u0081\u00d0\u00b0\u00d0\u00b1\u00d0\u00be\u00d1\u0082\u00d0\u00b0 \u00d1\u0081\u00d0\u00b0\u00d0\u00b1 \u00d1\u0081a'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00ba\u00d1\u0083 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b0',          '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b0',          '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b8',        '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b8',       '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d1\u0087\u00d0\u00b0\u00d1\u0081',             '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d1\u0087\u00d0\u00b0\u00d1\u0081',             '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00d1\u0087\u00d0\u00b0\u00d1\u0081\u00d0\u00b0',          '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d1\u0087\u00d0\u00b0\u00d1\u0081\u00d0\u00b0',          '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d1\u0087\u00d0\u00b0\u00d1\u0081\u00d0\u00b0',         '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd',             '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd',             '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d0\u00b0',          '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd',             '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d0\u00b0',          '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d0\u00b0',         '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086',           '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086',           '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086',           '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086\u00d0\u00b8',        '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086\u00d0\u00b8',        '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086\u00d0\u00b8',        '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086',           '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086\u00d0\u00b8',        '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d0\u00b0',          '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d0\u00b8',        '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d0\u00b0',          '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d0\u00b8',        '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d0\u00bf\u00d0\u00be\u00d1\u0081\u00d0\u00bb\u00d0\u00b5 \u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00ba\u00d1\u0083 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8', 'prefix');\n        assert.equal(moment(0).from(30000), '\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00b4 \u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00ba\u00d1\u0083 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8',  'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00b4 \u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00ba\u00d1\u0083 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d0\u00bf\u00d0\u00be\u00d1\u0081\u00d0\u00bb\u00d0\u00b5 \u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00ba\u00d1\u0083 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(),  '\u00d0\u00bf\u00d0\u00be\u00d1\u0081\u00d0\u00bb\u00d0\u00b5 5 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d0\u00b0', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d0\u0094\u00d0\u00b5\u00d0\u00bd\u00d0\u00b5\u00d1\u0081 \u00d0\u00b2\u00d0\u00be 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d0\u0094\u00d0\u00b5\u00d0\u00bd\u00d0\u00b5\u00d1\u0081 \u00d0\u00b2\u00d0\u00be 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d0\u0094\u00d0\u00b5\u00d0\u00bd\u00d0\u00b5\u00d1\u0081 \u00d0\u00b2\u00d0\u00be 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d0\u00a3\u00d1\u0082\u00d1\u0080\u00d0\u00b5 \u00d0\u00b2\u00d0\u00be 12:00',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d0\u0094\u00d0\u00b5\u00d0\u00bd\u00d0\u00b5\u00d1\u0081 \u00d0\u00b2\u00d0\u00be 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d0\u0092\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b0 \u00d0\u00b2\u00d0\u00be 12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00d0\u0092\u00d0\u00be] dddd [\u00d0\u00b2\u00d0\u00be] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00d0\u0092\u00d0\u00be] dddd [\u00d0\u00b2\u00d0\u00be] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00d0\u0092\u00d0\u00be] dddd [\u00d0\u00b2\u00d0\u00be] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n            case 3:\n            case 6:\n                return '[\u00d0\u0098\u00d0\u00b7\u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d0\u00b0\u00d1\u0082\u00d0\u00b0\u00d1\u0082\u00d0\u00b0] dddd [\u00d0\u00b2\u00d0\u00be] LT';\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n                return '[\u00d0\u0098\u00d0\u00b7\u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d0\u00b0\u00d1\u0082\u00d0\u00b8\u00d0\u00be\u00d1\u0082] dddd [\u00d0\u00b2\u00d0\u00be] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-\u00d0\u00b2\u00d0\u00b8', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-\u00d0\u00b2\u00d0\u00b8', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-\u00d1\u0080\u00d0\u00b8', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-\u00d1\u0080\u00d0\u00b8', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-\u00d1\u0082\u00d0\u00b8', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ml');\n\n    test('parse', function (assert) {\n        var tests = '\u00e0\u00b4\u009c\u00e0\u00b4\u00a8\u00e0\u00b5\u0081\u00e0\u00b4\u00b5\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf \u00e0\u00b4\u009c\u00e0\u00b4\u00a8\u00e0\u00b5\u0081._\u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081\u00e0\u00b4\u00b5\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf \u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081._\u00e0\u00b4\u00ae\u00e0\u00b4\u00be\u00e0\u00b5\u00bc\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a\u00e0\u00b5\u008d \u00e0\u00b4\u00ae\u00e0\u00b4\u00be\u00e0\u00b5\u00bc._\u00e0\u00b4\u008f\u00e0\u00b4\u00aa\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf\u00e0\u00b5\u00bd \u00e0\u00b4\u008f\u00e0\u00b4\u00aa\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf._\u00e0\u00b4\u00ae\u00e0\u00b5\u0087\u00e0\u00b4\u00af\u00e0\u00b5\u008d \u00e0\u00b4\u00ae\u00e0\u00b5\u0087\u00e0\u00b4\u00af\u00e0\u00b5\u008d_\u00e0\u00b4\u009c\u00e0\u00b5\u0082\u00e0\u00b5\u00ba \u00e0\u00b4\u009c\u00e0\u00b5\u0082\u00e0\u00b5\u00ba_\u00e0\u00b4\u009c\u00e0\u00b5\u0082\u00e0\u00b4\u00b2\u00e0\u00b5\u0088 \u00e0\u00b4\u009c\u00e0\u00b5\u0082\u00e0\u00b4\u00b2\u00e0\u00b5\u0088._\u00e0\u00b4\u0093\u00e0\u00b4\u0097\u00e0\u00b4\u00b8\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b5\u008d \u00e0\u00b4\u0093\u00e0\u00b4\u0097._\u00e0\u00b4\u00b8\u00e0\u00b5\u0086\u00e0\u00b4\u00aa\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b4\u0082\u00e0\u00b4\u00ac\u00e0\u00b5\u00bc \u00e0\u00b4\u00b8\u00e0\u00b5\u0086\u00e0\u00b4\u00aa\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b5\u008d\u00e0\u00b4\u00b1._\u00e0\u00b4\u0092\u00e0\u00b4\u0095\u00e0\u00b5\u008d\u00e0\u00b4\u009f\u00e0\u00b5\u008b\u00e0\u00b4\u00ac\u00e0\u00b5\u00bc \u00e0\u00b4\u0092\u00e0\u00b4\u0095\u00e0\u00b5\u008d\u00e0\u00b4\u009f\u00e0\u00b5\u008b._\u00e0\u00b4\u00a8\u00e0\u00b4\u00b5\u00e0\u00b4\u0082\u00e0\u00b4\u00ac\u00e0\u00b5\u00bc \u00e0\u00b4\u00a8\u00e0\u00b4\u00b5\u00e0\u00b4\u0082._\u00e0\u00b4\u00a1\u00e0\u00b4\u00bf\u00e0\u00b4\u00b8\u00e0\u00b4\u0082\u00e0\u00b4\u00ac\u00e0\u00b5\u00bc \u00e0\u00b4\u00a1\u00e0\u00b4\u00bf\u00e0\u00b4\u00b8\u00e0\u00b4\u0082.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, a h:mm:ss -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081',  '\u00e0\u00b4\u009e\u00e0\u00b4\u00be\u00e0\u00b4\u00af\u00e0\u00b4\u00b1\u00e0\u00b4\u00be\u00e0\u00b4\u00b4\u00e0\u00b5\u008d\u00e0\u00b4\u009a, 14 \u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081\u00e0\u00b4\u00b5\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf 2010, \u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d 3:25:50 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081'],\n                ['ddd, a h -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081',                       '\u00e0\u00b4\u009e\u00e0\u00b4\u00be\u00e0\u00b4\u00af\u00e0\u00b5\u00bc, \u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d 3 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 \u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081\u00e0\u00b4\u00b5\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf \u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 \u00e0\u00b4\u009e\u00e0\u00b4\u00be\u00e0\u00b4\u00af\u00e0\u00b4\u00b1\u00e0\u00b4\u00be\u00e0\u00b4\u00b4\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u009e\u00e0\u00b4\u00be\u00e0\u00b4\u00af\u00e0\u00b5\u00bc \u00e0\u00b4\u009e\u00e0\u00b4\u00be'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '8 8 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d \u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d'],\n                ['LTS',                                '\u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d 3:25:50 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 \u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081\u00e0\u00b4\u00b5\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf 2010'],\n                ['LLL',                                '14 \u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081\u00e0\u00b4\u00b5\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf 2010, \u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d 3:25 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081'],\n                ['LLLL',                               '\u00e0\u00b4\u009e\u00e0\u00b4\u00be\u00e0\u00b4\u00af\u00e0\u00b4\u00b1\u00e0\u00b4\u00be\u00e0\u00b4\u00b4\u00e0\u00b5\u008d\u00e0\u00b4\u009a, 14 \u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081\u00e0\u00b4\u00b5\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf 2010, \u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d 3:25 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 \u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081. 2010'],\n                ['lll',                                '14 \u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081. 2010, \u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d 3:25 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081'],\n                ['llll',                               '\u00e0\u00b4\u009e\u00e0\u00b4\u00be\u00e0\u00b4\u00af\u00e0\u00b5\u00bc, 14 \u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081. 2010, \u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d 3:25 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e0\u00b4\u009c\u00e0\u00b4\u00a8\u00e0\u00b5\u0081\u00e0\u00b4\u00b5\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf \u00e0\u00b4\u009c\u00e0\u00b4\u00a8\u00e0\u00b5\u0081._\u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081\u00e0\u00b4\u00b5\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf \u00e0\u00b4\u00ab\u00e0\u00b5\u0086\u00e0\u00b4\u00ac\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b5\u0081._\u00e0\u00b4\u00ae\u00e0\u00b4\u00be\u00e0\u00b5\u00bc\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a\u00e0\u00b5\u008d \u00e0\u00b4\u00ae\u00e0\u00b4\u00be\u00e0\u00b5\u00bc._\u00e0\u00b4\u008f\u00e0\u00b4\u00aa\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf\u00e0\u00b5\u00bd \u00e0\u00b4\u008f\u00e0\u00b4\u00aa\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf._\u00e0\u00b4\u00ae\u00e0\u00b5\u0087\u00e0\u00b4\u00af\u00e0\u00b5\u008d \u00e0\u00b4\u00ae\u00e0\u00b5\u0087\u00e0\u00b4\u00af\u00e0\u00b5\u008d_\u00e0\u00b4\u009c\u00e0\u00b5\u0082\u00e0\u00b5\u00ba \u00e0\u00b4\u009c\u00e0\u00b5\u0082\u00e0\u00b5\u00ba_\u00e0\u00b4\u009c\u00e0\u00b5\u0082\u00e0\u00b4\u00b2\u00e0\u00b5\u0088 \u00e0\u00b4\u009c\u00e0\u00b5\u0082\u00e0\u00b4\u00b2\u00e0\u00b5\u0088._\u00e0\u00b4\u0093\u00e0\u00b4\u0097\u00e0\u00b4\u00b8\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b5\u008d \u00e0\u00b4\u0093\u00e0\u00b4\u0097._\u00e0\u00b4\u00b8\u00e0\u00b5\u0086\u00e0\u00b4\u00aa\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b4\u0082\u00e0\u00b4\u00ac\u00e0\u00b5\u00bc \u00e0\u00b4\u00b8\u00e0\u00b5\u0086\u00e0\u00b4\u00aa\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b5\u008d\u00e0\u00b4\u00b1._\u00e0\u00b4\u0092\u00e0\u00b4\u0095\u00e0\u00b5\u008d\u00e0\u00b4\u009f\u00e0\u00b5\u008b\u00e0\u00b4\u00ac\u00e0\u00b5\u00bc \u00e0\u00b4\u0092\u00e0\u00b4\u0095\u00e0\u00b5\u008d\u00e0\u00b4\u009f\u00e0\u00b5\u008b._\u00e0\u00b4\u00a8\u00e0\u00b4\u00b5\u00e0\u00b4\u0082\u00e0\u00b4\u00ac\u00e0\u00b5\u00bc \u00e0\u00b4\u00a8\u00e0\u00b4\u00b5\u00e0\u00b4\u0082._\u00e0\u00b4\u00a1\u00e0\u00b4\u00bf\u00e0\u00b4\u00b8\u00e0\u00b4\u0082\u00e0\u00b4\u00ac\u00e0\u00b5\u00bc \u00e0\u00b4\u00a1\u00e0\u00b4\u00bf\u00e0\u00b4\u00b8\u00e0\u00b4\u0082.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e0\u00b4\u009e\u00e0\u00b4\u00be\u00e0\u00b4\u00af\u00e0\u00b4\u00b1\u00e0\u00b4\u00be\u00e0\u00b4\u00b4\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u009e\u00e0\u00b4\u00be\u00e0\u00b4\u00af\u00e0\u00b5\u00bc \u00e0\u00b4\u009e\u00e0\u00b4\u00be_\u00e0\u00b4\u00a4\u00e0\u00b4\u00bf\u00e0\u00b4\u0099\u00e0\u00b5\u008d\u00e0\u00b4\u0095\u00e0\u00b4\u00b3\u00e0\u00b4\u00be\u00e0\u00b4\u00b4\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u00a4\u00e0\u00b4\u00bf\u00e0\u00b4\u0099\u00e0\u00b5\u008d\u00e0\u00b4\u0095\u00e0\u00b5\u00be \u00e0\u00b4\u00a4\u00e0\u00b4\u00bf_\u00e0\u00b4\u009a\u00e0\u00b5\u008a\u00e0\u00b4\u00b5\u00e0\u00b5\u008d\u00e0\u00b4\u00b5\u00e0\u00b4\u00be\u00e0\u00b4\u00b4\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u009a\u00e0\u00b5\u008a\u00e0\u00b4\u00b5\u00e0\u00b5\u008d\u00e0\u00b4\u00b5 \u00e0\u00b4\u009a\u00e0\u00b5\u008a_\u00e0\u00b4\u00ac\u00e0\u00b5\u0081\u00e0\u00b4\u00a7\u00e0\u00b4\u00a8\u00e0\u00b4\u00be\u00e0\u00b4\u00b4\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u00ac\u00e0\u00b5\u0081\u00e0\u00b4\u00a7\u00e0\u00b5\u00bb \u00e0\u00b4\u00ac\u00e0\u00b5\u0081_\u00e0\u00b4\u00b5\u00e0\u00b5\u008d\u00e0\u00b4\u00af\u00e0\u00b4\u00be\u00e0\u00b4\u00b4\u00e0\u00b4\u00be\u00e0\u00b4\u00b4\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u00b5\u00e0\u00b5\u008d\u00e0\u00b4\u00af\u00e0\u00b4\u00be\u00e0\u00b4\u00b4\u00e0\u00b4\u0082 \u00e0\u00b4\u00b5\u00e0\u00b5\u008d\u00e0\u00b4\u00af\u00e0\u00b4\u00be_\u00e0\u00b4\u00b5\u00e0\u00b5\u0086\u00e0\u00b4\u00b3\u00e0\u00b5\u008d\u00e0\u00b4\u00b3\u00e0\u00b4\u00bf\u00e0\u00b4\u00af\u00e0\u00b4\u00be\u00e0\u00b4\u00b4\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u00b5\u00e0\u00b5\u0086\u00e0\u00b4\u00b3\u00e0\u00b5\u008d\u00e0\u00b4\u00b3\u00e0\u00b4\u00bf \u00e0\u00b4\u00b5\u00e0\u00b5\u0086_\u00e0\u00b4\u00b6\u00e0\u00b4\u00a8\u00e0\u00b4\u00bf\u00e0\u00b4\u00af\u00e0\u00b4\u00be\u00e0\u00b4\u00b4\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u00b6\u00e0\u00b4\u00a8\u00e0\u00b4\u00bf \u00e0\u00b4\u00b6'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e0\u00b4\u0085\u00e0\u00b5\u00bd\u00e0\u00b4\u00aa \u00e0\u00b4\u00a8\u00e0\u00b4\u00bf\u00e0\u00b4\u00ae\u00e0\u00b4\u00bf\u00e0\u00b4\u00b7\u00e0\u00b4\u0099\u00e0\u00b5\u008d\u00e0\u00b4\u0099\u00e0\u00b5\u00be', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00ae\u00e0\u00b4\u00bf\u00e0\u00b4\u00a8\u00e0\u00b4\u00bf\u00e0\u00b4\u00b1\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b5\u008d',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00ae\u00e0\u00b4\u00bf\u00e0\u00b4\u00a8\u00e0\u00b4\u00bf\u00e0\u00b4\u00b1\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b5\u008d',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00e0\u00b4\u00ae\u00e0\u00b4\u00bf\u00e0\u00b4\u00a8\u00e0\u00b4\u00bf\u00e0\u00b4\u00b1\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b5\u008d',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00e0\u00b4\u00ae\u00e0\u00b4\u00bf\u00e0\u00b4\u00a8\u00e0\u00b4\u00bf\u00e0\u00b4\u00b1\u00e0\u00b5\u008d\u00e0\u00b4\u00b1\u00e0\u00b5\u008d',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00ae\u00e0\u00b4\u00a3\u00e0\u00b4\u00bf\u00e0\u00b4\u0095\u00e0\u00b5\u008d\u00e0\u00b4\u0095\u00e0\u00b5\u0082\u00e0\u00b5\u00bc',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00ae\u00e0\u00b4\u00a3\u00e0\u00b4\u00bf\u00e0\u00b4\u0095\u00e0\u00b5\u008d\u00e0\u00b4\u0095\u00e0\u00b5\u0082\u00e0\u00b5\u00bc',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00e0\u00b4\u00ae\u00e0\u00b4\u00a3\u00e0\u00b4\u00bf\u00e0\u00b4\u0095\u00e0\u00b5\u008d\u00e0\u00b4\u0095\u00e0\u00b5\u0082\u00e0\u00b5\u00bc',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00e0\u00b4\u00ae\u00e0\u00b4\u00a3\u00e0\u00b4\u00bf\u00e0\u00b4\u0095\u00e0\u00b5\u008d\u00e0\u00b4\u0095\u00e0\u00b5\u0082\u00e0\u00b5\u00bc',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00e0\u00b4\u00ae\u00e0\u00b4\u00a3\u00e0\u00b4\u00bf\u00e0\u00b4\u0095\u00e0\u00b5\u008d\u00e0\u00b4\u0095\u00e0\u00b5\u0082\u00e0\u00b5\u00bc',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00a6\u00e0\u00b4\u00bf\u00e0\u00b4\u00b5\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00a6\u00e0\u00b4\u00bf\u00e0\u00b4\u00b5\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00e0\u00b4\u00a6\u00e0\u00b4\u00bf\u00e0\u00b4\u00b5\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00a6\u00e0\u00b4\u00bf\u00e0\u00b4\u00b5\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00e0\u00b4\u00a6\u00e0\u00b4\u00bf\u00e0\u00b4\u00b5\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00e0\u00b4\u00a6\u00e0\u00b4\u00bf\u00e0\u00b4\u00b5\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00ae\u00e0\u00b4\u00be\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00ae\u00e0\u00b4\u00be\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00ae\u00e0\u00b4\u00be\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00e0\u00b4\u00ae\u00e0\u00b4\u00be\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00e0\u00b4\u00ae\u00e0\u00b4\u00be\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00e0\u00b4\u00ae\u00e0\u00b4\u00be\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00ae\u00e0\u00b4\u00be\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00e0\u00b4\u00ae\u00e0\u00b4\u00be\u00e0\u00b4\u00b8\u00e0\u00b4\u0082',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00b5\u00e0\u00b5\u00bc\u00e0\u00b4\u00b7\u00e0\u00b4\u0082',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00e0\u00b4\u00b5\u00e0\u00b5\u00bc\u00e0\u00b4\u00b7\u00e0\u00b4\u0082',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00e0\u00b4\u0092\u00e0\u00b4\u00b0\u00e0\u00b5\u0081 \u00e0\u00b4\u00b5\u00e0\u00b5\u00bc\u00e0\u00b4\u00b7\u00e0\u00b4\u0082',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00e0\u00b4\u00b5\u00e0\u00b5\u00bc\u00e0\u00b4\u00b7\u00e0\u00b4\u0082',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e0\u00b4\u0085\u00e0\u00b5\u00bd\u00e0\u00b4\u00aa \u00e0\u00b4\u00a8\u00e0\u00b4\u00bf\u00e0\u00b4\u00ae\u00e0\u00b4\u00bf\u00e0\u00b4\u00b7\u00e0\u00b4\u0099\u00e0\u00b5\u008d\u00e0\u00b4\u0099\u00e0\u00b5\u00be \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e0\u00b4\u0085\u00e0\u00b5\u00bd\u00e0\u00b4\u00aa \u00e0\u00b4\u00a8\u00e0\u00b4\u00bf\u00e0\u00b4\u00ae\u00e0\u00b4\u00bf\u00e0\u00b4\u00b7\u00e0\u00b4\u0099\u00e0\u00b5\u008d\u00e0\u00b4\u0099\u00e0\u00b5\u00be \u00e0\u00b4\u00ae\u00e0\u00b5\u0081\u00e0\u00b5\u00bb\u00e0\u00b4\u00aa\u00e0\u00b5\u008d', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e0\u00b4\u0085\u00e0\u00b5\u00bd\u00e0\u00b4\u00aa \u00e0\u00b4\u00a8\u00e0\u00b4\u00bf\u00e0\u00b4\u00ae\u00e0\u00b4\u00bf\u00e0\u00b4\u00b7\u00e0\u00b4\u0099\u00e0\u00b5\u008d\u00e0\u00b4\u0099\u00e0\u00b5\u00be \u00e0\u00b4\u00ae\u00e0\u00b5\u0081\u00e0\u00b5\u00bb\u00e0\u00b4\u00aa\u00e0\u00b5\u008d',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e0\u00b4\u0085\u00e0\u00b5\u00bd\u00e0\u00b4\u00aa \u00e0\u00b4\u00a8\u00e0\u00b4\u00bf\u00e0\u00b4\u00ae\u00e0\u00b4\u00bf\u00e0\u00b4\u00b7\u00e0\u00b4\u0099\u00e0\u00b5\u008d\u00e0\u00b4\u0099\u00e0\u00b5\u00be \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d', '\u00e0\u00b4\u0085\u00e0\u00b5\u00bd\u00e0\u00b4\u00aa \u00e0\u00b4\u00a8\u00e0\u00b4\u00bf\u00e0\u00b4\u00ae\u00e0\u00b4\u00bf\u00e0\u00b4\u00b7\u00e0\u00b4\u0099\u00e0\u00b5\u008d\u00e0\u00b4\u0099\u00e0\u00b5\u00be \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 \u00e0\u00b4\u00a6\u00e0\u00b4\u00bf\u00e0\u00b4\u00b5\u00e0\u00b4\u00b8\u00e0\u00b4\u0082 \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d', '5 \u00e0\u00b4\u00a6\u00e0\u00b4\u00bf\u00e0\u00b4\u00b5\u00e0\u00b4\u00b8\u00e0\u00b4\u0082 \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e0\u00b4\u0087\u00e0\u00b4\u00a8\u00e0\u00b5\u008d\u00e0\u00b4\u00a8\u00e0\u00b5\u008d \u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d 12:00 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081',   'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e0\u00b4\u0087\u00e0\u00b4\u00a8\u00e0\u00b5\u008d\u00e0\u00b4\u00a8\u00e0\u00b5\u008d \u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d 12:25 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 3}).calendar(),       '\u00e0\u00b4\u0087\u00e0\u00b4\u00a8\u00e0\u00b5\u008d\u00e0\u00b4\u00a8\u00e0\u00b5\u008d \u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d 3:00 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081',    'Now plus 3 hours');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e0\u00b4\u00a8\u00e0\u00b4\u00be\u00e0\u00b4\u00b3\u00e0\u00b5\u0086 \u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d 12:00 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081',    'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e0\u00b4\u0087\u00e0\u00b4\u00a8\u00e0\u00b5\u008d\u00e0\u00b4\u00a8\u00e0\u00b5\u008d \u00e0\u00b4\u00b0\u00e0\u00b4\u00be\u00e0\u00b4\u00b5\u00e0\u00b4\u00bf\u00e0\u00b4\u00b2\u00e0\u00b5\u0086 11:00 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081',         'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e0\u00b4\u0087\u00e0\u00b4\u00a8\u00e0\u00b5\u008d\u00e0\u00b4\u00a8\u00e0\u00b4\u00b2\u00e0\u00b5\u0086 \u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d 12:00 -\u00e0\u00b4\u00a8\u00e0\u00b5\u0081',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e] dddd[,] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e] dddd[,] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('meridiem', function (assert) {\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '\u00e0\u00b4\u00b0\u00e0\u00b4\u00be\u00e0\u00b4\u00a4\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '\u00e0\u00b4\u00b0\u00e0\u00b4\u00be\u00e0\u00b4\u00b5\u00e0\u00b4\u00bf\u00e0\u00b4\u00b2\u00e0\u00b5\u0086', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '\u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d', 'during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '\u00e0\u00b4\u00b5\u00e0\u00b5\u0088\u00e0\u00b4\u0095\u00e0\u00b5\u0081\u00e0\u00b4\u00a8\u00e0\u00b5\u008d\u00e0\u00b4\u00a8\u00e0\u00b5\u0087\u00e0\u00b4\u00b0\u00e0\u00b4\u0082', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '\u00e0\u00b4\u00b5\u00e0\u00b5\u0088\u00e0\u00b4\u0095\u00e0\u00b5\u0081\u00e0\u00b4\u00a8\u00e0\u00b5\u008d\u00e0\u00b4\u00a8\u00e0\u00b5\u0087\u00e0\u00b4\u00b0\u00e0\u00b4\u0082', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '\u00e0\u00b4\u00b0\u00e0\u00b4\u00be\u00e0\u00b4\u00a4\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf', 'night');\n\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '\u00e0\u00b4\u00b0\u00e0\u00b4\u00be\u00e0\u00b4\u00a4\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '\u00e0\u00b4\u00b0\u00e0\u00b4\u00be\u00e0\u00b4\u00b5\u00e0\u00b4\u00bf\u00e0\u00b4\u00b2\u00e0\u00b5\u0086', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '\u00e0\u00b4\u0089\u00e0\u00b4\u009a\u00e0\u00b5\u008d\u00e0\u00b4\u009a \u00e0\u00b4\u0095\u00e0\u00b4\u00b4\u00e0\u00b4\u00bf\u00e0\u00b4\u009e\u00e0\u00b5\u008d\u00e0\u00b4\u009e\u00e0\u00b5\u008d', ' during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '\u00e0\u00b4\u00b5\u00e0\u00b5\u0088\u00e0\u00b4\u0095\u00e0\u00b5\u0081\u00e0\u00b4\u00a8\u00e0\u00b5\u008d\u00e0\u00b4\u00a8\u00e0\u00b5\u0087\u00e0\u00b4\u00b0\u00e0\u00b4\u0082', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '\u00e0\u00b4\u00b5\u00e0\u00b5\u0088\u00e0\u00b4\u0095\u00e0\u00b5\u0081\u00e0\u00b4\u00a8\u00e0\u00b5\u008d\u00e0\u00b4\u00a8\u00e0\u00b5\u0087\u00e0\u00b4\u00b0\u00e0\u00b4\u0082', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '\u00e0\u00b4\u00b0\u00e0\u00b4\u00be\u00e0\u00b4\u00a4\u00e0\u00b5\u008d\u00e0\u00b4\u00b0\u00e0\u00b4\u00bf', 'night');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('mr');\n\n    test('parse', function (assert) {\n        var tests = '\u00e0\u00a4\u009c\u00e0\u00a4\u00be\u00e0\u00a4\u00a8\u00e0\u00a5\u0087\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u009c\u00e0\u00a4\u00be\u00e0\u00a4\u00a8\u00e0\u00a5\u0087._\u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081._\u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u009a \u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u009a._\u00e0\u00a4\u008f\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a4\u00bf\u00e0\u00a4\u00b2 \u00e0\u00a4\u008f\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a4\u00bf._\u00e0\u00a4\u00ae\u00e0\u00a5\u0087 \u00e0\u00a4\u00ae\u00e0\u00a5\u0087._\u00e0\u00a4\u009c\u00e0\u00a5\u0082\u00e0\u00a4\u00a8 \u00e0\u00a4\u009c\u00e0\u00a5\u0082\u00e0\u00a4\u00a8._\u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00b2\u00e0\u00a5\u0088 \u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00b2\u00e0\u00a5\u0088._\u00e0\u00a4\u0091\u00e0\u00a4\u0097\u00e0\u00a4\u00b8\u00e0\u00a5\u008d\u00e0\u00a4\u009f \u00e0\u00a4\u0091\u00e0\u00a4\u0097._\u00e0\u00a4\u00b8\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u0087\u00e0\u00a4\u0082\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b8\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u0087\u00e0\u00a4\u0082._\u00e0\u00a4\u0091\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u008b\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u0091\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u008b._\u00e0\u00a4\u00a8\u00e0\u00a5\u008b\u00e0\u00a4\u00b5\u00e0\u00a5\u008d\u00e0\u00a4\u00b9\u00e0\u00a5\u0087\u00e0\u00a4\u0082\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a8\u00e0\u00a5\u008b\u00e0\u00a4\u00b5\u00e0\u00a5\u008d\u00e0\u00a4\u00b9\u00e0\u00a5\u0087\u00e0\u00a4\u0082._\u00e0\u00a4\u00a1\u00e0\u00a4\u00bf\u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u0082\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a1\u00e0\u00a4\u00bf\u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u0082.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, a h:mm:ss \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be', '\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0, \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab:\u00e0\u00a5\u00ab\u00e0\u00a5\u00a6 \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be'],\n                ['ddd, a h \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be',                       '\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf, \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a9 \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be'],\n                ['M Mo MM MMMM MMM',                   '\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a8 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081.'],\n                ['YYYY YY',                            '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['D Do DD',                            '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa'],\n                ['d do dddd ddd dd',                   '\u00e0\u00a5\u00a6 \u00e0\u00a5\u00a6 \u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf \u00e0\u00a4\u00b0'],\n                ['DDD DDDo DDDD',                      '\u00e0\u00a5\u00aa\u00e0\u00a5\u00ab \u00e0\u00a5\u00aa\u00e0\u00a5\u00ab \u00e0\u00a5\u00a6\u00e0\u00a5\u00aa\u00e0\u00a5\u00ab'],\n                ['w wo ww',                            '\u00e0\u00a5\u00ae \u00e0\u00a5\u00ae \u00e0\u00a5\u00a6\u00e0\u00a5\u00ae'],\n                ['h hh',                               '\u00e0\u00a5\u00a9 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a9'],\n                ['H HH',                               '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ab \u00e0\u00a5\u00a7\u00e0\u00a5\u00ab'],\n                ['m mm',                               '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a5\u00a8\u00e0\u00a5\u00ab'],\n                ['s ss',                               '\u00e0\u00a5\u00ab\u00e0\u00a5\u00a6 \u00e0\u00a5\u00ab\u00e0\u00a5\u00a6'],\n                ['a A',                                '\u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080'],\n                ['LTS',                                '\u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab:\u00e0\u00a5\u00ab\u00e0\u00a5\u00a6 \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be'],\n                ['L',                                  '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa/\u00e0\u00a5\u00a6\u00e0\u00a5\u00a8/\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['LL',                                 '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['LLL',                                '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be'],\n                ['LLLL',                               '\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0, \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be'],\n                ['l',                                  '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa/\u00e0\u00a5\u00a8/\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['ll',                                 '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081. \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['lll',                                '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081. \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be'],\n                ['llll',                               '\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf, \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081. \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '\u00e0\u00a5\u00a7', '\u00e0\u00a5\u00a7');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '\u00e0\u00a5\u00a8', '\u00e0\u00a5\u00a8');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '\u00e0\u00a5\u00a9', '\u00e0\u00a5\u00a9');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '\u00e0\u00a5\u00aa', '\u00e0\u00a5\u00aa');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '\u00e0\u00a5\u00ab', '\u00e0\u00a5\u00ab');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '\u00e0\u00a5\u00ac', '\u00e0\u00a5\u00ac');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '\u00e0\u00a5\u00ad', '\u00e0\u00a5\u00ad');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '\u00e0\u00a5\u00ae', '\u00e0\u00a5\u00ae');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '\u00e0\u00a5\u00af', '\u00e0\u00a5\u00af');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a7', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a7');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a8', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a8');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a9', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a9');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ab', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ab');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ac', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ac');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ad', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ad');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ae', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ae');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00af', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00af');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a7', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a7');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a8', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a8');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a9', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a9');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00aa', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00aa');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ac', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ac');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ad', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ad');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ae', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ae');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00af', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00af');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '\u00e0\u00a5\u00a9\u00e0\u00a5\u00a6', '\u00e0\u00a5\u00a9\u00e0\u00a5\u00a6');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '\u00e0\u00a5\u00a9\u00e0\u00a5\u00a7', '\u00e0\u00a5\u00a9\u00e0\u00a5\u00a7');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e0\u00a4\u009c\u00e0\u00a4\u00be\u00e0\u00a4\u00a8\u00e0\u00a5\u0087\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u009c\u00e0\u00a4\u00be\u00e0\u00a4\u00a8\u00e0\u00a5\u0087._\u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081._\u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u009a \u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u009a._\u00e0\u00a4\u008f\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a4\u00bf\u00e0\u00a4\u00b2 \u00e0\u00a4\u008f\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a4\u00bf._\u00e0\u00a4\u00ae\u00e0\u00a5\u0087 \u00e0\u00a4\u00ae\u00e0\u00a5\u0087._\u00e0\u00a4\u009c\u00e0\u00a5\u0082\u00e0\u00a4\u00a8 \u00e0\u00a4\u009c\u00e0\u00a5\u0082\u00e0\u00a4\u00a8._\u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00b2\u00e0\u00a5\u0088 \u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00b2\u00e0\u00a5\u0088._\u00e0\u00a4\u0091\u00e0\u00a4\u0097\u00e0\u00a4\u00b8\u00e0\u00a5\u008d\u00e0\u00a4\u009f \u00e0\u00a4\u0091\u00e0\u00a4\u0097._\u00e0\u00a4\u00b8\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u0087\u00e0\u00a4\u0082\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b8\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u0087\u00e0\u00a4\u0082._\u00e0\u00a4\u0091\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u008b\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u0091\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u008b._\u00e0\u00a4\u00a8\u00e0\u00a5\u008b\u00e0\u00a4\u00b5\u00e0\u00a5\u008d\u00e0\u00a4\u00b9\u00e0\u00a5\u0087\u00e0\u00a4\u0082\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a8\u00e0\u00a5\u008b\u00e0\u00a4\u00b5\u00e0\u00a5\u008d\u00e0\u00a4\u00b9\u00e0\u00a5\u0087\u00e0\u00a4\u0082._\u00e0\u00a4\u00a1\u00e0\u00a4\u00bf\u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u0082\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a1\u00e0\u00a4\u00bf\u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u0082.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00bf \u00e0\u00a4\u00b0_\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u00ae\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u00ae \u00e0\u00a4\u00b8\u00e0\u00a5\u008b_\u00e0\u00a4\u00ae\u00e0\u00a4\u0082\u00e0\u00a4\u0097\u00e0\u00a4\u00b3\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00ae\u00e0\u00a4\u0082\u00e0\u00a4\u0097\u00e0\u00a4\u00b3 \u00e0\u00a4\u00ae\u00e0\u00a4\u0082_\u00e0\u00a4\u00ac\u00e0\u00a5\u0081\u00e0\u00a4\u00a7\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00ac\u00e0\u00a5\u0081\u00e0\u00a4\u00a7 \u00e0\u00a4\u00ac\u00e0\u00a5\u0081_\u00e0\u00a4\u0097\u00e0\u00a5\u0081\u00e0\u00a4\u00b0\u00e0\u00a5\u0082\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u0097\u00e0\u00a5\u0081\u00e0\u00a4\u00b0\u00e0\u00a5\u0082 \u00e0\u00a4\u0097\u00e0\u00a5\u0081_\u00e0\u00a4\u00b6\u00e0\u00a5\u0081\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b6\u00e0\u00a5\u0081\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b6\u00e0\u00a5\u0081_\u00e0\u00a4\u00b6\u00e0\u00a4\u00a8\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b6\u00e0\u00a4\u00a8\u00e0\u00a4\u00bf \u00e0\u00a4\u00b6'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e0\u00a4\u0095\u00e0\u00a4\u00be\u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u0095\u00e0\u00a4\u0082\u00e0\u00a4\u00a6', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00bf\u00e0\u00a4\u009f',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00bf\u00e0\u00a4\u009f',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ae\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00bf\u00e0\u00a4\u009f\u00e0\u00a5\u0087',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '\u00e0\u00a5\u00aa\u00e0\u00a5\u00aa \u00e0\u00a4\u00ae\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00bf\u00e0\u00a4\u009f\u00e0\u00a5\u0087', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00a4\u00e0\u00a4\u00be\u00e0\u00a4\u00b8',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00a4\u00e0\u00a4\u00be\u00e0\u00a4\u00b8',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00a4\u00e0\u00a4\u00be\u00e0\u00a4\u00b8',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '\u00e0\u00a5\u00ab \u00e0\u00a4\u00a4\u00e0\u00a4\u00be\u00e0\u00a4\u00b8',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a7 \u00e0\u00a4\u00a4\u00e0\u00a4\u00be\u00e0\u00a4\u00b8',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00b8',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00b8',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00b8',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00b8',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '\u00e0\u00a5\u00ab \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00b8',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00b8',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00be', '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00be', '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00be', '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a5\u0087', '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a5\u0087', '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '\u00e0\u00a5\u00a9 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a5\u0087', '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00be', '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '\u00e0\u00a5\u00ab \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a5\u0087', '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b7',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a5\u0087',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b7',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '\u00e0\u00a5\u00ab \u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a5\u0087', '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e0\u00a4\u0095\u00e0\u00a4\u00be\u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u0095\u00e0\u00a4\u0082\u00e0\u00a4\u00a6\u00e0\u00a4\u00be\u00e0\u00a4\u0082\u00e0\u00a4\u00ae\u00e0\u00a4\u00a7\u00e0\u00a5\u008d\u00e0\u00a4\u00af\u00e0\u00a5\u0087', 'prefix');\n        assert.equal(moment(0).from(30000), '\u00e0\u00a4\u0095\u00e0\u00a4\u00be\u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u0095\u00e0\u00a4\u0082\u00e0\u00a4\u00a6\u00e0\u00a4\u00be\u00e0\u00a4\u0082\u00e0\u00a4\u00aa\u00e0\u00a5\u0082\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b5\u00e0\u00a5\u0080', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e0\u00a4\u0095\u00e0\u00a4\u00be\u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u0095\u00e0\u00a4\u0082\u00e0\u00a4\u00a6\u00e0\u00a4\u00be\u00e0\u00a4\u0082\u00e0\u00a4\u00aa\u00e0\u00a5\u0082\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b5\u00e0\u00a5\u0080',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e0\u00a4\u0095\u00e0\u00a4\u00be\u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u0095\u00e0\u00a4\u0082\u00e0\u00a4\u00a6\u00e0\u00a4\u00be\u00e0\u00a4\u0082\u00e0\u00a4\u00ae\u00e0\u00a4\u00a7\u00e0\u00a5\u008d\u00e0\u00a4\u00af\u00e0\u00a5\u0087', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00e0\u00a5\u00ab \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00b5\u00e0\u00a4\u00b8\u00e0\u00a4\u00be\u00e0\u00a4\u0082\u00e0\u00a4\u00ae\u00e0\u00a4\u00a7\u00e0\u00a5\u008d\u00e0\u00a4\u00af\u00e0\u00a5\u0087', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e0\u00a4\u0086\u00e0\u00a4\u009c \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a8:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e0\u00a4\u0086\u00e0\u00a4\u009c \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a8:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 3}).calendar(),       '\u00e0\u00a4\u0086\u00e0\u00a4\u009c \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be',     'Now plus 3 hours');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e0\u00a4\u0089\u00e0\u00a4\u00a6\u00e0\u00a5\u008d\u00e0\u00a4\u00af\u00e0\u00a4\u00be \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a8:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be', 'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e0\u00a4\u0086\u00e0\u00a4\u009c \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a7:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e0\u00a4\u0095\u00e0\u00a4\u00be\u00e0\u00a4\u00b2 \u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a8:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00b5\u00e0\u00a4\u00be\u00e0\u00a4\u009c\u00e0\u00a4\u00a4\u00e0\u00a4\u00be',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(), m.format('[\u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u0097\u00e0\u00a5\u0080\u00e0\u00a4\u00b2] dddd[,] LT'), 'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format('[\u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u0097\u00e0\u00a5\u0080\u00e0\u00a4\u00b2] dddd[,] LT'), 'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format('[\u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u0097\u00e0\u00a5\u0080\u00e0\u00a4\u00b2] dddd[,] LT'), 'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('meridiem', function (assert) {\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '\u00e0\u00a4\u00b0\u00e0\u00a4\u00be\u00e0\u00a4\u00a4\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0080', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '\u00e0\u00a4\u00b8\u00e0\u00a4\u0095\u00e0\u00a4\u00be\u00e0\u00a4\u00b3\u00e0\u00a5\u0080', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '\u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080', 'during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '\u00e0\u00a4\u00b8\u00e0\u00a4\u00be\u00e0\u00a4\u00af\u00e0\u00a4\u0082\u00e0\u00a4\u0095\u00e0\u00a4\u00be\u00e0\u00a4\u00b3\u00e0\u00a5\u0080', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '\u00e0\u00a4\u00b8\u00e0\u00a4\u00be\u00e0\u00a4\u00af\u00e0\u00a4\u0082\u00e0\u00a4\u0095\u00e0\u00a4\u00be\u00e0\u00a4\u00b3\u00e0\u00a5\u0080', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '\u00e0\u00a4\u00b0\u00e0\u00a4\u00be\u00e0\u00a4\u00a4\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0080', 'night');\n\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '\u00e0\u00a4\u00b0\u00e0\u00a4\u00be\u00e0\u00a4\u00a4\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0080', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '\u00e0\u00a4\u00b8\u00e0\u00a4\u0095\u00e0\u00a4\u00be\u00e0\u00a4\u00b3\u00e0\u00a5\u0080', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '\u00e0\u00a4\u00a6\u00e0\u00a5\u0081\u00e0\u00a4\u00aa\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u0080', ' during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '\u00e0\u00a4\u00b8\u00e0\u00a4\u00be\u00e0\u00a4\u00af\u00e0\u00a4\u0082\u00e0\u00a4\u0095\u00e0\u00a4\u00be\u00e0\u00a4\u00b3\u00e0\u00a5\u0080', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '\u00e0\u00a4\u00b8\u00e0\u00a4\u00be\u00e0\u00a4\u00af\u00e0\u00a4\u0082\u00e0\u00a4\u0095\u00e0\u00a4\u00be\u00e0\u00a4\u00b3\u00e0\u00a5\u0080', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '\u00e0\u00a4\u00b0\u00e0\u00a4\u00be\u00e0\u00a4\u00a4\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0080', 'night');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '\u00e0\u00a5\u00a7 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a7 \u00e0\u00a5\u00a7', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '\u00e0\u00a5\u00a7 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a7 \u00e0\u00a5\u00a7', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a8', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a8', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '\u00e0\u00a5\u00a9 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a9 \u00e0\u00a5\u00a9', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ms-my');\n\n    test('parse', function (assert) {\n        var i,\n            tests = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' sepatutnya bulan ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Ahad, Februari 14 2010, 3:25:50 petang'],\n                ['ddd, hA',                            'Ahd, 3petang'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 Ahad Ahd Ah'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '7 7 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'petang petang'],\n                ['[hari] [ke] DDDo [tahun] ini', 'hari ke 45 tahun ini'],\n                ['LTS',                                '15.25.50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 Februari 2010'],\n                ['LLL',                                '14 Februari 2010 pukul 15.25'],\n                ['LLLL',                               'Ahad, 14 Februari 2010 pukul 15.25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Feb 2010'],\n                ['lll',                                '14 Feb 2010 pukul 15.25'],\n                ['llll',                               'Ahd, 14 Feb 2010 pukul 15.25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var i,\n            expected = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var i,\n            expected = 'Ahad Ahd Ah_Isnin Isn Is_Selasa Sel Sl_Rabu Rab Rb_Khamis Kha Km_Jumaat Jum Jm_Sabtu Sab Sb'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'beberapa saat', '44 saat = beberapa saat');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'seminit',      '45 saat = seminit');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'seminit',      '89 saat = seminit');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minit',     '90 saat = 2 minit');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minit',    '44 minit = 44 minit');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sejam',       '45 minit = sejam');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sejam',       '89 minit = sejam');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minit = 2 jam');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 jam = 5 jam');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 jam = 21 jam');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sehari',         '22 jam = sehari');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sehari',         '35 jam = sehari');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 hari',        '36 jam = 2 hari');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sehari',         '1 hari = sehari');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 hari',        '5 hari = 5 hari');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 hari',       '25 hari = 25 hari');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sebulan',       '26 hari = sebulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sebulan',       '30 hari = sebulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sebulan',       '45 hari = sebulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 bulan',      '46 hari = 2 bulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 bulan',      '75 hari = 2 bulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 bulan',      '76 hari = 3 bulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sebulan',       '1 bulan = sebulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 bulan',      '5 bulan = 5 bulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setahun',        '345 hari = setahun');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 tahun',       '548 hari = 2 tahun');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setahun',        '1 tahun = setahun');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 tahun',       '5 tahun = 5 tahun');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'dalam beberapa saat',  'prefix');\n        assert.equal(moment(0).from(30000), 'beberapa saat yang lepas', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'beberapa saat yang lepas',  'waktu sekarang dari sekarang sepatutnya menunjukkan sebagai telah lepas');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'dalam beberapa saat', 'dalam beberapa saat');\n        assert.equal(moment().add({d: 5}).fromNow(), 'dalam 5 hari', 'dalam 5 hari');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Hari ini pukul 12.00',  'hari ini pada waktu yang sama');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Hari ini pukul 12.25',  'Sekarang tambah 25 minit');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Hari ini pukul 13.00',  'Sekarang tambah 1 jam');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Esok pukul 12.00',      'esok pada waktu yang sama');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hari ini pukul 11.00',  'Sekarang tolak 1 jam');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kelmarin pukul 12.00',  'kelmarin pada waktu yang sama');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari waktu sekarang');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari permulaan hari');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari tamat hari');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari waktu sekarang');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari permulaan hari');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari tamat hari');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 minggu lepas');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 1 minggu');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 minggu lepas');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 2 minggu');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 sepatutnya minggu 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 sepatutnya minggu 2');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 sepatutnya minggu 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 sepatutnya minggu 3');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 sepatutnya minggu 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ms');\n\n    test('parse', function (assert) {\n        var i,\n            tests = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' sepatutnya bulan ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Ahad, Februari 14 2010, 3:25:50 petang'],\n                ['ddd, hA',                            'Ahd, 3petang'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 Ahad Ahd Ah'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '7 7 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'petang petang'],\n                ['[hari] [ke] DDDo [tahun] ini', 'hari ke 45 tahun ini'],\n                ['LTS',                                '15.25.50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 Februari 2010'],\n                ['LLL',                                '14 Februari 2010 pukul 15.25'],\n                ['LLLL',                               'Ahad, 14 Februari 2010 pukul 15.25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Feb 2010'],\n                ['lll',                                '14 Feb 2010 pukul 15.25'],\n                ['llll',                               'Ahd, 14 Feb 2010 pukul 15.25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var i,\n            expected = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var i,\n            expected = 'Ahad Ahd Ah_Isnin Isn Is_Selasa Sel Sl_Rabu Rab Rb_Khamis Kha Km_Jumaat Jum Jm_Sabtu Sab Sb'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'beberapa saat', '44 saat = beberapa saat');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'seminit',      '45 saat = seminit');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'seminit',      '89 saat = seminit');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minit',     '90 saat = 2 minit');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minit',    '44 minit = 44 minit');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sejam',       '45 minit = sejam');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sejam',       '89 minit = sejam');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minit = 2 jam');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 jam = 5 jam');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 jam = 21 jam');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sehari',         '22 jam = sehari');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sehari',         '35 jam = sehari');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 hari',        '36 jam = 2 hari');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sehari',         '1 hari = sehari');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 hari',        '5 hari = 5 hari');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 hari',       '25 hari = 25 hari');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sebulan',       '26 hari = sebulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sebulan',       '30 hari = sebulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sebulan',       '45 hari = sebulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 bulan',      '46 hari = 2 bulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 bulan',      '75 hari = 2 bulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 bulan',      '76 hari = 3 bulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sebulan',       '1 bulan = sebulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 bulan',      '5 bulan = 5 bulan');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setahun',        '345 hari = setahun');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 tahun',       '548 hari = 2 tahun');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setahun',        '1 tahun = setahun');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 tahun',       '5 tahun = 5 tahun');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'dalam beberapa saat',  'prefix');\n        assert.equal(moment(0).from(30000), 'beberapa saat yang lepas', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'beberapa saat yang lepas',  'waktu sekarang dari sekarang sepatutnya menunjukkan sebagai telah lepas');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'dalam beberapa saat', 'dalam beberapa saat');\n        assert.equal(moment().add({d: 5}).fromNow(), 'dalam 5 hari', 'dalam 5 hari');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Hari ini pukul 12.00',  'hari ini pada waktu yang sama');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Hari ini pukul 12.25',  'Sekarang tambah 25 minit');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Hari ini pukul 13.00',  'Sekarang tambah 1 jam');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Esok pukul 12.00',      'esok pada waktu yang sama');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hari ini pukul 11.00',  'Sekarang tolak 1 jam');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kelmarin pukul 12.00',  'kelmarin pada waktu yang sama');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari waktu sekarang');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari permulaan hari');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari tamat hari');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari waktu sekarang');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari permulaan hari');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari tamat hari');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 minggu lepas');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 1 minggu');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 minggu lepas');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 2 minggu');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 sepatutnya minggu 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 sepatutnya minggu 2');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 sepatutnya minggu 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 sepatutnya minggu 3');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 sepatutnya minggu 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('my');\n\n    test('parse', function (assert) {\n        var tests = '\u00e1\u0080\u0087\u00e1\u0080\u0094\u00e1\u0080\u00ba\u00e1\u0080\u0094\u00e1\u0080\u009d\u00e1\u0080\u00ab\u00e1\u0080\u009b\u00e1\u0080\u00ae \u00e1\u0080\u0087\u00e1\u0080\u0094\u00e1\u0080\u00ba_\u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u00ba\u00e1\u0080\u009d\u00e1\u0080\u00ab\u00e1\u0080\u009b\u00e1\u0080\u00ae \u00e1\u0080\u0096\u00e1\u0080\u00b1_\u00e1\u0080\u0099\u00e1\u0080\u0090\u00e1\u0080\u00ba \u00e1\u0080\u0099\u00e1\u0080\u0090\u00e1\u0080\u00ba_\u00e1\u0080\u00a7\u00e1\u0080\u0095\u00e1\u0080\u00bc\u00e1\u0080\u00ae \u00e1\u0080\u0095\u00e1\u0080\u00bc\u00e1\u0080\u00ae_\u00e1\u0080\u0099\u00e1\u0080\u00b1 \u00e1\u0080\u0099\u00e1\u0080\u00b1_\u00e1\u0080\u0087\u00e1\u0080\u00bd\u00e1\u0080\u0094\u00e1\u0080\u00ba \u00e1\u0080\u0087\u00e1\u0080\u00bd\u00e1\u0080\u0094\u00e1\u0080\u00ba_\u00e1\u0080\u0087\u00e1\u0080\u00b0\u00e1\u0080\u009c\u00e1\u0080\u00ad\u00e1\u0080\u00af\u00e1\u0080\u0084\u00e1\u0080\u00ba \u00e1\u0080\u009c\u00e1\u0080\u00ad\u00e1\u0080\u00af\u00e1\u0080\u0084\u00e1\u0080\u00ba_\u00e1\u0080\u009e\u00e1\u0080\u00bc\u00e1\u0080\u0082\u00e1\u0080\u00af\u00e1\u0080\u0090\u00e1\u0080\u00ba \u00e1\u0080\u009e\u00e1\u0080\u00bc_\u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00ba\u00e1\u0080\u0090\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u0098\u00e1\u0080\u00ac \u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00ba_\u00e1\u0080\u00a1\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u0080\u00e1\u0080\u00ba\u00e1\u0080\u0090\u00e1\u0080\u00ad\u00e1\u0080\u00af\u00e1\u0080\u0098\u00e1\u0080\u00ac \u00e1\u0080\u00a1\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u0080\u00e1\u0080\u00ba_\u00e1\u0080\u0094\u00e1\u0080\u00ad\u00e1\u0080\u00af\u00e1\u0080\u009d\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u0098\u00e1\u0080\u00ac \u00e1\u0080\u0094\u00e1\u0080\u00ad\u00e1\u0080\u00af_\u00e1\u0080\u0092\u00e1\u0080\u00ae\u00e1\u0080\u0087\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u0098\u00e1\u0080\u00ac \u00e1\u0080\u0092\u00e1\u0080\u00ae'.split('_'),\n            i;\n\n        function equalTest (input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a', '\u00e1\u0080\u0090\u00e1\u0080\u0094\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u00b9\u00e1\u0080\u0082\u00e1\u0080\u0094\u00e1\u0080\u00bd\u00e1\u0080\u00b1, \u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u00ba\u00e1\u0080\u009d\u00e1\u0080\u00ab\u00e1\u0080\u009b\u00e1\u0080\u00ae \u00e1\u0081\u0081\u00e1\u0081\u0084 \u00e1\u0081\u0082\u00e1\u0081\u0080\u00e1\u0081\u0081\u00e1\u0081\u0080, \u00e1\u0081\u0083:\u00e1\u0081\u0082\u00e1\u0081\u0085:\u00e1\u0081\u0085\u00e1\u0081\u0080 pm'],\n                ['ddd, hA', '\u00e1\u0080\u0094\u00e1\u0080\u00bd\u00e1\u0080\u00b1, \u00e1\u0081\u0083PM'],\n                ['M Mo MM MMMM MMM', '\u00e1\u0081\u0082 \u00e1\u0081\u0082 \u00e1\u0081\u0080\u00e1\u0081\u0082 \u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u00ba\u00e1\u0080\u009d\u00e1\u0080\u00ab\u00e1\u0080\u009b\u00e1\u0080\u00ae \u00e1\u0080\u0096\u00e1\u0080\u00b1'],\n                ['YYYY YY', '\u00e1\u0081\u0082\u00e1\u0081\u0080\u00e1\u0081\u0081\u00e1\u0081\u0080 \u00e1\u0081\u0081\u00e1\u0081\u0080'],\n                ['D Do DD', '\u00e1\u0081\u0081\u00e1\u0081\u0084 \u00e1\u0081\u0081\u00e1\u0081\u0084 \u00e1\u0081\u0081\u00e1\u0081\u0084'],\n                ['d do dddd ddd dd', '\u00e1\u0081\u0080 \u00e1\u0081\u0080 \u00e1\u0080\u0090\u00e1\u0080\u0094\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u00b9\u00e1\u0080\u0082\u00e1\u0080\u0094\u00e1\u0080\u00bd\u00e1\u0080\u00b1 \u00e1\u0080\u0094\u00e1\u0080\u00bd\u00e1\u0080\u00b1 \u00e1\u0080\u0094\u00e1\u0080\u00bd\u00e1\u0080\u00b1'],\n                ['DDD DDDo DDDD', '\u00e1\u0081\u0084\u00e1\u0081\u0085 \u00e1\u0081\u0084\u00e1\u0081\u0085 \u00e1\u0081\u0080\u00e1\u0081\u0084\u00e1\u0081\u0085'],\n                ['w wo ww', '\u00e1\u0081\u0086 \u00e1\u0081\u0086 \u00e1\u0081\u0080\u00e1\u0081\u0086'],\n                ['h hh', '\u00e1\u0081\u0083 \u00e1\u0081\u0080\u00e1\u0081\u0083'],\n                ['H HH', '\u00e1\u0081\u0081\u00e1\u0081\u0085 \u00e1\u0081\u0081\u00e1\u0081\u0085'],\n                ['m mm', '\u00e1\u0081\u0082\u00e1\u0081\u0085 \u00e1\u0081\u0082\u00e1\u0081\u0085'],\n                ['s ss', '\u00e1\u0081\u0085\u00e1\u0081\u0080 \u00e1\u0081\u0085\u00e1\u0081\u0080'],\n                ['a A', 'pm PM'],\n                ['[\u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0081\u008f] DDDo [\u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba\u00e1\u0080\u0099\u00e1\u0080\u00bc\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u0080\u00e1\u0080\u00ba]', '\u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0081\u008f \u00e1\u0081\u0084\u00e1\u0081\u0085 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba\u00e1\u0080\u0099\u00e1\u0080\u00bc\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u0080\u00e1\u0080\u00ba'],\n                ['LTS', '\u00e1\u0081\u0081\u00e1\u0081\u0085:\u00e1\u0081\u0082\u00e1\u0081\u0085:\u00e1\u0081\u0085\u00e1\u0081\u0080'],\n                ['L', '\u00e1\u0081\u0081\u00e1\u0081\u0084/\u00e1\u0081\u0080\u00e1\u0081\u0082/\u00e1\u0081\u0082\u00e1\u0081\u0080\u00e1\u0081\u0081\u00e1\u0081\u0080'],\n                ['LL', '\u00e1\u0081\u0081\u00e1\u0081\u0084 \u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u00ba\u00e1\u0080\u009d\u00e1\u0080\u00ab\u00e1\u0080\u009b\u00e1\u0080\u00ae \u00e1\u0081\u0082\u00e1\u0081\u0080\u00e1\u0081\u0081\u00e1\u0081\u0080'],\n                ['LLL', '\u00e1\u0081\u0081\u00e1\u0081\u0084 \u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u00ba\u00e1\u0080\u009d\u00e1\u0080\u00ab\u00e1\u0080\u009b\u00e1\u0080\u00ae \u00e1\u0081\u0082\u00e1\u0081\u0080\u00e1\u0081\u0081\u00e1\u0081\u0080 \u00e1\u0081\u0081\u00e1\u0081\u0085:\u00e1\u0081\u0082\u00e1\u0081\u0085'],\n                ['LLLL', '\u00e1\u0080\u0090\u00e1\u0080\u0094\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u00b9\u00e1\u0080\u0082\u00e1\u0080\u0094\u00e1\u0080\u00bd\u00e1\u0080\u00b1 \u00e1\u0081\u0081\u00e1\u0081\u0084 \u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u00ba\u00e1\u0080\u009d\u00e1\u0080\u00ab\u00e1\u0080\u009b\u00e1\u0080\u00ae \u00e1\u0081\u0082\u00e1\u0081\u0080\u00e1\u0081\u0081\u00e1\u0081\u0080 \u00e1\u0081\u0081\u00e1\u0081\u0085:\u00e1\u0081\u0082\u00e1\u0081\u0085'],\n                ['l', '\u00e1\u0081\u0081\u00e1\u0081\u0084/\u00e1\u0081\u0082/\u00e1\u0081\u0082\u00e1\u0081\u0080\u00e1\u0081\u0081\u00e1\u0081\u0080'],\n                ['ll', '\u00e1\u0081\u0081\u00e1\u0081\u0084 \u00e1\u0080\u0096\u00e1\u0080\u00b1 \u00e1\u0081\u0082\u00e1\u0081\u0080\u00e1\u0081\u0081\u00e1\u0081\u0080'],\n                ['lll', '\u00e1\u0081\u0081\u00e1\u0081\u0084 \u00e1\u0080\u0096\u00e1\u0080\u00b1 \u00e1\u0081\u0082\u00e1\u0081\u0080\u00e1\u0081\u0081\u00e1\u0081\u0080 \u00e1\u0081\u0081\u00e1\u0081\u0085:\u00e1\u0081\u0082\u00e1\u0081\u0085'],\n                ['llll', '\u00e1\u0080\u0094\u00e1\u0080\u00bd\u00e1\u0080\u00b1 \u00e1\u0081\u0081\u00e1\u0081\u0084 \u00e1\u0080\u0096\u00e1\u0080\u00b1 \u00e1\u0081\u0082\u00e1\u0081\u0080\u00e1\u0081\u0081\u00e1\u0081\u0080 \u00e1\u0081\u0081\u00e1\u0081\u0085:\u00e1\u0081\u0082\u00e1\u0081\u0085']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '\u00e1\u0081\u0081', '\u00e1\u0081\u0081');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '\u00e1\u0081\u0082', '\u00e1\u0081\u0082');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '\u00e1\u0081\u0083', '\u00e1\u0081\u0083');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '\u00e1\u0081\u0084', '\u00e1\u0081\u0084');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '\u00e1\u0081\u0085', '\u00e1\u0081\u0085');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '\u00e1\u0081\u0086', '\u00e1\u0081\u0086');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '\u00e1\u0081\u0087', '\u00e1\u0081\u0087');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '\u00e1\u0081\u0088', '\u00e1\u0081\u0088');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '\u00e1\u0081\u0089', '\u00e1\u0081\u0089');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00e1\u0081\u0081\u00e1\u0081\u0080', '\u00e1\u0081\u0081\u00e1\u0081\u0080');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00e1\u0081\u0081\u00e1\u0081\u0081', '\u00e1\u0081\u0081\u00e1\u0081\u0081');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00e1\u0081\u0081\u00e1\u0081\u0082', '\u00e1\u0081\u0081\u00e1\u0081\u0082');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00e1\u0081\u0081\u00e1\u0081\u0083', '\u00e1\u0081\u0081\u00e1\u0081\u0083');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00e1\u0081\u0081\u00e1\u0081\u0084', '\u00e1\u0081\u0081\u00e1\u0081\u0084');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00e1\u0081\u0081\u00e1\u0081\u0085', '\u00e1\u0081\u0081\u00e1\u0081\u0085');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00e1\u0081\u0081\u00e1\u0081\u0086', '\u00e1\u0081\u0081\u00e1\u0081\u0086');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00e1\u0081\u0081\u00e1\u0081\u0087', '\u00e1\u0081\u0081\u00e1\u0081\u0087');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00e1\u0081\u0081\u00e1\u0081\u0088', '\u00e1\u0081\u0081\u00e1\u0081\u0088');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00e1\u0081\u0081\u00e1\u0081\u0089', '\u00e1\u0081\u0081\u00e1\u0081\u0089');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00e1\u0081\u0082\u00e1\u0081\u0080', '\u00e1\u0081\u0082\u00e1\u0081\u0080');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '\u00e1\u0081\u0082\u00e1\u0081\u0081', '\u00e1\u0081\u0082\u00e1\u0081\u0081');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '\u00e1\u0081\u0082\u00e1\u0081\u0082', '\u00e1\u0081\u0082\u00e1\u0081\u0082');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '\u00e1\u0081\u0082\u00e1\u0081\u0083', '\u00e1\u0081\u0082\u00e1\u0081\u0083');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '\u00e1\u0081\u0082\u00e1\u0081\u0084', '\u00e1\u0081\u0082\u00e1\u0081\u0084');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '\u00e1\u0081\u0082\u00e1\u0081\u0085', '\u00e1\u0081\u0082\u00e1\u0081\u0085');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '\u00e1\u0081\u0082\u00e1\u0081\u0086', '\u00e1\u0081\u0082\u00e1\u0081\u0086');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '\u00e1\u0081\u0082\u00e1\u0081\u0087', '\u00e1\u0081\u0082\u00e1\u0081\u0087');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '\u00e1\u0081\u0082\u00e1\u0081\u0088', '\u00e1\u0081\u0082\u00e1\u0081\u0088');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '\u00e1\u0081\u0082\u00e1\u0081\u0089', '\u00e1\u0081\u0082\u00e1\u0081\u0089');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '\u00e1\u0081\u0083\u00e1\u0081\u0080', '\u00e1\u0081\u0083\u00e1\u0081\u0080');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '\u00e1\u0081\u0083\u00e1\u0081\u0081', '\u00e1\u0081\u0083\u00e1\u0081\u0081');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e1\u0080\u0087\u00e1\u0080\u0094\u00e1\u0080\u00ba\u00e1\u0080\u0094\u00e1\u0080\u009d\u00e1\u0080\u00ab\u00e1\u0080\u009b\u00e1\u0080\u00ae \u00e1\u0080\u0087\u00e1\u0080\u0094\u00e1\u0080\u00ba_\u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u00ba\u00e1\u0080\u009d\u00e1\u0080\u00ab\u00e1\u0080\u009b\u00e1\u0080\u00ae \u00e1\u0080\u0096\u00e1\u0080\u00b1_\u00e1\u0080\u0099\u00e1\u0080\u0090\u00e1\u0080\u00ba \u00e1\u0080\u0099\u00e1\u0080\u0090\u00e1\u0080\u00ba_\u00e1\u0080\u00a7\u00e1\u0080\u0095\u00e1\u0080\u00bc\u00e1\u0080\u00ae \u00e1\u0080\u0095\u00e1\u0080\u00bc\u00e1\u0080\u00ae_\u00e1\u0080\u0099\u00e1\u0080\u00b1 \u00e1\u0080\u0099\u00e1\u0080\u00b1_\u00e1\u0080\u0087\u00e1\u0080\u00bd\u00e1\u0080\u0094\u00e1\u0080\u00ba \u00e1\u0080\u0087\u00e1\u0080\u00bd\u00e1\u0080\u0094\u00e1\u0080\u00ba_\u00e1\u0080\u0087\u00e1\u0080\u00b0\u00e1\u0080\u009c\u00e1\u0080\u00ad\u00e1\u0080\u00af\u00e1\u0080\u0084\u00e1\u0080\u00ba \u00e1\u0080\u009c\u00e1\u0080\u00ad\u00e1\u0080\u00af\u00e1\u0080\u0084\u00e1\u0080\u00ba_\u00e1\u0080\u009e\u00e1\u0080\u00bc\u00e1\u0080\u0082\u00e1\u0080\u00af\u00e1\u0080\u0090\u00e1\u0080\u00ba \u00e1\u0080\u009e\u00e1\u0080\u00bc_\u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00ba\u00e1\u0080\u0090\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u0098\u00e1\u0080\u00ac \u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00ba_\u00e1\u0080\u00a1\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u0080\u00e1\u0080\u00ba\u00e1\u0080\u0090\u00e1\u0080\u00ad\u00e1\u0080\u00af\u00e1\u0080\u0098\u00e1\u0080\u00ac \u00e1\u0080\u00a1\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u0080\u00e1\u0080\u00ba_\u00e1\u0080\u0094\u00e1\u0080\u00ad\u00e1\u0080\u00af\u00e1\u0080\u009d\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u0098\u00e1\u0080\u00ac \u00e1\u0080\u0094\u00e1\u0080\u00ad\u00e1\u0080\u00af_\u00e1\u0080\u0092\u00e1\u0080\u00ae\u00e1\u0080\u0087\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u0098\u00e1\u0080\u00ac \u00e1\u0080\u0092\u00e1\u0080\u00ae'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e1\u0080\u0090\u00e1\u0080\u0094\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u00b9\u00e1\u0080\u0082\u00e1\u0080\u0094\u00e1\u0080\u00bd\u00e1\u0080\u00b1 \u00e1\u0080\u0094\u00e1\u0080\u00bd\u00e1\u0080\u00b1 \u00e1\u0080\u0094\u00e1\u0080\u00bd\u00e1\u0080\u00b1_\u00e1\u0080\u0090\u00e1\u0080\u0094\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u00b9\u00e1\u0080\u009c\u00e1\u0080\u00ac \u00e1\u0080\u009c\u00e1\u0080\u00ac \u00e1\u0080\u009c\u00e1\u0080\u00ac_\u00e1\u0080\u00a1\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u00b9\u00e1\u0080\u0082\u00e1\u0080\u00ab \u00e1\u0080\u0082\u00e1\u0080\u00ab \u00e1\u0080\u0082\u00e1\u0080\u00ab_\u00e1\u0080\u0097\u00e1\u0080\u00af\u00e1\u0080\u0092\u00e1\u0080\u00b9\u00e1\u0080\u0093\u00e1\u0080\u009f\u00e1\u0080\u00b0\u00e1\u0080\u00b8 \u00e1\u0080\u009f\u00e1\u0080\u00b0\u00e1\u0080\u00b8 \u00e1\u0080\u009f\u00e1\u0080\u00b0\u00e1\u0080\u00b8_\u00e1\u0080\u0080\u00e1\u0080\u00bc\u00e1\u0080\u00ac\u00e1\u0080\u009e\u00e1\u0080\u0095\u00e1\u0080\u0090\u00e1\u0080\u00b1\u00e1\u0080\u00b8 \u00e1\u0080\u0080\u00e1\u0080\u00bc\u00e1\u0080\u00ac \u00e1\u0080\u0080\u00e1\u0080\u00bc\u00e1\u0080\u00ac_\u00e1\u0080\u009e\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u0080\u00e1\u0080\u00bc\u00e1\u0080\u00ac \u00e1\u0080\u009e\u00e1\u0080\u00b1\u00e1\u0080\u00ac \u00e1\u0080\u009e\u00e1\u0080\u00b1\u00e1\u0080\u00ac_\u00e1\u0080\u0085\u00e1\u0080\u0094\u00e1\u0080\u00b1 \u00e1\u0080\u0094\u00e1\u0080\u00b1 \u00e1\u0080\u0094\u00e1\u0080\u00b1'.split('_'),\n            i;\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            s: 44\n        }), true), '\u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00b9\u00e1\u0080\u0080\u00e1\u0080\u0094\u00e1\u0080\u00ba.\u00e1\u0080\u00a1\u00e1\u0080\u0094\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b8\u00e1\u0080\u0084\u00e1\u0080\u009a\u00e1\u0080\u00ba', '\u00e1\u0081\u0084\u00e1\u0081\u0084 \u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00b9\u00e1\u0080\u0080\u00e1\u0080\u0094\u00e1\u0080\u00ba. = \u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00b9\u00e1\u0080\u0080\u00e1\u0080\u0094\u00e1\u0080\u00ba.\u00e1\u0080\u00a1\u00e1\u0080\u0094\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b8\u00e1\u0080\u0084\u00e1\u0080\u009a\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            s: 45\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba', '\u00e1\u0081\u0084\u00e1\u0081\u0085 \u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00b9\u00e1\u0080\u0080\u00e1\u0080\u0094\u00e1\u0080\u00ba. = \u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            s: 89\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba', '\u00e1\u0081\u0088\u00e1\u0081\u0089 \u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00b9\u00e1\u0080\u0080\u00e1\u0080\u0094\u00e1\u0080\u00ba. = \u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            s: 90\n        }), true), '\u00e1\u0081\u0082 \u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba', '\u00e1\u0081\u0089\u00e1\u0081\u0080 \u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00b9\u00e1\u0080\u0080\u00e1\u0080\u0094\u00e1\u0080\u00ba. =  \u00e1\u0081\u0082 \u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            m: 44\n        }), true), '\u00e1\u0081\u0084\u00e1\u0081\u0084 \u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba', '\u00e1\u0081\u0084\u00e1\u0081\u0084 \u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba = \u00e1\u0081\u0084\u00e1\u0081\u0084 \u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            m: 45\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae', '\u00e1\u0081\u0084\u00e1\u0081\u0085 \u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba = \u00e1\u0081\u0081 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            m: 89\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae', '\u00e1\u0081\u0088\u00e1\u0081\u0089 \u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba = \u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            m: 90\n        }), true), '\u00e1\u0081\u0082 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae', '\u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba \u00e1\u0081\u0089\u00e1\u0081\u0080= \u00e1\u0081\u0082 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            h: 5\n        }), true), '\u00e1\u0081\u0085 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae', '\u00e1\u0081\u0085 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae= \u00e1\u0081\u0085 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            h: 21\n        }), true), '\u00e1\u0081\u0082\u00e1\u0081\u0081 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae', '\u00e1\u0081\u0082\u00e1\u0081\u0081 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae =\u00e1\u0081\u0082\u00e1\u0081\u0081 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            h: 22\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba', '\u00e1\u0081\u0082\u00e1\u0081\u0082 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae =\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            h: 35\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba', '\u00e1\u0081\u0083\u00e1\u0081\u0085 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae =\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            h: 36\n        }), true), '\u00e1\u0081\u0082 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba', '\u00e1\u0081\u0083\u00e1\u0081\u0086 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae = \u00e1\u0081\u0082 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 1\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba', '\u00e1\u0081\u0081 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba= \u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 5\n        }), true), '\u00e1\u0081\u0085 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba', '\u00e1\u0081\u0085 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba = \u00e1\u0081\u0085 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 25\n        }), true), '\u00e1\u0081\u0082\u00e1\u0081\u0085 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba', '\u00e1\u0081\u0082\u00e1\u0081\u0085 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba= \u00e1\u0081\u0082\u00e1\u0081\u0085 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 26\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009c', '\u00e1\u0081\u0082\u00e1\u0081\u0086 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba = \u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009c');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 30\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009c', '\u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba \u00e1\u0081\u0083\u00e1\u0081\u0080 = \u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009c');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 43\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009c', '\u00e1\u0081\u0084\u00e1\u0081\u0083 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba = \u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009c');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 46\n        }), true), '\u00e1\u0081\u0082 \u00e1\u0080\u009c', '\u00e1\u0081\u0084\u00e1\u0081\u0086 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba = \u00e1\u0081\u0082 \u00e1\u0080\u009c');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 74\n        }), true), '\u00e1\u0081\u0082 \u00e1\u0080\u009c', '\u00e1\u0081\u0087\u00e1\u0081\u0085 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba= \u00e1\u0081\u0082 \u00e1\u0080\u009c');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 76\n        }), true), '\u00e1\u0081\u0083 \u00e1\u0080\u009c', '\u00e1\u0081\u0087\u00e1\u0081\u0086 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba = \u00e1\u0081\u0083 \u00e1\u0080\u009c');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            M: 1\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009c', '\u00e1\u0081\u0081 \u00e1\u0080\u009c = \u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u009c');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            M: 5\n        }), true), '\u00e1\u0081\u0085 \u00e1\u0080\u009c', '\u00e1\u0081\u0085 \u00e1\u0080\u009c = \u00e1\u0081\u0085 \u00e1\u0080\u009c');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 345\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u00ba', '\u00e1\u0081\u0083\u00e1\u0081\u0084\u00e1\u0081\u0085 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba = \u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            d: 548\n        }), true), '\u00e1\u0081\u0082 \u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u00ba', '\u00e1\u0081\u0085\u00e1\u0081\u0084\u00e1\u0081\u0088 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba = \u00e1\u0081\u0082 \u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            y: 1\n        }), true), '\u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u00ba', '\u00e1\u0081\u0081 \u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u00ba = \u00e1\u0080\u0090\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u00ba');\n        assert.equal(start.from(moment([2007, 1, 28]).add({\n            y: 5\n        }), true), '\u00e1\u0081\u0085 \u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u00ba', '\u00e1\u0081\u0085 \u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u00ba = \u00e1\u0081\u0085 \u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u00ba');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e1\u0080\u009c\u00e1\u0080\u00ac\u00e1\u0080\u0099\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b7 \u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00b9\u00e1\u0080\u0080\u00e1\u0080\u0094\u00e1\u0080\u00ba.\u00e1\u0080\u00a1\u00e1\u0080\u0094\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b8\u00e1\u0080\u0084\u00e1\u0080\u009a\u00e1\u0080\u00ba \u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac', 'prefix');\n        assert.equal(moment(0).from(30000), '\u00e1\u0080\u009c\u00e1\u0080\u00bd\u00e1\u0080\u0094\u00e1\u0080\u00ba\u00e1\u0080\u0081\u00e1\u0080\u00b2\u00e1\u0080\u00b7\u00e1\u0080\u009e\u00e1\u0080\u00b1\u00e1\u0080\u00ac \u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00b9\u00e1\u0080\u0080\u00e1\u0080\u0094\u00e1\u0080\u00ba.\u00e1\u0080\u00a1\u00e1\u0080\u0094\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b8\u00e1\u0080\u0084\u00e1\u0080\u009a\u00e1\u0080\u00ba \u00e1\u0080\u0080', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e1\u0080\u009c\u00e1\u0080\u00bd\u00e1\u0080\u0094\u00e1\u0080\u00ba\u00e1\u0080\u0081\u00e1\u0080\u00b2\u00e1\u0080\u00b7\u00e1\u0080\u009e\u00e1\u0080\u00b1\u00e1\u0080\u00ac \u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00b9\u00e1\u0080\u0080\u00e1\u0080\u0094\u00e1\u0080\u00ba.\u00e1\u0080\u00a1\u00e1\u0080\u0094\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b8\u00e1\u0080\u0084\u00e1\u0080\u009a\u00e1\u0080\u00ba \u00e1\u0080\u0080', '\u00e1\u0080\u009a\u00e1\u0080\u0081\u00e1\u0080\u00af\u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u0085\u00e1\u0080\u0095\u00e1\u0080\u00bc\u00e1\u0080\u00ae\u00e1\u0080\u00b8 \u00e1\u0080\u00a1\u00e1\u0080\u0090\u00e1\u0080\u00ad\u00e1\u0080\u0090\u00e1\u0080\u00ba\u00e1\u0080\u0090\u00e1\u0080\u00bd\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u00ba\u00e1\u0080\u0095\u00e1\u0080\u00bc\u00e1\u0080\u009e\u00e1\u0080\u009c\u00e1\u0080\u00ad\u00e1\u0080\u00af\u00e1\u0080\u0096\u00e1\u0080\u00b1\u00e1\u0080\u00ac\u00e1\u0080\u00ba\u00e1\u0080\u0095\u00e1\u0080\u00bc\u00e1\u0080\u0099\u00e1\u0080\u008a\u00e1\u0080\u00ba');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({\n            s: 30\n        }).fromNow(), '\u00e1\u0080\u009c\u00e1\u0080\u00ac\u00e1\u0080\u0099\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b7 \u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00b9\u00e1\u0080\u0080\u00e1\u0080\u0094\u00e1\u0080\u00ba.\u00e1\u0080\u00a1\u00e1\u0080\u0094\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b8\u00e1\u0080\u0084\u00e1\u0080\u009a\u00e1\u0080\u00ba \u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac', '\u00e1\u0080\u009c\u00e1\u0080\u00ac\u00e1\u0080\u0099\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b7 \u00e1\u0080\u0085\u00e1\u0080\u0080\u00e1\u0080\u00b9\u00e1\u0080\u0080\u00e1\u0080\u0094\u00e1\u0080\u00ba.\u00e1\u0080\u00a1\u00e1\u0080\u0094\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b8\u00e1\u0080\u0084\u00e1\u0080\u009a\u00e1\u0080\u00ba \u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac');\n        assert.equal(moment().add({\n            d: 5\n        }).fromNow(), '\u00e1\u0080\u009c\u00e1\u0080\u00ac\u00e1\u0080\u0099\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b7 \u00e1\u0081\u0085 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba \u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac', '\u00e1\u0080\u009c\u00e1\u0080\u00ac\u00e1\u0080\u0099\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b7 \u00e1\u0081\u0085 \u00e1\u0080\u009b\u00e1\u0080\u0080\u00e1\u0080\u00ba \u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                  '\u00e1\u0080\u009a\u00e1\u0080\u0094\u00e1\u0080\u00b1. \u00e1\u0081\u0081\u00e1\u0081\u0082:\u00e1\u0081\u0080\u00e1\u0081\u0080 \u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac',      '\u00e1\u0080\u009a\u00e1\u0080\u0094\u00e1\u0080\u00b1. \u00e1\u0080\u0092\u00e1\u0080\u00ae\u00e1\u0080\u00a1\u00e1\u0080\u0081\u00e1\u0080\u00bb\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u00ba');\n        assert.equal(moment(a).add({m: 25}).calendar(),     '\u00e1\u0080\u009a\u00e1\u0080\u0094\u00e1\u0080\u00b1. \u00e1\u0081\u0081\u00e1\u0081\u0082:\u00e1\u0081\u0082\u00e1\u0081\u0085 \u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac',      '\u00e1\u0080\u009a\u00e1\u0080\u0081\u00e1\u0080\u00af\u00e1\u0080\u0099\u00e1\u0080\u00be \u00e1\u0081\u0082\u00e1\u0081\u0085 \u00e1\u0080\u0099\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u0085\u00e1\u0080\u00ba\u00e1\u0080\u0095\u00e1\u0080\u00b1\u00e1\u0080\u00ab\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u00b8\u00e1\u0080\u0091\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b7');\n        assert.equal(moment(a).add({h: 1}).calendar(),      '\u00e1\u0080\u009a\u00e1\u0080\u0094\u00e1\u0080\u00b1. \u00e1\u0081\u0081\u00e1\u0081\u0083:\u00e1\u0081\u0080\u00e1\u0081\u0080 \u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac',      '\u00e1\u0080\u009a\u00e1\u0080\u0081\u00e1\u0080\u00af\u00e1\u0080\u0099\u00e1\u0080\u00be \u00e1\u0081\u0081 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae\u00e1\u0080\u0095\u00e1\u0080\u00b1\u00e1\u0080\u00ab\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u00b8\u00e1\u0080\u0091\u00e1\u0080\u008a\u00e1\u0080\u00ba\u00e1\u0080\u00b7');\n        assert.equal(moment(a).add({d: 1}).calendar(),      '\u00e1\u0080\u0099\u00e1\u0080\u0094\u00e1\u0080\u0080\u00e1\u0080\u00ba\u00e1\u0080\u0096\u00e1\u0080\u00bc\u00e1\u0080\u0094\u00e1\u0080\u00ba \u00e1\u0081\u0081\u00e1\u0081\u0082:\u00e1\u0081\u0080\u00e1\u0081\u0080 \u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac',  '\u00e1\u0080\u0099\u00e1\u0080\u0094\u00e1\u0080\u0080\u00e1\u0080\u00ba\u00e1\u0080\u0096\u00e1\u0080\u00bc\u00e1\u0080\u0094\u00e1\u0080\u00ba \u00e1\u0080\u0092\u00e1\u0080\u00ae\u00e1\u0080\u00a1\u00e1\u0080\u0081\u00e1\u0080\u00bb\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u00ba');\n        assert.equal(moment(a).subtract({h: 1}).calendar(), '\u00e1\u0080\u009a\u00e1\u0080\u0094\u00e1\u0080\u00b1. \u00e1\u0081\u0081\u00e1\u0081\u0081:\u00e1\u0081\u0080\u00e1\u0081\u0080 \u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac',      '\u00e1\u0080\u009a\u00e1\u0080\u0081\u00e1\u0080\u00af\u00e1\u0080\u0099\u00e1\u0080\u00be \u00e1\u0081\u0081 \u00e1\u0080\u0094\u00e1\u0080\u00ac\u00e1\u0080\u009b\u00e1\u0080\u00ae\u00e1\u0080\u0094\u00e1\u0080\u00be\u00e1\u0080\u00af\u00e1\u0080\u0090\u00e1\u0080\u00ba');\n        assert.equal(moment(a).subtract({d: 1}).calendar(), '\u00e1\u0080\u0099\u00e1\u0080\u0094\u00e1\u0080\u00b1.\u00e1\u0080\u0080 \u00e1\u0081\u0081\u00e1\u0081\u0082:\u00e1\u0081\u0080\u00e1\u0081\u0080 \u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac',     '\u00e1\u0080\u0099\u00e1\u0080\u0094\u00e1\u0080\u00b1.\u00e1\u0080\u0080 \u00e1\u0080\u0092\u00e1\u0080\u00ae\u00e1\u0080\u00a1\u00e1\u0080\u0081\u00e1\u0080\u00bb\u00e1\u0080\u00ad\u00e1\u0080\u0094\u00e1\u0080\u00ba');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({\n                d: i\n            });\n            assert.equal(m.calendar(), m.format('dddd LT [\u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac]'), 'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format('dddd LT [\u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac]'), 'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format('dddd LT [\u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac]'), 'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({\n                d: i\n            });\n            assert.equal(m.calendar(), m.format('[\u00e1\u0080\u0095\u00e1\u0080\u00bc\u00e1\u0080\u00ae\u00e1\u0080\u00b8\u00e1\u0080\u0081\u00e1\u0080\u00b2\u00e1\u0080\u00b7\u00e1\u0080\u009e\u00e1\u0080\u00b1\u00e1\u0080\u00ac] dddd LT [\u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac]'), 'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format('[\u00e1\u0080\u0095\u00e1\u0080\u00bc\u00e1\u0080\u00ae\u00e1\u0080\u00b8\u00e1\u0080\u0081\u00e1\u0080\u00b2\u00e1\u0080\u00b7\u00e1\u0080\u009e\u00e1\u0080\u00b1\u00e1\u0080\u00ac] dddd LT [\u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac]'), 'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format('[\u00e1\u0080\u0095\u00e1\u0080\u00bc\u00e1\u0080\u00ae\u00e1\u0080\u00b8\u00e1\u0080\u0081\u00e1\u0080\u00b2\u00e1\u0080\u00b7\u00e1\u0080\u009e\u00e1\u0080\u00b1\u00e1\u0080\u00ac] dddd LT [\u00e1\u0080\u0099\u00e1\u0080\u00be\u00e1\u0080\u00ac]'), 'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({\n                w: 1\n            }),\n            weeksFromNow = moment().add({\n                w: 1\n            });\n\n        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '\u00e1\u0080\u009c\u00e1\u0080\u00bd\u00e1\u0080\u0094\u00e1\u0080\u00ba\u00e1\u0080\u0081\u00e1\u0080\u00b2\u00e1\u0080\u00b7\u00e1\u0080\u009e\u00e1\u0080\u00b1\u00e1\u0080\u00ac \u00e1\u0081\u0081 \u00e1\u0080\u0095\u00e1\u0080\u0090\u00e1\u0080\u00ba\u00e1\u0080\u0080');\n        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), '\u00e1\u0081\u0081 \u00e1\u0080\u0095\u00e1\u0080\u0090\u00e1\u0080\u00ba\u00e1\u0080\u00a1\u00e1\u0080\u0090\u00e1\u0080\u00bd\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u00b8');\n\n        weeksAgo = moment().subtract({\n            w: 2\n        });\n        weeksFromNow = moment().add({\n            w: 2\n        });\n\n        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '\u00e1\u0081\u0082 \u00e1\u0080\u0095\u00e1\u0080\u0090\u00e1\u0080\u00ba \u00e1\u0080\u00a1\u00e1\u0080\u009b\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u0080');\n        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), '\u00e1\u0081\u0082 \u00e1\u0080\u0095\u00e1\u0080\u0090\u00e1\u0080\u00ba \u00e1\u0080\u00a1\u00e1\u0080\u0090\u00e1\u0080\u00bd\u00e1\u0080\u0084\u00e1\u0080\u00ba\u00e1\u0080\u00b8');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '\u00e1\u0081\u0085\u00e1\u0081\u0082 \u00e1\u0081\u0085\u00e1\u0081\u0082 \u00e1\u0081\u0085\u00e1\u0081\u0082', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '\u00e1\u0081\u0081 \u00e1\u0081\u0080\u00e1\u0081\u0081 \u00e1\u0081\u0081', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '\u00e1\u0081\u0081 \u00e1\u0081\u0080\u00e1\u0081\u0081 \u00e1\u0081\u0081', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '\u00e1\u0081\u0082 \u00e1\u0081\u0080\u00e1\u0081\u0082 \u00e1\u0081\u0082', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '\u00e1\u0081\u0082 \u00e1\u0081\u0080\u00e1\u0081\u0082 \u00e1\u0081\u0082', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('nb');\n\n    test('parse', function (assert) {\n        var tests = 'januar jan._februar feb._mars mars_april april_mai mai_juni juni_juli juli_august aug._september sep._oktober okt._november nov._desember des.'.split('_'),\n            i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      's\u00c3\u00b8ndag, februar 14. 2010, 3:25:50 pm'],\n                ['ddd, hA',                            's\u00c3\u00b8., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. s\u00c3\u00b8ndag s\u00c3\u00b8. s\u00c3\u00b8'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[den] DDDo [dagen i \u00c3\u00a5ret]',          'den 45. dagen i \u00c3\u00a5ret'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14. februar 2010'],\n                ['LLL',                                '14. februar 2010 kl. 15:25'],\n                ['LLLL',                               's\u00c3\u00b8ndag 14. februar 2010 kl. 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14. feb. 2010'],\n                ['lll',                                '14. feb. 2010 kl. 15:25'],\n                ['llll',                               's\u00c3\u00b8. 14. feb. 2010 kl. 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'januar jan._februar feb._mars mars_april april_mai mai_juni juni_juli juli_august aug._september sep._oktober okt._november nov._desember des.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 's\u00c3\u00b8ndag s\u00c3\u00b8. s\u00c3\u00b8_mandag ma. ma_tirsdag ti. ti_onsdag on. on_torsdag to. to_fredag fr. fr_l\u00c3\u00b8rdag l\u00c3\u00b8. l\u00c3\u00b8'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'noen sekunder', '44 sekunder = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ett minutt',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ett minutt',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutter',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutter',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'en time',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'en time',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timer',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timer',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timer',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dag',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dag',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dager',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dag',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dager',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dager',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en m\u00c3\u00a5ned',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en m\u00c3\u00a5ned',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en m\u00c3\u00a5ned',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m\u00c3\u00a5neder',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m\u00c3\u00a5neder',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m\u00c3\u00a5neder',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en m\u00c3\u00a5ned',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m\u00c3\u00a5neder',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ett \u00c3\u00a5r',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00c3\u00a5r',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ett \u00c3\u00a5r',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00c3\u00a5r',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'om noen sekunder',  'prefix');\n        assert.equal(moment(0).from(30000), 'noen sekunder siden', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'noen sekunder siden',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'om noen sekunder', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dager', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'i dag kl. 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'i dag kl. 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'i dag kl. 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'i morgen kl. 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'i dag kl. 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'i g\u00c3\u00a5r kl. 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[forrige] dddd [kl.] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[forrige] dddd [kl.] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[forrige] dddd [kl.] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ne');\n\n    test('parse', function (assert) {\n        var tests = '\u00e0\u00a4\u009c\u00e0\u00a4\u00a8\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u009c\u00e0\u00a4\u00a8._\u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081._\u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u009a \u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u009a_\u00e0\u00a4\u0085\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a4\u00bf\u00e0\u00a4\u00b2 \u00e0\u00a4\u0085\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a4\u00bf._\u00e0\u00a4\u00ae\u00e0\u00a4\u0088 \u00e0\u00a4\u00ae\u00e0\u00a4\u0088_\u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00a8 \u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00a8_\u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00b2\u00e0\u00a4\u00be\u00e0\u00a4\u0088 \u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00b2\u00e0\u00a4\u00be\u00e0\u00a4\u0088._\u00e0\u00a4\u0085\u00e0\u00a4\u0097\u00e0\u00a4\u00b7\u00e0\u00a5\u008d\u00e0\u00a4\u009f \u00e0\u00a4\u0085\u00e0\u00a4\u0097._\u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u0087\u00e0\u00a4\u00ae\u00e0\u00a5\u008d\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u009f._\u00e0\u00a4\u0085\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u008b\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u0085\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u008b._\u00e0\u00a4\u00a8\u00e0\u00a5\u008b\u00e0\u00a4\u00ad\u00e0\u00a5\u0087\u00e0\u00a4\u00ae\u00e0\u00a5\u008d\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a8\u00e0\u00a5\u008b\u00e0\u00a4\u00ad\u00e0\u00a5\u0087._\u00e0\u00a4\u00a1\u00e0\u00a4\u00bf\u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u00ae\u00e0\u00a5\u008d\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a1\u00e0\u00a4\u00bf\u00e0\u00a4\u00b8\u00e0\u00a5\u0087.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, a\u00e0\u00a4\u0095\u00e0\u00a5\u008b h:mm:ss \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',      '\u00e0\u00a4\u0086\u00e0\u00a4\u0087\u00e0\u00a4\u00a4\u00e0\u00a4\u00ac\u00e0\u00a4\u00be\u00e0\u00a4\u00b0, \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab:\u00e0\u00a5\u00ab\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087'],\n                ['ddd, a\u00e0\u00a4\u0095\u00e0\u00a5\u008b h \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',                                                '\u00e0\u00a4\u0086\u00e0\u00a4\u0087\u00e0\u00a4\u00a4., \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a9 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087'],\n                ['M Mo MM MMMM MMM',                   '\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a8 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081.'],\n                ['YYYY YY',                            '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6 \u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['D Do DD',                            '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa'],\n                ['d do dddd ddd dd',                   '\u00e0\u00a5\u00a6 \u00e0\u00a5\u00a6 \u00e0\u00a4\u0086\u00e0\u00a4\u0087\u00e0\u00a4\u00a4\u00e0\u00a4\u00ac\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u0086\u00e0\u00a4\u0087\u00e0\u00a4\u00a4. \u00e0\u00a4\u0086.'],\n                ['DDD DDDo DDDD',                      '\u00e0\u00a5\u00aa\u00e0\u00a5\u00ab \u00e0\u00a5\u00aa\u00e0\u00a5\u00ab \u00e0\u00a5\u00a6\u00e0\u00a5\u00aa\u00e0\u00a5\u00ab'],\n                ['w wo ww',                            '\u00e0\u00a5\u00ae \u00e0\u00a5\u00ae \u00e0\u00a5\u00a6\u00e0\u00a5\u00ae'],\n                ['h hh',                               '\u00e0\u00a5\u00a9 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a9'],\n                ['H HH',                               '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ab \u00e0\u00a5\u00a7\u00e0\u00a5\u00ab'],\n                ['m mm',                               '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a5\u00a8\u00e0\u00a5\u00ab'],\n                ['s ss',                               '\u00e0\u00a5\u00ab\u00e0\u00a5\u00a6 \u00e0\u00a5\u00ab\u00e0\u00a5\u00a6'],\n                ['a A',                                '\u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b'],\n                ['LTS',                                '\u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab:\u00e0\u00a5\u00ab\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087'],\n                ['L',                                  '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa/\u00e0\u00a5\u00a6\u00e0\u00a5\u00a8/\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['LL',                                 '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['LLL',                                '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087'],\n                ['LLLL',                               '\u00e0\u00a4\u0086\u00e0\u00a4\u0087\u00e0\u00a4\u00a4\u00e0\u00a4\u00ac\u00e0\u00a4\u00be\u00e0\u00a4\u00b0, \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087'],\n                ['l',                                  '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa/\u00e0\u00a5\u00a8/\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['ll',                                 '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081. \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6'],\n                ['lll',                                '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081. \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087'],\n                ['llll',                               '\u00e0\u00a4\u0086\u00e0\u00a4\u0087\u00e0\u00a4\u00a4., \u00e0\u00a5\u00a7\u00e0\u00a5\u00aa \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081. \u00e0\u00a5\u00a8\u00e0\u00a5\u00a6\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6, \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a9:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '\u00e0\u00a5\u00a7', '\u00e0\u00a5\u00a7');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '\u00e0\u00a5\u00a8', '\u00e0\u00a5\u00a8');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '\u00e0\u00a5\u00a9', '\u00e0\u00a5\u00a9');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '\u00e0\u00a5\u00aa', '\u00e0\u00a5\u00aa');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '\u00e0\u00a5\u00ab', '\u00e0\u00a5\u00ab');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '\u00e0\u00a5\u00ac', '\u00e0\u00a5\u00ac');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '\u00e0\u00a5\u00ad', '\u00e0\u00a5\u00ad');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '\u00e0\u00a5\u00ae', '\u00e0\u00a5\u00ae');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '\u00e0\u00a5\u00af', '\u00e0\u00a5\u00af');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a6');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a7', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a7');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a8', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a8');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a9', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00a9');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00aa');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ab', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ab');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ac', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ac');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ad', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ad');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ae', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00ae');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00e0\u00a5\u00a7\u00e0\u00a5\u00af', '\u00e0\u00a5\u00a7\u00e0\u00a5\u00af');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a6');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a7', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a7');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a8', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a8');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a9', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a9');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00aa', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00aa');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ac', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ac');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ad', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ad');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ae', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ae');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '\u00e0\u00a5\u00a8\u00e0\u00a5\u00af', '\u00e0\u00a5\u00a8\u00e0\u00a5\u00af');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '\u00e0\u00a5\u00a9\u00e0\u00a5\u00a6', '\u00e0\u00a5\u00a9\u00e0\u00a5\u00a6');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '\u00e0\u00a5\u00a9\u00e0\u00a5\u00a7', '\u00e0\u00a5\u00a9\u00e0\u00a5\u00a7');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e0\u00a4\u009c\u00e0\u00a4\u00a8\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u009c\u00e0\u00a4\u00a8._\u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081\u00e0\u00a4\u00b5\u00e0\u00a4\u00b0\u00e0\u00a5\u0080 \u00e0\u00a4\u00ab\u00e0\u00a5\u0087\u00e0\u00a4\u00ac\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a5\u0081._\u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u009a \u00e0\u00a4\u00ae\u00e0\u00a4\u00be\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u009a_\u00e0\u00a4\u0085\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a4\u00bf\u00e0\u00a4\u00b2 \u00e0\u00a4\u0085\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a4\u00bf._\u00e0\u00a4\u00ae\u00e0\u00a4\u0088 \u00e0\u00a4\u00ae\u00e0\u00a4\u0088_\u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00a8 \u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00a8_\u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00b2\u00e0\u00a4\u00be\u00e0\u00a4\u0088 \u00e0\u00a4\u009c\u00e0\u00a5\u0081\u00e0\u00a4\u00b2\u00e0\u00a4\u00be\u00e0\u00a4\u0088._\u00e0\u00a4\u0085\u00e0\u00a4\u0097\u00e0\u00a4\u00b7\u00e0\u00a5\u008d\u00e0\u00a4\u009f \u00e0\u00a4\u0085\u00e0\u00a4\u0097._\u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u0087\u00e0\u00a4\u00ae\u00e0\u00a5\u008d\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u00aa\u00e0\u00a5\u008d\u00e0\u00a4\u009f._\u00e0\u00a4\u0085\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u008b\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u0085\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a5\u008b._\u00e0\u00a4\u00a8\u00e0\u00a5\u008b\u00e0\u00a4\u00ad\u00e0\u00a5\u0087\u00e0\u00a4\u00ae\u00e0\u00a5\u008d\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a8\u00e0\u00a5\u008b\u00e0\u00a4\u00ad\u00e0\u00a5\u0087._\u00e0\u00a4\u00a1\u00e0\u00a4\u00bf\u00e0\u00a4\u00b8\u00e0\u00a5\u0087\u00e0\u00a4\u00ae\u00e0\u00a5\u008d\u00e0\u00a4\u00ac\u00e0\u00a4\u00b0 \u00e0\u00a4\u00a1\u00e0\u00a4\u00bf\u00e0\u00a4\u00b8\u00e0\u00a5\u0087.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e0\u00a4\u0086\u00e0\u00a4\u0087\u00e0\u00a4\u00a4\u00e0\u00a4\u00ac\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u0086\u00e0\u00a4\u0087\u00e0\u00a4\u00a4. \u00e0\u00a4\u0086._\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u00ae\u00e0\u00a4\u00ac\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u00ae. \u00e0\u00a4\u00b8\u00e0\u00a5\u008b._\u00e0\u00a4\u00ae\u00e0\u00a4\u0099\u00e0\u00a5\u008d\u00e0\u00a4\u0097\u00e0\u00a4\u00b2\u00e0\u00a4\u00ac\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00ae\u00e0\u00a4\u0099\u00e0\u00a5\u008d\u00e0\u00a4\u0097\u00e0\u00a4\u00b2. \u00e0\u00a4\u00ae\u00e0\u00a4\u0082._\u00e0\u00a4\u00ac\u00e0\u00a5\u0081\u00e0\u00a4\u00a7\u00e0\u00a4\u00ac\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00ac\u00e0\u00a5\u0081\u00e0\u00a4\u00a7. \u00e0\u00a4\u00ac\u00e0\u00a5\u0081._\u00e0\u00a4\u00ac\u00e0\u00a4\u00bf\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00ac\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00ac\u00e0\u00a4\u00bf\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf. \u00e0\u00a4\u00ac\u00e0\u00a4\u00bf._\u00e0\u00a4\u00b6\u00e0\u00a5\u0081\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b0\u00e0\u00a4\u00ac\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b6\u00e0\u00a5\u0081\u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b0. \u00e0\u00a4\u00b6\u00e0\u00a5\u0081._\u00e0\u00a4\u00b6\u00e0\u00a4\u00a8\u00e0\u00a4\u00bf\u00e0\u00a4\u00ac\u00e0\u00a4\u00be\u00e0\u00a4\u00b0 \u00e0\u00a4\u00b6\u00e0\u00a4\u00a8\u00e0\u00a4\u00bf. \u00e0\u00a4\u00b6.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e0\u00a4\u0095\u00e0\u00a5\u0087\u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a4\u00a3', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a5\u0087\u00e0\u00a4\u009f',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a5\u0087\u00e0\u00a4\u009f',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ae\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a5\u0087\u00e0\u00a4\u009f',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '\u00e0\u00a5\u00aa\u00e0\u00a5\u00aa \u00e0\u00a4\u00ae\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a5\u0087\u00e0\u00a4\u009f',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u0098\u00e0\u00a4\u00a3\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a4\u00be',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u0098\u00e0\u00a4\u00a3\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a4\u00be',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u0098\u00e0\u00a4\u00a3\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a4\u00be',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '\u00e0\u00a5\u00ab \u00e0\u00a4\u0098\u00e0\u00a4\u00a3\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a4\u00be',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '\u00e0\u00a5\u00a8\u00e0\u00a5\u00a7 \u00e0\u00a4\u0098\u00e0\u00a4\u00a3\u00e0\u00a5\u008d\u00e0\u00a4\u009f\u00e0\u00a4\u00be',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '\u00e0\u00a5\u00ab \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00be',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00be',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00be',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00be',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00be',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '\u00e0\u00a5\u00a9 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00be',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00be',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '\u00e0\u00a5\u00ab \u00e0\u00a4\u00ae\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00be',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ac\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b7',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00e0\u00a5\u00a8 \u00e0\u00a4\u00ac\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b7',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00e0\u00a4\u008f\u00e0\u00a4\u0095 \u00e0\u00a4\u00ac\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b7',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '\u00e0\u00a5\u00ab \u00e0\u00a4\u00ac\u00e0\u00a4\u00b0\u00e0\u00a5\u008d\u00e0\u00a4\u00b7',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e0\u00a4\u0095\u00e0\u00a5\u0087\u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a4\u00a3\u00e0\u00a4\u00ae\u00e0\u00a4\u00be',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e0\u00a4\u0095\u00e0\u00a5\u0087\u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a4\u00a3 \u00e0\u00a4\u0085\u00e0\u00a4\u0097\u00e0\u00a4\u00be\u00e0\u00a4\u00a1\u00e0\u00a4\u00bf', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e0\u00a4\u0095\u00e0\u00a5\u0087\u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a4\u00a3 \u00e0\u00a4\u0085\u00e0\u00a4\u0097\u00e0\u00a4\u00be\u00e0\u00a4\u00a1\u00e0\u00a4\u00bf',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e0\u00a4\u0095\u00e0\u00a5\u0087\u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a4\u00a3\u00e0\u00a4\u00ae\u00e0\u00a4\u00be', '\u00e0\u00a4\u0095\u00e0\u00a5\u0087\u00e0\u00a4\u00b9\u00e0\u00a5\u0080 \u00e0\u00a4\u0095\u00e0\u00a5\u008d\u00e0\u00a4\u00b7\u00e0\u00a4\u00a3\u00e0\u00a4\u00ae\u00e0\u00a4\u00be');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00e0\u00a5\u00ab \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00ae\u00e0\u00a4\u00be', '\u00e0\u00a5\u00ab \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u00a8\u00e0\u00a4\u00ae\u00e0\u00a4\u00be');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e0\u00a4\u0086\u00e0\u00a4\u009c \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a7\u00e0\u00a5\u00a8:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e0\u00a4\u0086\u00e0\u00a4\u009c \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a7\u00e0\u00a5\u00a8:\u00e0\u00a5\u00a8\u00e0\u00a5\u00ab \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00e0\u00a4\u0086\u00e0\u00a4\u009c \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a7:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e0\u00a4\u00ad\u00e0\u00a5\u008b\u00e0\u00a4\u00b2\u00e0\u00a4\u00bf \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a7\u00e0\u00a5\u00a8:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e0\u00a4\u0086\u00e0\u00a4\u009c \u00e0\u00a4\u00ac\u00e0\u00a4\u00bf\u00e0\u00a4\u00b9\u00e0\u00a4\u00be\u00e0\u00a4\u00a8\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a7\u00e0\u00a5\u00a7:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e0\u00a4\u00b9\u00e0\u00a4\u00bf\u00e0\u00a4\u009c\u00e0\u00a5\u008b \u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b\u00e0\u00a4\u0095\u00e0\u00a5\u008b \u00e0\u00a5\u00a7\u00e0\u00a5\u00a8:\u00e0\u00a5\u00a6\u00e0\u00a5\u00a6 \u00e0\u00a4\u00ac\u00e0\u00a4\u009c\u00e0\u00a5\u0087',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a4\u0086\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00a6\u00e0\u00a5\u008b] dddd[,] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a4\u0086\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00a6\u00e0\u00a5\u008b] dddd[,] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a4\u0086\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00a6\u00e0\u00a5\u008b] dddd[,] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a4\u0097\u00e0\u00a4\u008f\u00e0\u00a4\u0095\u00e0\u00a5\u008b] dddd[,] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a4\u0097\u00e0\u00a4\u008f\u00e0\u00a4\u0095\u00e0\u00a5\u008b] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a4\u0097\u00e0\u00a4\u008f\u00e0\u00a4\u0095\u00e0\u00a5\u008b] dddd[,] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('meridiem', function (assert) {\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '\u00e0\u00a4\u00b0\u00e0\u00a4\u00be\u00e0\u00a4\u00a4\u00e0\u00a4\u00bf', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '\u00e0\u00a4\u00ac\u00e0\u00a4\u00bf\u00e0\u00a4\u00b9\u00e0\u00a4\u00be\u00e0\u00a4\u00a8', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '\u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b', 'during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '\u00e0\u00a4\u00b8\u00e0\u00a4\u00be\u00e0\u00a4\u0081\u00e0\u00a4\u009d', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '\u00e0\u00a4\u00b8\u00e0\u00a4\u00be\u00e0\u00a4\u0081\u00e0\u00a4\u009d', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '\u00e0\u00a4\u00b0\u00e0\u00a4\u00be\u00e0\u00a4\u00a4\u00e0\u00a4\u00bf', 'night');\n\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '\u00e0\u00a4\u00b0\u00e0\u00a4\u00be\u00e0\u00a4\u00a4\u00e0\u00a4\u00bf', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '\u00e0\u00a4\u00ac\u00e0\u00a4\u00bf\u00e0\u00a4\u00b9\u00e0\u00a4\u00be\u00e0\u00a4\u00a8', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '\u00e0\u00a4\u00a6\u00e0\u00a4\u00bf\u00e0\u00a4\u0089\u00e0\u00a4\u0081\u00e0\u00a4\u00b8\u00e0\u00a5\u008b', 'during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '\u00e0\u00a4\u00b8\u00e0\u00a4\u00be\u00e0\u00a4\u0081\u00e0\u00a4\u009d', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '\u00e0\u00a4\u00b8\u00e0\u00a4\u00be\u00e0\u00a4\u0081\u00e0\u00a4\u009d', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '\u00e0\u00a4\u00b0\u00e0\u00a4\u00be\u00e0\u00a4\u00a4\u00e0\u00a4\u00bf', 'night');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '\u00e0\u00a5\u00ab\u00e0\u00a5\u00a9 \u00e0\u00a5\u00ab\u00e0\u00a5\u00a9 \u00e0\u00a5\u00ab\u00e0\u00a5\u00a9', 'Dec 26 2011 should be week 53');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '\u00e0\u00a5\u00a7 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a7 \u00e0\u00a5\u00a7', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '\u00e0\u00a5\u00a7 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a7 \u00e0\u00a5\u00a7', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a8', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a6\u00e0\u00a5\u00a8 \u00e0\u00a5\u00a8', 'Jan  9 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('nl');\n\n    test('parse', function (assert) {\n        var tests = 'januari jan._februari feb._maart mrt._april apr._mei mei._juni jun._juli jul._augustus aug._september sep._oktober okt._november nov._december dec.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, HH:mm:ss',       'zondag, februari 14de 2010, 15:25:50'],\n                ['ddd, HH',                            'zo., 15'],\n                ['M Mo MM MMMM MMM',                   '2 2de 02 februari feb.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14de 14'],\n                ['d do dddd ddd dd',                   '0 0de zondag zo. Zo'],\n                ['DDD DDDo DDDD',                      '45 45ste 045'],\n                ['w wo ww',                            '6 6de 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45ste day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14-02-2010'],\n                ['LL',                                 '14 februari 2010'],\n                ['LLL',                                '14 februari 2010 15:25'],\n                ['LLLL',                               'zondag 14 februari 2010 15:25'],\n                ['l',                                  '14-2-2010'],\n                ['ll',                                 '14 feb. 2010'],\n                ['lll',                                '14 feb. 2010 15:25'],\n                ['llll',                               'zo. 14 feb. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ste', '1ste');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2de', '2de');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3de', '3de');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4de', '4de');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5de', '5de');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6de', '6de');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7de', '7de');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ste', '8ste');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9de', '9de');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10de', '10de');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11de', '11de');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12de', '12de');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13de', '13de');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14de', '14de');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15de', '15de');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16de', '16de');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17de', '17de');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18de', '18de');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19de', '19de');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ste', '20ste');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ste', '21ste');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ste', '22ste');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ste', '23ste');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ste', '24ste');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ste', '25ste');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ste', '26ste');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ste', '27ste');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ste', '28ste');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ste', '29ste');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ste', '30ste');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ste', '31ste');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'januari jan._februari feb._maart mrt._april apr._mei mei_juni jun._juli jul._augustus aug._september sep._oktober okt._november nov._december dec.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'zondag zo. Zo_maandag ma. Ma_dinsdag di. Di_woensdag wo. Wo_donderdag do. Do_vrijdag vr. Vr_zaterdag za. Za'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'een paar seconden', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00c3\u00a9\u00c3\u00a9n minuut',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00c3\u00a9\u00c3\u00a9n minuut',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuten',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuten',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00c3\u00a9\u00c3\u00a9n uur',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00c3\u00a9\u00c3\u00a9n uur',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 uur',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 uur',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 uur',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00c3\u00a9\u00c3\u00a9n dag',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00c3\u00a9\u00c3\u00a9n dag',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagen',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00c3\u00a9\u00c3\u00a9n dag',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagen',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagen',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00c3\u00a9\u00c3\u00a9n maand',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00c3\u00a9\u00c3\u00a9n maand',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00c3\u00a9\u00c3\u00a9n maand',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 maanden',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 maanden',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 maanden',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00c3\u00a9\u00c3\u00a9n maand',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 maanden',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00c3\u00a9\u00c3\u00a9n jaar',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jaar',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00c3\u00a9\u00c3\u00a9n jaar',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jaar',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'over een paar seconden',  'prefix');\n        assert.equal(moment(0).from(30000), 'een paar seconden geleden', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'een paar seconden geleden',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'over een paar seconden', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'over 5 dagen', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'vandaag om 12:00',   'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'vandaag om 12:25',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'vandaag om 13:00',   'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'morgen om 12:00',    'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'vandaag om 11:00',   'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'gisteren om 12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[afgelopen] dddd [om] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[afgelopen] dddd [om] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[afgelopen] dddd [om] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('month abbreviation', function (assert) {\n        assert.equal(moment([2012, 5, 23]).format('D-MMM-YYYY'), '23-jun-2012', 'format month abbreviation surrounded by dashes should not include a dot');\n        assert.equal(moment([2012, 5, 23]).format('D MMM YYYY'), '23 jun. 2012', 'format month abbreviation not surrounded by dashes should include a dot');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ste', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1ste', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1ste', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),    '2 02 2de', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),    '2 02 2de', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('nn');\n\n    test('parse', function (assert) {\n        var tests = 'januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sundag, februar 14. 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'sun, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. sundag sun su'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14. februar 2010'],\n                ['LLL',                                '14. februar 2010 kl. 15:25'],\n                ['LLLL',                               'sundag 14. februar 2010 kl. 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14. feb 2010'],\n                ['lll',                                '14. feb 2010 kl. 15:25'],\n                ['llll',                               'sun 14. feb 2010 kl. 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'sundag sun su_m\u00c3\u00a5ndag m\u00c3\u00a5n m\u00c3\u00a5_tysdag tys ty_onsdag ons on_torsdag tor to_fredag fre fr_laurdag lau l\u00c3\u00b8'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nokre sekund', '44 sekunder = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'eit minutt',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'eit minutt',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutt',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutt',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ein time',     '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ein time',     '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timar',      '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timar',      '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timar',     '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ein dag',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ein dag',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',      '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ein dag',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',      '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',     '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ein m\u00c3\u00a5nad',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ein m\u00c3\u00a5nad',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ein m\u00c3\u00a5nad',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m\u00c3\u00a5nader',    '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m\u00c3\u00a5nader',    '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m\u00c3\u00a5nader',    '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ein m\u00c3\u00a5nad',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m\u00c3\u00a5nader',    '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'eit \u00c3\u00a5r',       '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00c3\u00a5r',         '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'eit \u00c3\u00a5r',       '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00c3\u00a5r',         '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'om nokre sekund',  'prefix');\n        assert.equal(moment(0).from(30000), 'nokre sekund sidan', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'nokre sekund sidan',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'om nokre sekund', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dagar', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'I dag klokka 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'I dag klokka 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'I dag klokka 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'I morgon klokka 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'I dag klokka 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'I g\u00c3\u00a5r klokka 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [klokka] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [klokka] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [klokka] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[F\u00c3\u00b8reg\u00c3\u00a5ande] dddd [klokka] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[F\u00c3\u00b8reg\u00c3\u00a5ande] dddd [klokka] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[F\u00c3\u00b8reg\u00c3\u00a5ande] dddd [klokka] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('pa-in');\n\n    test('parse', function (assert) {\n        var tests = '\u00e0\u00a8\u009c\u00e0\u00a8\u00a8\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080 \u00e0\u00a8\u009c\u00e0\u00a8\u00a8\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080_\u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080 \u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080_\u00e0\u00a8\u00ae\u00e0\u00a8\u00be\u00e0\u00a8\u00b0\u00e0\u00a8\u009a \u00e0\u00a8\u00ae\u00e0\u00a8\u00be\u00e0\u00a8\u00b0\u00e0\u00a8\u009a_\u00e0\u00a8\u0085\u00e0\u00a8\u00aa\u00e0\u00a9\u008d\u00e0\u00a8\u00b0\u00e0\u00a9\u0088\u00e0\u00a8\u00b2 \u00e0\u00a8\u0085\u00e0\u00a8\u00aa\u00e0\u00a9\u008d\u00e0\u00a8\u00b0\u00e0\u00a9\u0088\u00e0\u00a8\u00b2_\u00e0\u00a8\u00ae\u00e0\u00a8\u0088 \u00e0\u00a8\u00ae\u00e0\u00a8\u0088_\u00e0\u00a8\u009c\u00e0\u00a9\u0082\u00e0\u00a8\u00a8 \u00e0\u00a8\u009c\u00e0\u00a9\u0082\u00e0\u00a8\u00a8_\u00e0\u00a8\u009c\u00e0\u00a9\u0081\u00e0\u00a8\u00b2\u00e0\u00a8\u00be\u00e0\u00a8\u0088 \u00e0\u00a8\u009c\u00e0\u00a9\u0081\u00e0\u00a8\u00b2\u00e0\u00a8\u00be\u00e0\u00a8\u0088_\u00e0\u00a8\u0085\u00e0\u00a8\u0097\u00e0\u00a8\u00b8\u00e0\u00a8\u00a4 \u00e0\u00a8\u0085\u00e0\u00a8\u0097\u00e0\u00a8\u00b8\u00e0\u00a8\u00a4_\u00e0\u00a8\u00b8\u00e0\u00a8\u00a4\u00e0\u00a9\u00b0\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0 \u00e0\u00a8\u00b8\u00e0\u00a8\u00a4\u00e0\u00a9\u00b0\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0_\u00e0\u00a8\u0085\u00e0\u00a8\u0095\u00e0\u00a8\u00a4\u00e0\u00a9\u0082\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0 \u00e0\u00a8\u0085\u00e0\u00a8\u0095\u00e0\u00a8\u00a4\u00e0\u00a9\u0082\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0_\u00e0\u00a8\u00a8\u00e0\u00a8\u00b5\u00e0\u00a9\u00b0\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0 \u00e0\u00a8\u00a8\u00e0\u00a8\u00b5\u00e0\u00a9\u00b0\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0_\u00e0\u00a8\u00a6\u00e0\u00a8\u00b8\u00e0\u00a9\u00b0\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0 \u00e0\u00a8\u00a6\u00e0\u00a8\u00b8\u00e0\u00a9\u00b0\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, a h:mm:ss \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087',  '\u00e0\u00a8\u0090\u00e0\u00a8\u00a4\u00e0\u00a8\u00b5\u00e0\u00a8\u00be\u00e0\u00a8\u00b0, \u00e0\u00a9\u00a7\u00e0\u00a9\u00aa \u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080 \u00e0\u00a9\u00a8\u00e0\u00a9\u00a6\u00e0\u00a9\u00a7\u00e0\u00a9\u00a6, \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a9:\u00e0\u00a9\u00a8\u00e0\u00a9\u00ab:\u00e0\u00a9\u00ab\u00e0\u00a9\u00a6 \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087'],\n                ['ddd, a h \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087',                       '\u00e0\u00a8\u0090\u00e0\u00a8\u00a4, \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a9 \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087'],\n                ['M Mo MM MMMM MMM',                   '\u00e0\u00a9\u00a8 \u00e0\u00a9\u00a8 \u00e0\u00a9\u00a6\u00e0\u00a9\u00a8 \u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080 \u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080'],\n                ['YYYY YY',                            '\u00e0\u00a9\u00a8\u00e0\u00a9\u00a6\u00e0\u00a9\u00a7\u00e0\u00a9\u00a6 \u00e0\u00a9\u00a7\u00e0\u00a9\u00a6'],\n                ['D Do DD',                            '\u00e0\u00a9\u00a7\u00e0\u00a9\u00aa \u00e0\u00a9\u00a7\u00e0\u00a9\u00aa \u00e0\u00a9\u00a7\u00e0\u00a9\u00aa'],\n                ['d do dddd ddd dd',                   '\u00e0\u00a9\u00a6 \u00e0\u00a9\u00a6 \u00e0\u00a8\u0090\u00e0\u00a8\u00a4\u00e0\u00a8\u00b5\u00e0\u00a8\u00be\u00e0\u00a8\u00b0 \u00e0\u00a8\u0090\u00e0\u00a8\u00a4 \u00e0\u00a8\u0090\u00e0\u00a8\u00a4'],\n                ['DDD DDDo DDDD',                      '\u00e0\u00a9\u00aa\u00e0\u00a9\u00ab \u00e0\u00a9\u00aa\u00e0\u00a9\u00ab \u00e0\u00a9\u00a6\u00e0\u00a9\u00aa\u00e0\u00a9\u00ab'],\n                ['w wo ww',                            '\u00e0\u00a9\u00ae \u00e0\u00a9\u00ae \u00e0\u00a9\u00a6\u00e0\u00a9\u00ae'],\n                ['h hh',                               '\u00e0\u00a9\u00a9 \u00e0\u00a9\u00a6\u00e0\u00a9\u00a9'],\n                ['H HH',                               '\u00e0\u00a9\u00a7\u00e0\u00a9\u00ab \u00e0\u00a9\u00a7\u00e0\u00a9\u00ab'],\n                ['m mm',                               '\u00e0\u00a9\u00a8\u00e0\u00a9\u00ab \u00e0\u00a9\u00a8\u00e0\u00a9\u00ab'],\n                ['s ss',                               '\u00e0\u00a9\u00ab\u00e0\u00a9\u00a6 \u00e0\u00a9\u00ab\u00e0\u00a9\u00a6'],\n                ['a A',                                '\u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0'],\n                ['LTS',                                '\u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a9:\u00e0\u00a9\u00a8\u00e0\u00a9\u00ab:\u00e0\u00a9\u00ab\u00e0\u00a9\u00a6 \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087'],\n                ['L',                                  '\u00e0\u00a9\u00a7\u00e0\u00a9\u00aa/\u00e0\u00a9\u00a6\u00e0\u00a9\u00a8/\u00e0\u00a9\u00a8\u00e0\u00a9\u00a6\u00e0\u00a9\u00a7\u00e0\u00a9\u00a6'],\n                ['LL',                                 '\u00e0\u00a9\u00a7\u00e0\u00a9\u00aa \u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080 \u00e0\u00a9\u00a8\u00e0\u00a9\u00a6\u00e0\u00a9\u00a7\u00e0\u00a9\u00a6'],\n                ['LLL',                                '\u00e0\u00a9\u00a7\u00e0\u00a9\u00aa \u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080 \u00e0\u00a9\u00a8\u00e0\u00a9\u00a6\u00e0\u00a9\u00a7\u00e0\u00a9\u00a6, \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a9:\u00e0\u00a9\u00a8\u00e0\u00a9\u00ab \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087'],\n                ['LLLL',                               '\u00e0\u00a8\u0090\u00e0\u00a8\u00a4\u00e0\u00a8\u00b5\u00e0\u00a8\u00be\u00e0\u00a8\u00b0, \u00e0\u00a9\u00a7\u00e0\u00a9\u00aa \u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080 \u00e0\u00a9\u00a8\u00e0\u00a9\u00a6\u00e0\u00a9\u00a7\u00e0\u00a9\u00a6, \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a9:\u00e0\u00a9\u00a8\u00e0\u00a9\u00ab \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087'],\n                ['l',                                  '\u00e0\u00a9\u00a7\u00e0\u00a9\u00aa/\u00e0\u00a9\u00a8/\u00e0\u00a9\u00a8\u00e0\u00a9\u00a6\u00e0\u00a9\u00a7\u00e0\u00a9\u00a6'],\n                ['ll',                                 '\u00e0\u00a9\u00a7\u00e0\u00a9\u00aa \u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080 \u00e0\u00a9\u00a8\u00e0\u00a9\u00a6\u00e0\u00a9\u00a7\u00e0\u00a9\u00a6'],\n                ['lll',                                '\u00e0\u00a9\u00a7\u00e0\u00a9\u00aa \u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080 \u00e0\u00a9\u00a8\u00e0\u00a9\u00a6\u00e0\u00a9\u00a7\u00e0\u00a9\u00a6, \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a9:\u00e0\u00a9\u00a8\u00e0\u00a9\u00ab \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087'],\n                ['llll',                               '\u00e0\u00a8\u0090\u00e0\u00a8\u00a4, \u00e0\u00a9\u00a7\u00e0\u00a9\u00aa \u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080 \u00e0\u00a9\u00a8\u00e0\u00a9\u00a6\u00e0\u00a9\u00a7\u00e0\u00a9\u00a6, \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a9:\u00e0\u00a9\u00a8\u00e0\u00a9\u00ab \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '\u00e0\u00a9\u00a7', '\u00e0\u00a9\u00a7');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '\u00e0\u00a9\u00a8', '\u00e0\u00a9\u00a8');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '\u00e0\u00a9\u00a9', '\u00e0\u00a9\u00a9');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '\u00e0\u00a9\u00aa', '\u00e0\u00a9\u00aa');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '\u00e0\u00a9\u00ab', '\u00e0\u00a9\u00ab');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '\u00e0\u00a9\u00ac', '\u00e0\u00a9\u00ac');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '\u00e0\u00a9\u00ad', '\u00e0\u00a9\u00ad');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '\u00e0\u00a9\u00ae', '\u00e0\u00a9\u00ae');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '\u00e0\u00a9\u00af', '\u00e0\u00a9\u00af');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00e0\u00a9\u00a7\u00e0\u00a9\u00a6', '\u00e0\u00a9\u00a7\u00e0\u00a9\u00a6');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00e0\u00a9\u00a7\u00e0\u00a9\u00a7', '\u00e0\u00a9\u00a7\u00e0\u00a9\u00a7');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00e0\u00a9\u00a7\u00e0\u00a9\u00a8', '\u00e0\u00a9\u00a7\u00e0\u00a9\u00a8');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00e0\u00a9\u00a7\u00e0\u00a9\u00a9', '\u00e0\u00a9\u00a7\u00e0\u00a9\u00a9');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00e0\u00a9\u00a7\u00e0\u00a9\u00aa', '\u00e0\u00a9\u00a7\u00e0\u00a9\u00aa');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00e0\u00a9\u00a7\u00e0\u00a9\u00ab', '\u00e0\u00a9\u00a7\u00e0\u00a9\u00ab');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00e0\u00a9\u00a7\u00e0\u00a9\u00ac', '\u00e0\u00a9\u00a7\u00e0\u00a9\u00ac');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00e0\u00a9\u00a7\u00e0\u00a9\u00ad', '\u00e0\u00a9\u00a7\u00e0\u00a9\u00ad');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00e0\u00a9\u00a7\u00e0\u00a9\u00ae', '\u00e0\u00a9\u00a7\u00e0\u00a9\u00ae');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00e0\u00a9\u00a7\u00e0\u00a9\u00af', '\u00e0\u00a9\u00a7\u00e0\u00a9\u00af');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00e0\u00a9\u00a8\u00e0\u00a9\u00a6', '\u00e0\u00a9\u00a8\u00e0\u00a9\u00a6');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '\u00e0\u00a9\u00a8\u00e0\u00a9\u00a7', '\u00e0\u00a9\u00a8\u00e0\u00a9\u00a7');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '\u00e0\u00a9\u00a8\u00e0\u00a9\u00a8', '\u00e0\u00a9\u00a8\u00e0\u00a9\u00a8');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '\u00e0\u00a9\u00a8\u00e0\u00a9\u00a9', '\u00e0\u00a9\u00a8\u00e0\u00a9\u00a9');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '\u00e0\u00a9\u00a8\u00e0\u00a9\u00aa', '\u00e0\u00a9\u00a8\u00e0\u00a9\u00aa');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '\u00e0\u00a9\u00a8\u00e0\u00a9\u00ab', '\u00e0\u00a9\u00a8\u00e0\u00a9\u00ab');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '\u00e0\u00a9\u00a8\u00e0\u00a9\u00ac', '\u00e0\u00a9\u00a8\u00e0\u00a9\u00ac');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '\u00e0\u00a9\u00a8\u00e0\u00a9\u00ad', '\u00e0\u00a9\u00a8\u00e0\u00a9\u00ad');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '\u00e0\u00a9\u00a8\u00e0\u00a9\u00ae', '\u00e0\u00a9\u00a8\u00e0\u00a9\u00ae');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '\u00e0\u00a9\u00a8\u00e0\u00a9\u00af', '\u00e0\u00a9\u00a8\u00e0\u00a9\u00af');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '\u00e0\u00a9\u00a9\u00e0\u00a9\u00a6', '\u00e0\u00a9\u00a9\u00e0\u00a9\u00a6');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '\u00e0\u00a9\u00a9\u00e0\u00a9\u00a7', '\u00e0\u00a9\u00a9\u00e0\u00a9\u00a7');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e0\u00a8\u009c\u00e0\u00a8\u00a8\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080 \u00e0\u00a8\u009c\u00e0\u00a8\u00a8\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080_\u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080 \u00e0\u00a8\u00ab\u00e0\u00a8\u00bc\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00b0\u00e0\u00a9\u0080_\u00e0\u00a8\u00ae\u00e0\u00a8\u00be\u00e0\u00a8\u00b0\u00e0\u00a8\u009a \u00e0\u00a8\u00ae\u00e0\u00a8\u00be\u00e0\u00a8\u00b0\u00e0\u00a8\u009a_\u00e0\u00a8\u0085\u00e0\u00a8\u00aa\u00e0\u00a9\u008d\u00e0\u00a8\u00b0\u00e0\u00a9\u0088\u00e0\u00a8\u00b2 \u00e0\u00a8\u0085\u00e0\u00a8\u00aa\u00e0\u00a9\u008d\u00e0\u00a8\u00b0\u00e0\u00a9\u0088\u00e0\u00a8\u00b2_\u00e0\u00a8\u00ae\u00e0\u00a8\u0088 \u00e0\u00a8\u00ae\u00e0\u00a8\u0088_\u00e0\u00a8\u009c\u00e0\u00a9\u0082\u00e0\u00a8\u00a8 \u00e0\u00a8\u009c\u00e0\u00a9\u0082\u00e0\u00a8\u00a8_\u00e0\u00a8\u009c\u00e0\u00a9\u0081\u00e0\u00a8\u00b2\u00e0\u00a8\u00be\u00e0\u00a8\u0088 \u00e0\u00a8\u009c\u00e0\u00a9\u0081\u00e0\u00a8\u00b2\u00e0\u00a8\u00be\u00e0\u00a8\u0088_\u00e0\u00a8\u0085\u00e0\u00a8\u0097\u00e0\u00a8\u00b8\u00e0\u00a8\u00a4 \u00e0\u00a8\u0085\u00e0\u00a8\u0097\u00e0\u00a8\u00b8\u00e0\u00a8\u00a4_\u00e0\u00a8\u00b8\u00e0\u00a8\u00a4\u00e0\u00a9\u00b0\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0 \u00e0\u00a8\u00b8\u00e0\u00a8\u00a4\u00e0\u00a9\u00b0\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0_\u00e0\u00a8\u0085\u00e0\u00a8\u0095\u00e0\u00a8\u00a4\u00e0\u00a9\u0082\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0 \u00e0\u00a8\u0085\u00e0\u00a8\u0095\u00e0\u00a8\u00a4\u00e0\u00a9\u0082\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0_\u00e0\u00a8\u00a8\u00e0\u00a8\u00b5\u00e0\u00a9\u00b0\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0 \u00e0\u00a8\u00a8\u00e0\u00a8\u00b5\u00e0\u00a9\u00b0\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0_\u00e0\u00a8\u00a6\u00e0\u00a8\u00b8\u00e0\u00a9\u00b0\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0 \u00e0\u00a8\u00a6\u00e0\u00a8\u00b8\u00e0\u00a9\u00b0\u00e0\u00a8\u00ac\u00e0\u00a8\u00b0'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e0\u00a8\u0090\u00e0\u00a8\u00a4\u00e0\u00a8\u00b5\u00e0\u00a8\u00be\u00e0\u00a8\u00b0 \u00e0\u00a8\u0090\u00e0\u00a8\u00a4 \u00e0\u00a8\u0090\u00e0\u00a8\u00a4_\u00e0\u00a8\u00b8\u00e0\u00a9\u008b\u00e0\u00a8\u00ae\u00e0\u00a8\u00b5\u00e0\u00a8\u00be\u00e0\u00a8\u00b0 \u00e0\u00a8\u00b8\u00e0\u00a9\u008b\u00e0\u00a8\u00ae \u00e0\u00a8\u00b8\u00e0\u00a9\u008b\u00e0\u00a8\u00ae_\u00e0\u00a8\u00ae\u00e0\u00a9\u00b0\u00e0\u00a8\u0097\u00e0\u00a8\u00b2\u00e0\u00a8\u00b5\u00e0\u00a8\u00be\u00e0\u00a8\u00b0 \u00e0\u00a8\u00ae\u00e0\u00a9\u00b0\u00e0\u00a8\u0097\u00e0\u00a8\u00b2 \u00e0\u00a8\u00ae\u00e0\u00a9\u00b0\u00e0\u00a8\u0097\u00e0\u00a8\u00b2_\u00e0\u00a8\u00ac\u00e0\u00a9\u0081\u00e0\u00a8\u00a7\u00e0\u00a8\u00b5\u00e0\u00a8\u00be\u00e0\u00a8\u00b0 \u00e0\u00a8\u00ac\u00e0\u00a9\u0081\u00e0\u00a8\u00a7 \u00e0\u00a8\u00ac\u00e0\u00a9\u0081\u00e0\u00a8\u00a7_\u00e0\u00a8\u00b5\u00e0\u00a9\u0080\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00be\u00e0\u00a8\u00b0 \u00e0\u00a8\u00b5\u00e0\u00a9\u0080\u00e0\u00a8\u00b0 \u00e0\u00a8\u00b5\u00e0\u00a9\u0080\u00e0\u00a8\u00b0_\u00e0\u00a8\u00b8\u00e0\u00a8\u00bc\u00e0\u00a9\u0081\u00e0\u00a9\u00b1\u00e0\u00a8\u0095\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00be\u00e0\u00a8\u00b0 \u00e0\u00a8\u00b8\u00e0\u00a8\u00bc\u00e0\u00a9\u0081\u00e0\u00a8\u0095\u00e0\u00a8\u00b0 \u00e0\u00a8\u00b8\u00e0\u00a8\u00bc\u00e0\u00a9\u0081\u00e0\u00a8\u0095\u00e0\u00a8\u00b0_\u00e0\u00a8\u00b8\u00e0\u00a8\u00bc\u00e0\u00a8\u00a8\u00e0\u00a9\u0080\u00e0\u00a8\u009a\u00e0\u00a8\u00b0\u00e0\u00a8\u00b5\u00e0\u00a8\u00be\u00e0\u00a8\u00b0 \u00e0\u00a8\u00b8\u00e0\u00a8\u00bc\u00e0\u00a8\u00a8\u00e0\u00a9\u0080 \u00e0\u00a8\u00b8\u00e0\u00a8\u00bc\u00e0\u00a8\u00a8\u00e0\u00a9\u0080'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e0\u00a8\u0095\u00e0\u00a9\u0081\u00e0\u00a8\u009d \u00e0\u00a8\u00b8\u00e0\u00a8\u0095\u00e0\u00a8\u00bf\u00e0\u00a9\u00b0\u00e0\u00a8\u009f', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00e0\u00a8\u0087\u00e0\u00a8\u0095 \u00e0\u00a8\u00ae\u00e0\u00a8\u00bf\u00e0\u00a9\u00b0\u00e0\u00a8\u009f',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00e0\u00a8\u0087\u00e0\u00a8\u0095 \u00e0\u00a8\u00ae\u00e0\u00a8\u00bf\u00e0\u00a9\u00b0\u00e0\u00a8\u009f',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '\u00e0\u00a9\u00a8 \u00e0\u00a8\u00ae\u00e0\u00a8\u00bf\u00e0\u00a9\u00b0\u00e0\u00a8\u009f',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '\u00e0\u00a9\u00aa\u00e0\u00a9\u00aa \u00e0\u00a8\u00ae\u00e0\u00a8\u00bf\u00e0\u00a9\u00b0\u00e0\u00a8\u009f',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00e0\u00a8\u0087\u00e0\u00a9\u00b1\u00e0\u00a8\u0095 \u00e0\u00a8\u0098\u00e0\u00a9\u00b0\u00e0\u00a8\u009f\u00e0\u00a8\u00be',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00e0\u00a8\u0087\u00e0\u00a9\u00b1\u00e0\u00a8\u0095 \u00e0\u00a8\u0098\u00e0\u00a9\u00b0\u00e0\u00a8\u009f\u00e0\u00a8\u00be',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00e0\u00a9\u00a8 \u00e0\u00a8\u0098\u00e0\u00a9\u00b0\u00e0\u00a8\u009f\u00e0\u00a9\u0087',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '\u00e0\u00a9\u00ab \u00e0\u00a8\u0098\u00e0\u00a9\u00b0\u00e0\u00a8\u009f\u00e0\u00a9\u0087',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '\u00e0\u00a9\u00a8\u00e0\u00a9\u00a7 \u00e0\u00a8\u0098\u00e0\u00a9\u00b0\u00e0\u00a8\u009f\u00e0\u00a9\u0087',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00e0\u00a8\u0087\u00e0\u00a9\u00b1\u00e0\u00a8\u0095 \u00e0\u00a8\u00a6\u00e0\u00a8\u00bf\u00e0\u00a8\u00a8',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00e0\u00a8\u0087\u00e0\u00a9\u00b1\u00e0\u00a8\u0095 \u00e0\u00a8\u00a6\u00e0\u00a8\u00bf\u00e0\u00a8\u00a8',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00e0\u00a9\u00a8 \u00e0\u00a8\u00a6\u00e0\u00a8\u00bf\u00e0\u00a8\u00a8',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00e0\u00a8\u0087\u00e0\u00a9\u00b1\u00e0\u00a8\u0095 \u00e0\u00a8\u00a6\u00e0\u00a8\u00bf\u00e0\u00a8\u00a8',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '\u00e0\u00a9\u00ab \u00e0\u00a8\u00a6\u00e0\u00a8\u00bf\u00e0\u00a8\u00a8',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '\u00e0\u00a9\u00a8\u00e0\u00a9\u00ab \u00e0\u00a8\u00a6\u00e0\u00a8\u00bf\u00e0\u00a8\u00a8',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00e0\u00a8\u0087\u00e0\u00a9\u00b1\u00e0\u00a8\u0095 \u00e0\u00a8\u00ae\u00e0\u00a8\u00b9\u00e0\u00a9\u0080\u00e0\u00a8\u00a8\u00e0\u00a8\u00be',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00e0\u00a8\u0087\u00e0\u00a9\u00b1\u00e0\u00a8\u0095 \u00e0\u00a8\u00ae\u00e0\u00a8\u00b9\u00e0\u00a9\u0080\u00e0\u00a8\u00a8\u00e0\u00a8\u00be',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00e0\u00a8\u0087\u00e0\u00a9\u00b1\u00e0\u00a8\u0095 \u00e0\u00a8\u00ae\u00e0\u00a8\u00b9\u00e0\u00a9\u0080\u00e0\u00a8\u00a8\u00e0\u00a8\u00be',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '\u00e0\u00a9\u00a8 \u00e0\u00a8\u00ae\u00e0\u00a8\u00b9\u00e0\u00a9\u0080\u00e0\u00a8\u00a8\u00e0\u00a9\u0087',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '\u00e0\u00a9\u00a8 \u00e0\u00a8\u00ae\u00e0\u00a8\u00b9\u00e0\u00a9\u0080\u00e0\u00a8\u00a8\u00e0\u00a9\u0087',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '\u00e0\u00a9\u00a9 \u00e0\u00a8\u00ae\u00e0\u00a8\u00b9\u00e0\u00a9\u0080\u00e0\u00a8\u00a8\u00e0\u00a9\u0087',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00e0\u00a8\u0087\u00e0\u00a9\u00b1\u00e0\u00a8\u0095 \u00e0\u00a8\u00ae\u00e0\u00a8\u00b9\u00e0\u00a9\u0080\u00e0\u00a8\u00a8\u00e0\u00a8\u00be',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '\u00e0\u00a9\u00ab \u00e0\u00a8\u00ae\u00e0\u00a8\u00b9\u00e0\u00a9\u0080\u00e0\u00a8\u00a8\u00e0\u00a9\u0087',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e0\u00a8\u0087\u00e0\u00a9\u00b1\u00e0\u00a8\u0095 \u00e0\u00a8\u00b8\u00e0\u00a8\u00be\u00e0\u00a8\u00b2',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00e0\u00a9\u00a8 \u00e0\u00a8\u00b8\u00e0\u00a8\u00be\u00e0\u00a8\u00b2',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00e0\u00a8\u0087\u00e0\u00a9\u00b1\u00e0\u00a8\u0095 \u00e0\u00a8\u00b8\u00e0\u00a8\u00be\u00e0\u00a8\u00b2',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '\u00e0\u00a9\u00ab \u00e0\u00a8\u00b8\u00e0\u00a8\u00be\u00e0\u00a8\u00b2',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e0\u00a8\u0095\u00e0\u00a9\u0081\u00e0\u00a8\u009d \u00e0\u00a8\u00b8\u00e0\u00a8\u0095\u00e0\u00a8\u00bf\u00e0\u00a9\u00b0\u00e0\u00a8\u009f \u00e0\u00a8\u00b5\u00e0\u00a8\u00bf\u00e0\u00a9\u00b1\u00e0\u00a8\u009a',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e0\u00a8\u0095\u00e0\u00a9\u0081\u00e0\u00a8\u009d \u00e0\u00a8\u00b8\u00e0\u00a8\u0095\u00e0\u00a8\u00bf\u00e0\u00a9\u00b0\u00e0\u00a8\u009f \u00e0\u00a8\u00aa\u00e0\u00a8\u00bf\u00e0\u00a8\u009b\u00e0\u00a8\u00b2\u00e0\u00a9\u0087', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e0\u00a8\u0095\u00e0\u00a9\u0081\u00e0\u00a8\u009d \u00e0\u00a8\u00b8\u00e0\u00a8\u0095\u00e0\u00a8\u00bf\u00e0\u00a9\u00b0\u00e0\u00a8\u009f \u00e0\u00a8\u00aa\u00e0\u00a8\u00bf\u00e0\u00a8\u009b\u00e0\u00a8\u00b2\u00e0\u00a9\u0087',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e0\u00a8\u0095\u00e0\u00a9\u0081\u00e0\u00a8\u009d \u00e0\u00a8\u00b8\u00e0\u00a8\u0095\u00e0\u00a8\u00bf\u00e0\u00a9\u00b0\u00e0\u00a8\u009f \u00e0\u00a8\u00b5\u00e0\u00a8\u00bf\u00e0\u00a9\u00b1\u00e0\u00a8\u009a', '\u00e0\u00a8\u0095\u00e0\u00a9\u0081\u00e0\u00a8\u009d \u00e0\u00a8\u00b8\u00e0\u00a8\u0095\u00e0\u00a8\u00bf\u00e0\u00a9\u00b0\u00e0\u00a8\u009f \u00e0\u00a8\u00b5\u00e0\u00a8\u00bf\u00e0\u00a9\u00b1\u00e0\u00a8\u009a');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00e0\u00a9\u00ab \u00e0\u00a8\u00a6\u00e0\u00a8\u00bf\u00e0\u00a8\u00a8 \u00e0\u00a8\u00b5\u00e0\u00a8\u00bf\u00e0\u00a9\u00b1\u00e0\u00a8\u009a', '\u00e0\u00a9\u00ab \u00e0\u00a8\u00a6\u00e0\u00a8\u00bf\u00e0\u00a8\u00a8 \u00e0\u00a8\u00b5\u00e0\u00a8\u00bf\u00e0\u00a9\u00b1\u00e0\u00a8\u009a');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e0\u00a8\u0085\u00e0\u00a8\u009c \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a7\u00e0\u00a9\u00a8:\u00e0\u00a9\u00a6\u00e0\u00a9\u00a6 \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e0\u00a8\u0085\u00e0\u00a8\u009c \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a7\u00e0\u00a9\u00a8:\u00e0\u00a9\u00a8\u00e0\u00a9\u00ab \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 3}).calendar(),       '\u00e0\u00a8\u0085\u00e0\u00a8\u009c \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a9:\u00e0\u00a9\u00a6\u00e0\u00a9\u00a6 \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087',   'Now plus 3 hours');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e0\u00a8\u0095\u00e0\u00a8\u00b2 \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a7\u00e0\u00a9\u00a8:\u00e0\u00a9\u00a6\u00e0\u00a9\u00a6 \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e0\u00a8\u0085\u00e0\u00a8\u009c \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a7\u00e0\u00a9\u00a7:\u00e0\u00a9\u00a6\u00e0\u00a9\u00a6 \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e0\u00a8\u0095\u00e0\u00a8\u00b2 \u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0 \u00e0\u00a9\u00a7\u00e0\u00a9\u00a8:\u00e0\u00a9\u00a6\u00e0\u00a9\u00a6 \u00e0\u00a8\u00b5\u00e0\u00a8\u009c\u00e0\u00a9\u0087',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a8\u00aa\u00e0\u00a8\u00bf\u00e0\u00a8\u009b\u00e0\u00a8\u00b2\u00e0\u00a9\u0087] dddd[,] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a8\u00aa\u00e0\u00a8\u00bf\u00e0\u00a8\u009b\u00e0\u00a8\u00b2\u00e0\u00a9\u0087] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00a8\u00aa\u00e0\u00a8\u00bf\u00e0\u00a8\u009b\u00e0\u00a8\u00b2\u00e0\u00a9\u0087] dddd[,] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('meridiem invariant', function (assert) {\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '\u00e0\u00a8\u00b0\u00e0\u00a8\u00be\u00e0\u00a8\u00a4', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '\u00e0\u00a8\u00b8\u00e0\u00a8\u00b5\u00e0\u00a9\u0087\u00e0\u00a8\u00b0', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '\u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0', 'during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '\u00e0\u00a8\u00b8\u00e0\u00a8\u00bc\u00e0\u00a8\u00be\u00e0\u00a8\u00ae', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '\u00e0\u00a8\u00b8\u00e0\u00a8\u00bc\u00e0\u00a8\u00be\u00e0\u00a8\u00ae', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '\u00e0\u00a8\u00b0\u00e0\u00a8\u00be\u00e0\u00a8\u00a4', 'night');\n\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '\u00e0\u00a8\u00b0\u00e0\u00a8\u00be\u00e0\u00a8\u00a4', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '\u00e0\u00a8\u00b8\u00e0\u00a8\u00b5\u00e0\u00a9\u0087\u00e0\u00a8\u00b0', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '\u00e0\u00a8\u00a6\u00e0\u00a9\u0081\u00e0\u00a8\u00aa\u00e0\u00a8\u00b9\u00e0\u00a8\u00bf\u00e0\u00a8\u00b0', ' during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '\u00e0\u00a8\u00b8\u00e0\u00a8\u00bc\u00e0\u00a8\u00be\u00e0\u00a8\u00ae', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '\u00e0\u00a8\u00b8\u00e0\u00a8\u00bc\u00e0\u00a8\u00be\u00e0\u00a8\u00ae', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '\u00e0\u00a8\u00b0\u00e0\u00a8\u00be\u00e0\u00a8\u00a4', 'night');\n    });\n\n    test('weeks year starting sunday', function (assert) {\n        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');\n    });\n\n    test('weeks year starting monday', function (assert) {\n        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');\n        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');\n        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');\n        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');\n        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');\n        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');\n    });\n\n    test('weeks year starting tuesday', function (assert) {\n        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');\n        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');\n        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');\n        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');\n        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');\n        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');\n    });\n\n    test('weeks year starting wednesday', function (assert) {\n        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');\n        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');\n        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');\n        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');\n        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');\n        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');\n    });\n\n    test('weeks year starting thursday', function (assert) {\n        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');\n        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');\n        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');\n        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');\n        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');\n        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');\n    });\n\n    test('weeks year starting friday', function (assert) {\n        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');\n        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');\n        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');\n        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');\n        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');\n        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');\n    });\n\n    test('weeks year starting saturday', function (assert) {\n        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');\n        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');\n        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');\n        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');\n        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '\u00e0\u00a9\u00a7 \u00e0\u00a9\u00a6\u00e0\u00a9\u00a7 \u00e0\u00a9\u00a7', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '\u00e0\u00a9\u00a7 \u00e0\u00a9\u00a6\u00e0\u00a9\u00a7 \u00e0\u00a9\u00a7', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '\u00e0\u00a9\u00a8 \u00e0\u00a9\u00a6\u00e0\u00a9\u00a8 \u00e0\u00a9\u00a8', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '\u00e0\u00a9\u00a8 \u00e0\u00a9\u00a6\u00e0\u00a9\u00a8 \u00e0\u00a9\u00a8', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '\u00e0\u00a9\u00a9 \u00e0\u00a9\u00a6\u00e0\u00a9\u00a9 \u00e0\u00a9\u00a9', 'Jan 15 2012 should be week 3');\n    });\n\n    test('lenient ordinal parsing', function (assert) {\n        var i, ordinalStr, testMoment;\n        for (i = 1; i <= 31; ++i) {\n            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n            testMoment = moment(ordinalStr, 'YYYY MM Do');\n            assert.equal(testMoment.year(), 2014,\n                    'lenient ordinal parsing ' + i + ' year check');\n            assert.equal(testMoment.month(), 0,\n                    'lenient ordinal parsing ' + i + ' month check');\n            assert.equal(testMoment.date(), i,\n                    'lenient ordinal parsing ' + i + ' date check');\n        }\n    });\n\n    test('lenient ordinal parsing of number', function (assert) {\n        var i, testMoment;\n        for (i = 1; i <= 31; ++i) {\n            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n            assert.equal(testMoment.year(), 2014,\n                    'lenient ordinal parsing of number ' + i + ' year check');\n            assert.equal(testMoment.month(), 0,\n                    'lenient ordinal parsing of number ' + i + ' month check');\n            assert.equal(testMoment.date(), i,\n                    'lenient ordinal parsing of number ' + i + ' date check');\n        }\n    });\n\n    test('strict ordinal parsing', function (assert) {\n        var i, ordinalStr, testMoment;\n        for (i = 1; i <= 31; ++i) {\n            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n            testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n        }\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('pl');\n\n    test('parse', function (assert) {\n        var tests = 'stycze\u00c5\u0084 stycznia sty_luty lutego lut_marzec marca mar_kwiecie\u00c5\u0084 kwietnia kwi_maj maja maj_czerwiec czerwca cze_lipiec lipca lip_sierpie\u00c5\u0084 sierpnia sie_wrzesie\u00c5\u0084 wrze\u00c5\u009bnia wrz_pa\u00c5\u00badziernik pa\u00c5\u00badziernika pa\u00c5\u00ba_listopad listopada lis_grudzie\u00c5\u0084 grudnia gru'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][2], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][2], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][2].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][2].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('parse strict', function (assert) {\n        var tests = 'stycze\u00c5\u0084 stycznia sty_luty lutego lut_marzec marca mar_kwiecie\u00c5\u0084 kwietnia kwi_maj maja maj_czerwiec czerwca cze_lipiec lipca lip_sierpie\u00c5\u0084 sierpnia sie_wrzesie\u00c5\u0084 wrze\u00c5\u009bnia wrz_pa\u00c5\u00badziernik pa\u00c5\u00badziernika pa\u00c5\u00ba_listopad listopada lis_grudzie\u00c5\u0084 grudnia gru'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm, true).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][2], 'MMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][2].toLocaleLowerCase(), 'MMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][2].toLocaleUpperCase(), 'MMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'niedziela, luty 14. 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'nie, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 luty lut'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. niedziela nie Nd'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 lutego 2010'],\n                ['LLL',                                '14 lutego 2010 15:25'],\n                ['LLLL',                               'niedziela, 14 lutego 2010 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 lut 2010'],\n                ['lll',                                '14 lut 2010 15:25'],\n                ['llll',                               'nie, 14 lut 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'stycze\u00c5\u0084 sty_luty lut_marzec mar_kwiecie\u00c5\u0084 kwi_maj maj_czerwiec cze_lipiec lip_sierpie\u00c5\u0084 sie_wrzesie\u00c5\u0084 wrz_pa\u00c5\u00badziernik pa\u00c5\u00ba_listopad lis_grudzie\u00c5\u0084 gru'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'niedziela nie Nd_poniedzia\u00c5\u0082ek pon Pn_wtorek wt Wt_\u00c5\u009broda \u00c5\u009br \u00c5\u009ar_czwartek czw Cz_pi\u00c4\u0085tek pt Pt_sobota sb So'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'kilka sekund',  '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuta',        '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuta',        '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuty',      '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuty',     '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'godzina',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'godzina',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 godziny',     '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 godzin',      '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 godzin',     '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 dzie\u00c5\u0084',       '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 dzie\u00c5\u0084',       '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dni',         '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 dzie\u00c5\u0084',       '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dni',         '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dni',        '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'miesi\u00c4\u0085c',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'miesi\u00c4\u0085c',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'miesi\u00c4\u0085c',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 miesi\u00c4\u0085ce',    '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 miesi\u00c4\u0085ce',    '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 miesi\u00c4\u0085ce',    '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'miesi\u00c4\u0085c',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 miesi\u00c4\u0099cy',    '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'rok',           '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 lata',        '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'rok',           '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 lat',         '5 years = 5 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 112}), true), '112 lat',       '112 years = 112 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 122}), true), '122 lata',      '122 years = 122 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 213}), true), '213 lat',       '213 years = 213 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 223}), true), '223 lata',      '223 years = 223 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'za kilka sekund',  'prefix');\n        assert.equal(moment(0).from(30000), 'kilka sekund temu', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'kilka sekund temu',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'za kilka sekund', 'in a few seconds');\n        assert.equal(moment().add({h: 1}).fromNow(), 'za godzin\u00c4\u0099', 'in an hour');\n        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dni', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Dzi\u00c5\u009b o 12:00',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Dzi\u00c5\u009b o 12:25',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Dzi\u00c5\u009b o 13:00',    'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Jutro o 12:00',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Dzi\u00c5\u009b o 11:00',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Wczoraj o 12:00', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[W] dddd [o] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[W] dddd [o] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[W] dddd [o] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n                return '[W zesz\u00c5\u0082\u00c4\u0085 niedziel\u00c4\u0099 o] LT';\n            case 3:\n                return '[W zesz\u00c5\u0082\u00c4\u0085 \u00c5\u009brod\u00c4\u0099 o] LT';\n            case 6:\n                return '[W zesz\u00c5\u0082\u00c4\u0085 sobot\u00c4\u0099 o] LT';\n            default:\n                return '[W zesz\u00c5\u0082y] dddd [o] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(), m.format(makeFormat(m)), 'Today - ' + i + ' days current time');\n\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format(makeFormat(m)), 'Today - ' + i + ' days beginning of day');\n\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format(makeFormat(m)), 'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('pt-br');\n\n    test('parse', function (assert) {\n        var tests = 'janeiro jan_fevereiro fev_mar\u00c3\u00a7o mar_abril abr_maio mai_junho jun_julho jul_agosto ago_setembro set_outubro out_novembro nov_dezembro dez'.split('_'), i;\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Fevereiro 14\u00c2\u00ba 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Dom, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2\u00c2\u00ba 02 Fevereiro Fev'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\u00c2\u00ba 14'],\n                ['d do dddd ddd',                      '0 0\u00c2\u00ba Domingo Dom'],\n                ['DDD DDDo DDDD',                      '45 45\u00c2\u00ba 045'],\n                ['w wo ww',                            '8 8\u00c2\u00ba 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45\u00c2\u00ba day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 de Fevereiro de 2010'],\n                ['LLL',                                '14 de Fevereiro de 2010 \u00c3\u00a0s 15:25'],\n                ['LLLL',                               'Domingo, 14 de Fevereiro de 2010 \u00c3\u00a0s 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 de Fev de 2010'],\n                ['lll',                                '14 de Fev de 2010 \u00c3\u00a0s 15:25'],\n                ['llll',                               'Dom, 14 de Fev de 2010 \u00c3\u00a0s 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1\u00c2\u00ba', '1\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2\u00c2\u00ba', '2\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3\u00c2\u00ba', '3\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4\u00c2\u00ba', '4\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\u00c2\u00ba', '5\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\u00c2\u00ba', '6\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\u00c2\u00ba', '7\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\u00c2\u00ba', '8\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\u00c2\u00ba', '9\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\u00c2\u00ba', '10\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\u00c2\u00ba', '11\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\u00c2\u00ba', '12\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\u00c2\u00ba', '13\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\u00c2\u00ba', '14\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\u00c2\u00ba', '15\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\u00c2\u00ba', '16\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\u00c2\u00ba', '17\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\u00c2\u00ba', '18\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\u00c2\u00ba', '19\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\u00c2\u00ba', '20\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\u00c2\u00ba', '21\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\u00c2\u00ba', '22\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\u00c2\u00ba', '23\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\u00c2\u00ba', '24\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\u00c2\u00ba', '25\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\u00c2\u00ba', '26\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\u00c2\u00ba', '27\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\u00c2\u00ba', '28\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\u00c2\u00ba', '29\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\u00c2\u00ba', '30\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\u00c2\u00ba', '31\u00c2\u00ba');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Janeiro Jan_Fevereiro Fev_Mar\u00c3\u00a7o Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Domingo Dom_Segunda-feira Seg_Ter\u00c3\u00a7a-feira Ter_Quarta-feira Qua_Quinta-feira Qui_Sexta-feira Sex_S\u00c3\u00a1bado S\u00c3\u00a1b'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'poucos segundos', '44 seconds = seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'um minuto',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'um minuto',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'uma hora',    '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'uma hora',    '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',    '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',    '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',   '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'um dia',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'um dia',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dias',     '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'um dia',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dias',     '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dias',    '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'um m\u00c3\u00aas',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'um m\u00c3\u00aas',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'um m\u00c3\u00aas',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'um m\u00c3\u00aas',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'um ano',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anos',    '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'um ano',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anos',    '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'em poucos segundos', 'prefix');\n        assert.equal(moment(0).from(30000), 'poucos segundos atr\u00c3\u00a1s', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'em poucos segundos', 'in seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'em 5 dias', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Hoje \u00c3\u00a0s 12:00',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Hoje \u00c3\u00a0s 12:25',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Hoje \u00c3\u00a0s 13:00',    'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Amanh\u00c3\u00a3 \u00c3\u00a0s 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hoje \u00c3\u00a0s 11:00',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ontem \u00c3\u00a0s 12:00',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0s] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0s] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0s] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[\u00c3\u009altimo] dddd [\u00c3\u00a0s] LT' : '[\u00c3\u009altima] dddd [\u00c3\u00a0s] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[\u00c3\u009altimo] dddd [\u00c3\u00a0s] LT' : '[\u00c3\u009altima] dddd [\u00c3\u00a0s] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[\u00c3\u009altimo] dddd [\u00c3\u00a0s] LT' : '[\u00c3\u009altima] dddd [\u00c3\u00a0s] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1\u00c2\u00ba', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1\u00c2\u00ba', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2\u00c2\u00ba', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2\u00c2\u00ba', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3\u00c2\u00ba', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('pt');\n\n    test('parse', function (assert) {\n        var tests = 'Janeiro Jan_Fevereiro Fev_Mar\u00c3\u00a7o Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Fevereiro 14\u00c2\u00ba 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Dom, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2\u00c2\u00ba 02 Fevereiro Fev'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\u00c2\u00ba 14'],\n                ['d do dddd ddd',                      '0 0\u00c2\u00ba Domingo Dom'],\n                ['DDD DDDo DDDD',                      '45 45\u00c2\u00ba 045'],\n                ['w wo ww',                            '6 6\u00c2\u00ba 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45\u00c2\u00ba day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 de Fevereiro de 2010'],\n                ['LLL',                                '14 de Fevereiro de 2010 15:25'],\n                ['LLLL',                               'Domingo, 14 de Fevereiro de 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 de Fev de 2010'],\n                ['lll',                                '14 de Fev de 2010 15:25'],\n                ['llll',                               'Dom, 14 de Fev de 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1\u00c2\u00ba', '1\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2\u00c2\u00ba', '2\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3\u00c2\u00ba', '3\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4\u00c2\u00ba', '4\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\u00c2\u00ba', '5\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\u00c2\u00ba', '6\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\u00c2\u00ba', '7\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\u00c2\u00ba', '8\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\u00c2\u00ba', '9\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\u00c2\u00ba', '10\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\u00c2\u00ba', '11\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\u00c2\u00ba', '12\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\u00c2\u00ba', '13\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\u00c2\u00ba', '14\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\u00c2\u00ba', '15\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\u00c2\u00ba', '16\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\u00c2\u00ba', '17\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\u00c2\u00ba', '18\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\u00c2\u00ba', '19\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\u00c2\u00ba', '20\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\u00c2\u00ba', '21\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\u00c2\u00ba', '22\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\u00c2\u00ba', '23\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\u00c2\u00ba', '24\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\u00c2\u00ba', '25\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\u00c2\u00ba', '26\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\u00c2\u00ba', '27\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\u00c2\u00ba', '28\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\u00c2\u00ba', '29\u00c2\u00ba');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\u00c2\u00ba', '30\u00c2\u00ba');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\u00c2\u00ba', '31\u00c2\u00ba');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Janeiro Jan_Fevereiro Fev_Mar\u00c3\u00a7o Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Domingo Dom Dom_Segunda-Feira Seg 2\u00c2\u00aa_Ter\u00c3\u00a7a-Feira Ter 3\u00c2\u00aa_Quarta-Feira Qua 4\u00c2\u00aa_Quinta-Feira Qui 5\u00c2\u00aa_Sexta-Feira Sex 6\u00c2\u00aa_S\u00c3\u00a1bado S\u00c3\u00a1b S\u00c3\u00a1b'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'segundos',    '44 seconds = seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'um minuto',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'um minuto',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'uma hora',    '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'uma hora',    '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',    '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',    '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',   '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'um dia',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'um dia',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dias',     '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'um dia',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dias',     '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dias',    '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'um m\u00c3\u00aas',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'um m\u00c3\u00aas',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'um m\u00c3\u00aas',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'um m\u00c3\u00aas',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'um ano',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anos',    '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'um ano',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anos',    '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'em segundos', 'prefix');\n        assert.equal(moment(0).from(30000), 'h\u00c3\u00a1 segundos', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'em segundos', 'in seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'em 5 dias', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Hoje \u00c3\u00a0s 12:00',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Hoje \u00c3\u00a0s 12:25',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Hoje \u00c3\u00a0s 13:00',    'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Amanh\u00c3\u00a3 \u00c3\u00a0s 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hoje \u00c3\u00a0s 11:00',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ontem \u00c3\u00a0s 12:00',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0s] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0s] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0s] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[\u00c3\u009altimo] dddd [\u00c3\u00a0s] LT' : '[\u00c3\u009altima] dddd [\u00c3\u00a0s] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[\u00c3\u009altimo] dddd [\u00c3\u00a0s] LT' : '[\u00c3\u009altima] dddd [\u00c3\u00a0s] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[\u00c3\u009altimo] dddd [\u00c3\u00a0s] LT' : '[\u00c3\u009altima] dddd [\u00c3\u00a0s] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52\u00c2\u00ba', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1\u00c2\u00ba', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1\u00c2\u00ba', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2\u00c2\u00ba', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2\u00c2\u00ba', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ro');\n\n    test('parse', function (assert) {\n        var tests = 'ianuarie ian._februarie febr._martie mart._aprilie apr._mai mai_iunie iun._iulie iul._august aug._septembrie sept._octombrie oct._noiembrie nov._decembrie dec.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss A',  'duminic\u00c4\u0083, februarie 14 2010, 3:25:50 PM'],\n                ['ddd, hA',                        'Dum, 3PM'],\n                ['M Mo MM MMMM MMM',               '2 2 02 februarie febr.'],\n                ['YYYY YY',                        '2010 10'],\n                ['D Do DD',                        '14 14 14'],\n                ['d do dddd ddd dd',               '0 0 duminic\u00c4\u0083 Dum Du'],\n                ['DDD DDDo DDDD',                  '45 45 045'],\n                ['w wo ww',                        '7 7 07'],\n                ['h hh',                           '3 03'],\n                ['H HH',                           '15 15'],\n                ['m mm',                           '25 25'],\n                ['s ss',                           '50 50'],\n                ['a A',                            'pm PM'],\n                ['[a] DDDo[a zi a anului]',        'a 45a zi a anului'],\n                ['LTS',                            '15:25:50'],\n                ['L',                              '14.02.2010'],\n                ['LL',                             '14 februarie 2010'],\n                ['LLL',                            '14 februarie 2010 15:25'],\n                ['LLLL',                           'duminic\u00c4\u0083, 14 februarie 2010 15:25'],\n                ['l',                              '14.2.2010'],\n                ['ll',                             '14 febr. 2010'],\n                ['lll',                            '14 febr. 2010 15:25'],\n                ['llll',                           'Dum, 14 febr. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'ianuarie ian._februarie febr._martie mart._aprilie apr._mai mai_iunie iun._iulie iul._august aug._septembrie sept._octombrie oct._noiembrie nov._decembrie dec.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'duminic\u00c4\u0083 Dum Du_luni Lun Lu_mar\u00c8\u009bi Mar Ma_miercuri Mie Mi_joi Joi Jo_vineri Vin Vi_s\u00c3\u00a2mb\u00c4\u0083t\u00c4\u0083 S\u00c3\u00a2m S\u00c3\u00a2'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'c\u00c3\u00a2teva secunde', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minut',       '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minut',       '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',       '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 de minute',   '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'o or\u00c4\u0083',          '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'o or\u00c4\u0083',          '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ore',          '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ore',          '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 de ore',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'o zi',           '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'o zi',           '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 zile',         '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'o zi',           '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 zile',         '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 de zile',     '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'o lun\u00c4\u0083',         '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'o lun\u00c4\u0083',         '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'o lun\u00c4\u0083',         '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 luni',         '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 luni',         '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 luni',         '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'o lun\u00c4\u0083',         '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 luni',         '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',          '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ani',          '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',          '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ani',          '5 years = 5 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 19}), true),   '19 ani',        '19 years = 19 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 20}), true),   '20 de ani',     '20 years = 20 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 100}), true),   '100 de ani',   '100 years = 100 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 101}), true),   '101 ani',      '101 years = 101 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 119}), true),   '119 ani',      '119 years = 119 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 120}), true),   '120 de ani',   '120 years = 120 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 219}), true),   '219 ani',      '219 years = 219 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 220}), true),   '220 de ani',   '220 years = 220 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'peste c\u00c3\u00a2teva secunde',   'prefix');\n        assert.equal(moment(0).from(30000), 'c\u00c3\u00a2teva secunde \u00c3\u00aen urm\u00c4\u0083', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'c\u00c3\u00a2teva secunde \u00c3\u00aen urm\u00c4\u0083',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'peste c\u00c3\u00a2teva secunde', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'peste 5 zile', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'azi la 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'azi la 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'azi la 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'm\u00c3\u00a2ine la 12:00',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'azi la 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ieri la 12:00',    'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [la] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [la] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [la] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[fosta] dddd [la] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[fosta] dddd [la] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[fosta] dddd [la] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ru');\n\n    test('parse', function (assert) {\n        var tests = '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2\u00d0\u00b0\u00d1\u0080\u00d1\u008c \u00d1\u008f\u00d0\u00bd\u00d0\u00b2._\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008c \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00bb\u00d1\u008c \u00d0\u00b0\u00d0\u00bf\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9 \u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008c \u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008c_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008c \u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008c_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3._\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082._\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d0\u00be\u00d0\u00ba\u00d1\u0082._\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1._\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        function equalTestStrict(input, mmm, monthIndex) {\n            assert.equal(moment(input, mmm, true).month(), monthIndex, input + ' ' + mmm + ' should be strict month ' + (monthIndex + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n\n            equalTestStrict(tests[i][1], 'MMM', i);\n            equalTestStrict(tests[i][0], 'MMMM', i);\n            equalTestStrict(tests[i][1].toLocaleLowerCase(), 'MMM', i);\n            equalTestStrict(tests[i][1].toLocaleUpperCase(), 'MMM', i);\n            equalTestStrict(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTestStrict(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('parse exceptional case', function (assert) {\n        assert.equal(moment('11 \u00d0\u009c\u00d0\u00b0\u00d1\u008f 1989', ['DD MMMM YYYY']).format('DD-MM-YYYY'), '11-05-1989');\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, HH:mm:ss',       '\u00d0\u00b2\u00d0\u00be\u00d1\u0081\u00d0\u00ba\u00d1\u0080\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u008c\u00d0\u00b5, 14-\u00d0\u00b3\u00d0\u00be \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008f 2010, 15:25:50'],\n                ['ddd, h A',                           '\u00d0\u00b2\u00d1\u0081, 3 \u00d0\u00b4\u00d0\u00bd\u00d1\u008f'],\n                ['M Mo MM MMMM MMM',                   '2 2-\u00d0\u00b9 02 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008c \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14-\u00d0\u00b3\u00d0\u00be 14'],\n                ['d do dddd ddd dd',                   '0 0-\u00d0\u00b9 \u00d0\u00b2\u00d0\u00be\u00d1\u0081\u00d0\u00ba\u00d1\u0080\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u008c\u00d0\u00b5 \u00d0\u00b2\u00d1\u0081 \u00d0\u00b2\u00d1\u0081'],\n                ['DDD DDDo DDDD',                      '45 45-\u00d0\u00b9 045'],\n                ['w wo ww',                            '7 7-\u00d1\u008f 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00d0\u00b4\u00d0\u00bd\u00d1\u008f \u00d0\u00b4\u00d0\u00bd\u00d1\u008f'],\n                ['DDDo [\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b0]',                   '45-\u00d0\u00b9 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b0'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008f 2010 \u00d0\u00b3.'],\n                ['LLL',                                '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008f 2010 \u00d0\u00b3., 15:25'],\n                ['LLLL',                               '\u00d0\u00b2\u00d0\u00be\u00d1\u0081\u00d0\u00ba\u00d1\u0080\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u008c\u00d0\u00b5, 14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008f 2010 \u00d0\u00b3., 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080. 2010 \u00d0\u00b3.'],\n                ['lll',                                '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080. 2010 \u00d0\u00b3., 15:25'],\n                ['llll',                               '\u00d0\u00b2\u00d1\u0081, 14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080. 2010 \u00d0\u00b3., 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format meridiem', function (assert) {\n        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), '\u00d0\u00bd\u00d0\u00be\u00d1\u0087\u00d0\u00b8', 'night');\n        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), '\u00d0\u00bd\u00d0\u00be\u00d1\u0087\u00d0\u00b8', 'night');\n        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), '\u00d1\u0083\u00d1\u0082\u00d1\u0080\u00d0\u00b0', 'morning');\n        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), '\u00d1\u0083\u00d1\u0082\u00d1\u0080\u00d0\u00b0', 'morning');\n        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), '\u00d0\u00b4\u00d0\u00bd\u00d1\u008f', 'afternoon');\n        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), '\u00d0\u00b4\u00d0\u00bd\u00d1\u008f', 'afternoon');\n        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), '\u00d0\u00b2\u00d0\u00b5\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b0', 'evening');\n        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), '\u00d0\u00b2\u00d0\u00b5\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b0', 'evening');\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-\u00d0\u00b9', '1-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-\u00d0\u00b9', '2-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-\u00d0\u00b9', '3-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-\u00d0\u00b9', '4-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-\u00d0\u00b9', '5-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-\u00d0\u00b9', '6-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-\u00d0\u00b9', '7-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-\u00d0\u00b9', '8-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-\u00d0\u00b9', '9-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-\u00d0\u00b9', '10-\u00d0\u00b9');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-\u00d0\u00b9', '11-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-\u00d0\u00b9', '12-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-\u00d0\u00b9', '13-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-\u00d0\u00b9', '14-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-\u00d0\u00b9', '15-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-\u00d0\u00b9', '16-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-\u00d0\u00b9', '17-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-\u00d0\u00b9', '18-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-\u00d0\u00b9', '19-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-\u00d0\u00b9', '20-\u00d0\u00b9');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-\u00d0\u00b9', '21-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-\u00d0\u00b9', '22-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-\u00d0\u00b9', '23-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-\u00d0\u00b9', '24-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-\u00d0\u00b9', '25-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-\u00d0\u00b9', '26-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-\u00d0\u00b9', '27-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-\u00d0\u00b9', '28-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-\u00d0\u00b9', '29-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-\u00d0\u00b9', '30-\u00d0\u00b9');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-\u00d0\u00b9', '31-\u00d0\u00b9');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2\u00d0\u00b0\u00d1\u0080\u00d1\u008c \u00d1\u008f\u00d0\u00bd\u00d0\u00b2._\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008c \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00bb\u00d1\u008c \u00d0\u00b0\u00d0\u00bf\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9 \u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008c \u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008c_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008c \u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008c_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3._\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082._\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d0\u00be\u00d0\u00ba\u00d1\u0082._\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1._\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00b1\u00d1\u0080\u00d1\u008c \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format month case', function (assert) {\n        var months = {\n            'nominative': '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2\u00d0\u00b0\u00d1\u0080\u00d1\u008c_\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008c_\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00bb\u00d1\u008c_\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008c_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008c_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082_\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c_\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c_\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c_\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00b1\u00d1\u0080\u00d1\u008c'.split('_'),\n            'accusative': '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2\u00d0\u00b0\u00d1\u0080\u00d1\u008f_\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008f_\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082\u00d0\u00b0_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00bb\u00d1\u008f_\u00d0\u00bc\u00d0\u00b0\u00d1\u008f_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008f_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008f_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082\u00d0\u00b0_\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008f_\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008f_\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008f_\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00b1\u00d1\u0080\u00d1\u008f'.split('_')\n        }, i;\n        for (i = 0; i < 12; i++) {\n            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);\n            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);\n        }\n    });\n\n    test('format month short case', function (assert) {\n        var monthsShort = {\n            'nominative': '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2._\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008c_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008c_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3._\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082._\u00d0\u00be\u00d0\u00ba\u00d1\u0082._\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1._\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba.'.split('_'),\n            'accusative': '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2._\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d1\u0080._\u00d0\u00b0\u00d0\u00bf\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d1\u008f_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008f_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008f_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3._\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082._\u00d0\u00be\u00d0\u00ba\u00d1\u0082._\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1._\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba.'.split('_')\n        }, i;\n        for (i = 0; i < 12; i++) {\n            assert.equal(moment([2011, i, 1]).format('D MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);\n            assert.equal(moment([2011, i, 1]).format('MMM'), monthsShort.nominative[i], '1 ' + monthsShort.nominative[i]);\n        }\n    });\n\n    test('format month case with escaped symbols', function (assert) {\n        var months = {\n            'nominative': '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2\u00d0\u00b0\u00d1\u0080\u00d1\u008c_\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008c_\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00bb\u00d1\u008c_\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008c_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008c_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082_\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c_\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c_\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008c_\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00b1\u00d1\u0080\u00d1\u008c'.split('_'),\n            'accusative': '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2\u00d0\u00b0\u00d1\u0080\u00d1\u008f_\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb\u00d1\u008f_\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082\u00d0\u00b0_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00bb\u00d1\u008f_\u00d0\u00bc\u00d0\u00b0\u00d1\u008f_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008f_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008f_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082\u00d0\u00b0_\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008f_\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008f_\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1\u00d1\u0080\u00d1\u008f_\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00b1\u00d1\u0080\u00d1\u008f'.split('_')\n        }, i;\n        for (i = 0; i < 12; i++) {\n            assert.equal(moment([2013, i, 1]).format('D[] MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);\n            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMMM[</b>]'), '<i>1</i> <b>' + months.accusative[i] + '</b>', '1 <b>' + months.accusative[i] + '</b>');\n            assert.equal(moment([2013, i, 1]).format('D[-\u00d0\u00b9 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c] MMMM'), '1-\u00d0\u00b9 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c ' + months.accusative[i], '1-\u00d0\u00b9 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c ' + months.accusative[i]);\n            assert.equal(moment([2013, i, 1]).format('D, MMMM'), '1, ' + months.nominative[i], '1, ' + months.nominative[i]);\n        }\n    });\n\n    test('format month short case with escaped symbols', function (assert) {\n        var monthsShort = {\n            'nominative': '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2._\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008c_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008c_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3._\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082._\u00d0\u00be\u00d0\u00ba\u00d1\u0082._\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1._\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba.'.split('_'),\n            'accusative': '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2._\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d1\u0080._\u00d0\u00b0\u00d0\u00bf\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d1\u008f_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd\u00d1\u008f_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb\u00d1\u008f_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3._\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082._\u00d0\u00be\u00d0\u00ba\u00d1\u0082._\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1._\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba.'.split('_')\n        }, i;\n        for (i = 0; i < 12; i++) {\n            assert.equal(moment([2013, i, 1]).format('D[] MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);\n            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMM[</b>]'), '<i>1</i> <b>' + monthsShort.accusative[i] + '</b>', '1 <b>' + monthsShort.accusative[i] + '</b>');\n            assert.equal(moment([2013, i, 1]).format('D[-\u00d0\u00b9 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c] MMM'), '1-\u00d0\u00b9 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c ' + monthsShort.accusative[i], '1-\u00d0\u00b9 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c ' + monthsShort.accusative[i]);\n            assert.equal(moment([2013, i, 1]).format('D, MMM'), '1, ' + monthsShort.nominative[i], '1, ' + monthsShort.nominative[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d0\u00b2\u00d0\u00be\u00d1\u0081\u00d0\u00ba\u00d1\u0080\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u008c\u00d0\u00b5 \u00d0\u00b2\u00d1\u0081 \u00d0\u00b2\u00d1\u0081_\u00d0\u00bf\u00d0\u00be\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d0\u00bb\u00d1\u008c\u00d0\u00bd\u00d0\u00b8\u00d0\u00ba \u00d0\u00bf\u00d0\u00bd \u00d0\u00bf\u00d0\u00bd_\u00d0\u00b2\u00d1\u0082\u00d0\u00be\u00d1\u0080\u00d0\u00bd\u00d0\u00b8\u00d0\u00ba \u00d0\u00b2\u00d1\u0082 \u00d0\u00b2\u00d1\u0082_\u00d1\u0081\u00d1\u0080\u00d0\u00b5\u00d0\u00b4\u00d0\u00b0 \u00d1\u0081\u00d1\u0080 \u00d1\u0081\u00d1\u0080_\u00d1\u0087\u00d0\u00b5\u00d1\u0082\u00d0\u00b2\u00d0\u00b5\u00d1\u0080\u00d0\u00b3 \u00d1\u0087\u00d1\u0082 \u00d1\u0087\u00d1\u0082_\u00d0\u00bf\u00d1\u008f\u00d1\u0082\u00d0\u00bd\u00d0\u00b8\u00d1\u0086\u00d0\u00b0 \u00d0\u00bf\u00d1\u0082 \u00d0\u00bf\u00d1\u0082_\u00d1\u0081\u00d1\u0083\u00d0\u00b1\u00d0\u00b1\u00d0\u00be\u00d1\u0082\u00d0\u00b0 \u00d1\u0081\u00d0\u00b1 \u00d1\u0081\u00d0\u00b1'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d0\u00bd\u00d0\u00b5\u00d1\u0081\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d1\u008c\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4',    '44 seconds = seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b0',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b0',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d1\u008b',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 31}), true),  '31 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b0',  '31 minutes = 31 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d1\u008b', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d1\u0087\u00d0\u00b0\u00d1\u0081',    '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d1\u0087\u00d0\u00b0\u00d1\u0081',    '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00d1\u0087\u00d0\u00b0\u00d1\u0081\u00d0\u00b0',    '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d1\u0087\u00d0\u00b0\u00d1\u0081\u00d0\u00be\u00d0\u00b2',    '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d1\u0087\u00d0\u00b0\u00d1\u0081',   '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00d0\u00b4\u00d0\u00bd\u00d1\u008f',     '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d0\u00b4\u00d0\u00bd\u00d0\u00b5\u00d0\u00b9',     '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 \u00d0\u00b4\u00d0\u00bd\u00d0\u00b5\u00d0\u00b9',     '11 days = 11 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c',     '21 days = 21 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d0\u00b4\u00d0\u00bd\u00d0\u00b5\u00d0\u00b9',    '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d0\u00b0',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d0\u00b0',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d0\u00b0',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d0\u00b5\u00d0\u00b2',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d0\u00b3\u00d0\u00be\u00d0\u00b4',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b0',    '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d0\u00b3\u00d0\u00be\u00d0\u00b4',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d0\u00bb\u00d0\u00b5\u00d1\u0082',    '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d0\u00b7 \u00d0\u00bd\u00d0\u00b5\u00d1\u0081\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d1\u008c\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4', 'prefix');\n        assert.equal(moment(0).from(30000), '\u00d0\u00bd\u00d0\u00b5\u00d1\u0081\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d1\u008c\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 \u00d0\u00bd\u00d0\u00b0\u00d0\u00b7\u00d0\u00b0\u00d0\u00b4', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d0\u00b7 \u00d0\u00bd\u00d0\u00b5\u00d1\u0081\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d1\u008c\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4', 'in seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d0\u00b7 5 \u00d0\u00b4\u00d0\u00bd\u00d0\u00b5\u00d0\u00b9', 'in 5 days');\n        assert.equal(moment().add({m: 31}).fromNow(), '\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d0\u00b7 31 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d1\u0083', 'in 31 minutes = in 31 minutes');\n        assert.equal(moment().subtract({m: 31}).fromNow(), '31 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d1\u0083 \u00d0\u00bd\u00d0\u00b0\u00d0\u00b7\u00d0\u00b0\u00d0\u00b4', '31 minutes ago = 31 minutes ago');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d0\u00a1\u00d0\u00b5\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00bd\u00d1\u008f \u00d0\u00b2 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d0\u00a1\u00d0\u00b5\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00bd\u00d1\u008f \u00d0\u00b2 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d0\u00a1\u00d0\u00b5\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00bd\u00d1\u008f \u00d0\u00b2 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d0\u0097\u00d0\u00b0\u00d0\u00b2\u00d1\u0082\u00d1\u0080\u00d0\u00b0 \u00d0\u00b2 12:00',      'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d0\u00a1\u00d0\u00b5\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00bd\u00d1\u008f \u00d0\u00b2 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d0\u0092\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b0 \u00d0\u00b2 12:00',       'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m, now;\n\n        function makeFormatNext(d) {\n            switch (d.day()) {\n            case 0:\n                return '[\u00d0\u0092 \u00d1\u0081\u00d0\u00bb\u00d0\u00b5\u00d0\u00b4\u00d1\u0083\u00d1\u008e\u00d1\u0089\u00d0\u00b5\u00d0\u00b5] dddd [\u00d0\u00b2] LT';\n            case 1:\n            case 2:\n            case 4:\n                return '[\u00d0\u0092 \u00d1\u0081\u00d0\u00bb\u00d0\u00b5\u00d0\u00b4\u00d1\u0083\u00d1\u008e\u00d1\u0089\u00d0\u00b8\u00d0\u00b9] dddd [\u00d0\u00b2] LT';\n            case 3:\n            case 5:\n            case 6:\n                return '[\u00d0\u0092 \u00d1\u0081\u00d0\u00bb\u00d0\u00b5\u00d0\u00b4\u00d1\u0083\u00d1\u008e\u00d1\u0089\u00d1\u0083\u00d1\u008e] dddd [\u00d0\u00b2] LT';\n            }\n        }\n\n        function makeFormatThis(d) {\n            if (d.day() === 2) {\n                return '[\u00d0\u0092\u00d0\u00be] dddd [\u00d0\u00b2] LT';\n            }\n            else {\n                return '[\u00d0\u0092] dddd [\u00d0\u00b2] LT';\n            }\n        }\n\n        now = moment().startOf('week');\n        for (i = 2; i < 7; i++) {\n            m = moment(now).add({d: i});\n            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today + ' + i + ' days end of day');\n        }\n\n        now = moment().endOf('week');\n        for (i = 2; i < 7; i++) {\n            m = moment(now).add({d: i});\n            assert.equal(m.calendar(now),       m.format(makeFormatNext(m)),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(now),       m.format(makeFormatNext(m)),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(now),       m.format(makeFormatNext(m)),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m, now;\n\n        function makeFormatLast(d) {\n            switch (d.day()) {\n            case 0:\n                return '[\u00d0\u0092 \u00d0\u00bf\u00d1\u0080\u00d0\u00be\u00d1\u0088\u00d0\u00bb\u00d0\u00be\u00d0\u00b5] dddd [\u00d0\u00b2] LT';\n            case 1:\n            case 2:\n            case 4:\n                return '[\u00d0\u0092 \u00d0\u00bf\u00d1\u0080\u00d0\u00be\u00d1\u0088\u00d0\u00bb\u00d1\u008b\u00d0\u00b9] dddd [\u00d0\u00b2] LT';\n            case 3:\n            case 5:\n            case 6:\n                return '[\u00d0\u0092 \u00d0\u00bf\u00d1\u0080\u00d0\u00be\u00d1\u0088\u00d0\u00bb\u00d1\u0083\u00d1\u008e] dddd [\u00d0\u00b2] LT';\n            }\n        }\n\n        function makeFormatThis(d) {\n            if (d.day() === 2) {\n                return '[\u00d0\u0092\u00d0\u00be] dddd [\u00d0\u00b2] LT';\n            }\n            else {\n                return '[\u00d0\u0092] dddd [\u00d0\u00b2] LT';\n            }\n        }\n\n        now = moment().startOf('week');\n        for (i = 2; i < 7; i++) {\n            m = moment(now).subtract({d: i});\n            assert.equal(m.calendar(now),       m.format(makeFormatLast(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(now),       m.format(makeFormatLast(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(now),       m.format(makeFormatLast(m)),  'Today - ' + i + ' days end of day');\n        }\n\n        now = moment().endOf('week');\n        for (i = 2; i < 7; i++) {\n            m = moment(now).subtract({d: i});\n            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-\u00d1\u008f', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-\u00d1\u008f', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-\u00d1\u008f', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-\u00d1\u008f', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-\u00d1\u008f', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('se');\n\n    test('parse', function (assert) {\n        var i,\n            tests = 'o\u00c4\u0091\u00c4\u0091ajagem\u00c3\u00a1nnu o\u00c4\u0091\u00c4\u0091j_guovvam\u00c3\u00a1nnu guov_njuk\u00c4\u008dam\u00c3\u00a1nnu njuk_cuo\u00c5\u008bom\u00c3\u00a1nnu cuo_miessem\u00c3\u00a1nnu mies_geassem\u00c3\u00a1nnu geas_suoidnem\u00c3\u00a1nnu suoi_borgem\u00c3\u00a1nnu borg_\u00c4\u008dak\u00c4\u008dam\u00c3\u00a1nnu \u00c4\u008dak\u00c4\u008d_golggotm\u00c3\u00a1nnu golg_sk\u00c3\u00a1bmam\u00c3\u00a1nnu sk\u00c3\u00a1b_juovlam\u00c3\u00a1nnu juov'.split('_');\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sotnabeaivi, guovvam\u00c3\u00a1nnu 14. 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'sotn, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 guovvam\u00c3\u00a1nnu guov'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. sotnabeaivi sotn s'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[jagi] DDDo [beaivi]',               'jagi 45. beaivi'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 'guovvam\u00c3\u00a1nnu 14. b. 2010'],\n                ['LLL',                                'guovvam\u00c3\u00a1nnu 14. b. 2010 ti. 15:25'],\n                ['LLLL',                               'sotnabeaivi, guovvam\u00c3\u00a1nnu 14. b. 2010 ti. 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 'guov 14. b. 2010'],\n                ['lll',                                'guov 14. b. 2010 ti. 15:25'],\n                ['llll',                               'sotn, guov 14. b. 2010 ti. 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var i,\n            expected = 'o\u00c4\u0091\u00c4\u0091ajagem\u00c3\u00a1nnu o\u00c4\u0091\u00c4\u0091j_guovvam\u00c3\u00a1nnu guov_njuk\u00c4\u008dam\u00c3\u00a1nnu njuk_cuo\u00c5\u008bom\u00c3\u00a1nnu cuo_miessem\u00c3\u00a1nnu mies_geassem\u00c3\u00a1nnu geas_suoidnem\u00c3\u00a1nnu suoi_borgem\u00c3\u00a1nnu borg_\u00c4\u008dak\u00c4\u008dam\u00c3\u00a1nnu \u00c4\u008dak\u00c4\u008d_golggotm\u00c3\u00a1nnu golg_sk\u00c3\u00a1bmam\u00c3\u00a1nnu sk\u00c3\u00a1b_juovlam\u00c3\u00a1nnu juov'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var i,\n            expected = 'sotnabeaivi sotn s_vuoss\u00c3\u00a1rga vuos v_ma\u00c5\u008b\u00c5\u008beb\u00c3\u00a1rga ma\u00c5\u008b m_gaskavahkku gask g_duorastat duor d_bearjadat bear b_l\u00c3\u00a1vvardat l\u00c3\u00a1v L'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'moadde sekunddat', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'okta minuhta',  '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'okta minuhta',  '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuhtat',    '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuhtat',   '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'okta diimmu',   '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'okta diimmu',   '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 diimmut',     '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 diimmut',     '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 diimmut',    '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'okta beaivi',   '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'okta beaivi',   '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 beaivvit',    '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'okta beaivi',   '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 beaivvit',    '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 beaivvit',   '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'okta m\u00c3\u00a1nnu',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'okta m\u00c3\u00a1nnu',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'okta m\u00c3\u00a1nnu',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m\u00c3\u00a1nut',       '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m\u00c3\u00a1nut',       '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m\u00c3\u00a1nut',       '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'okta m\u00c3\u00a1nnu',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m\u00c3\u00a1nut',       '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'okta jahki',    '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jagit',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'okta jahki',    '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jagit',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'moadde sekunddat gea\u00c5\u00bees',  'prefix');\n        assert.equal(moment(0).from(30000), 'ma\u00c5\u008bit moadde sekunddat', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'ma\u00c5\u008bit moadde sekunddat',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'moadde sekunddat gea\u00c5\u00bees', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 beaivvit gea\u00c5\u00bees', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'otne ti 12:00',     'Today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'otne ti 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'otne ti 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'ihttin ti 12:00',   'Tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'otne ti 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ikte ti 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [ti] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [ti] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [ti] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[ovddit] dddd [ti] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[ovddit] dddd [ti] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[ovddit] dddd [ti] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('si');\n\n    /*jshint -W100*/\n    test('parse', function (assert) {\n        var tests = '\u00e0\u00b6\u00a2\u00e0\u00b6\u00b1\u00e0\u00b7\u0080\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u0092 \u00e0\u00b6\u00a2\u00e0\u00b6\u00b1_\u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u0080\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u0092 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6_\u00e0\u00b6\u00b8\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u008a\u00e0\u00b6\u00ad\u00e0\u00b7\u0094 \u00e0\u00b6\u00b8\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u008a_\u00e0\u00b6\u0085\u00e0\u00b6\u00b4\u00e0\u00b7\u008a\u00e2\u0080\u008d\u00e0\u00b6\u00bb\u00e0\u00b7\u009a\u00e0\u00b6\u00bd\u00e0\u00b7\u008a \u00e0\u00b6\u0085\u00e0\u00b6\u00b4\u00e0\u00b7\u008a_\u00e0\u00b6\u00b8\u00e0\u00b7\u0090\u00e0\u00b6\u00ba\u00e0\u00b7\u0092 \u00e0\u00b6\u00b8\u00e0\u00b7\u0090\u00e0\u00b6\u00ba\u00e0\u00b7\u0092_\u00e0\u00b6\u00a2\u00e0\u00b7\u0096\u00e0\u00b6\u00b1\u00e0\u00b7\u0092 \u00e0\u00b6\u00a2\u00e0\u00b7\u0096\u00e0\u00b6\u00b1\u00e0\u00b7\u0092_\u00e0\u00b6\u00a2\u00e0\u00b7\u0096\u00e0\u00b6\u00bd\u00e0\u00b7\u0092 \u00e0\u00b6\u00a2\u00e0\u00b7\u0096\u00e0\u00b6\u00bd\u00e0\u00b7\u0092_\u00e0\u00b6\u0085\u00e0\u00b6\u009c\u00e0\u00b7\u009d\u00e0\u00b7\u0083\u00e0\u00b7\u008a\u00e0\u00b6\u00ad\u00e0\u00b7\u0094 \u00e0\u00b6\u0085\u00e0\u00b6\u009c\u00e0\u00b7\u009d_\u00e0\u00b7\u0083\u00e0\u00b7\u0090\u00e0\u00b6\u00b4\u00e0\u00b7\u008a\u00e0\u00b6\u00ad\u00e0\u00b7\u0090\u00e0\u00b6\u00b8\u00e0\u00b7\u008a\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u008a \u00e0\u00b7\u0083\u00e0\u00b7\u0090\u00e0\u00b6\u00b4\u00e0\u00b7\u008a_\u00e0\u00b6\u0094\u00e0\u00b6\u009a\u00e0\u00b7\u008a\u00e0\u00b6\u00ad\u00e0\u00b7\u009d\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u008a \u00e0\u00b6\u0094\u00e0\u00b6\u009a\u00e0\u00b7\u008a_\u00e0\u00b6\u00b1\u00e0\u00b7\u009c\u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b8\u00e0\u00b7\u008a\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u008a \u00e0\u00b6\u00b1\u00e0\u00b7\u009c\u00e0\u00b7\u0080\u00e0\u00b7\u0090_\u00e0\u00b6\u00af\u00e0\u00b7\u0099\u00e0\u00b7\u0083\u00e0\u00b7\u0090\u00e0\u00b6\u00b8\u00e0\u00b7\u008a\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u008a \u00e0\u00b6\u00af\u00e0\u00b7\u0099\u00e0\u00b7\u0083\u00e0\u00b7\u0090'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['YYYY MMMM Do dddd, a h:mm:ss',       '2010 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u0080\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u0092 14 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092 \u00e0\u00b6\u0089\u00e0\u00b6\u00bb\u00e0\u00b7\u0092\u00e0\u00b6\u00af\u00e0\u00b7\u008f, \u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 3:25:50'],\n                ['YYYY MMMM Do dddd, a h:mm:ss',       '2010 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u0080\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u0092 14 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092 \u00e0\u00b6\u0089\u00e0\u00b6\u00bb\u00e0\u00b7\u0092\u00e0\u00b6\u00af\u00e0\u00b7\u008f, \u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 3:25:50'],\n                ['ddd, A h',                            '\u00e0\u00b6\u0089\u00e0\u00b6\u00bb\u00e0\u00b7\u0092, \u00e0\u00b6\u00b4\u00e0\u00b7\u0083\u00e0\u00b7\u008a \u00e0\u00b7\u0080\u00e0\u00b6\u00bb\u00e0\u00b7\u0094 3'],\n                ['M Mo MM MMMM MMM',                   '2 2 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092 02 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u0080\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u0092 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092 14'],\n                ['d do dddd ddd dd',                   '0 0 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092 \u00e0\u00b6\u0089\u00e0\u00b6\u00bb\u00e0\u00b7\u0092\u00e0\u00b6\u00af\u00e0\u00b7\u008f \u00e0\u00b6\u0089\u00e0\u00b6\u00bb\u00e0\u00b7\u0092 \u00e0\u00b6\u0089'],\n                ['DDD DDDo DDDD',                      '45 45 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092 045'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. \u00e0\u00b6\u00b4\u00e0\u00b7\u0083\u00e0\u00b7\u008a \u00e0\u00b7\u0080\u00e0\u00b6\u00bb\u00e0\u00b7\u0094'],\n                ['[\u00e0\u00b7\u0080\u00e0\u00b7\u0083\u00e0\u00b6\u00bb\u00e0\u00b7\u009a] DDDo [\u00e0\u00b6\u00af\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b6\u00ba]',                      '\u00e0\u00b7\u0080\u00e0\u00b7\u0083\u00e0\u00b6\u00bb\u00e0\u00b7\u009a 45 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092 \u00e0\u00b6\u00af\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b6\u00ba'],\n                ['LTS',                                '\u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 3:25:50'],\n                ['LT',                                 '\u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 3:25'],\n                ['L',                                  '2010/02/14'],\n                ['LL',                                 '2010 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u0080\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u0092 14'],\n                ['LLL',                                '2010 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u0080\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u0092 14, \u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 3:25'],\n                ['LLLL',                               '2010 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u0080\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u0092 14 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092 \u00e0\u00b6\u0089\u00e0\u00b6\u00bb\u00e0\u00b7\u0092\u00e0\u00b6\u00af\u00e0\u00b7\u008f, \u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 3:25:50'],\n                ['l',                                  '2010/2/14'],\n                ['ll',                                 '2010 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6 14'],\n                ['lll',                                '2010 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6 14, \u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 3:25'],\n                ['llll',                               '2010 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6 14 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092 \u00e0\u00b6\u0089\u00e0\u00b6\u00bb\u00e0\u00b7\u0092, \u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 3:25:50']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '1 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '2 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '3 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '4 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '5 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '6 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '7 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '8 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '9 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '10 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '11 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '12 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '13 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '14 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '15 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '16 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '17 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '18 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '19 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '20 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '21 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '22 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '23 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '24 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '25 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '26 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '27 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '28 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '29 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '30 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092', '31 \u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b1\u00e0\u00b7\u0092');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e0\u00b6\u00a2\u00e0\u00b6\u00b1\u00e0\u00b7\u0080\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u0092 \u00e0\u00b6\u00a2\u00e0\u00b6\u00b1_\u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u0080\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u0092 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00b6_\u00e0\u00b6\u00b8\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u008a\u00e0\u00b6\u00ad\u00e0\u00b7\u0094 \u00e0\u00b6\u00b8\u00e0\u00b7\u008f\u00e0\u00b6\u00bb\u00e0\u00b7\u008a_\u00e0\u00b6\u0085\u00e0\u00b6\u00b4\u00e0\u00b7\u008a\u00e2\u0080\u008d\u00e0\u00b6\u00bb\u00e0\u00b7\u009a\u00e0\u00b6\u00bd\u00e0\u00b7\u008a \u00e0\u00b6\u0085\u00e0\u00b6\u00b4\u00e0\u00b7\u008a_\u00e0\u00b6\u00b8\u00e0\u00b7\u0090\u00e0\u00b6\u00ba\u00e0\u00b7\u0092 \u00e0\u00b6\u00b8\u00e0\u00b7\u0090\u00e0\u00b6\u00ba\u00e0\u00b7\u0092_\u00e0\u00b6\u00a2\u00e0\u00b7\u0096\u00e0\u00b6\u00b1\u00e0\u00b7\u0092 \u00e0\u00b6\u00a2\u00e0\u00b7\u0096\u00e0\u00b6\u00b1\u00e0\u00b7\u0092_\u00e0\u00b6\u00a2\u00e0\u00b7\u0096\u00e0\u00b6\u00bd\u00e0\u00b7\u0092 \u00e0\u00b6\u00a2\u00e0\u00b7\u0096\u00e0\u00b6\u00bd\u00e0\u00b7\u0092_\u00e0\u00b6\u0085\u00e0\u00b6\u009c\u00e0\u00b7\u009d\u00e0\u00b7\u0083\u00e0\u00b7\u008a\u00e0\u00b6\u00ad\u00e0\u00b7\u0094 \u00e0\u00b6\u0085\u00e0\u00b6\u009c\u00e0\u00b7\u009d_\u00e0\u00b7\u0083\u00e0\u00b7\u0090\u00e0\u00b6\u00b4\u00e0\u00b7\u008a\u00e0\u00b6\u00ad\u00e0\u00b7\u0090\u00e0\u00b6\u00b8\u00e0\u00b7\u008a\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u008a \u00e0\u00b7\u0083\u00e0\u00b7\u0090\u00e0\u00b6\u00b4\u00e0\u00b7\u008a_\u00e0\u00b6\u0094\u00e0\u00b6\u009a\u00e0\u00b7\u008a\u00e0\u00b6\u00ad\u00e0\u00b7\u009d\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u008a \u00e0\u00b6\u0094\u00e0\u00b6\u009a\u00e0\u00b7\u008a_\u00e0\u00b6\u00b1\u00e0\u00b7\u009c\u00e0\u00b7\u0080\u00e0\u00b7\u0090\u00e0\u00b6\u00b8\u00e0\u00b7\u008a\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u008a \u00e0\u00b6\u00b1\u00e0\u00b7\u009c\u00e0\u00b7\u0080\u00e0\u00b7\u0090_\u00e0\u00b6\u00af\u00e0\u00b7\u0099\u00e0\u00b7\u0083\u00e0\u00b7\u0090\u00e0\u00b6\u00b8\u00e0\u00b7\u008a\u00e0\u00b6\u00b6\u00e0\u00b6\u00bb\u00e0\u00b7\u008a \u00e0\u00b6\u00af\u00e0\u00b7\u0099\u00e0\u00b7\u0083\u00e0\u00b7\u0090'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e0\u00b6\u0089\u00e0\u00b6\u00bb\u00e0\u00b7\u0092\u00e0\u00b6\u00af\u00e0\u00b7\u008f \u00e0\u00b6\u0089\u00e0\u00b6\u00bb\u00e0\u00b7\u0092 \u00e0\u00b6\u0089_\u00e0\u00b7\u0083\u00e0\u00b6\u00b3\u00e0\u00b7\u0094\u00e0\u00b6\u00af\u00e0\u00b7\u008f \u00e0\u00b7\u0083\u00e0\u00b6\u00b3\u00e0\u00b7\u0094 \u00e0\u00b7\u0083_\u00e0\u00b6\u0085\u00e0\u00b6\u009f\u00e0\u00b7\u0084\u00e0\u00b6\u00bb\u00e0\u00b7\u0094\u00e0\u00b7\u0080\u00e0\u00b7\u008f\u00e0\u00b6\u00af\u00e0\u00b7\u008f \u00e0\u00b6\u0085\u00e0\u00b6\u009f \u00e0\u00b6\u0085_\u00e0\u00b6\u00b6\u00e0\u00b6\u00af\u00e0\u00b7\u008f\u00e0\u00b6\u00af\u00e0\u00b7\u008f \u00e0\u00b6\u00b6\u00e0\u00b6\u00af\u00e0\u00b7\u008f \u00e0\u00b6\u00b6_\u00e0\u00b6\u00b6\u00e0\u00b7\u008a\u00e2\u0080\u008d\u00e0\u00b6\u00bb\u00e0\u00b7\u0084\u00e0\u00b7\u0083\u00e0\u00b7\u008a\u00e0\u00b6\u00b4\u00e0\u00b6\u00ad\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b7\u008a\u00e0\u00b6\u00af\u00e0\u00b7\u008f \u00e0\u00b6\u00b6\u00e0\u00b7\u008a\u00e2\u0080\u008d\u00e0\u00b6\u00bb\u00e0\u00b7\u0084 \u00e0\u00b6\u00b6\u00e0\u00b7\u008a\u00e2\u0080\u008d\u00e0\u00b6\u00bb_\u00e0\u00b7\u0083\u00e0\u00b7\u0092\u00e0\u00b6\u009a\u00e0\u00b7\u0094\u00e0\u00b6\u00bb\u00e0\u00b7\u008f\u00e0\u00b6\u00af\u00e0\u00b7\u008f \u00e0\u00b7\u0083\u00e0\u00b7\u0092\u00e0\u00b6\u009a\u00e0\u00b7\u0094 \u00e0\u00b7\u0083\u00e0\u00b7\u0092_\u00e0\u00b7\u0083\u00e0\u00b7\u0099\u00e0\u00b6\u00b1\u00e0\u00b7\u0083\u00e0\u00b7\u0094\u00e0\u00b6\u00bb\u00e0\u00b7\u008f\u00e0\u00b6\u00af\u00e0\u00b7\u008f \u00e0\u00b7\u0083\u00e0\u00b7\u0099\u00e0\u00b6\u00b1 \u00e0\u00b7\u0083\u00e0\u00b7\u0099'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e0\u00b6\u00ad\u00e0\u00b6\u00ad\u00e0\u00b7\u008a\u00e0\u00b6\u00b4\u00e0\u00b6\u00bb \u00e0\u00b6\u009a\u00e0\u00b7\u0092\u00e0\u00b7\u0084\u00e0\u00b7\u0092\u00e0\u00b6\u00b4\u00e0\u00b6\u00ba', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00e0\u00b6\u00b8\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b7\u0092\u00e0\u00b6\u00ad\u00e0\u00b7\u008a\u00e0\u00b6\u00ad\u00e0\u00b7\u0094\u00e0\u00b7\u0080',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00e0\u00b6\u00b8\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b7\u0092\u00e0\u00b6\u00ad\u00e0\u00b7\u008a\u00e0\u00b6\u00ad\u00e0\u00b7\u0094\u00e0\u00b7\u0080',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '\u00e0\u00b6\u00b8\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b7\u0092\u00e0\u00b6\u00ad\u00e0\u00b7\u008a\u00e0\u00b6\u00ad\u00e0\u00b7\u0094 2',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '\u00e0\u00b6\u00b8\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b7\u0092\u00e0\u00b6\u00ad\u00e0\u00b7\u008a\u00e0\u00b6\u00ad\u00e0\u00b7\u0094 44',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00e0\u00b6\u00b4\u00e0\u00b7\u0090\u00e0\u00b6\u00ba',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00e0\u00b6\u00b4\u00e0\u00b7\u0090\u00e0\u00b6\u00ba',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00e0\u00b6\u00b4\u00e0\u00b7\u0090\u00e0\u00b6\u00ba 2',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '\u00e0\u00b6\u00b4\u00e0\u00b7\u0090\u00e0\u00b6\u00ba 5',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '\u00e0\u00b6\u00b4\u00e0\u00b7\u0090\u00e0\u00b6\u00ba 21',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00e0\u00b6\u00af\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b6\u00ba',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00e0\u00b6\u00af\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b6\u00ba',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00e0\u00b6\u00af\u00e0\u00b7\u0092\u00e0\u00b6\u00b1 2',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00e0\u00b6\u00af\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b6\u00ba',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '\u00e0\u00b6\u00af\u00e0\u00b7\u0092\u00e0\u00b6\u00b1 5',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '\u00e0\u00b6\u00af\u00e0\u00b7\u0092\u00e0\u00b6\u00b1 25',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00e0\u00b6\u00b8\u00e0\u00b7\u008f\u00e0\u00b7\u0083\u00e0\u00b6\u00ba',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00e0\u00b6\u00b8\u00e0\u00b7\u008f\u00e0\u00b7\u0083\u00e0\u00b6\u00ba',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00e0\u00b6\u00b8\u00e0\u00b7\u008f\u00e0\u00b7\u0083\u00e0\u00b6\u00ba',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '\u00e0\u00b6\u00b8\u00e0\u00b7\u008f\u00e0\u00b7\u0083 2',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '\u00e0\u00b6\u00b8\u00e0\u00b7\u008f\u00e0\u00b7\u0083 2',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '\u00e0\u00b6\u00b8\u00e0\u00b7\u008f\u00e0\u00b7\u0083 3',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00e0\u00b6\u00b8\u00e0\u00b7\u008f\u00e0\u00b7\u0083\u00e0\u00b6\u00ba',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '\u00e0\u00b6\u00b8\u00e0\u00b7\u008f\u00e0\u00b7\u0083 5',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e0\u00b7\u0080\u00e0\u00b7\u0083\u00e0\u00b6\u00bb',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00e0\u00b7\u0080\u00e0\u00b7\u0083\u00e0\u00b6\u00bb 2',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00e0\u00b7\u0080\u00e0\u00b7\u0083\u00e0\u00b6\u00bb',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '\u00e0\u00b7\u0080\u00e0\u00b7\u0083\u00e0\u00b6\u00bb 5',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e0\u00b6\u00ad\u00e0\u00b6\u00ad\u00e0\u00b7\u008a\u00e0\u00b6\u00b4\u00e0\u00b6\u00bb \u00e0\u00b6\u009a\u00e0\u00b7\u0092\u00e0\u00b7\u0084\u00e0\u00b7\u0092\u00e0\u00b6\u00b4\u00e0\u00b6\u00ba\u00e0\u00b6\u009a\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b7\u008a',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e0\u00b6\u00ad\u00e0\u00b6\u00ad\u00e0\u00b7\u008a\u00e0\u00b6\u00b4\u00e0\u00b6\u00bb \u00e0\u00b6\u009a\u00e0\u00b7\u0092\u00e0\u00b7\u0084\u00e0\u00b7\u0092\u00e0\u00b6\u00b4\u00e0\u00b6\u00ba\u00e0\u00b6\u009a\u00e0\u00b6\u00a7 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00bb', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e0\u00b6\u00ad\u00e0\u00b6\u00ad\u00e0\u00b7\u008a\u00e0\u00b6\u00b4\u00e0\u00b6\u00bb \u00e0\u00b6\u009a\u00e0\u00b7\u0092\u00e0\u00b7\u0084\u00e0\u00b7\u0092\u00e0\u00b6\u00b4\u00e0\u00b6\u00ba\u00e0\u00b6\u009a\u00e0\u00b6\u00a7 \u00e0\u00b6\u00b4\u00e0\u00b7\u0099\u00e0\u00b6\u00bb',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e0\u00b6\u00ad\u00e0\u00b6\u00ad\u00e0\u00b7\u008a\u00e0\u00b6\u00b4\u00e0\u00b6\u00bb \u00e0\u00b6\u009a\u00e0\u00b7\u0092\u00e0\u00b7\u0084\u00e0\u00b7\u0092\u00e0\u00b6\u00b4\u00e0\u00b6\u00ba\u00e0\u00b6\u009a\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b7\u008a', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00e0\u00b6\u00af\u00e0\u00b7\u0092\u00e0\u00b6\u00b1 5\u00e0\u00b6\u009a\u00e0\u00b7\u0092\u00e0\u00b6\u00b1\u00e0\u00b7\u008a', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e0\u00b6\u0085\u00e0\u00b6\u00af \u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 12:00\u00e0\u00b6\u00a7',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e0\u00b6\u0085\u00e0\u00b6\u00af \u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 12:25\u00e0\u00b6\u00a7',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00e0\u00b6\u0085\u00e0\u00b6\u00af \u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 1:00\u00e0\u00b6\u00a7',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e0\u00b7\u0084\u00e0\u00b7\u0099\u00e0\u00b6\u00a7 \u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 12:00\u00e0\u00b6\u00a7',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e0\u00b6\u0085\u00e0\u00b6\u00af \u00e0\u00b6\u00b4\u00e0\u00b7\u0099.\u00e0\u00b7\u0080. 11:00\u00e0\u00b6\u00a7',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e0\u00b6\u008a\u00e0\u00b6\u00ba\u00e0\u00b7\u009a \u00e0\u00b6\u00b4.\u00e0\u00b7\u0080. 12:00\u00e0\u00b6\u00a7',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd LT[\u00e0\u00b6\u00a7]'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd LT[\u00e0\u00b6\u00a7]'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd LT[\u00e0\u00b6\u00a7]'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00b6\u00b4\u00e0\u00b7\u0083\u00e0\u00b7\u0094\u00e0\u00b6\u009c\u00e0\u00b7\u0092\u00e0\u00b6\u00ba] dddd LT[\u00e0\u00b6\u00a7]'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00b6\u00b4\u00e0\u00b7\u0083\u00e0\u00b7\u0094\u00e0\u00b6\u009c\u00e0\u00b7\u0092\u00e0\u00b6\u00ba] dddd LT[\u00e0\u00b6\u00a7]'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00b6\u00b4\u00e0\u00b7\u0083\u00e0\u00b7\u0094\u00e0\u00b6\u009c\u00e0\u00b7\u0092\u00e0\u00b6\u00ba] dddd LT[\u00e0\u00b6\u00a7]'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('sk');\n\n    test('parse', function (assert) {\n        var tests = 'janu\u00c3\u00a1r jan._febru\u00c3\u00a1r feb._marec mar._apr\u00c3\u00adl apr._m\u00c3\u00a1j m\u00c3\u00a1j_j\u00c3\u00ban j\u00c3\u00ban._j\u00c3\u00bal j\u00c3\u00bal._august aug._september sep._okt\u00c3\u00b3ber okt._november nov._december dec.'.split('_'), i;\n        function equalTest(input, mmm, monthIndex) {\n            assert.equal(moment(input, mmm).month(), monthIndex, input + ' should be month ' + (monthIndex + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss',  'nede\u00c4\u00bea, febru\u00c3\u00a1r 14. 2010, 3:25:50'],\n                ['ddd, h',                       'ne, 3'],\n                ['M Mo MM MMMM MMM',             '2 2. 02 febru\u00c3\u00a1r feb'],\n                ['YYYY YY',                      '2010 10'],\n                ['D Do DD',                      '14 14. 14'],\n                ['d do dddd ddd dd',             '0 0. nede\u00c4\u00bea ne ne'],\n                ['DDD DDDo DDDD',                '45 45. 045'],\n                ['w wo ww',                      '6 6. 06'],\n                ['h hh',                         '3 03'],\n                ['H HH',                         '15 15'],\n                ['m mm',                         '25 25'],\n                ['s ss',                         '50 50'],\n                ['a A',                          'pm PM'],\n                ['DDDo [de\u00c5\u0088 v roku]',            '45. de\u00c5\u0088 v roku'],\n                ['LTS',                          '15:25:50'],\n                ['L',                            '14.02.2010'],\n                ['LL',                           '14. febru\u00c3\u00a1r 2010'],\n                ['LLL',                          '14. febru\u00c3\u00a1r 2010 15:25'],\n                ['LLLL',                         'nede\u00c4\u00bea 14. febru\u00c3\u00a1r 2010 15:25'],\n                ['l',                            '14.2.2010'],\n                ['ll',                           '14. feb 2010'],\n                ['lll',                          '14. feb 2010 15:25'],\n                ['llll',                         'ne 14. feb 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'janu\u00c3\u00a1r jan_febru\u00c3\u00a1r feb_marec mar_apr\u00c3\u00adl apr_m\u00c3\u00a1j m\u00c3\u00a1j_j\u00c3\u00ban j\u00c3\u00ban_j\u00c3\u00bal j\u00c3\u00bal_august aug_september sep_okt\u00c3\u00b3ber okt_november nov_december dec'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'nede\u00c4\u00bea ne ne_pondelok po po_utorok ut ut_streda st st_\u00c5\u00a1tvrtok \u00c5\u00a1t \u00c5\u00a1t_piatok pi pi_sobota so so'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'p\u00c3\u00a1r sek\u00c3\u00band',  '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'min\u00c3\u00bata',        '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'min\u00c3\u00bata',        '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 min\u00c3\u00baty',      '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 min\u00c3\u00bat',     '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'hodina',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'hodina',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hodiny',     '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hod\u00c3\u00adn',      '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hod\u00c3\u00adn',     '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'de\u00c5\u0088',       '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'de\u00c5\u0088',       '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dni',         '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'de\u00c5\u0088',       '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dn\u00c3\u00ad',         '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dn\u00c3\u00ad',        '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mesiac',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mesiac',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mesiac',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesiace',    '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesiace',    '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesiace',    '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mesiac',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesiacov',    '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'rok',           '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 roky',        '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'rok',           '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 rokov',         '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'za p\u00c3\u00a1r sek\u00c3\u00band',  'prefix');\n        assert.equal(moment(0).from(30000), 'pred p\u00c3\u00a1r sekundami', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'pred p\u00c3\u00a1r sekundami',  'now from now should display as in the past');\n    });\n\n    test('fromNow (future)', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'za p\u00c3\u00a1r sek\u00c3\u00band', 'in a few seconds');\n        assert.equal(moment().add({m: 1}).fromNow(), 'za min\u00c3\u00batu', 'in a minute');\n        assert.equal(moment().add({m: 3}).fromNow(), 'za 3 min\u00c3\u00baty', 'in 3 minutes');\n        assert.equal(moment().add({m: 10}).fromNow(), 'za 10 min\u00c3\u00bat', 'in 10 minutes');\n        assert.equal(moment().add({h: 1}).fromNow(), 'za hodinu', 'in an hour');\n        assert.equal(moment().add({h: 3}).fromNow(), 'za 3 hodiny', 'in 3 hours');\n        assert.equal(moment().add({h: 10}).fromNow(), 'za 10 hod\u00c3\u00adn', 'in 10 hours');\n        assert.equal(moment().add({d: 1}).fromNow(), 'za de\u00c5\u0088', 'in a day');\n        assert.equal(moment().add({d: 3}).fromNow(), 'za 3 dni', 'in 3 days');\n        assert.equal(moment().add({d: 10}).fromNow(), 'za 10 dn\u00c3\u00ad', 'in 10 days');\n        assert.equal(moment().add({M: 1}).fromNow(), 'za mesiac', 'in a month');\n        assert.equal(moment().add({M: 3}).fromNow(), 'za 3 mesiace', 'in 3 months');\n        assert.equal(moment().add({M: 10}).fromNow(), 'za 10 mesiacov', 'in 10 months');\n        assert.equal(moment().add({y: 1}).fromNow(), 'za rok', 'in a year');\n        assert.equal(moment().add({y: 3}).fromNow(), 'za 3 roky', 'in 3 years');\n        assert.equal(moment().add({y: 10}).fromNow(), 'za 10 rokov', 'in 10 years');\n    });\n\n    test('fromNow (past)', function (assert) {\n        assert.equal(moment().subtract({s: 30}).fromNow(), 'pred p\u00c3\u00a1r sekundami', 'a few seconds ago');\n        assert.equal(moment().subtract({m: 1}).fromNow(), 'pred min\u00c3\u00batou', 'a minute ago');\n        assert.equal(moment().subtract({m: 3}).fromNow(), 'pred 3 min\u00c3\u00batami', '3 minutes ago');\n        assert.equal(moment().subtract({m: 10}).fromNow(), 'pred 10 min\u00c3\u00batami', '10 minutes ago');\n        assert.equal(moment().subtract({h: 1}).fromNow(), 'pred hodinou', 'an hour ago');\n        assert.equal(moment().subtract({h: 3}).fromNow(), 'pred 3 hodinami', '3 hours ago');\n        assert.equal(moment().subtract({h: 10}).fromNow(), 'pred 10 hodinami', '10 hours ago');\n        assert.equal(moment().subtract({d: 1}).fromNow(), 'pred d\u00c5\u0088om', 'a day ago');\n        assert.equal(moment().subtract({d: 3}).fromNow(), 'pred 3 d\u00c5\u0088ami', '3 days ago');\n        assert.equal(moment().subtract({d: 10}).fromNow(), 'pred 10 d\u00c5\u0088ami', '10 days ago');\n        assert.equal(moment().subtract({M: 1}).fromNow(), 'pred mesiacom', 'a month ago');\n        assert.equal(moment().subtract({M: 3}).fromNow(), 'pred 3 mesiacmi', '3 months ago');\n        assert.equal(moment().subtract({M: 10}).fromNow(), 'pred 10 mesiacmi', '10 months ago');\n        assert.equal(moment().subtract({y: 1}).fromNow(), 'pred rokom', 'a year ago');\n        assert.equal(moment().subtract({y: 3}).fromNow(), 'pred 3 rokmi', '3 years ago');\n        assert.equal(moment().subtract({y: 10}).fromNow(), 'pred 10 rokmi', '10 years ago');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'dnes o 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'dnes o 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'dnes o 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'zajtra o 12:00',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'dnes o 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'v\u00c4\u008dera o 12:00',    'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m, nextDay;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            nextDay = '';\n            switch (m.day()) {\n            case 0:\n                nextDay = 'v nede\u00c4\u00beu';\n                break;\n            case 1:\n                nextDay = 'v pondelok';\n                break;\n            case 2:\n                nextDay = 'v utorok';\n                break;\n            case 3:\n                nextDay = 'v stredu';\n                break;\n            case 4:\n                nextDay = 'vo \u00c5\u00a1tvrtok';\n                break;\n            case 5:\n                nextDay = 'v piatok';\n                break;\n            case 6:\n                nextDay = 'v sobotu';\n                break;\n            }\n            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [o] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [o] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [o] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m, lastDay;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            lastDay = '';\n            switch (m.day()) {\n            case 0:\n                lastDay = 'minul\u00c3\u00ba nede\u00c4\u00beu';\n                break;\n            case 1:\n                lastDay = 'minul\u00c3\u00bd pondelok';\n                break;\n            case 2:\n                lastDay = 'minul\u00c3\u00bd utorok';\n                break;\n            case 3:\n                lastDay = 'minul\u00c3\u00ba stredu';\n                break;\n            case 4:\n                lastDay = 'minul\u00c3\u00bd \u00c5\u00a1tvrtok';\n                break;\n            case 5:\n                lastDay = 'minul\u00c3\u00bd piatok';\n                break;\n            case 6:\n                lastDay = 'minul\u00c3\u00ba sobotu';\n                break;\n            }\n            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [o] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [o] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [o] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('humanize duration', function (assert) {\n        assert.equal(moment.duration(1, 'minutes').humanize(), 'min\u00c3\u00bata', 'a minute (future)');\n        assert.equal(moment.duration(1, 'minutes').humanize(true), 'za min\u00c3\u00batu', 'in a minute');\n        assert.equal(moment.duration(-1, 'minutes').humanize(), 'min\u00c3\u00bata', 'a minute (past)');\n        assert.equal(moment.duration(-1, 'minutes').humanize(true), 'pred min\u00c3\u00batou', 'a minute ago');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('sl');\n\n    test('parse', function (assert) {\n        var tests = 'januar jan._februar feb._marec mar._april apr._maj maj_junij jun._julij jul._avgust avg._september sep._oktober okt._november nov._december dec.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedelja, 14. februar 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'ned., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. nedelja ned. ne'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '7 7. 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14. 02. 2010'],\n                ['LL',                                 '14. februar 2010'],\n                ['LLL',                                '14. februar 2010 15:25'],\n                ['LLLL',                               'nedelja, 14. februar 2010 15:25'],\n                ['l',                                  '14. 2. 2010'],\n                ['ll',                                 '14. feb. 2010'],\n                ['lll',                                '14. feb. 2010 15:25'],\n                ['llll',                               'ned., 14. feb. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'januar jan._februar feb._marec mar._april apr._maj maj._junij jun._julij jul._avgust avg._september sep._oktober okt._november nov._december dec.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'nedelja ned. ne_ponedeljek pon. po_torek tor. to_sreda sre. sr_\u00c4\u008detrtek \u00c4\u008det. \u00c4\u008de_petek pet. pe_sobota sob. so'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nekaj sekund', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ena minuta',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ena minuta',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuti',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minut',     '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ena ura',      '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ena ura',      '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 uri',        '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ur',         '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ur',        '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dan',       '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dan',       '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dni',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dan',       '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dni',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dni',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en mesec',     '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en mesec',     '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en mesec',     '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meseca',     '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meseca',     '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesece',     '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en mesec',     '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesecev',    '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'eno leto',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 leti',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'eno leto',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 let',        '5 years = 5 years');\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 1}), true),  'ena minuta', 'a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 2}), true),  '2 minuti',   '2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 3}), true),  '3 minute',   '3 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 4}), true),  '4 minute',   '4 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 5}), true),  '5 minut',    '5 minutes');\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 1}), true),  'ena ura', 'an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 2}), true),  '2 uri',   '2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 3}), true),  '3 ure',   '3 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 4}), true),  '4 ure',   '4 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),  '5 ur',    '5 hours');\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),  'en dan', 'a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 2}), true),  '2 dni',  '2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 3}), true),  '3 dni',  '3 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 4}), true),  '4 dni',  '4 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),  '5 dni',  '5 days');\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),  'en mesec',  'a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 2}), true),  '2 meseca',  '2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 3}), true),  '3 mesece',  '3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 4}), true),  '4 mesece',  '4 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),  '5 mesecev', '5 months');\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),  'eno leto', 'a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 2}), true),  '2 leti',   '2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 3}), true),  '3 leta',   '3 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 4}), true),  '4 leta',   '4 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),  '5 let',    '5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00c4\u008dez nekaj sekund',  'prefix');\n        assert.equal(moment(0).from(30000), 'pred nekaj sekundami', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'pred nekaj sekundami',  'now from now should display as in the past');\n    });\n\n    test('fromNow (future)', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00c4\u008dez nekaj sekund', 'in a few seconds');\n        assert.equal(moment().add({m: 1}).fromNow(),  '\u00c4\u008dez eno minuto', 'in a minute');\n        assert.equal(moment().add({m: 2}).fromNow(),  '\u00c4\u008dez 2 minuti',   'in 2 minutes');\n        assert.equal(moment().add({m: 3}).fromNow(),  '\u00c4\u008dez 3 minute',   'in 3 minutes');\n        assert.equal(moment().add({m: 4}).fromNow(),  '\u00c4\u008dez 4 minute',   'in 4 minutes');\n        assert.equal(moment().add({m: 5}).fromNow(),  '\u00c4\u008dez 5 minut',    'in 5 minutes');\n\n        assert.equal(moment().add({h: 1}).fromNow(),  '\u00c4\u008dez eno uro', 'in an hour');\n        assert.equal(moment().add({h: 2}).fromNow(),  '\u00c4\u008dez 2 uri',   'in 2 hours');\n        assert.equal(moment().add({h: 3}).fromNow(),  '\u00c4\u008dez 3 ure',   'in 3 hours');\n        assert.equal(moment().add({h: 4}).fromNow(),  '\u00c4\u008dez 4 ure',   'in 4 hours');\n        assert.equal(moment().add({h: 5}).fromNow(),  '\u00c4\u008dez 5 ur',    'in 5 hours');\n\n        assert.equal(moment().add({d: 1}).fromNow(),  '\u00c4\u008dez en dan', 'in a day');\n        assert.equal(moment().add({d: 2}).fromNow(),  '\u00c4\u008dez 2 dni',  'in 2 days');\n        assert.equal(moment().add({d: 3}).fromNow(),  '\u00c4\u008dez 3 dni',  'in 3 days');\n        assert.equal(moment().add({d: 4}).fromNow(),  '\u00c4\u008dez 4 dni',  'in 4 days');\n        assert.equal(moment().add({d: 5}).fromNow(),  '\u00c4\u008dez 5 dni',  'in 5 days');\n\n        assert.equal(moment().add({M: 1}).fromNow(),  '\u00c4\u008dez en mesec',  'in a month');\n        assert.equal(moment().add({M: 2}).fromNow(),  '\u00c4\u008dez 2 meseca',  'in 2 months');\n        assert.equal(moment().add({M: 3}).fromNow(),  '\u00c4\u008dez 3 mesece',  'in 3 months');\n        assert.equal(moment().add({M: 4}).fromNow(),  '\u00c4\u008dez 4 mesece',  'in 4 months');\n        assert.equal(moment().add({M: 5}).fromNow(),  '\u00c4\u008dez 5 mesecev', 'in 5 months');\n\n        assert.equal(moment().add({y: 1}).fromNow(),  '\u00c4\u008dez eno leto', 'in a year');\n        assert.equal(moment().add({y: 2}).fromNow(),  '\u00c4\u008dez 2 leti',   'in 2 years');\n        assert.equal(moment().add({y: 3}).fromNow(),  '\u00c4\u008dez 3 leta',   'in 3 years');\n        assert.equal(moment().add({y: 4}).fromNow(),  '\u00c4\u008dez 4 leta',   'in 4 years');\n        assert.equal(moment().add({y: 5}).fromNow(),  '\u00c4\u008dez 5 let',    'in 5 years');\n\n        assert.equal(moment().subtract({s: 30}).fromNow(), 'pred nekaj sekundami', 'a few seconds ago');\n\n        assert.equal(moment().subtract({m: 1}).fromNow(),  'pred eno minuto', 'a minute ago');\n        assert.equal(moment().subtract({m: 2}).fromNow(),  'pred 2 minutama', '2 minutes ago');\n        assert.equal(moment().subtract({m: 3}).fromNow(),  'pred 3 minutami', '3 minutes ago');\n        assert.equal(moment().subtract({m: 4}).fromNow(),  'pred 4 minutami', '4 minutes ago');\n        assert.equal(moment().subtract({m: 5}).fromNow(),  'pred 5 minutami', '5 minutes ago');\n\n        assert.equal(moment().subtract({h: 1}).fromNow(),  'pred eno uro', 'an hour ago');\n        assert.equal(moment().subtract({h: 2}).fromNow(),  'pred 2 urama', '2 hours ago');\n        assert.equal(moment().subtract({h: 3}).fromNow(),  'pred 3 urami', '3 hours ago');\n        assert.equal(moment().subtract({h: 4}).fromNow(),  'pred 4 urami', '4 hours ago');\n        assert.equal(moment().subtract({h: 5}).fromNow(),  'pred 5 urami', '5 hours ago');\n\n        assert.equal(moment().subtract({d: 1}).fromNow(),  'pred enim dnem', 'a day ago');\n        assert.equal(moment().subtract({d: 2}).fromNow(),  'pred 2 dnevoma', '2 days ago');\n        assert.equal(moment().subtract({d: 3}).fromNow(),  'pred 3 dnevi',   '3 days ago');\n        assert.equal(moment().subtract({d: 4}).fromNow(),  'pred 4 dnevi',   '4 days ago');\n        assert.equal(moment().subtract({d: 5}).fromNow(),  'pred 5 dnevi',   '5 days ago');\n\n        assert.equal(moment().subtract({M: 1}).fromNow(),  'pred enim mesecem', 'a month ago');\n        assert.equal(moment().subtract({M: 2}).fromNow(),  'pred 2 mesecema',   '2 months ago');\n        assert.equal(moment().subtract({M: 3}).fromNow(),  'pred 3 meseci',     '3 months ago');\n        assert.equal(moment().subtract({M: 4}).fromNow(),  'pred 4 meseci',     '4 months ago');\n        assert.equal(moment().subtract({M: 5}).fromNow(),  'pred 5 meseci',     '5 months ago');\n\n        assert.equal(moment().subtract({y: 1}).fromNow(),  'pred enim letom', 'a year ago');\n        assert.equal(moment().subtract({y: 2}).fromNow(),  'pred 2 letoma',   '2 years ago');\n        assert.equal(moment().subtract({y: 3}).fromNow(),  'pred 3 leti',     '3 years ago');\n        assert.equal(moment().subtract({y: 4}).fromNow(),  'pred 4 leti',     '4 years ago');\n        assert.equal(moment().subtract({y: 5}).fromNow(),  'pred 5 leti',     '5 years ago');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'danes ob 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'danes ob 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'danes ob 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'jutri ob 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danes ob 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'v\u00c4\u008deraj ob 12:00', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n                return '[v] [nedeljo] [ob] LT';\n            case 3:\n                return '[v] [sredo] [ob] LT';\n            case 6:\n                return '[v] [soboto] [ob] LT';\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n                return '[v] dddd [ob] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n                return '[prej\u00c5\u00a1njo] [nedeljo] [ob] LT';\n            case 3:\n                return '[prej\u00c5\u00a1njo] [sredo] [ob] LT';\n            case 6:\n                return '[prej\u00c5\u00a1njo] [soboto] [ob] LT';\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n                return '[prej\u00c5\u00a1nji] dddd [ob] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('sq');\n\n    test('parse', function (assert) {\n        var i,\n            tests = 'Janar Jan_Shkurt Shk_Mars Mar_Prill Pri_Maj Maj_Qershor Qer_Korrik Kor_Gusht Gus_Shtator Sht_Tetor Tet_N\u00c3\u00abntor N\u00c3\u00abn_Dhjetor Dhj'.split('_');\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, HH:mm:ss',       'E Diel, Shkurt 14. 2010, 15:25:50'],\n                ['ddd, HH',                            'Die, 15'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 Shkurt Shk'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. E Diel Die D'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'MD MD'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 Shkurt 2010'],\n                ['LLL',                                '14 Shkurt 2010 15:25'],\n                ['LLLL',                               'E Diel, 14 Shkurt 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Shk 2010'],\n                ['lll',                                '14 Shk 2010 15:25'],\n                ['llll',                               'Die, 14 Shk 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('meridiem', function (assert) {\n        assert.equal(moment([2011, 2, 23,  0, 0]).format('A'), 'PD', 'before dawn');\n        assert.equal(moment([2011, 2, 23, 12, 0]).format('A'), 'MD', 'noon');\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var i,\n            expected = 'Janar Jan_Shkurt Shk_Mars Mar_Prill Pri_Maj Maj_Qershor Qer_Korrik Kor_Gusht Gus_Shtator Sht_Tetor Tet_N\u00c3\u00abntor N\u00c3\u00abn_Dhjetor Dhj'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var i,\n            expected = 'E Diel Die D_E H\u00c3\u00abn\u00c3\u00ab H\u00c3\u00abn H_E Mart\u00c3\u00ab Mar Ma_E M\u00c3\u00abrkur\u00c3\u00ab M\u00c3\u00abr M\u00c3\u00ab_E Enjte Enj E_E Premte Pre P_E Shtun\u00c3\u00ab Sht Sh'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'disa sekonda', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'nj\u00c3\u00ab minut\u00c3\u00ab',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'nj\u00c3\u00ab minut\u00c3\u00ab',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuta',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'nj\u00c3\u00ab or\u00c3\u00ab',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'nj\u00c3\u00ab or\u00c3\u00ab',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 or\u00c3\u00ab',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 or\u00c3\u00ab',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 or\u00c3\u00ab',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'nj\u00c3\u00ab dit\u00c3\u00ab',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'nj\u00c3\u00ab dit\u00c3\u00ab',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dit\u00c3\u00ab',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'nj\u00c3\u00ab dit\u00c3\u00ab',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dit\u00c3\u00ab',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dit\u00c3\u00ab',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'nj\u00c3\u00ab muaj',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'nj\u00c3\u00ab muaj',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'nj\u00c3\u00ab muaj',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 muaj',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 muaj',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 muaj',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'nj\u00c3\u00ab muaj',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 muaj',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'nj\u00c3\u00ab vit',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 vite',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'nj\u00c3\u00ab vit',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 vite',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'n\u00c3\u00ab disa sekonda',  'prefix');\n        assert.equal(moment(0).from(30000), 'disa sekonda m\u00c3\u00ab par\u00c3\u00ab', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'disa sekonda m\u00c3\u00ab par\u00c3\u00ab',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'n\u00c3\u00ab disa sekonda', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'n\u00c3\u00ab 5 dit\u00c3\u00ab', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Sot n\u00c3\u00ab 12:00',   'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Sot n\u00c3\u00ab 12:25',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Sot n\u00c3\u00ab 13:00',   'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Nes\u00c3\u00abr n\u00c3\u00ab 12:00', 'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Sot n\u00c3\u00ab 11:00',   'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Dje n\u00c3\u00ab 12:00',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [n\u00c3\u00ab] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [n\u00c3\u00ab] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [n\u00c3\u00ab] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [e kaluar n\u00c3\u00ab] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [e kaluar n\u00c3\u00ab] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [e kaluar n\u00c3\u00ab] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('sr-cyrl');\n\n    test('parse', function (assert) {\n        var tests = '\u00d1\u0098\u00d0\u00b0\u00d0\u00bd\u00d1\u0083\u00d0\u00b0\u00d1\u0080 \u00d1\u0098\u00d0\u00b0\u00d0\u00bd._\u00d1\u0084\u00d0\u00b5\u00d0\u00b1\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080 \u00d1\u0084\u00d0\u00b5\u00d0\u00b1._\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080._\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b8\u00d0\u00bb \u00d0\u00b0\u00d0\u00bf\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d1\u0098 \u00d0\u00bc\u00d0\u00b0\u00d1\u0098_\u00d1\u0098\u00d1\u0083\u00d0\u00bd \u00d1\u0098\u00d1\u0083\u00d0\u00bd_\u00d1\u0098\u00d1\u0083\u00d0\u00bb \u00d1\u0098\u00d1\u0083\u00d0\u00bb_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3._\u00d1\u0081\u00d0\u00b5\u00d0\u00bf\u00d1\u0082\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b0\u00d1\u0080 \u00d1\u0081\u00d0\u00b5\u00d0\u00bf._\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d0\u00be\u00d0\u00b1\u00d0\u00b0\u00d1\u0080 \u00d0\u00be\u00d0\u00ba\u00d1\u0082._\u00d0\u00bd\u00d0\u00be\u00d0\u00b2\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b0\u00d1\u0080 \u00d0\u00bd\u00d0\u00be\u00d0\u00b2._\u00d0\u00b4\u00d0\u00b5\u00d1\u0086\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b0\u00d1\u0080 \u00d0\u00b4\u00d0\u00b5\u00d1\u0086.'.split('_'),\n            i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a',      '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d1\u0099\u00d0\u00b0, 14. \u00d1\u0084\u00d0\u00b5\u00d0\u00b1\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080 2010, 3:25:50 pm'],\n                ['ddd, hA',                            '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 \u00d1\u0084\u00d0\u00b5\u00d0\u00b1\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080 \u00d1\u0084\u00d0\u00b5\u00d0\u00b1.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. \u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d1\u0099\u00d0\u00b0 \u00d0\u00bd\u00d0\u00b5\u00d0\u00b4. \u00d0\u00bd\u00d0\u00b5'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '7 7. 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14. 02. 2010'],\n                ['LL',                                 '14. \u00d1\u0084\u00d0\u00b5\u00d0\u00b1\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080 2010'],\n                ['LLL',                                '14. \u00d1\u0084\u00d0\u00b5\u00d0\u00b1\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080 2010 15:25'],\n                ['LLLL',                               '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d1\u0099\u00d0\u00b0, 14. \u00d1\u0084\u00d0\u00b5\u00d0\u00b1\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080 2010 15:25'],\n                ['l',                                  '14. 2. 2010'],\n                ['ll',                                 '14. \u00d1\u0084\u00d0\u00b5\u00d0\u00b1. 2010'],\n                ['lll',                                '14. \u00d1\u0084\u00d0\u00b5\u00d0\u00b1. 2010 15:25'],\n                ['llll',                               '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4., 14. \u00d1\u0084\u00d0\u00b5\u00d0\u00b1. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d1\u0098\u00d0\u00b0\u00d0\u00bd\u00d1\u0083\u00d0\u00b0\u00d1\u0080 \u00d1\u0098\u00d0\u00b0\u00d0\u00bd._\u00d1\u0084\u00d0\u00b5\u00d0\u00b1\u00d1\u0080\u00d1\u0083\u00d0\u00b0\u00d1\u0080 \u00d1\u0084\u00d0\u00b5\u00d0\u00b1._\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080._\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b8\u00d0\u00bb \u00d0\u00b0\u00d0\u00bf\u00d1\u0080._\u00d0\u00bc\u00d0\u00b0\u00d1\u0098 \u00d0\u00bc\u00d0\u00b0\u00d1\u0098_\u00d1\u0098\u00d1\u0083\u00d0\u00bd \u00d1\u0098\u00d1\u0083\u00d0\u00bd_\u00d1\u0098\u00d1\u0083\u00d0\u00bb \u00d1\u0098\u00d1\u0083\u00d0\u00bb_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3._\u00d1\u0081\u00d0\u00b5\u00d0\u00bf\u00d1\u0082\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b0\u00d1\u0080 \u00d1\u0081\u00d0\u00b5\u00d0\u00bf._\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d0\u00be\u00d0\u00b1\u00d0\u00b0\u00d1\u0080 \u00d0\u00be\u00d0\u00ba\u00d1\u0082._\u00d0\u00bd\u00d0\u00be\u00d0\u00b2\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b0\u00d1\u0080 \u00d0\u00bd\u00d0\u00be\u00d0\u00b2._\u00d0\u00b4\u00d0\u00b5\u00d1\u0086\u00d0\u00b5\u00d0\u00bc\u00d0\u00b1\u00d0\u00b0\u00d1\u0080 \u00d0\u00b4\u00d0\u00b5\u00d1\u0086.'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d1\u0099\u00d0\u00b0 \u00d0\u00bd\u00d0\u00b5\u00d0\u00b4. \u00d0\u00bd\u00d0\u00b5_\u00d0\u00bf\u00d0\u00be\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d1\u0099\u00d0\u00b0\u00d0\u00ba \u00d0\u00bf\u00d0\u00be\u00d0\u00bd. \u00d0\u00bf\u00d0\u00be_\u00d1\u0083\u00d1\u0082\u00d0\u00be\u00d1\u0080\u00d0\u00b0\u00d0\u00ba \u00d1\u0083\u00d1\u0082\u00d0\u00be. \u00d1\u0083\u00d1\u0082_\u00d1\u0081\u00d1\u0080\u00d0\u00b5\u00d0\u00b4\u00d0\u00b0 \u00d1\u0081\u00d1\u0080\u00d0\u00b5. \u00d1\u0081\u00d1\u0080_\u00d1\u0087\u00d0\u00b5\u00d1\u0082\u00d0\u00b2\u00d1\u0080\u00d1\u0082\u00d0\u00b0\u00d0\u00ba \u00d1\u0087\u00d0\u00b5\u00d1\u0082. \u00d1\u0087\u00d0\u00b5_\u00d0\u00bf\u00d0\u00b5\u00d1\u0082\u00d0\u00b0\u00d0\u00ba \u00d0\u00bf\u00d0\u00b5\u00d1\u0082. \u00d0\u00bf\u00d0\u00b5_\u00d1\u0081\u00d1\u0083\u00d0\u00b1\u00d0\u00be\u00d1\u0082\u00d0\u00b0 \u00d1\u0081\u00d1\u0083\u00d0\u00b1. \u00d1\u0081\u00d1\u0083'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00b8\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d1\u0098\u00d0\u00b5\u00d0\u00b4\u00d0\u00b0\u00d0\u00bd \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d1\u0098\u00d0\u00b5\u00d0\u00b4\u00d0\u00b0\u00d0\u00bd \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b5',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082\u00d0\u00b0',     '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d1\u0098\u00d0\u00b5\u00d0\u00b4\u00d0\u00b0\u00d0\u00bd \u00d1\u0081\u00d0\u00b0\u00d1\u0082',      '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d1\u0098\u00d0\u00b5\u00d0\u00b4\u00d0\u00b0\u00d0\u00bd \u00d1\u0081\u00d0\u00b0\u00d1\u0082',      '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00d1\u0081\u00d0\u00b0\u00d1\u0082\u00d0\u00b0',        '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d1\u0081\u00d0\u00b0\u00d1\u0082\u00d0\u00b8',         '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d1\u0081\u00d0\u00b0\u00d1\u0082\u00d0\u00b8',        '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d0\u00b4\u00d0\u00b0\u00d0\u00bd',       '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d0\u00b4\u00d0\u00b0\u00d0\u00bd',       '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00d0\u00b4\u00d0\u00b0\u00d0\u00bd\u00d0\u00b0',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d0\u00b4\u00d0\u00b0\u00d0\u00bd',       '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d0\u00b4\u00d0\u00b0\u00d0\u00bd\u00d0\u00b0',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d0\u00b4\u00d0\u00b0\u00d0\u00bd\u00d0\u00b0',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086',     '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086',     '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086',     '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086\u00d0\u00b0',     '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086\u00d0\u00b0',     '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086\u00d0\u00b0',     '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086',     '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d0\u00bc\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d1\u0086\u00d0\u00b8',    '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d1\u0083',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d0\u00b5',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d1\u0083',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d0\u00b0',        '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d0\u00b7\u00d0\u00b0 \u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00b8\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00d0\u00bf\u00d1\u0080\u00d0\u00b5 \u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00b8\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8', 'prefix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00d0\u00bf\u00d1\u0080\u00d0\u00b5 \u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00b8\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d0\u00b7\u00d0\u00b0 \u00d0\u00bd\u00d0\u00b5\u00d0\u00ba\u00d0\u00be\u00d0\u00bb\u00d0\u00b8\u00d0\u00ba\u00d0\u00be \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4\u00d0\u00b8', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00d0\u00b7\u00d0\u00b0 5 \u00d0\u00b4\u00d0\u00b0\u00d0\u00bd\u00d0\u00b0', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d0\u00b4\u00d0\u00b0\u00d0\u00bd\u00d0\u00b0\u00d1\u0081 \u00d1\u0083 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d0\u00b4\u00d0\u00b0\u00d0\u00bd\u00d0\u00b0\u00d1\u0081 \u00d1\u0083 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d0\u00b4\u00d0\u00b0\u00d0\u00bd\u00d0\u00b0\u00d1\u0081 \u00d1\u0083 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d1\u0081\u00d1\u0083\u00d1\u0082\u00d1\u0080\u00d0\u00b0 \u00d1\u0083 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d0\u00b4\u00d0\u00b0\u00d0\u00bd\u00d0\u00b0\u00d1\u0081 \u00d1\u0083 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d1\u0098\u00d1\u0083\u00d1\u0087\u00d0\u00b5 \u00d1\u0083 12:00',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n                return '[\u00d1\u0083] [\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d1\u0099\u00d1\u0083] [\u00d1\u0083] LT';\n            case 3:\n                return '[\u00d1\u0083] [\u00d1\u0081\u00d1\u0080\u00d0\u00b5\u00d0\u00b4\u00d1\u0083] [\u00d1\u0083] LT';\n            case 6:\n                return '[\u00d1\u0083] [\u00d1\u0081\u00d1\u0083\u00d0\u00b1\u00d0\u00be\u00d1\u0082\u00d1\u0083] [\u00d1\u0083] LT';\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n                return '[\u00d1\u0083] dddd [\u00d1\u0083] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            var lastWeekDay = [\n                    '[\u00d0\u00bf\u00d1\u0080\u00d0\u00be\u00d1\u0088\u00d0\u00bb\u00d0\u00b5] [\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d1\u0099\u00d0\u00b5] [\u00d1\u0083] LT',\n                    '[\u00d0\u00bf\u00d1\u0080\u00d0\u00be\u00d1\u0088\u00d0\u00bb\u00d0\u00be\u00d0\u00b3] [\u00d0\u00bf\u00d0\u00be\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5\u00d1\u0099\u00d0\u00ba\u00d0\u00b0] [\u00d1\u0083] LT',\n                    '[\u00d0\u00bf\u00d1\u0080\u00d0\u00be\u00d1\u0088\u00d0\u00bb\u00d0\u00be\u00d0\u00b3] [\u00d1\u0083\u00d1\u0082\u00d0\u00be\u00d1\u0080\u00d0\u00ba\u00d0\u00b0] [\u00d1\u0083] LT',\n                    '[\u00d0\u00bf\u00d1\u0080\u00d0\u00be\u00d1\u0088\u00d0\u00bb\u00d0\u00b5] [\u00d1\u0081\u00d1\u0080\u00d0\u00b5\u00d0\u00b4\u00d0\u00b5] [\u00d1\u0083] LT',\n                    '[\u00d0\u00bf\u00d1\u0080\u00d0\u00be\u00d1\u0088\u00d0\u00bb\u00d0\u00be\u00d0\u00b3] [\u00d1\u0087\u00d0\u00b5\u00d1\u0082\u00d0\u00b2\u00d1\u0080\u00d1\u0082\u00d0\u00ba\u00d0\u00b0] [\u00d1\u0083] LT',\n                    '[\u00d0\u00bf\u00d1\u0080\u00d0\u00be\u00d1\u0088\u00d0\u00bb\u00d0\u00be\u00d0\u00b3] [\u00d0\u00bf\u00d0\u00b5\u00d1\u0082\u00d0\u00ba\u00d0\u00b0] [\u00d1\u0083] LT',\n                    '[\u00d0\u00bf\u00d1\u0080\u00d0\u00be\u00d1\u0088\u00d0\u00bb\u00d0\u00b5] [\u00d1\u0081\u00d1\u0083\u00d0\u00b1\u00d0\u00be\u00d1\u0082\u00d0\u00b5] [\u00d1\u0083] LT'\n                ];\n\n            return lastWeekDay[d.day()];\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('sr');\n\n    test('parse', function (assert) {\n        var tests = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),\n            i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedelja, 14. februar 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'ned., 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. nedelja ned. ne'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '7 7. 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14. 02. 2010'],\n                ['LL',                                 '14. februar 2010'],\n                ['LLL',                                '14. februar 2010 15:25'],\n                ['LLLL',                               'nedelja, 14. februar 2010 15:25'],\n                ['l',                                  '14. 2. 2010'],\n                ['ll',                                 '14. feb. 2010'],\n                ['lll',                                '14. feb. 2010 15:25'],\n                ['llll',                               'ned., 14. feb. 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'nedelja ned. ne_ponedeljak pon. po_utorak uto. ut_sreda sre. sr_\u00c4\u008detvrtak \u00c4\u008det. \u00c4\u008de_petak pet. pe_subota sub. su'.split('_'),\n            i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nekoliko sekundi', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedan minut',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedan minut',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mesec',     '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mesec',     '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mesec',     '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meseca',     '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meseca',     '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meseca',     '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mesec',     '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meseci',    '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'za nekoliko sekundi',  'prefix');\n        assert.equal(moment(0).from(30000), 'pre nekoliko sekundi', 'prefix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'pre nekoliko sekundi',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'za nekoliko sekundi', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'danas u 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'sutra u 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ju\u00c4\u008de u 12:00',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n                return '[u] [nedelju] [u] LT';\n            case 3:\n                return '[u] [sredu] [u] LT';\n            case 6:\n                return '[u] [subotu] [u] LT';\n            case 1:\n            case 2:\n            case 4:\n            case 5:\n                return '[u] dddd [u] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            var lastWeekDay = [\n                    '[pro\u00c5\u00a1le] [nedelje] [u] LT',\n                    '[pro\u00c5\u00a1log] [ponedeljka] [u] LT',\n                    '[pro\u00c5\u00a1log] [utorka] [u] LT',\n                    '[pro\u00c5\u00a1le] [srede] [u] LT',\n                    '[pro\u00c5\u00a1log] [\u00c4\u008detvrtka] [u] LT',\n                    '[pro\u00c5\u00a1log] [petka] [u] LT',\n                    '[pro\u00c5\u00a1le] [subote] [u] LT'\n                ];\n\n            return lastWeekDay[d.day()];\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ss');\n\n    test('parse', function (assert) {\n        var tests = \"Bhimbidvwane Bhi_Indlovana Ina_Indlov'lenkhulu Inu_Mabasa Mab_Inkhwekhweti Ink_Inhlaba Inh_Kholwane Kho_Ingci Igc_Inyoni Iny_Imphala Imp_Lweti lwe_Ingongoni Igo\".split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('parse meridiem', function (assert) {\n        var i,\n            b = moment(),\n            meridiemTests = [\n                // h a patterns, expected hours, isValid\n                ['10 ekuseni',   10, true],\n                ['11 emini',   11, true],\n                ['3 entsambama',   15, true],\n                ['4 entsambama',   16, true],\n                ['6 entsambama',   18, true],\n                ['7 ebusuku',   19, true],\n                ['12 ebusuku',   0, true],\n                ['10 am',   10, false],\n                ['10 pm',   10, false]\n            ],\n            parsed;\n\n        // test that a formatted moment including meridiem string can be parsed back to the same moment\n        assert.ok(b.isSame(moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'ss', true), 'seconds'), b.format('h:mm:ss a') + ' should be equal to ' + moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'ss', true).format('h:mm:ss a'));\n\n        // test that a formatted moment having a meridiem string can be parsed with strict flag\n        assert.ok(moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'ss', true).isValid(), b.format('h:mm:ss a') + ' should be parsed as valid');\n\n        for (i = 0; i < meridiemTests.length; i++) {\n            parsed = moment(meridiemTests[i][0], 'h a', 'ss', true);\n            assert.equal(parsed.isValid(), meridiemTests[i][2], 'validity for ' + meridiemTests[i][0]);\n            if (parsed.isValid()) {\n                assert.equal(parsed.hours(), meridiemTests[i][1], 'hours for ' + meridiemTests[i][0]);\n            }\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Lisontfo, Indlovana 14 2010, 3:25:50 entsambama'],\n                ['ddd, h A',                            'Lis, 3 entsambama'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 Indlovana Ina'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 Lisontfo Lis Li'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '6 6 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'entsambama entsambama'],\n                ['[Lilanga] DDDo [lilanga lelinyaka]', 'Lilanga 45 lilanga lelinyaka'],\n                ['LTS',                                '3:25:50 entsambama'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 Indlovana 2010'],\n                ['LLL',                                '14 Indlovana 2010 3:25 entsambama'],\n                ['LLLL',                               'Lisontfo, 14 Indlovana 2010 3:25 entsambama'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Ina 2010'],\n                ['lll',                                '14 Ina 2010 3:25 entsambama'],\n                ['llll',                               'Lis, 14 Ina 2010 3:25 entsambama']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = \"Bhimbidvwane Bhi_Indlovana Ina_Indlov'lenkhulu Inu_Mabasa Mab_Inkhwekhweti Ink_Inhlaba Inh_Kholwane Kho_Ingci Igc_Inyoni Iny_Imphala Imp_Lweti Lwe_Ingongoni Igo\".split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Lisontfo Lis Li_Umsombuluko Umb Us_Lesibili Lsb Lb_Lesitsatfu Les Lt_Lesine Lsi Ls_Lesihlanu Lsh Lh_Umgcibelo Umg Ug'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'emizuzwana lomcane', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'umzuzu',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'umzuzu',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 emizuzu',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 emizuzu',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'lihora',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'lihora',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 emahora',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 emahora',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 emahora',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'lilanga',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'lilanga',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 emalanga',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'lilanga',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 emalanga',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 emalanga',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'inyanga',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'inyanga',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'inyanga',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 tinyanga',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 tinyanga',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 tinyanga',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'inyanga',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 tinyanga',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'umnyaka',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 iminyaka',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'umnyaka',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 iminyaka',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'nga emizuzwana lomcane',  'prefix');\n        assert.equal(moment(0).from(30000), 'wenteka nga emizuzwana lomcane', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'wenteka nga emizuzwana lomcane',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'nga emizuzwana lomcane', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'nga 5 emalanga', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Namuhla nga 12:00 emini',      'Today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Namuhla nga 12:25 emini',      'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Namuhla nga 1:00 emini',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Kusasa nga 12:00 emini',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Namuhla nga 11:00 emini',      'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Itolo nga 12:00 emini',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [nga] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [nga] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [nga] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [leliphelile] [nga] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [leliphelile] [nga] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [leliphelile] [nga] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1', 'Jan  4 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('sv');\n\n    test('parse', function (assert) {\n        var tests = 'januari jan_februari feb_mars mar_april apr_maj maj_juni jun_juli jul_augusti aug_september sep_oktober okt_november nov_december dec'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      's\u00c3\u00b6ndag, februari 14e 2010, 3:25:50 pm'],\n                ['ddd, hA',                            's\u00c3\u00b6n, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2a 02 februari feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14e 14'],\n                ['d do dddd ddd dd',                   '0 0e s\u00c3\u00b6ndag s\u00c3\u00b6n s\u00c3\u00b6'],\n                ['DDD DDDo DDDD',                      '45 45e 045'],\n                ['w wo ww',                            '6 6e 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45e day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '2010-02-14'],\n                ['LL',                                 '14 februari 2010'],\n                ['LLL',                                '14 februari 2010 kl. 15:25'],\n                ['LLLL',                               's\u00c3\u00b6ndag 14 februari 2010 kl. 15:25'],\n                ['l',                                  '2010-2-14'],\n                ['ll',                                 '14 feb 2010'],\n                ['lll',                                '14 feb 2010 15:25'],\n                ['llll',                               's\u00c3\u00b6n 14 feb 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1a', '1a');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2a', '2a');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3e', '3e');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4e', '4e');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5e', '5e');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6e', '6e');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7e', '7e');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8e', '8e');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9e', '9e');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10e', '10e');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11e', '11e');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12e', '12e');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13e', '13e');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14e', '14e');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15e', '15e');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16e', '16e');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17e', '17e');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18e', '18e');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19e', '19e');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20e', '20e');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21a', '21a');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22a', '22a');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23e', '23e');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24e', '24e');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25e', '25e');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26e', '26e');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27e', '27e');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28e', '28e');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29e', '29e');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30e', '30e');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31a', '31a');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'januari jan_februari feb_mars mar_april apr_maj maj_juni jun_juli jul_augusti aug_september sep_oktober okt_november nov_december dec'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 's\u00c3\u00b6ndag s\u00c3\u00b6n s\u00c3\u00b6_m\u00c3\u00a5ndag m\u00c3\u00a5n m\u00c3\u00a5_tisdag tis ti_onsdag ons on_torsdag tor to_fredag fre fr_l\u00c3\u00b6rdag l\u00c3\u00b6r l\u00c3\u00b6'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'n\u00c3\u00a5gra sekunder', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'en minut',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'en minut',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuter',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuter',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'en timme',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'en timme',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timmar',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timmar',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timmar',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dag',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dag',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dag',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en m\u00c3\u00a5nad',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en m\u00c3\u00a5nad',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en m\u00c3\u00a5nad',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m\u00c3\u00a5nader',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m\u00c3\u00a5nader',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m\u00c3\u00a5nader',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en m\u00c3\u00a5nad',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m\u00c3\u00a5nader',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ett \u00c3\u00a5r',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00c3\u00a5r',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ett \u00c3\u00a5r',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00c3\u00a5r',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'om n\u00c3\u00a5gra sekunder',  'prefix');\n        assert.equal(moment(0).from(30000), 'f\u00c3\u00b6r n\u00c3\u00a5gra sekunder sedan', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'f\u00c3\u00b6r n\u00c3\u00a5gra sekunder sedan',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'om n\u00c3\u00a5gra sekunder', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dagar', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Idag 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Idag 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Idag 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Imorgon 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Idag 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ig\u00c3\u00a5r 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[P\u00c3\u00a5] dddd LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[P\u00c3\u00a5] dddd LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[P\u00c3\u00a5] dddd LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[I] dddd[s] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[I] dddd[s] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[I] dddd[s] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52a', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1a', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1a', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2a', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2a', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('sw');\n\n    test('parse', function (assert) {\n        var tests = 'Januari Jan_Februari Feb_Machi Mac_Aprili Apr_Mei Mei_Juni Jun_Julai Jul_Agosti Ago_Septemba Sep_Oktoba Okt_Novemba Nov_Desemba Des'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Jumapili, Februari 14 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Jpl, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 Jumapili Jpl J2'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '7 7 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[siku] DDDo [ya mwaka]',             'siku 45 ya mwaka'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 Februari 2010'],\n                ['LLL',                                '14 Februari 2010 15:25'],\n                ['LLLL',                               'Jumapili, 14 Februari 2010 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 Feb 2010'],\n                ['lll',                                '14 Feb 2010 15:25'],\n                ['llll',                               'Jpl, 14 Feb 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Januari Jan_Februari Feb_Machi Mac_Aprili Apr_Mei Mei_Juni Jun_Julai Jul_Agosti Ago_Septemba Sep_Oktoba Okt_Novemba Nov_Desemba Des'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Jumapili Jpl J2_Jumatatu Jtat J3_Jumanne Jnne J4_Jumatano Jtan J5_Alhamisi Alh Al_Ijumaa Ijm Ij_Jumamosi Jmos J1'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'hivi punde',   '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'dakika moja',  '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'dakika moja',  '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'dakika 2',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'dakika 44',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'saa limoja',   '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'saa limoja',   '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'masaa 2',      '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'masaa 5',      '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'masaa 21',     '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'siku moja',    '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'siku moja',    '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'masiku 2',     '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'siku moja',    '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'masiku 5',     '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'masiku 25',    '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mwezi mmoja',  '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mwezi mmoja',  '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mwezi mmoja',  '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'miezi 2',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'miezi 2',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'miezi 3',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mwezi mmoja',  '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'miezi 5',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'mwaka mmoja',  '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'miaka 2',      '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'mwaka mmoja',  '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'miaka 5',      '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'hivi punde baadaye',  'prefix');\n        assert.equal(moment(0).from(30000), 'tokea hivi punde', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'tokea hivi punde',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'hivi punde baadaye', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'masiku 5 baadaye', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n        assert.equal(moment(a).calendar(),                   'leo saa 12:00',      'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'leo saa 12:25',      'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'leo saa 13:00',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'kesho saa 12:00',    'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'leo saa 11:00',      'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'jana 12:00',         'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[wiki ijayo] dddd [saat] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[wiki ijayo] dddd [saat] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[wiki ijayo] dddd [saat] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[wiki iliyopita] dddd [saat] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[wiki iliyopita] dddd [saat] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[wiki iliyopita] dddd [saat] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('ta');\n\n    test('parse', function (assert) {\n        var tests = '\u00e0\u00ae\u009c\u00e0\u00ae\u00a9\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf \u00e0\u00ae\u009c\u00e0\u00ae\u00a9\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf_\u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf \u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf_\u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00b0\u00e0\u00af\u008d\u00e0\u00ae\u009a\u00e0\u00af\u008d \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00b0\u00e0\u00af\u008d\u00e0\u00ae\u009a\u00e0\u00af\u008d_\u00e0\u00ae\u008f\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b2\u00e0\u00af\u008d \u00e0\u00ae\u008f\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b2\u00e0\u00af\u008d_\u00e0\u00ae\u00ae\u00e0\u00af\u0087 \u00e0\u00ae\u00ae\u00e0\u00af\u0087_\u00e0\u00ae\u009c\u00e0\u00af\u0082\u00e0\u00ae\u00a9\u00e0\u00af\u008d \u00e0\u00ae\u009c\u00e0\u00af\u0082\u00e0\u00ae\u00a9\u00e0\u00af\u008d_\u00e0\u00ae\u009c\u00e0\u00af\u0082\u00e0\u00ae\u00b2\u00e0\u00af\u0088 \u00e0\u00ae\u009c\u00e0\u00af\u0082\u00e0\u00ae\u00b2\u00e0\u00af\u0088_\u00e0\u00ae\u0086\u00e0\u00ae\u0095\u00e0\u00ae\u00b8\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u008d \u00e0\u00ae\u0086\u00e0\u00ae\u0095\u00e0\u00ae\u00b8\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u008d_\u00e0\u00ae\u009a\u00e0\u00af\u0086\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0086\u00e0\u00ae\u00ae\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d \u00e0\u00ae\u009a\u00e0\u00af\u0086\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0086\u00e0\u00ae\u00ae\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d_\u00e0\u00ae\u0085\u00e0\u00ae\u0095\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0087\u00e0\u00ae\u00be\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d \u00e0\u00ae\u0085\u00e0\u00ae\u0095\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0087\u00e0\u00ae\u00be\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d_\u00e0\u00ae\u00a8\u00e0\u00ae\u00b5\u00e0\u00ae\u00ae\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d \u00e0\u00ae\u00a8\u00e0\u00ae\u00b5\u00e0\u00ae\u00ae\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d_\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u009a\u00e0\u00ae\u00ae\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d \u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u009a\u00e0\u00ae\u00ae\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a', '\u00e0\u00ae\u009e\u00e0\u00ae\u00be\u00e0\u00ae\u00af\u00e0\u00ae\u00bf\u00e0\u00ae\u00b1\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081\u00e0\u00ae\u0095\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00bf\u00e0\u00ae\u00b4\u00e0\u00ae\u00ae\u00e0\u00af\u0088, \u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf \u00e0\u00af\u00a7\u00e0\u00af\u00aa\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081 \u00e0\u00af\u00a8\u00e0\u00af\u00a6\u00e0\u00af\u00a7\u00e0\u00af\u00a6, \u00e0\u00af\u00a9:\u00e0\u00af\u00a8\u00e0\u00af\u00ab:\u00e0\u00af\u00ab\u00e0\u00af\u00a6  \u00e0\u00ae\u008e\u00e0\u00ae\u00b1\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u0081'],\n                ['ddd, hA',                       '\u00e0\u00ae\u009e\u00e0\u00ae\u00be\u00e0\u00ae\u00af\u00e0\u00ae\u00bf\u00e0\u00ae\u00b1\u00e0\u00af\u0081, \u00e0\u00af\u00a9 \u00e0\u00ae\u008e\u00e0\u00ae\u00b1\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u0081'],\n                ['M Mo MM MMMM MMM',              '\u00e0\u00af\u00a8 \u00e0\u00af\u00a8\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081 \u00e0\u00af\u00a6\u00e0\u00af\u00a8 \u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf \u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf'],\n                ['YYYY YY',                       '\u00e0\u00af\u00a8\u00e0\u00af\u00a6\u00e0\u00af\u00a7\u00e0\u00af\u00a6 \u00e0\u00af\u00a7\u00e0\u00af\u00a6'],\n                ['D Do DD',                       '\u00e0\u00af\u00a7\u00e0\u00af\u00aa \u00e0\u00af\u00a7\u00e0\u00af\u00aa\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081 \u00e0\u00af\u00a7\u00e0\u00af\u00aa'],\n                ['d do dddd ddd dd',              '\u00e0\u00af\u00a6 \u00e0\u00af\u00a6\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081 \u00e0\u00ae\u009e\u00e0\u00ae\u00be\u00e0\u00ae\u00af\u00e0\u00ae\u00bf\u00e0\u00ae\u00b1\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081\u00e0\u00ae\u0095\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00bf\u00e0\u00ae\u00b4\u00e0\u00ae\u00ae\u00e0\u00af\u0088 \u00e0\u00ae\u009e\u00e0\u00ae\u00be\u00e0\u00ae\u00af\u00e0\u00ae\u00bf\u00e0\u00ae\u00b1\u00e0\u00af\u0081 \u00e0\u00ae\u009e\u00e0\u00ae\u00be'],\n                ['DDD DDDo DDDD',                 '\u00e0\u00af\u00aa\u00e0\u00af\u00ab \u00e0\u00af\u00aa\u00e0\u00af\u00ab\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081 \u00e0\u00af\u00a6\u00e0\u00af\u00aa\u00e0\u00af\u00ab'],\n                ['w wo ww',                       '\u00e0\u00af\u00ae \u00e0\u00af\u00ae\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081 \u00e0\u00af\u00a6\u00e0\u00af\u00ae'],\n                ['h hh',                          '\u00e0\u00af\u00a9 \u00e0\u00af\u00a6\u00e0\u00af\u00a9'],\n                ['H HH',                          '\u00e0\u00af\u00a7\u00e0\u00af\u00ab \u00e0\u00af\u00a7\u00e0\u00af\u00ab'],\n                ['m mm',                          '\u00e0\u00af\u00a8\u00e0\u00af\u00ab \u00e0\u00af\u00a8\u00e0\u00af\u00ab'],\n                ['s ss',                          '\u00e0\u00af\u00ab\u00e0\u00af\u00a6 \u00e0\u00af\u00ab\u00e0\u00af\u00a6'],\n                ['a A',                           ' \u00e0\u00ae\u008e\u00e0\u00ae\u00b1\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u0081  \u00e0\u00ae\u008e\u00e0\u00ae\u00b1\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u0081'],\n                ['[\u00e0\u00ae\u0086\u00e0\u00ae\u00a3\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u00a9\u00e0\u00af\u008d] DDDo  [\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u00b3\u00e0\u00af\u008d]', '\u00e0\u00ae\u0086\u00e0\u00ae\u00a3\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u00a9\u00e0\u00af\u008d \u00e0\u00af\u00aa\u00e0\u00af\u00ab\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081  \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u00b3\u00e0\u00af\u008d'],\n                ['LTS',                           '\u00e0\u00af\u00a7\u00e0\u00af\u00ab:\u00e0\u00af\u00a8\u00e0\u00af\u00ab:\u00e0\u00af\u00ab\u00e0\u00af\u00a6'],\n                ['L',                             '\u00e0\u00af\u00a7\u00e0\u00af\u00aa/\u00e0\u00af\u00a6\u00e0\u00af\u00a8/\u00e0\u00af\u00a8\u00e0\u00af\u00a6\u00e0\u00af\u00a7\u00e0\u00af\u00a6'],\n                ['LL',                            '\u00e0\u00af\u00a7\u00e0\u00af\u00aa \u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf \u00e0\u00af\u00a8\u00e0\u00af\u00a6\u00e0\u00af\u00a7\u00e0\u00af\u00a6'],\n                ['LLL',                           '\u00e0\u00af\u00a7\u00e0\u00af\u00aa \u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf \u00e0\u00af\u00a8\u00e0\u00af\u00a6\u00e0\u00af\u00a7\u00e0\u00af\u00a6, \u00e0\u00af\u00a7\u00e0\u00af\u00ab:\u00e0\u00af\u00a8\u00e0\u00af\u00ab'],\n                ['LLLL',                          '\u00e0\u00ae\u009e\u00e0\u00ae\u00be\u00e0\u00ae\u00af\u00e0\u00ae\u00bf\u00e0\u00ae\u00b1\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081\u00e0\u00ae\u0095\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00bf\u00e0\u00ae\u00b4\u00e0\u00ae\u00ae\u00e0\u00af\u0088, \u00e0\u00af\u00a7\u00e0\u00af\u00aa \u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf \u00e0\u00af\u00a8\u00e0\u00af\u00a6\u00e0\u00af\u00a7\u00e0\u00af\u00a6, \u00e0\u00af\u00a7\u00e0\u00af\u00ab:\u00e0\u00af\u00a8\u00e0\u00af\u00ab'],\n                ['l',                             '\u00e0\u00af\u00a7\u00e0\u00af\u00aa/\u00e0\u00af\u00a8/\u00e0\u00af\u00a8\u00e0\u00af\u00a6\u00e0\u00af\u00a7\u00e0\u00af\u00a6'],\n                ['ll',                            '\u00e0\u00af\u00a7\u00e0\u00af\u00aa \u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf \u00e0\u00af\u00a8\u00e0\u00af\u00a6\u00e0\u00af\u00a7\u00e0\u00af\u00a6'],\n                ['lll',                           '\u00e0\u00af\u00a7\u00e0\u00af\u00aa \u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf \u00e0\u00af\u00a8\u00e0\u00af\u00a6\u00e0\u00af\u00a7\u00e0\u00af\u00a6, \u00e0\u00af\u00a7\u00e0\u00af\u00ab:\u00e0\u00af\u00a8\u00e0\u00af\u00ab'],\n                ['llll',                          '\u00e0\u00ae\u009e\u00e0\u00ae\u00be\u00e0\u00ae\u00af\u00e0\u00ae\u00bf\u00e0\u00ae\u00b1\u00e0\u00af\u0081, \u00e0\u00af\u00a7\u00e0\u00af\u00aa \u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf \u00e0\u00af\u00a8\u00e0\u00af\u00a6\u00e0\u00af\u00a7\u00e0\u00af\u00a6, \u00e0\u00af\u00a7\u00e0\u00af\u00ab:\u00e0\u00af\u00a8\u00e0\u00af\u00ab']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '\u00e0\u00af\u00a7\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a7\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '\u00e0\u00af\u00a8\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a8\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '\u00e0\u00af\u00a9\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a9\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '\u00e0\u00af\u00aa\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00aa\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '\u00e0\u00af\u00ab\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00ab\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '\u00e0\u00af\u00ac\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00ac\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '\u00e0\u00af\u00ad\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00ad\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '\u00e0\u00af\u00ae\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00ae\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '\u00e0\u00af\u00af\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00af\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '\u00e0\u00af\u00a7\u00e0\u00af\u00a6\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a7\u00e0\u00af\u00a6\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '\u00e0\u00af\u00a7\u00e0\u00af\u00a7\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a7\u00e0\u00af\u00a7\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '\u00e0\u00af\u00a7\u00e0\u00af\u00a8\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a7\u00e0\u00af\u00a8\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '\u00e0\u00af\u00a7\u00e0\u00af\u00a9\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a7\u00e0\u00af\u00a9\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '\u00e0\u00af\u00a7\u00e0\u00af\u00aa\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a7\u00e0\u00af\u00aa\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '\u00e0\u00af\u00a7\u00e0\u00af\u00ab\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a7\u00e0\u00af\u00ab\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '\u00e0\u00af\u00a7\u00e0\u00af\u00ac\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a7\u00e0\u00af\u00ac\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '\u00e0\u00af\u00a7\u00e0\u00af\u00ad\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a7\u00e0\u00af\u00ad\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '\u00e0\u00af\u00a7\u00e0\u00af\u00ae\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a7\u00e0\u00af\u00ae\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '\u00e0\u00af\u00a7\u00e0\u00af\u00af\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a7\u00e0\u00af\u00af\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '\u00e0\u00af\u00a8\u00e0\u00af\u00a6\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a8\u00e0\u00af\u00a6\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '\u00e0\u00af\u00a8\u00e0\u00af\u00a7\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a8\u00e0\u00af\u00a7\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '\u00e0\u00af\u00a8\u00e0\u00af\u00a8\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a8\u00e0\u00af\u00a8\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '\u00e0\u00af\u00a8\u00e0\u00af\u00a9\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a8\u00e0\u00af\u00a9\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '\u00e0\u00af\u00a8\u00e0\u00af\u00aa\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a8\u00e0\u00af\u00aa\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '\u00e0\u00af\u00a8\u00e0\u00af\u00ab\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a8\u00e0\u00af\u00ab\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '\u00e0\u00af\u00a8\u00e0\u00af\u00ac\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a8\u00e0\u00af\u00ac\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '\u00e0\u00af\u00a8\u00e0\u00af\u00ad\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a8\u00e0\u00af\u00ad\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '\u00e0\u00af\u00a8\u00e0\u00af\u00ae\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a8\u00e0\u00af\u00ae\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '\u00e0\u00af\u00a8\u00e0\u00af\u00af\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a8\u00e0\u00af\u00af\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '\u00e0\u00af\u00a9\u00e0\u00af\u00a6\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a9\u00e0\u00af\u00a6\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '\u00e0\u00af\u00a9\u00e0\u00af\u00a7\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081', '\u00e0\u00af\u00a9\u00e0\u00af\u00a7\u00e0\u00ae\u00b5\u00e0\u00ae\u00a4\u00e0\u00af\u0081');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e0\u00ae\u009c\u00e0\u00ae\u00a9\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf \u00e0\u00ae\u009c\u00e0\u00ae\u00a9\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf_\u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf \u00e0\u00ae\u00aa\u00e0\u00ae\u00bf\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00ae\u00bf_\u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00b0\u00e0\u00af\u008d\u00e0\u00ae\u009a\u00e0\u00af\u008d \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00b0\u00e0\u00af\u008d\u00e0\u00ae\u009a\u00e0\u00af\u008d_\u00e0\u00ae\u008f\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b2\u00e0\u00af\u008d \u00e0\u00ae\u008f\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00b0\u00e0\u00ae\u00b2\u00e0\u00af\u008d_\u00e0\u00ae\u00ae\u00e0\u00af\u0087 \u00e0\u00ae\u00ae\u00e0\u00af\u0087_\u00e0\u00ae\u009c\u00e0\u00af\u0082\u00e0\u00ae\u00a9\u00e0\u00af\u008d \u00e0\u00ae\u009c\u00e0\u00af\u0082\u00e0\u00ae\u00a9\u00e0\u00af\u008d_\u00e0\u00ae\u009c\u00e0\u00af\u0082\u00e0\u00ae\u00b2\u00e0\u00af\u0088 \u00e0\u00ae\u009c\u00e0\u00af\u0082\u00e0\u00ae\u00b2\u00e0\u00af\u0088_\u00e0\u00ae\u0086\u00e0\u00ae\u0095\u00e0\u00ae\u00b8\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u008d \u00e0\u00ae\u0086\u00e0\u00ae\u0095\u00e0\u00ae\u00b8\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u008d_\u00e0\u00ae\u009a\u00e0\u00af\u0086\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0086\u00e0\u00ae\u00ae\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d \u00e0\u00ae\u009a\u00e0\u00af\u0086\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0086\u00e0\u00ae\u00ae\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d_\u00e0\u00ae\u0085\u00e0\u00ae\u0095\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0087\u00e0\u00ae\u00be\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d \u00e0\u00ae\u0085\u00e0\u00ae\u0095\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0087\u00e0\u00ae\u00be\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d_\u00e0\u00ae\u00a8\u00e0\u00ae\u00b5\u00e0\u00ae\u00ae\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d \u00e0\u00ae\u00a8\u00e0\u00ae\u00b5\u00e0\u00ae\u00ae\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d_\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u009a\u00e0\u00ae\u00ae\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d \u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u009a\u00e0\u00ae\u00ae\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00b0\u00e0\u00af\u008d'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e0\u00ae\u009e\u00e0\u00ae\u00be\u00e0\u00ae\u00af\u00e0\u00ae\u00bf\u00e0\u00ae\u00b1\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081\u00e0\u00ae\u0095\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00bf\u00e0\u00ae\u00b4\u00e0\u00ae\u00ae\u00e0\u00af\u0088 \u00e0\u00ae\u009e\u00e0\u00ae\u00be\u00e0\u00ae\u00af\u00e0\u00ae\u00bf\u00e0\u00ae\u00b1\u00e0\u00af\u0081 \u00e0\u00ae\u009e\u00e0\u00ae\u00be_\u00e0\u00ae\u00a4\u00e0\u00ae\u00bf\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00bf\u00e0\u00ae\u00b4\u00e0\u00ae\u00ae\u00e0\u00af\u0088 \u00e0\u00ae\u00a4\u00e0\u00ae\u00bf\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d \u00e0\u00ae\u00a4\u00e0\u00ae\u00bf_\u00e0\u00ae\u009a\u00e0\u00af\u0086\u00e0\u00ae\u00b5\u00e0\u00af\u008d\u00e0\u00ae\u00b5\u00e0\u00ae\u00be\u00e0\u00ae\u00af\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00bf\u00e0\u00ae\u00b4\u00e0\u00ae\u00ae\u00e0\u00af\u0088 \u00e0\u00ae\u009a\u00e0\u00af\u0086\u00e0\u00ae\u00b5\u00e0\u00af\u008d\u00e0\u00ae\u00b5\u00e0\u00ae\u00be\u00e0\u00ae\u00af\u00e0\u00af\u008d \u00e0\u00ae\u009a\u00e0\u00af\u0086_\u00e0\u00ae\u00aa\u00e0\u00af\u0081\u00e0\u00ae\u00a4\u00e0\u00ae\u00a9\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00bf\u00e0\u00ae\u00b4\u00e0\u00ae\u00ae\u00e0\u00af\u0088 \u00e0\u00ae\u00aa\u00e0\u00af\u0081\u00e0\u00ae\u00a4\u00e0\u00ae\u00a9\u00e0\u00af\u008d \u00e0\u00ae\u00aa\u00e0\u00af\u0081_\u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00af\u00e0\u00ae\u00be\u00e0\u00ae\u00b4\u00e0\u00ae\u0095\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00bf\u00e0\u00ae\u00b4\u00e0\u00ae\u00ae\u00e0\u00af\u0088 \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00af\u00e0\u00ae\u00be\u00e0\u00ae\u00b4\u00e0\u00ae\u00a9\u00e0\u00af\u008d \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf_\u00e0\u00ae\u00b5\u00e0\u00af\u0086\u00e0\u00ae\u00b3\u00e0\u00af\u008d\u00e0\u00ae\u00b3\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00bf\u00e0\u00ae\u00b4\u00e0\u00ae\u00ae\u00e0\u00af\u0088 \u00e0\u00ae\u00b5\u00e0\u00af\u0086\u00e0\u00ae\u00b3\u00e0\u00af\u008d\u00e0\u00ae\u00b3\u00e0\u00ae\u00bf \u00e0\u00ae\u00b5\u00e0\u00af\u0086_\u00e0\u00ae\u009a\u00e0\u00ae\u00a9\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00bf\u00e0\u00ae\u00b4\u00e0\u00ae\u00ae\u00e0\u00af\u0088 \u00e0\u00ae\u009a\u00e0\u00ae\u00a9\u00e0\u00ae\u00bf \u00e0\u00ae\u009a'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u009a\u00e0\u00ae\u00bf\u00e0\u00ae\u00b2 \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d', '44 \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u009a\u00e0\u00ae\u00bf\u00e0\u00ae\u00b2 \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00a8\u00e0\u00ae\u00bf\u00e0\u00ae\u00ae\u00e0\u00ae\u00bf\u00e0\u00ae\u009f\u00e0\u00ae\u00ae\u00e0\u00af\u008d',      '45 \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00a8\u00e0\u00ae\u00bf\u00e0\u00ae\u00ae\u00e0\u00ae\u00bf\u00e0\u00ae\u009f\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00a8\u00e0\u00ae\u00bf\u00e0\u00ae\u00ae\u00e0\u00ae\u00bf\u00e0\u00ae\u009f\u00e0\u00ae\u00ae\u00e0\u00af\u008d',      '89 \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00a8\u00e0\u00ae\u00bf\u00e0\u00ae\u00ae\u00e0\u00ae\u00bf\u00e0\u00ae\u009f\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '\u00e0\u00af\u00a8 \u00e0\u00ae\u00a8\u00e0\u00ae\u00bf\u00e0\u00ae\u00ae\u00e0\u00ae\u00bf\u00e0\u00ae\u009f\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d',     '90 \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00af\u00a8 \u00e0\u00ae\u00a8\u00e0\u00ae\u00bf\u00e0\u00ae\u00ae\u00e0\u00ae\u00bf\u00e0\u00ae\u009f\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '\u00e0\u00af\u00aa\u00e0\u00af\u00aa \u00e0\u00ae\u00a8\u00e0\u00ae\u00bf\u00e0\u00ae\u00ae\u00e0\u00ae\u00bf\u00e0\u00ae\u009f\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d',    '44 \u00e0\u00ae\u00a8\u00e0\u00ae\u00bf\u00e0\u00ae\u00ae\u00e0\u00ae\u00bf\u00e0\u00ae\u009f\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = 44 \u00e0\u00ae\u00a8\u00e0\u00ae\u00bf\u00e0\u00ae\u00ae\u00e0\u00ae\u00bf\u00e0\u00ae\u009f\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d',       '45 \u00e0\u00ae\u00a8\u00e0\u00ae\u00bf\u00e0\u00ae\u00ae\u00e0\u00ae\u00bf\u00e0\u00ae\u009f\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d',       '89 \u00e0\u00ae\u00a8\u00e0\u00ae\u00bf\u00e0\u00ae\u00ae\u00e0\u00ae\u00bf\u00e0\u00ae\u009f\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '\u00e0\u00af\u00a8 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d',       '90 \u00e0\u00ae\u00a8\u00e0\u00ae\u00bf\u00e0\u00ae\u00ae\u00e0\u00ae\u00bf\u00e0\u00ae\u009f\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00af\u00a8 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '\u00e0\u00af\u00ab \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d',       '5 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d = 5 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '\u00e0\u00af\u00a8\u00e0\u00af\u00a7 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d',      '\u00e0\u00af\u00a8\u00e0\u00af\u00a7 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d = \u00e0\u00af\u00a8\u00e0\u00af\u00a7 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u00b3\u00e0\u00af\u008d',         '\u00e0\u00af\u00a8\u00e0\u00af\u00a8 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u00b3\u00e0\u00af\u008d',         '\u00e0\u00af\u00a95 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '\u00e0\u00af\u00a8 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d',        '\u00e0\u00af\u00a96 \u00e0\u00ae\u00ae\u00e0\u00ae\u00a3\u00e0\u00ae\u00bf \u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d = \u00e0\u00af\u00a8 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u00b3\u00e0\u00af\u008d',         '\u00e0\u00af\u00a7 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '\u00e0\u00af\u00ab \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d',        '5 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = 5 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '\u00e0\u00af\u00a8\u00e0\u00af\u00ab \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d',       '\u00e0\u00af\u00a85 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00af\u00a85 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u00ae\u00e0\u00af\u008d',       '\u00e0\u00af\u00a86 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u00ae\u00e0\u00af\u008d',       '\u00e0\u00af\u00a90 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u00ae\u00e0\u00af\u008d',       '45 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '\u00e0\u00af\u00a8 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d',      '46 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00af\u00a8 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '\u00e0\u00af\u00a8 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d',      '75 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00af\u00a8 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '\u00e0\u00af\u00a9 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d',      '76 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00af\u00a9 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u00ae\u00e0\u00af\u008d',       '\u00e0\u00af\u00a7 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u00ae\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '\u00e0\u00af\u00ab \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d',      '5 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = 5 \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00ae\u0099\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00af\u0081\u00e0\u00ae\u009f\u00e0\u00ae\u00ae\u00e0\u00af\u008d',        '\u00e0\u00af\u00a945 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00af\u0081\u00e0\u00ae\u009f\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '\u00e0\u00af\u00a8 \u00e0\u00ae\u0086\u00e0\u00ae\u00a3\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0081\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d',       '548 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = \u00e0\u00af\u00a8 \u00e0\u00ae\u0086\u00e0\u00ae\u00a3\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0081\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00af\u0081\u00e0\u00ae\u009f\u00e0\u00ae\u00ae\u00e0\u00af\u008d',        '\u00e0\u00af\u00a7 \u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00af\u0081\u00e0\u00ae\u009f\u00e0\u00ae\u00ae\u00e0\u00af\u008d = \u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u00b5\u00e0\u00ae\u00b0\u00e0\u00af\u0081\u00e0\u00ae\u009f\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '\u00e0\u00af\u00ab \u00e0\u00ae\u0086\u00e0\u00ae\u00a3\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0081\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d',       '5 \u00e0\u00ae\u0086\u00e0\u00ae\u00a3\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0081\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d = 5 \u00e0\u00ae\u0086\u00e0\u00ae\u00a3\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0081\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u009a\u00e0\u00ae\u00bf\u00e0\u00ae\u00b2 \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d \u00e0\u00ae\u0087\u00e0\u00ae\u00b2\u00e0\u00af\u008d',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u009a\u00e0\u00ae\u00bf\u00e0\u00ae\u00b2 \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d \u00e0\u00ae\u00ae\u00e0\u00af\u0081\u00e0\u00ae\u00a9\u00e0\u00af\u008d', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u009a\u00e0\u00ae\u00bf\u00e0\u00ae\u00b2 \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d \u00e0\u00ae\u00ae\u00e0\u00af\u0081\u00e0\u00ae\u00a9\u00e0\u00af\u008d',  '\u00e0\u00ae\u0087\u00e0\u00ae\u00aa\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00af\u0087\u00e0\u00ae\u00be\u00e0\u00ae\u00a4\u00e0\u00af\u0081 \u00e0\u00ae\u0087\u00e0\u00ae\u00b0\u00e0\u00af\u0081\u00e0\u00ae\u00a8\u00e0\u00af\u008d\u00e0\u00ae\u00a4\u00e0\u00af\u0081 \u00e0\u00ae\u0095\u00e0\u00ae\u009f\u00e0\u00ae\u00a8\u00e0\u00af\u008d\u00e0\u00ae\u00a4 \u00e0\u00ae\u0095\u00e0\u00ae\u00be\u00e0\u00ae\u00b2\u00e0\u00ae\u00a4\u00e0\u00af\u008d\u00e0\u00ae\u00a4\u00e0\u00ae\u00bf\u00e0\u00ae\u00b2\u00e0\u00af\u008d \u00e0\u00ae\u0095\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u009f \u00e0\u00ae\u00b5\u00e0\u00af\u0087\u00e0\u00ae\u00a3\u00e0\u00af\u008d\u00e0\u00ae\u009f\u00e0\u00af\u0081\u00e0\u00ae\u00ae\u00e0\u00af\u008d');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u009a\u00e0\u00ae\u00bf\u00e0\u00ae\u00b2 \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d \u00e0\u00ae\u0087\u00e0\u00ae\u00b2\u00e0\u00af\u008d', '\u00e0\u00ae\u0092\u00e0\u00ae\u00b0\u00e0\u00af\u0081 \u00e0\u00ae\u009a\u00e0\u00ae\u00bf\u00e0\u00ae\u00b2 \u00e0\u00ae\u00b5\u00e0\u00ae\u00bf\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00ae\u00bf\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d \u00e0\u00ae\u0087\u00e0\u00ae\u00b2\u00e0\u00af\u008d');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00e0\u00af\u00ab \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d \u00e0\u00ae\u0087\u00e0\u00ae\u00b2\u00e0\u00af\u008d', '5 \u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u008d\u00e0\u00ae\u0095\u00e0\u00ae\u00b3\u00e0\u00af\u008d \u00e0\u00ae\u0087\u00e0\u00ae\u00b2\u00e0\u00af\u008d');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e0\u00ae\u0087\u00e0\u00ae\u00a9\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081 \u00e0\u00af\u00a7\u00e0\u00af\u00a8:\u00e0\u00af\u00a6\u00e0\u00af\u00a6',   '\u00e0\u00ae\u0087\u00e0\u00ae\u00a9\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081  12:00');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e0\u00ae\u0087\u00e0\u00ae\u00a9\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081 \u00e0\u00af\u00a7\u00e0\u00af\u00a8:\u00e0\u00af\u00a8\u00e0\u00af\u00ab',   '\u00e0\u00ae\u0087\u00e0\u00ae\u00a9\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081  12:25');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00e0\u00ae\u0087\u00e0\u00ae\u00a9\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081 \u00e0\u00af\u00a7\u00e0\u00af\u00a9:\u00e0\u00af\u00a6\u00e0\u00af\u00a6',   '\u00e0\u00ae\u0087\u00e0\u00ae\u00a9\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081  13:00');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u00b3\u00e0\u00af\u0088 \u00e0\u00af\u00a7\u00e0\u00af\u00a8:\u00e0\u00af\u00a6\u00e0\u00af\u00a6',    '\u00e0\u00ae\u00a8\u00e0\u00ae\u00be\u00e0\u00ae\u00b3\u00e0\u00af\u0088  12:00');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e0\u00ae\u0087\u00e0\u00ae\u00a9\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081 \u00e0\u00af\u00a7\u00e0\u00af\u00a7:\u00e0\u00af\u00a6\u00e0\u00af\u00a6',   '\u00e0\u00ae\u0087\u00e0\u00ae\u00a9\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081  11:00');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b1\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081 \u00e0\u00af\u00a7\u00e0\u00af\u00a8:\u00e0\u00af\u00a6\u00e0\u00af\u00a6',  '\u00e0\u00ae\u00a8\u00e0\u00af\u0087\u00e0\u00ae\u00b1\u00e0\u00af\u008d\u00e0\u00ae\u00b1\u00e0\u00af\u0081  12:00');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd, LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd, LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd, LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00ae\u0095\u00e0\u00ae\u009f\u00e0\u00ae\u00a8\u00e0\u00af\u008d\u00e0\u00ae\u00a4 \u00e0\u00ae\u00b5\u00e0\u00ae\u00be\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d] dddd, LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00ae\u0095\u00e0\u00ae\u009f\u00e0\u00ae\u00a8\u00e0\u00af\u008d\u00e0\u00ae\u00a4 \u00e0\u00ae\u00b5\u00e0\u00ae\u00be\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d] dddd, LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00ae\u0095\u00e0\u00ae\u009f\u00e0\u00ae\u00a8\u00e0\u00af\u008d\u00e0\u00ae\u00a4 \u00e0\u00ae\u00b5\u00e0\u00ae\u00be\u00e0\u00ae\u00b0\u00e0\u00ae\u00ae\u00e0\u00af\u008d] dddd, LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('meridiem', function (assert) {\n        assert.equal(moment([2011, 2, 23,  0, 30]).format('a'), ' \u00e0\u00ae\u00af\u00e0\u00ae\u00be\u00e0\u00ae\u00ae\u00e0\u00ae\u00ae\u00e0\u00af\u008d', '(after) midnight');\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), ' \u00e0\u00ae\u00b5\u00e0\u00af\u0088\u00e0\u00ae\u0095\u00e0\u00ae\u00b1\u00e0\u00af\u0088', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), ' \u00e0\u00ae\u0095\u00e0\u00ae\u00be\u00e0\u00ae\u00b2\u00e0\u00af\u0088', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), ' \u00e0\u00ae\u008e\u00e0\u00ae\u00b1\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u0081', 'during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), ' \u00e0\u00ae\u008e\u00e0\u00ae\u00b1\u00e0\u00af\u008d\u00e0\u00ae\u00aa\u00e0\u00ae\u00be\u00e0\u00ae\u009f\u00e0\u00af\u0081', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), ' \u00e0\u00ae\u00ae\u00e0\u00ae\u00be\u00e0\u00ae\u00b2\u00e0\u00af\u0088', 'late evening');\n        assert.equal(moment([2011, 2, 23, 23, 30]).format('a'), ' \u00e0\u00ae\u00af\u00e0\u00ae\u00be\u00e0\u00ae\u00ae\u00e0\u00ae\u00ae\u00e0\u00af\u008d', '(before) midnight');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('te');\n\n    test('parse', function (assert) {\n        var tests = '\u00e0\u00b0\u009c\u00e0\u00b0\u00a8\u00e0\u00b0\u00b5\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf \u00e0\u00b0\u009c\u00e0\u00b0\u00a8._\u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00b5\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf \u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0._\u00e0\u00b0\u00ae\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b1\u008d\u00e0\u00b0\u009a\u00e0\u00b0\u00bf \u00e0\u00b0\u00ae\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b1\u008d\u00e0\u00b0\u009a\u00e0\u00b0\u00bf_\u00e0\u00b0\u008f\u00e0\u00b0\u00aa\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf\u00e0\u00b0\u00b2\u00e0\u00b1\u008d \u00e0\u00b0\u008f\u00e0\u00b0\u00aa\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf._\u00e0\u00b0\u00ae\u00e0\u00b1\u0087 \u00e0\u00b0\u00ae\u00e0\u00b1\u0087_\u00e0\u00b0\u009c\u00e0\u00b1\u0082\u00e0\u00b0\u00a8\u00e0\u00b1\u008d \u00e0\u00b0\u009c\u00e0\u00b1\u0082\u00e0\u00b0\u00a8\u00e0\u00b1\u008d_\u00e0\u00b0\u009c\u00e0\u00b1\u0082\u00e0\u00b0\u00b2\u00e0\u00b1\u0086\u00e0\u00b1\u0096 \u00e0\u00b0\u009c\u00e0\u00b1\u0082\u00e0\u00b0\u00b2\u00e0\u00b1\u0086\u00e0\u00b1\u0096_\u00e0\u00b0\u0086\u00e0\u00b0\u0097\u00e0\u00b0\u00b8\u00e0\u00b1\u008d\u00e0\u00b0\u009f\u00e0\u00b1\u0081 \u00e0\u00b0\u0086\u00e0\u00b0\u0097._\u00e0\u00b0\u00b8\u00e0\u00b1\u0086\u00e0\u00b0\u00aa\u00e0\u00b1\u008d\u00e0\u00b0\u009f\u00e0\u00b1\u0086\u00e0\u00b0\u0082\u00e0\u00b0\u00ac\u00e0\u00b0\u00b0\u00e0\u00b1\u008d \u00e0\u00b0\u00b8\u00e0\u00b1\u0086\u00e0\u00b0\u00aa\u00e0\u00b1\u008d._\u00e0\u00b0\u0085\u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u009f\u00e0\u00b1\u008b\u00e0\u00b0\u00ac\u00e0\u00b0\u00b0\u00e0\u00b1\u008d \u00e0\u00b0\u0085\u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u009f\u00e0\u00b1\u008b._\u00e0\u00b0\u00a8\u00e0\u00b0\u00b5\u00e0\u00b0\u0082\u00e0\u00b0\u00ac\u00e0\u00b0\u00b0\u00e0\u00b1\u008d \u00e0\u00b0\u00a8\u00e0\u00b0\u00b5._\u00e0\u00b0\u00a1\u00e0\u00b0\u00bf\u00e0\u00b0\u00b8\u00e0\u00b1\u0086\u00e0\u00b0\u0082\u00e0\u00b0\u00ac\u00e0\u00b0\u00b0\u00e0\u00b1\u008d \u00e0\u00b0\u00a1\u00e0\u00b0\u00bf\u00e0\u00b0\u00b8\u00e0\u00b1\u0086.'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do \u00e0\u00b0\u00a4\u00e0\u00b1\u0087\u00e0\u00b0\u00a6\u00e0\u00b1\u0080 MMMM YYYY, a h:mm:ss',  '\u00e0\u00b0\u0086\u00e0\u00b0\u00a6\u00e0\u00b0\u00bf\u00e0\u00b0\u00b5\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b0\u0082, 14\u00e0\u00b0\u00b5 \u00e0\u00b0\u00a4\u00e0\u00b1\u0087\u00e0\u00b0\u00a6\u00e0\u00b1\u0080 \u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00b5\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf 2010, \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 3:25:50'],\n                ['ddd, a h \u00e0\u00b0\u0097\u00e0\u00b0\u0082\u00e0\u00b0\u009f\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',                 '\u00e0\u00b0\u0086\u00e0\u00b0\u00a6\u00e0\u00b0\u00bf, \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 3 \u00e0\u00b0\u0097\u00e0\u00b0\u0082\u00e0\u00b0\u009f\u00e0\u00b0\u00b2\u00e0\u00b1\u0081'],\n                ['M Mo \u00e0\u00b0\u00a8\u00e0\u00b1\u0086\u00e0\u00b0\u00b2 MM MMMM MMM',                   '2 2\u00e0\u00b0\u00b5 \u00e0\u00b0\u00a8\u00e0\u00b1\u0086\u00e0\u00b0\u00b2 02 \u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00b5\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf \u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0.'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\u00e0\u00b0\u00b5 14'],\n                ['d do dddd ddd dd',                   '0 0\u00e0\u00b0\u00b5 \u00e0\u00b0\u0086\u00e0\u00b0\u00a6\u00e0\u00b0\u00bf\u00e0\u00b0\u00b5\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b0\u0082 \u00e0\u00b0\u0086\u00e0\u00b0\u00a6\u00e0\u00b0\u00bf \u00e0\u00b0\u0086'],\n                ['DDD DDDo DDDD',                      '45 45\u00e0\u00b0\u00b5 045'],\n                ['w wo ww',                            '8 8\u00e0\u00b0\u00b5 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082'],\n                ['LTS',                                '\u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 3:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 \u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00b5\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf 2010'],\n                ['LLL',                                '14 \u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00b5\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf 2010, \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 3:25'],\n                ['LLLL',                               '\u00e0\u00b0\u0086\u00e0\u00b0\u00a6\u00e0\u00b0\u00bf\u00e0\u00b0\u00b5\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b0\u0082, 14 \u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00b5\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf 2010, \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 3:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 \u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0. 2010'],\n                ['lll',                                '14 \u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0. 2010, \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 3:25'],\n                ['llll',                               '\u00e0\u00b0\u0086\u00e0\u00b0\u00a6\u00e0\u00b0\u00bf, 14 \u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0. 2010, \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 3:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1\u00e0\u00b0\u00b5', '1\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2\u00e0\u00b0\u00b5', '2\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3\u00e0\u00b0\u00b5', '3\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4\u00e0\u00b0\u00b5', '4\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\u00e0\u00b0\u00b5', '5\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\u00e0\u00b0\u00b5', '6\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\u00e0\u00b0\u00b5', '7\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\u00e0\u00b0\u00b5', '8\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\u00e0\u00b0\u00b5', '9\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\u00e0\u00b0\u00b5', '10\u00e0\u00b0\u00b5');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\u00e0\u00b0\u00b5', '11\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\u00e0\u00b0\u00b5', '12\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\u00e0\u00b0\u00b5', '13\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\u00e0\u00b0\u00b5', '14\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\u00e0\u00b0\u00b5', '15\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\u00e0\u00b0\u00b5', '16\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\u00e0\u00b0\u00b5', '17\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\u00e0\u00b0\u00b5', '18\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\u00e0\u00b0\u00b5', '19\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\u00e0\u00b0\u00b5', '20\u00e0\u00b0\u00b5');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\u00e0\u00b0\u00b5', '21\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\u00e0\u00b0\u00b5', '22\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\u00e0\u00b0\u00b5', '23\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\u00e0\u00b0\u00b5', '24\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\u00e0\u00b0\u00b5', '25\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\u00e0\u00b0\u00b5', '26\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\u00e0\u00b0\u00b5', '27\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\u00e0\u00b0\u00b5', '28\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\u00e0\u00b0\u00b5', '29\u00e0\u00b0\u00b5');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\u00e0\u00b0\u00b5', '30\u00e0\u00b0\u00b5');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\u00e0\u00b0\u00b5', '31\u00e0\u00b0\u00b5');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e0\u00b0\u009c\u00e0\u00b0\u00a8\u00e0\u00b0\u00b5\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf \u00e0\u00b0\u009c\u00e0\u00b0\u00a8._\u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00b5\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf \u00e0\u00b0\u00ab\u00e0\u00b0\u00bf\u00e0\u00b0\u00ac\u00e0\u00b1\u008d\u00e0\u00b0\u00b0._\u00e0\u00b0\u00ae\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b1\u008d\u00e0\u00b0\u009a\u00e0\u00b0\u00bf \u00e0\u00b0\u00ae\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b1\u008d\u00e0\u00b0\u009a\u00e0\u00b0\u00bf_\u00e0\u00b0\u008f\u00e0\u00b0\u00aa\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf\u00e0\u00b0\u00b2\u00e0\u00b1\u008d \u00e0\u00b0\u008f\u00e0\u00b0\u00aa\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf._\u00e0\u00b0\u00ae\u00e0\u00b1\u0087 \u00e0\u00b0\u00ae\u00e0\u00b1\u0087_\u00e0\u00b0\u009c\u00e0\u00b1\u0082\u00e0\u00b0\u00a8\u00e0\u00b1\u008d \u00e0\u00b0\u009c\u00e0\u00b1\u0082\u00e0\u00b0\u00a8\u00e0\u00b1\u008d_\u00e0\u00b0\u009c\u00e0\u00b1\u0082\u00e0\u00b0\u00b2\u00e0\u00b1\u0086\u00e0\u00b1\u0096 \u00e0\u00b0\u009c\u00e0\u00b1\u0082\u00e0\u00b0\u00b2\u00e0\u00b1\u0086\u00e0\u00b1\u0096_\u00e0\u00b0\u0086\u00e0\u00b0\u0097\u00e0\u00b0\u00b8\u00e0\u00b1\u008d\u00e0\u00b0\u009f\u00e0\u00b1\u0081 \u00e0\u00b0\u0086\u00e0\u00b0\u0097._\u00e0\u00b0\u00b8\u00e0\u00b1\u0086\u00e0\u00b0\u00aa\u00e0\u00b1\u008d\u00e0\u00b0\u009f\u00e0\u00b1\u0086\u00e0\u00b0\u0082\u00e0\u00b0\u00ac\u00e0\u00b0\u00b0\u00e0\u00b1\u008d \u00e0\u00b0\u00b8\u00e0\u00b1\u0086\u00e0\u00b0\u00aa\u00e0\u00b1\u008d._\u00e0\u00b0\u0085\u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u009f\u00e0\u00b1\u008b\u00e0\u00b0\u00ac\u00e0\u00b0\u00b0\u00e0\u00b1\u008d \u00e0\u00b0\u0085\u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u009f\u00e0\u00b1\u008b._\u00e0\u00b0\u00a8\u00e0\u00b0\u00b5\u00e0\u00b0\u0082\u00e0\u00b0\u00ac\u00e0\u00b0\u00b0\u00e0\u00b1\u008d \u00e0\u00b0\u00a8\u00e0\u00b0\u00b5._\u00e0\u00b0\u00a1\u00e0\u00b0\u00bf\u00e0\u00b0\u00b8\u00e0\u00b1\u0086\u00e0\u00b0\u0082\u00e0\u00b0\u00ac\u00e0\u00b0\u00b0\u00e0\u00b1\u008d \u00e0\u00b0\u00a1\u00e0\u00b0\u00bf\u00e0\u00b0\u00b8\u00e0\u00b1\u0086.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e0\u00b0\u0086\u00e0\u00b0\u00a6\u00e0\u00b0\u00bf\u00e0\u00b0\u00b5\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b0\u0082 \u00e0\u00b0\u0086\u00e0\u00b0\u00a6\u00e0\u00b0\u00bf \u00e0\u00b0\u0086_\u00e0\u00b0\u00b8\u00e0\u00b1\u008b\u00e0\u00b0\u00ae\u00e0\u00b0\u00b5\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b0\u0082 \u00e0\u00b0\u00b8\u00e0\u00b1\u008b\u00e0\u00b0\u00ae \u00e0\u00b0\u00b8\u00e0\u00b1\u008b_\u00e0\u00b0\u00ae\u00e0\u00b0\u0082\u00e0\u00b0\u0097\u00e0\u00b0\u00b3\u00e0\u00b0\u00b5\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b0\u0082 \u00e0\u00b0\u00ae\u00e0\u00b0\u0082\u00e0\u00b0\u0097\u00e0\u00b0\u00b3 \u00e0\u00b0\u00ae\u00e0\u00b0\u0082_\u00e0\u00b0\u00ac\u00e0\u00b1\u0081\u00e0\u00b0\u00a7\u00e0\u00b0\u00b5\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b0\u0082 \u00e0\u00b0\u00ac\u00e0\u00b1\u0081\u00e0\u00b0\u00a7 \u00e0\u00b0\u00ac\u00e0\u00b1\u0081_\u00e0\u00b0\u0097\u00e0\u00b1\u0081\u00e0\u00b0\u00b0\u00e0\u00b1\u0081\u00e0\u00b0\u00b5\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b0\u0082 \u00e0\u00b0\u0097\u00e0\u00b1\u0081\u00e0\u00b0\u00b0\u00e0\u00b1\u0081 \u00e0\u00b0\u0097\u00e0\u00b1\u0081_\u00e0\u00b0\u00b6\u00e0\u00b1\u0081\u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00b5\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b0\u0082 \u00e0\u00b0\u00b6\u00e0\u00b1\u0081\u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u00b0 \u00e0\u00b0\u00b6\u00e0\u00b1\u0081_\u00e0\u00b0\u00b6\u00e0\u00b0\u00a8\u00e0\u00b0\u00bf\u00e0\u00b0\u00b5\u00e0\u00b0\u00be\u00e0\u00b0\u00b0\u00e0\u00b0\u0082 \u00e0\u00b0\u00b6\u00e0\u00b0\u00a8\u00e0\u00b0\u00bf \u00e0\u00b0\u00b6'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e0\u00b0\u0095\u00e0\u00b1\u008a\u00e0\u00b0\u00a8\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u00bf \u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u00b7\u00e0\u00b0\u00a3\u00e0\u00b0\u00be\u00e0\u00b0\u00b2\u00e0\u00b1\u0081', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u00a8\u00e0\u00b0\u00bf\u00e0\u00b0\u00ae\u00e0\u00b0\u00bf\u00e0\u00b0\u00b7\u00e0\u00b0\u0082',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u00a8\u00e0\u00b0\u00bf\u00e0\u00b0\u00ae\u00e0\u00b0\u00bf\u00e0\u00b0\u00b7\u00e0\u00b0\u0082',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00e0\u00b0\u00a8\u00e0\u00b0\u00bf\u00e0\u00b0\u00ae\u00e0\u00b0\u00bf\u00e0\u00b0\u00b7\u00e0\u00b0\u00be\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00e0\u00b0\u00a8\u00e0\u00b0\u00bf\u00e0\u00b0\u00ae\u00e0\u00b0\u00bf\u00e0\u00b0\u00b7\u00e0\u00b0\u00be\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u0097\u00e0\u00b0\u0082\u00e0\u00b0\u009f',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u0097\u00e0\u00b0\u0082\u00e0\u00b0\u009f',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00e0\u00b0\u0097\u00e0\u00b0\u0082\u00e0\u00b0\u009f\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00e0\u00b0\u0097\u00e0\u00b0\u0082\u00e0\u00b0\u009f\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00e0\u00b0\u0097\u00e0\u00b0\u0082\u00e0\u00b0\u009f\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u00b0\u00e0\u00b1\u008b\u00e0\u00b0\u009c\u00e0\u00b1\u0081',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u00b0\u00e0\u00b1\u008b\u00e0\u00b0\u009c\u00e0\u00b1\u0081',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00e0\u00b0\u00b0\u00e0\u00b1\u008b\u00e0\u00b0\u009c\u00e0\u00b1\u0081\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u00b0\u00e0\u00b1\u008b\u00e0\u00b0\u009c\u00e0\u00b1\u0081',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00e0\u00b0\u00b0\u00e0\u00b1\u008b\u00e0\u00b0\u009c\u00e0\u00b1\u0081\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00e0\u00b0\u00b0\u00e0\u00b1\u008b\u00e0\u00b0\u009c\u00e0\u00b1\u0081\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u00a8\u00e0\u00b1\u0086\u00e0\u00b0\u00b2',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u00a8\u00e0\u00b1\u0086\u00e0\u00b0\u00b2',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u00a8\u00e0\u00b1\u0086\u00e0\u00b0\u00b2',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00e0\u00b0\u00a8\u00e0\u00b1\u0086\u00e0\u00b0\u00b2\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00e0\u00b0\u00a8\u00e0\u00b1\u0086\u00e0\u00b0\u00b2\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00e0\u00b0\u00a8\u00e0\u00b1\u0086\u00e0\u00b0\u00b2\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u00a8\u00e0\u00b1\u0086\u00e0\u00b0\u00b2',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00e0\u00b0\u00a8\u00e0\u00b1\u0086\u00e0\u00b0\u00b2\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u00b8\u00e0\u00b0\u0082\u00e0\u00b0\u00b5\u00e0\u00b0\u00a4\u00e0\u00b1\u008d\u00e0\u00b0\u00b8\u00e0\u00b0\u00b0\u00e0\u00b0\u0082',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00e0\u00b0\u00b8\u00e0\u00b0\u0082\u00e0\u00b0\u00b5\u00e0\u00b0\u00a4\u00e0\u00b1\u008d\u00e0\u00b0\u00b8\u00e0\u00b0\u00b0\u00e0\u00b0\u00be\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00e0\u00b0\u0092\u00e0\u00b0\u0095 \u00e0\u00b0\u00b8\u00e0\u00b0\u0082\u00e0\u00b0\u00b5\u00e0\u00b0\u00a4\u00e0\u00b1\u008d\u00e0\u00b0\u00b8\u00e0\u00b0\u00b0\u00e0\u00b0\u0082',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00e0\u00b0\u00b8\u00e0\u00b0\u0082\u00e0\u00b0\u00b5\u00e0\u00b0\u00a4\u00e0\u00b1\u008d\u00e0\u00b0\u00b8\u00e0\u00b0\u00b0\u00e0\u00b0\u00be\u00e0\u00b0\u00b2\u00e0\u00b1\u0081',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e0\u00b0\u0095\u00e0\u00b1\u008a\u00e0\u00b0\u00a8\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u00bf \u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u00b7\u00e0\u00b0\u00a3\u00e0\u00b0\u00be\u00e0\u00b0\u00b2\u00e0\u00b1\u0081 \u00e0\u00b0\u00b2\u00e0\u00b1\u008b',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e0\u00b0\u0095\u00e0\u00b1\u008a\u00e0\u00b0\u00a8\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u00bf \u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u00b7\u00e0\u00b0\u00a3\u00e0\u00b0\u00be\u00e0\u00b0\u00b2\u00e0\u00b1\u0081 \u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf\u00e0\u00b0\u00a4\u00e0\u00b0\u0082', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e0\u00b0\u0095\u00e0\u00b1\u008a\u00e0\u00b0\u00a8\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u00bf \u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u00b7\u00e0\u00b0\u00a3\u00e0\u00b0\u00be\u00e0\u00b0\u00b2\u00e0\u00b1\u0081 \u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf\u00e0\u00b0\u00a4\u00e0\u00b0\u0082',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e0\u00b0\u0095\u00e0\u00b1\u008a\u00e0\u00b0\u00a8\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u00bf \u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u00b7\u00e0\u00b0\u00a3\u00e0\u00b0\u00be\u00e0\u00b0\u00b2\u00e0\u00b1\u0081 \u00e0\u00b0\u00b2\u00e0\u00b1\u008b', '\u00e0\u00b0\u0095\u00e0\u00b1\u008a\u00e0\u00b0\u00a8\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u00bf \u00e0\u00b0\u0095\u00e0\u00b1\u008d\u00e0\u00b0\u00b7\u00e0\u00b0\u00a3\u00e0\u00b0\u00be\u00e0\u00b0\u00b2\u00e0\u00b1\u0081 \u00e0\u00b0\u00b2\u00e0\u00b1\u008b');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 \u00e0\u00b0\u00b0\u00e0\u00b1\u008b\u00e0\u00b0\u009c\u00e0\u00b1\u0081\u00e0\u00b0\u00b2\u00e0\u00b1\u0081 \u00e0\u00b0\u00b2\u00e0\u00b1\u008b', '5 \u00e0\u00b0\u00b0\u00e0\u00b1\u008b\u00e0\u00b0\u009c\u00e0\u00b1\u0081\u00e0\u00b0\u00b2\u00e0\u00b1\u0081 \u00e0\u00b0\u00b2\u00e0\u00b1\u008b');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e0\u00b0\u00a8\u00e0\u00b1\u0087\u00e0\u00b0\u00a1\u00e0\u00b1\u0081 \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 12:00',   'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e0\u00b0\u00a8\u00e0\u00b1\u0087\u00e0\u00b0\u00a1\u00e0\u00b1\u0081 \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 12:25',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 3}).calendar(),       '\u00e0\u00b0\u00a8\u00e0\u00b1\u0087\u00e0\u00b0\u00a1\u00e0\u00b1\u0081 \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 3:00',    'Now plus 3 hours');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e0\u00b0\u00b0\u00e0\u00b1\u0087\u00e0\u00b0\u00aa\u00e0\u00b1\u0081 \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 12:00',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e0\u00b0\u00a8\u00e0\u00b1\u0087\u00e0\u00b0\u00a1\u00e0\u00b1\u0081 \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 11:00',   'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e0\u00b0\u00a8\u00e0\u00b0\u00bf\u00e0\u00b0\u00a8\u00e0\u00b1\u008d\u00e0\u00b0\u00a8 \u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082 12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00b0\u0097\u00e0\u00b0\u00a4] dddd[,] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00b0\u0097\u00e0\u00b0\u00a4] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00b0\u0097\u00e0\u00b0\u00a4] dddd[,] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('meridiem', function (assert) {\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '\u00e0\u00b0\u00b0\u00e0\u00b0\u00be\u00e0\u00b0\u00a4\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '\u00e0\u00b0\u0089\u00e0\u00b0\u00a6\u00e0\u00b0\u00af\u00e0\u00b0\u0082', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '\u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082', 'during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '\u00e0\u00b0\u00b8\u00e0\u00b0\u00be\u00e0\u00b0\u00af\u00e0\u00b0\u0082\u00e0\u00b0\u00a4\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u0082', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '\u00e0\u00b0\u00b8\u00e0\u00b0\u00be\u00e0\u00b0\u00af\u00e0\u00b0\u0082\u00e0\u00b0\u00a4\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u0082', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '\u00e0\u00b0\u00b0\u00e0\u00b0\u00be\u00e0\u00b0\u00a4\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf', 'night');\n\n        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '\u00e0\u00b0\u00b0\u00e0\u00b0\u00be\u00e0\u00b0\u00a4\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '\u00e0\u00b0\u0089\u00e0\u00b0\u00a6\u00e0\u00b0\u00af\u00e0\u00b0\u0082', 'morning');\n        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '\u00e0\u00b0\u00ae\u00e0\u00b0\u00a7\u00e0\u00b1\u008d\u00e0\u00b0\u00af\u00e0\u00b0\u00be\u00e0\u00b0\u00b9\u00e0\u00b1\u008d\u00e0\u00b0\u00a8\u00e0\u00b0\u0082', ' during day');\n        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '\u00e0\u00b0\u00b8\u00e0\u00b0\u00be\u00e0\u00b0\u00af\u00e0\u00b0\u0082\u00e0\u00b0\u00a4\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u0082', 'evening');\n        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '\u00e0\u00b0\u00b8\u00e0\u00b0\u00be\u00e0\u00b0\u00af\u00e0\u00b0\u0082\u00e0\u00b0\u00a4\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u0082', 'late evening');\n        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '\u00e0\u00b0\u00b0\u00e0\u00b0\u00be\u00e0\u00b0\u00a4\u00e0\u00b1\u008d\u00e0\u00b0\u00b0\u00e0\u00b0\u00bf', 'night');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1\u00e0\u00b0\u00b5', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1\u00e0\u00b0\u00b5', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2\u00e0\u00b0\u00b5', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2\u00e0\u00b0\u00b5', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3\u00e0\u00b0\u00b5', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('th');\n\n    test('parse', function (assert) {\n        var tests = '\u00e0\u00b8\u00a1\u00e0\u00b8\u0081\u00e0\u00b8\u00a3\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u00a1\u00e0\u00b8\u0081\u00e0\u00b8\u00a3\u00e0\u00b8\u00b2_\u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2\u00e0\u00b8\u009e\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0098\u00e0\u00b9\u008c \u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2_\u00e0\u00b8\u00a1\u00e0\u00b8\u00b5\u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u00a1\u00e0\u00b8\u00b5\u00e0\u00b8\u0099\u00e0\u00b8\u00b2_\u00e0\u00b9\u0080\u00e0\u00b8\u00a1\u00e0\u00b8\u00a9\u00e0\u00b8\u00b2\u00e0\u00b8\u00a2\u00e0\u00b8\u0099 \u00e0\u00b9\u0080\u00e0\u00b8\u00a1\u00e0\u00b8\u00a9\u00e0\u00b8\u00b2_\u00e0\u00b8\u009e\u00e0\u00b8\u00a4\u00e0\u00b8\u00a9\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u009e\u00e0\u00b8\u00a4\u00e0\u00b8\u00a9\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2_\u00e0\u00b8\u00a1\u00e0\u00b8\u00b4\u00e0\u00b8\u0096\u00e0\u00b8\u00b8\u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00a2\u00e0\u00b8\u0099 \u00e0\u00b8\u00a1\u00e0\u00b8\u00b4\u00e0\u00b8\u0096\u00e0\u00b8\u00b8\u00e0\u00b8\u0099\u00e0\u00b8\u00b2_\u00e0\u00b8\u0081\u00e0\u00b8\u00a3\u00e0\u00b8\u0081\u00e0\u00b8\u008e\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u0081\u00e0\u00b8\u00a3\u00e0\u00b8\u0081\u00e0\u00b8\u008e\u00e0\u00b8\u00b2_\u00e0\u00b8\u00aa\u00e0\u00b8\u00b4\u00e0\u00b8\u0087\u00e0\u00b8\u00ab\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u00aa\u00e0\u00b8\u00b4\u00e0\u00b8\u0087\u00e0\u00b8\u00ab\u00e0\u00b8\u00b2_\u00e0\u00b8\u0081\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u00a2\u00e0\u00b8\u00b2\u00e0\u00b8\u00a2\u00e0\u00b8\u0099 \u00e0\u00b8\u0081\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u00a2\u00e0\u00b8\u00b2_\u00e0\u00b8\u0095\u00e0\u00b8\u00b8\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u0095\u00e0\u00b8\u00b8\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2_\u00e0\u00b8\u009e\u00e0\u00b8\u00a4\u00e0\u00b8\u00a8\u00e0\u00b8\u0088\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2\u00e0\u00b8\u00a2\u00e0\u00b8\u0099 \u00e0\u00b8\u009e\u00e0\u00b8\u00a4\u00e0\u00b8\u00a8\u00e0\u00b8\u0088\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2_\u00e0\u00b8\u0098\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u00a7\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u0098\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u00a7\u00e0\u00b8\u00b2'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, h:mm:ss a',      '\u00e0\u00b8\u00ad\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b4\u00e0\u00b8\u0095\u00e0\u00b8\u00a2\u00e0\u00b9\u008c, 14 \u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2\u00e0\u00b8\u009e\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0098\u00e0\u00b9\u008c 2010, 3:25:50 \u00e0\u00b8\u00ab\u00e0\u00b8\u00a5\u00e0\u00b8\u00b1\u00e0\u00b8\u0087\u00e0\u00b9\u0080\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b8\u00a2\u00e0\u00b8\u0087'],\n                ['ddd, h A',                           '\u00e0\u00b8\u00ad\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b4\u00e0\u00b8\u0095\u00e0\u00b8\u00a2\u00e0\u00b9\u008c, 3 \u00e0\u00b8\u00ab\u00e0\u00b8\u00a5\u00e0\u00b8\u00b1\u00e0\u00b8\u0087\u00e0\u00b9\u0080\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b8\u00a2\u00e0\u00b8\u0087'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 \u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2\u00e0\u00b8\u009e\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0098\u00e0\u00b9\u008c \u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 \u00e0\u00b8\u00ad\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b4\u00e0\u00b8\u0095\u00e0\u00b8\u00a2\u00e0\u00b9\u008c \u00e0\u00b8\u00ad\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b4\u00e0\u00b8\u0095\u00e0\u00b8\u00a2\u00e0\u00b9\u008c \u00e0\u00b8\u00ad\u00e0\u00b8\u00b2.'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '8 8 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00e0\u00b8\u00ab\u00e0\u00b8\u00a5\u00e0\u00b8\u00b1\u00e0\u00b8\u0087\u00e0\u00b9\u0080\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b8\u00a2\u00e0\u00b8\u0087 \u00e0\u00b8\u00ab\u00e0\u00b8\u00a5\u00e0\u00b8\u00b1\u00e0\u00b8\u0087\u00e0\u00b9\u0080\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b8\u00a2\u00e0\u00b8\u0087'],\n                ['[the] DDDo [day of the year]',       'the 45 day of the year'],\n                ['LTS',                                '15 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00ac\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2 25 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5 50 \u00e0\u00b8\u00a7\u00e0\u00b8\u00b4\u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5'],\n                ['L',                                  '2010/02/14'],\n                ['LL',                                 '14 \u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2\u00e0\u00b8\u009e\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0098\u00e0\u00b9\u008c 2010'],\n                ['LLL',                                '14 \u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2\u00e0\u00b8\u009e\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0098\u00e0\u00b9\u008c 2010 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2 15 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00ac\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2 25 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5'],\n                ['LLLL',                               '\u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u00ad\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b4\u00e0\u00b8\u0095\u00e0\u00b8\u00a2\u00e0\u00b9\u008c\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b9\u0088 14 \u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2\u00e0\u00b8\u009e\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0098\u00e0\u00b9\u008c 2010 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2 15 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00ac\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2 25 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5'],\n                ['l',                                  '2010/2/14'],\n                ['ll',                                 '14 \u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2 2010'],\n                ['lll',                                '14 \u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2 2010 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2 15 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00ac\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2 25 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5'],\n                ['llll',                               '\u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u00ad\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b4\u00e0\u00b8\u0095\u00e0\u00b8\u00a2\u00e0\u00b9\u008c\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b9\u0088 14 \u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2 2010 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2 15 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00ac\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2 25 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e0\u00b8\u00a1\u00e0\u00b8\u0081\u00e0\u00b8\u00a3\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u00a1\u00e0\u00b8\u0081\u00e0\u00b8\u00a3\u00e0\u00b8\u00b2_\u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2\u00e0\u00b8\u009e\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0098\u00e0\u00b9\u008c \u00e0\u00b8\u0081\u00e0\u00b8\u00b8\u00e0\u00b8\u00a1\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2_\u00e0\u00b8\u00a1\u00e0\u00b8\u00b5\u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u00a1\u00e0\u00b8\u00b5\u00e0\u00b8\u0099\u00e0\u00b8\u00b2_\u00e0\u00b9\u0080\u00e0\u00b8\u00a1\u00e0\u00b8\u00a9\u00e0\u00b8\u00b2\u00e0\u00b8\u00a2\u00e0\u00b8\u0099 \u00e0\u00b9\u0080\u00e0\u00b8\u00a1\u00e0\u00b8\u00a9\u00e0\u00b8\u00b2_\u00e0\u00b8\u009e\u00e0\u00b8\u00a4\u00e0\u00b8\u00a9\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u009e\u00e0\u00b8\u00a4\u00e0\u00b8\u00a9\u00e0\u00b8\u00a0\u00e0\u00b8\u00b2_\u00e0\u00b8\u00a1\u00e0\u00b8\u00b4\u00e0\u00b8\u0096\u00e0\u00b8\u00b8\u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00a2\u00e0\u00b8\u0099 \u00e0\u00b8\u00a1\u00e0\u00b8\u00b4\u00e0\u00b8\u0096\u00e0\u00b8\u00b8\u00e0\u00b8\u0099\u00e0\u00b8\u00b2_\u00e0\u00b8\u0081\u00e0\u00b8\u00a3\u00e0\u00b8\u0081\u00e0\u00b8\u008e\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u0081\u00e0\u00b8\u00a3\u00e0\u00b8\u0081\u00e0\u00b8\u008e\u00e0\u00b8\u00b2_\u00e0\u00b8\u00aa\u00e0\u00b8\u00b4\u00e0\u00b8\u0087\u00e0\u00b8\u00ab\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u00aa\u00e0\u00b8\u00b4\u00e0\u00b8\u0087\u00e0\u00b8\u00ab\u00e0\u00b8\u00b2_\u00e0\u00b8\u0081\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u00a2\u00e0\u00b8\u00b2\u00e0\u00b8\u00a2\u00e0\u00b8\u0099 \u00e0\u00b8\u0081\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u00a2\u00e0\u00b8\u00b2_\u00e0\u00b8\u0095\u00e0\u00b8\u00b8\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u0095\u00e0\u00b8\u00b8\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2_\u00e0\u00b8\u009e\u00e0\u00b8\u00a4\u00e0\u00b8\u00a8\u00e0\u00b8\u0088\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2\u00e0\u00b8\u00a2\u00e0\u00b8\u0099 \u00e0\u00b8\u009e\u00e0\u00b8\u00a4\u00e0\u00b8\u00a8\u00e0\u00b8\u0088\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2_\u00e0\u00b8\u0098\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u00a7\u00e0\u00b8\u00b2\u00e0\u00b8\u0084\u00e0\u00b8\u00a1 \u00e0\u00b8\u0098\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u00a7\u00e0\u00b8\u00b2'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e0\u00b8\u00ad\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b4\u00e0\u00b8\u0095\u00e0\u00b8\u00a2\u00e0\u00b9\u008c \u00e0\u00b8\u00ad\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b4\u00e0\u00b8\u0095\u00e0\u00b8\u00a2\u00e0\u00b9\u008c \u00e0\u00b8\u00ad\u00e0\u00b8\u00b2._\u00e0\u00b8\u0088\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0097\u00e0\u00b8\u00a3\u00e0\u00b9\u008c \u00e0\u00b8\u0088\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0097\u00e0\u00b8\u00a3\u00e0\u00b9\u008c \u00e0\u00b8\u0088._\u00e0\u00b8\u00ad\u00e0\u00b8\u00b1\u00e0\u00b8\u0087\u00e0\u00b8\u0084\u00e0\u00b8\u00b2\u00e0\u00b8\u00a3 \u00e0\u00b8\u00ad\u00e0\u00b8\u00b1\u00e0\u00b8\u0087\u00e0\u00b8\u0084\u00e0\u00b8\u00b2\u00e0\u00b8\u00a3 \u00e0\u00b8\u00ad._\u00e0\u00b8\u009e\u00e0\u00b8\u00b8\u00e0\u00b8\u0098 \u00e0\u00b8\u009e\u00e0\u00b8\u00b8\u00e0\u00b8\u0098 \u00e0\u00b8\u009e._\u00e0\u00b8\u009e\u00e0\u00b8\u00a4\u00e0\u00b8\u00ab\u00e0\u00b8\u00b1\u00e0\u00b8\u00aa\u00e0\u00b8\u009a\u00e0\u00b8\u0094\u00e0\u00b8\u00b5 \u00e0\u00b8\u009e\u00e0\u00b8\u00a4\u00e0\u00b8\u00ab\u00e0\u00b8\u00b1\u00e0\u00b8\u00aa \u00e0\u00b8\u009e\u00e0\u00b8\u00a4._\u00e0\u00b8\u00a8\u00e0\u00b8\u00b8\u00e0\u00b8\u0081\u00e0\u00b8\u00a3\u00e0\u00b9\u008c \u00e0\u00b8\u00a8\u00e0\u00b8\u00b8\u00e0\u00b8\u0081\u00e0\u00b8\u00a3\u00e0\u00b9\u008c \u00e0\u00b8\u00a8._\u00e0\u00b9\u0080\u00e0\u00b8\u00aa\u00e0\u00b8\u00b2\u00e0\u00b8\u00a3\u00e0\u00b9\u008c \u00e0\u00b9\u0080\u00e0\u00b8\u00aa\u00e0\u00b8\u00b2\u00e0\u00b8\u00a3\u00e0\u00b9\u008c \u00e0\u00b8\u00aa.'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e0\u00b9\u0084\u00e0\u00b8\u00a1\u00e0\u00b9\u0088\u00e0\u00b8\u0081\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b8\u00a7\u00e0\u00b8\u00b4\u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5',   '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5', '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5', '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1 \u00e0\u00b8\u008a\u00e0\u00b8\u00b1\u00e0\u00b9\u0088\u00e0\u00b8\u00a7\u00e0\u00b9\u0082\u00e0\u00b8\u00a1\u00e0\u00b8\u0087', '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1 \u00e0\u00b8\u008a\u00e0\u00b8\u00b1\u00e0\u00b9\u0088\u00e0\u00b8\u00a7\u00e0\u00b9\u0082\u00e0\u00b8\u00a1\u00e0\u00b8\u0087', '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00e0\u00b8\u008a\u00e0\u00b8\u00b1\u00e0\u00b9\u0088\u00e0\u00b8\u00a7\u00e0\u00b9\u0082\u00e0\u00b8\u00a1\u00e0\u00b8\u0087',  '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00e0\u00b8\u008a\u00e0\u00b8\u00b1\u00e0\u00b9\u0088\u00e0\u00b8\u00a7\u00e0\u00b9\u0082\u00e0\u00b8\u00a1\u00e0\u00b8\u0087',  '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00e0\u00b8\u008a\u00e0\u00b8\u00b1\u00e0\u00b9\u0088\u00e0\u00b8\u00a7\u00e0\u00b9\u0082\u00e0\u00b8\u00a1\u00e0\u00b8\u0087', '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 \u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099',   '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 \u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099',   '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099',   '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 \u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099',   '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099',   '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099',  '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1 \u00e0\u00b9\u0080\u00e0\u00b8\u0094\u00e0\u00b8\u00b7\u00e0\u00b8\u00ad\u00e0\u00b8\u0099', '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1 \u00e0\u00b9\u0080\u00e0\u00b8\u0094\u00e0\u00b8\u00b7\u00e0\u00b8\u00ad\u00e0\u00b8\u0099', '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1 \u00e0\u00b9\u0080\u00e0\u00b8\u0094\u00e0\u00b8\u00b7\u00e0\u00b8\u00ad\u00e0\u00b8\u0099', '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00e0\u00b9\u0080\u00e0\u00b8\u0094\u00e0\u00b8\u00b7\u00e0\u00b8\u00ad\u00e0\u00b8\u0099',  '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00e0\u00b9\u0080\u00e0\u00b8\u0094\u00e0\u00b8\u00b7\u00e0\u00b8\u00ad\u00e0\u00b8\u0099',  '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00e0\u00b9\u0080\u00e0\u00b8\u0094\u00e0\u00b8\u00b7\u00e0\u00b8\u00ad\u00e0\u00b8\u0099',  '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1 \u00e0\u00b9\u0080\u00e0\u00b8\u0094\u00e0\u00b8\u00b7\u00e0\u00b8\u00ad\u00e0\u00b8\u0099', '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00e0\u00b9\u0080\u00e0\u00b8\u0094\u00e0\u00b8\u00b7\u00e0\u00b8\u00ad\u00e0\u00b8\u0099',  '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1 \u00e0\u00b8\u009b\u00e0\u00b8\u00b5',   '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00e0\u00b8\u009b\u00e0\u00b8\u00b5',   '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1 \u00e0\u00b8\u009b\u00e0\u00b8\u00b5',   '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00e0\u00b8\u009b\u00e0\u00b8\u00b5',   '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e0\u00b8\u00ad\u00e0\u00b8\u00b5\u00e0\u00b8\u0081 \u00e0\u00b9\u0084\u00e0\u00b8\u00a1\u00e0\u00b9\u0088\u00e0\u00b8\u0081\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b8\u00a7\u00e0\u00b8\u00b4\u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e0\u00b9\u0084\u00e0\u00b8\u00a1\u00e0\u00b9\u0088\u00e0\u00b8\u0081\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b8\u00a7\u00e0\u00b8\u00b4\u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b9\u0081\u00e0\u00b8\u00a5\u00e0\u00b9\u0089\u00e0\u00b8\u00a7', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e0\u00b9\u0084\u00e0\u00b8\u00a1\u00e0\u00b9\u0088\u00e0\u00b8\u0081\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b8\u00a7\u00e0\u00b8\u00b4\u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b9\u0081\u00e0\u00b8\u00a5\u00e0\u00b9\u0089\u00e0\u00b8\u00a7',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e0\u00b8\u00ad\u00e0\u00b8\u00b5\u00e0\u00b8\u0081 \u00e0\u00b9\u0084\u00e0\u00b8\u00a1\u00e0\u00b9\u0088\u00e0\u00b8\u0081\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b8\u00a7\u00e0\u00b8\u00b4\u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00e0\u00b8\u00ad\u00e0\u00b8\u00b5\u00e0\u00b8\u0081 5 \u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0099\u00e0\u00b8\u00b5\u00e0\u00b9\u0089 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2 12 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00ac\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2 0 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5',      'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0099\u00e0\u00b8\u00b5\u00e0\u00b9\u0089 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2 12 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00ac\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2 25 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0099\u00e0\u00b8\u00b5\u00e0\u00b9\u0089 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2 13 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00ac\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2 0 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e0\u00b8\u009e\u00e0\u00b8\u00a3\u00e0\u00b8\u00b8\u00e0\u00b9\u0088\u00e0\u00b8\u0087\u00e0\u00b8\u0099\u00e0\u00b8\u00b5\u00e0\u00b9\u0089 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2 12 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00ac\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2 0 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5',    'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099\u00e0\u00b8\u0099\u00e0\u00b8\u00b5\u00e0\u00b9\u0089 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2 11 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00ac\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2 0 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5',      'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e0\u00b9\u0080\u00e0\u00b8\u00a1\u00e0\u00b8\u00b7\u00e0\u00b9\u0088\u00e0\u00b8\u00ad\u00e0\u00b8\u00a7\u00e0\u00b8\u00b2\u00e0\u00b8\u0099\u00e0\u00b8\u0099\u00e0\u00b8\u00b5\u00e0\u00b9\u0089 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2 12 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u00ac\u00e0\u00b8\u00b4\u00e0\u00b8\u0081\u00e0\u00b8\u00b2 0 \u00e0\u00b8\u0099\u00e0\u00b8\u00b2\u00e0\u00b8\u0097\u00e0\u00b8\u00b5', 'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd[\u00e0\u00b8\u00ab\u00e0\u00b8\u0099\u00e0\u00b9\u0089\u00e0\u00b8\u00b2 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd[\u00e0\u00b8\u00ab\u00e0\u00b8\u0099\u00e0\u00b9\u0089\u00e0\u00b8\u00b2 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd[\u00e0\u00b8\u00ab\u00e0\u00b8\u0099\u00e0\u00b9\u0089\u00e0\u00b8\u00b2 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099]dddd[\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b9\u0081\u00e0\u00b8\u00a5\u00e0\u00b9\u0089\u00e0\u00b8\u00a7 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099]dddd[\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b9\u0081\u00e0\u00b8\u00a5\u00e0\u00b9\u0089\u00e0\u00b8\u00a7 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e0\u00b8\u00a7\u00e0\u00b8\u00b1\u00e0\u00b8\u0099]dddd[\u00e0\u00b8\u0097\u00e0\u00b8\u00b5\u00e0\u00b9\u0088\u00e0\u00b9\u0081\u00e0\u00b8\u00a5\u00e0\u00b9\u0089\u00e0\u00b8\u00a7 \u00e0\u00b9\u0080\u00e0\u00b8\u00a7\u00e0\u00b8\u00a5\u00e0\u00b8\u00b2] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('tl-ph');\n\n    test('parse', function (assert) {\n        var tests = 'Enero Ene_Pebrero Peb_Marso Mar_Abril Abr_Mayo May_Hunyo Hun_Hulyo Hul_Agosto Ago_Setyembre Set_Oktubre Okt_Nobyembre Nob_Disyembre Dis'.split('_'),\n            i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Linggo, Pebrero 14 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Lin, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 Pebrero Peb'],\n                ['YYYY YY',                             '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 Linggo Lin Li'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '6 6 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45 day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '02/14/2010'],\n                ['LL',                                 'Pebrero 14, 2010'],\n                ['LLL',                                'Pebrero 14, 2010 15:25'],\n                ['LLLL',                               'Linggo, Pebrero 14, 2010 15:25'],\n                ['l',                                  '2/14/2010'],\n                ['ll',                                 'Peb 14, 2010'],\n                ['lll',                                'Peb 14, 2010 15:25'],\n                ['llll',                               'Lin, Peb 14, 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Enero Ene_Pebrero Peb_Marso Mar_Abril Abr_Mayo May_Hunyo Hun_Hulyo Hul_Agosto Ago_Setyembre Set_Oktubre Okt_Nobyembre Nob_Disyembre Dis'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Linggo Lin Li_Lunes Lun Lu_Martes Mar Ma_Miyerkules Miy Mi_Huwebes Huw Hu_Biyernes Biy Bi_Sabado Sab Sab'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ilang segundo', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'isang minuto',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'isang minuto',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuto',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuto', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'isang oras',    '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'isang oras',    '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 oras',    '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 oras',    '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 oras',   '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'isang araw',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'isang araw',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 araw',     '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'isang araw',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 araw',     '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 araw',    '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'isang buwan',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'isang buwan',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'isang buwan',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 buwan',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 buwan',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 buwan',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'isang buwan',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 buwan',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'isang taon',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 taon',    '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'isang taon',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 taon',    '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'sa loob ng ilang segundo', 'prefix');\n        assert.equal(moment(0).from(30000), 'ilang segundo ang nakalipas', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'sa loob ng ilang segundo', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'sa loob ng 5 araw', 'in 5 days');\n    });\n\n    test('same day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Ngayon sa 12:00',    'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Ngayon sa 12:25',    'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Ngayon sa 13:00',    'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Bukas sa 12:00',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ngayon sa 11:00',    'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kahapon sa 12:00',   'yesterday at the same time');\n    });\n\n    test('same next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [sa] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [sa] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [sa] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('same last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [huling linggo] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [huling linggo] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [huling linggo] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('same all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('tlh');\n\n    //Current parsing method doesn't allow parsing correctly months 10, 11 and 12.\n    /*\n     * test('parse', function (assert) {\n        var tests = 'tera\u00e2\u0080\u0099 jar wa\u00e2\u0080\u0099.jar wa\u00e2\u0080\u0099_tera\u00e2\u0080\u0099 jar cha\u00e2\u0080\u0099.jar cha\u00e2\u0080\u0099_tera\u00e2\u0080\u0099 jar wej.jar wej_tera\u00e2\u0080\u0099 jar loS.jar loS_tera\u00e2\u0080\u0099 jar vagh.jar vagh_tera\u00e2\u0080\u0099 jar jav.jar jav_tera\u00e2\u0080\u0099 jar Soch.jar Soch_tera\u00e2\u0080\u0099 jar chorgh.jar chorgh_tera\u00e2\u0080\u0099 jar Hut.jar Hut_tera\u00e2\u0080\u0099 jar wa\u00e2\u0080\u0099maH.jar wa\u00e2\u0080\u0099maH_tera\u00e2\u0080\u0099 jar wa\u00e2\u0080\u0099maH wa\u00e2\u0080\u0099.jar wa\u00e2\u0080\u0099maH wa\u00e2\u0080\u0099_tera\u00e2\u0080\u0099 jar wa\u00e2\u0080\u0099maH cha\u00e2\u0080\u0099.jar wa\u00e2\u0080\u0099maH cha\u00e2\u0080\u0099'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split('.');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n    */\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'lojmItjaj, tera\u00e2\u0080\u0099 jar cha\u00e2\u0080\u0099 14. 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'lojmItjaj, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 tera\u00e2\u0080\u0099 jar cha\u00e2\u0080\u0099 jar cha\u00e2\u0080\u0099'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. lojmItjaj lojmItjaj lojmItjaj'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[DIS jaj] DDDo',                     'DIS jaj 45.'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 tera\u00e2\u0080\u0099 jar cha\u00e2\u0080\u0099 2010'],\n                ['LLL',                                '14 tera\u00e2\u0080\u0099 jar cha\u00e2\u0080\u0099 2010 15:25'],\n                ['LLLL',                               'lojmItjaj, 14 tera\u00e2\u0080\u0099 jar cha\u00e2\u0080\u0099 2010 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 jar cha\u00e2\u0080\u0099 2010'],\n                ['lll',                                '14 jar cha\u00e2\u0080\u0099 2010 15:25'],\n                ['llll',                               'lojmItjaj, 14 jar cha\u00e2\u0080\u0099 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'tera\u00e2\u0080\u0099 jar wa\u00e2\u0080\u0099 jar wa\u00e2\u0080\u0099_tera\u00e2\u0080\u0099 jar cha\u00e2\u0080\u0099 jar cha\u00e2\u0080\u0099_tera\u00e2\u0080\u0099 jar wej jar wej_tera\u00e2\u0080\u0099 jar loS jar loS_tera\u00e2\u0080\u0099 jar vagh jar vagh_tera\u00e2\u0080\u0099 jar jav jar jav_tera\u00e2\u0080\u0099 jar Soch jar Soch_tera\u00e2\u0080\u0099 jar chorgh jar chorgh_tera\u00e2\u0080\u0099 jar Hut jar Hut_tera\u00e2\u0080\u0099 jar wa\u00e2\u0080\u0099maH jar wa\u00e2\u0080\u0099maH_tera\u00e2\u0080\u0099 jar wa\u00e2\u0080\u0099maH wa\u00e2\u0080\u0099 jar wa\u00e2\u0080\u0099maH wa\u00e2\u0080\u0099_tera\u00e2\u0080\u0099 jar wa\u00e2\u0080\u0099maH cha\u00e2\u0080\u0099 jar wa\u00e2\u0080\u0099maH cha\u00e2\u0080\u0099'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'lojmItjaj lojmItjaj lojmItjaj_DaSjaj DaSjaj DaSjaj_povjaj povjaj povjaj_ghItlhjaj ghItlhjaj ghItlhjaj_loghjaj loghjaj loghjaj_buqjaj buqjaj buqjaj_ghInjaj ghInjaj ghInjaj'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'puS lup',  '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'wa\u00e2\u0080\u0099 tup',        '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'wa\u00e2\u0080\u0099 tup',        '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'cha\u00e2\u0080\u0099 tup',      '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  'loSmaH loS tup',     '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'wa\u00e2\u0080\u0099 rep',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'wa\u00e2\u0080\u0099 rep',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'cha\u00e2\u0080\u0099 rep',     '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'vagh rep',      '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  'cha\u00e2\u0080\u0099maH wa\u00e2\u0080\u0099 rep',     '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'wa\u00e2\u0080\u0099 jaj',       '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'wa\u00e2\u0080\u0099 jaj',       '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'cha\u00e2\u0080\u0099 jaj',         '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'wa\u00e2\u0080\u0099 jaj',       '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'vagh jaj',         '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  'cha\u00e2\u0080\u0099maH vagh jaj',        '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'wa\u00e2\u0080\u0099 jar',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'wa\u00e2\u0080\u0099 jar',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'wa\u00e2\u0080\u0099 jar',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'cha\u00e2\u0080\u0099 jar',    '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'cha\u00e2\u0080\u0099 jar',    '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'wej jar',    '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'wa\u00e2\u0080\u0099 jar',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'vagh jar',    '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'wa\u00e2\u0080\u0099 DIS',           '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'cha\u00e2\u0080\u0099 DIS',        '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'wa\u00e2\u0080\u0099 DIS',           '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'vagh DIS',         '5 years = 5 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 112}), true), 'wa\u00e2\u0080\u0099vatlh wa\u00e2\u0080\u0099maH cha\u00e2\u0080\u0099 DIS',       '112 years = 112 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 122}), true), 'wa\u00e2\u0080\u0099vatlh cha\u00e2\u0080\u0099maH cha\u00e2\u0080\u0099 DIS',      '122 years = 122 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 213}), true), 'cha\u00e2\u0080\u0099vatlh wa\u00e2\u0080\u0099maH wej DIS',       '213 years = 213 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 223}), true), 'cha\u00e2\u0080\u0099vatlh cha\u00e2\u0080\u0099maH wej DIS',      '223 years = 223 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'puS lup pIq',  'suffix');\n        assert.equal(moment(0).from(30000), 'puS lup ret', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'puS lup ret',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'puS lup pIq', 'in a few seconds');\n        assert.equal(moment().add({h: 1}).fromNow(), 'wa\u00e2\u0080\u0099 rep pIq', 'in an hour');\n        assert.equal(moment().add({d: 5}).fromNow(), 'vagh leS', 'in 5 days');\n        assert.equal(moment().add({M: 2}).fromNow(), 'cha\u00e2\u0080\u0099 waQ', 'in 2 months');\n        assert.equal(moment().add({y: 1}).fromNow(), 'wa\u00e2\u0080\u0099 nem', 'in a year');\n        assert.equal(moment().add({s: -30}).fromNow(), 'puS lup ret', 'a few seconds ago');\n        assert.equal(moment().add({h: -1}).fromNow(), 'wa\u00e2\u0080\u0099 rep ret', 'an hour ago');\n        assert.equal(moment().add({d: -5}).fromNow(), 'vagh Hu\u00e2\u0080\u0099', '5 days ago');\n        assert.equal(moment().add({M: -2}).fromNow(), 'cha\u00e2\u0080\u0099 wen', '2 months ago');\n        assert.equal(moment().add({y: -1}).fromNow(), 'wa\u00e2\u0080\u0099 ben', 'a year ago');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'DaHjaj 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'DaHjaj 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'DaHjaj 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'wa\u00e2\u0080\u0099leS 12:00',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'DaHjaj 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'wa\u00e2\u0080\u0099Hu\u00e2\u0080\u0099 12:00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('LLL'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('LLL'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('LLL'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(), m.format('LLL'), 'Today - ' + i + ' days current time');\n\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(), m.format('LLL'), 'Today - ' + i + ' days beginning of day');\n\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(), m.format('LLL'), 'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('tr');\n\n    test('parse', function (assert) {\n        var tests = 'Ocak Oca_\u00c5\u009eubat \u00c5\u009eub_Mart Mar_Nisan Nis_May\u00c4\u00b1s May_Haziran Haz_Temmuz Tem_A\u00c4\u009fustos A\u00c4\u009fu_Eyl\u00c3\u00bcl Eyl_Ekim Eki_Kas\u00c4\u00b1m Kas_Aral\u00c4\u00b1k Ara'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Pazar, \u00c5\u009eubat 14\\'\u00c3\u00bcnc\u00c3\u00bc 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'Paz, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2\\'nci 02 \u00c5\u009eubat \u00c5\u009eub'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\\'\u00c3\u00bcnc\u00c3\u00bc 14'],\n                ['d do dddd ddd dd',                   '0 0\\'\u00c4\u00b1nc\u00c4\u00b1 Pazar Paz Pz'],\n                ['DDD DDDo DDDD',                      '45 45\\'inci 045'],\n                ['w wo ww',                            '7 7\\'nci 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[y\u00c4\u00b1l\u00c4\u00b1n] DDDo [g\u00c3\u00bcn\u00c3\u00bc]',                'y\u00c4\u00b1l\u00c4\u00b1n 45\\'inci g\u00c3\u00bcn\u00c3\u00bc'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 \u00c5\u009eubat 2010'],\n                ['LLL',                                '14 \u00c5\u009eubat 2010 15:25'],\n                ['LLLL',                               'Pazar, 14 \u00c5\u009eubat 2010 15:25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14 \u00c5\u009eub 2010'],\n                ['lll',                                '14 \u00c5\u009eub 2010 15:25'],\n                ['llll',                               'Paz, 14 \u00c5\u009eub 2010 15:25']\n            ],\n            DDDo = [\n                [359, '360\\'\u00c4\u00b1nc\u00c4\u00b1'],\n                [199, '200\\'\u00c3\u00bcnc\u00c3\u00bc'],\n                [149, '150\\'nci']\n            ],\n            dt = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            DDDoDt,\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(dt.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n        for (i = 0; i < DDDo.length; i++) {\n            DDDoDt = moment([2010]);\n            assert.equal(DDDoDt.add(DDDo[i][0], 'days').format('DDDo'), DDDo[i][1], DDDo[i][0] + ' ---> ' + DDDo[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1\\'inci', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2\\'nci', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3\\'\u00c3\u00bcnc\u00c3\u00bc', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4\\'\u00c3\u00bcnc\u00c3\u00bc', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\\'inci', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\\'nc\u00c4\u00b1', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\\'nci', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\\'inci', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\\'uncu', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\\'uncu', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\\'inci', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\\'nci', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\\'\u00c3\u00bcnc\u00c3\u00bc', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\\'\u00c3\u00bcnc\u00c3\u00bc', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\\'inci', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\\'nc\u00c4\u00b1', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\\'nci', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\\'inci', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\\'uncu', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\\'nci', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\\'inci', '21th');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\\'nci', '22th');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\\'\u00c3\u00bcnc\u00c3\u00bc', '23th');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\\'\u00c3\u00bcnc\u00c3\u00bc', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\\'inci', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\\'nc\u00c4\u00b1', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\\'nci', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\\'inci', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\\'uncu', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\\'uncu', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\\'inci', '31st');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Ocak Oca_\u00c5\u009eubat \u00c5\u009eub_Mart Mar_Nisan Nis_May\u00c4\u00b1s May_Haziran Haz_Temmuz Tem_A\u00c4\u009fustos A\u00c4\u009fu_Eyl\u00c3\u00bcl Eyl_Ekim Eki_Kas\u00c4\u00b1m Kas_Aral\u00c4\u00b1k Ara'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'Pazar Paz Pz_Pazartesi Pts Pt_Sal\u00c4\u00b1 Sal Sa_\u00c3\u0087ar\u00c5\u009famba \u00c3\u0087ar \u00c3\u0087a_Per\u00c5\u009fembe Per Pe_Cuma Cum Cu_Cumartesi Cts Ct'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'birka\u00c3\u00a7 saniye', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'bir dakika',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'bir dakika',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 dakika',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 dakika',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'bir saat',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'bir saat',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 saat',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 saat',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 saat',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'bir g\u00c3\u00bcn',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'bir g\u00c3\u00bcn',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 g\u00c3\u00bcn',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'bir g\u00c3\u00bcn',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 g\u00c3\u00bcn',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 g\u00c3\u00bcn',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'bir ay',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'bir ay',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'bir ay',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ay',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ay',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ay',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'bir ay',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ay',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'bir y\u00c4\u00b1l',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 y\u00c4\u00b1l',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'bir y\u00c4\u00b1l',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 y\u00c4\u00b1l',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'birka\u00c3\u00a7 saniye sonra',  'prefix');\n        assert.equal(moment(0).from(30000), 'birka\u00c3\u00a7 saniye \u00c3\u00b6nce', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'birka\u00c3\u00a7 saniye \u00c3\u00b6nce',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'birka\u00c3\u00a7 saniye sonra', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 g\u00c3\u00bcn sonra', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'bug\u00c3\u00bcn saat 12:00',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'bug\u00c3\u00bcn saat 12:25',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'bug\u00c3\u00bcn saat 13:00',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'yar\u00c4\u00b1n saat 12:00',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'bug\u00c3\u00bcn saat 11:00',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'd\u00c3\u00bcn 12:00',            'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[haftaya] dddd [saat] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[haftaya] dddd [saat] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[haftaya] dddd [saat] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[ge\u00c3\u00a7en hafta] dddd [saat] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[ge\u00c3\u00a7en hafta] dddd [saat] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[ge\u00c3\u00a7en hafta] dddd [saat] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1\\'inci', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1\\'inci', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2\\'nci', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2\\'nci', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3\\'\u00c3\u00bcnc\u00c3\u00bc', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('tzl');\n\n    test('parse', function (assert) {\n        var tests = 'Januar Jan_Fevraglh Fev_Mar\u00c3\u00a7 Mar_Avr\u00c3\u00afu Avr_Mai Mai_G\u00c3\u00bcn G\u00c3\u00bcn_Julia Jul_Guscht Gus_Setemvar Set_Listop\u00c3\u00a4ts Lis_Noemvar Noe_Zecemvar Zec'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h.mm.ss a',      'S\u00c3\u00baladi, Fevraglh 14. 2010, 3.25.50 d\\'o'],\n                ['ddd, hA',                            'S\u00c3\u00bal, 3D\\'O'],\n                ['M Mo MM MMMM MMM',                   '2 2. 02 Fevraglh Fev'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14. 14'],\n                ['d do dddd ddd dd',                   '0 0. S\u00c3\u00baladi S\u00c3\u00bal S\u00c3\u00ba'],\n                ['DDD DDDo DDDD',                      '45 45. 045'],\n                ['w wo ww',                            '6 6. 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'd\\'o D\\'O'],\n                ['[the] DDDo [day of the year]',       'the 45. day of the year'],\n                ['LTS',                                '15.25.50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14. Fevraglh dallas 2010'],\n                ['LLL',                                '14. Fevraglh dallas 2010 15.25'],\n                ['LLLL',                               'S\u00c3\u00baladi, li 14. Fevraglh dallas 2010 15.25'],\n                ['l',                                  '14.2.2010'],\n                ['ll',                                 '14. Fev dallas 2010'],\n                ['lll',                                '14. Fev dallas 2010 15.25'],\n                ['llll',                               'S\u00c3\u00bal, li 14. Fev dallas 2010 15.25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'Januar Jan_Fevraglh Fev_Mar\u00c3\u00a7 Mar_Avr\u00c3\u00afu Avr_Mai Mai_G\u00c3\u00bcn G\u00c3\u00bcn_Julia Jul_Guscht Gus_Setemvar Set_Listop\u00c3\u00a4ts Lis_Noemvar Noe_Zecemvar Zec'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'S\u00c3\u00baladi S\u00c3\u00bal S\u00c3\u00ba_L\u00c3\u00bane\u00c3\u00a7i L\u00c3\u00ban L\u00c3\u00ba_Maitzi Mai Ma_M\u00c3\u00a1rcuri M\u00c3\u00a1r M\u00c3\u00a1_Xh\u00c3\u00baadi Xh\u00c3\u00ba Xh_Vi\u00c3\u00a9ner\u00c3\u00a7i Vi\u00c3\u00a9 Vi_S\u00c3\u00a1turi S\u00c3\u00a1t S\u00c3\u00a1'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'viensas secunds', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\\'n m\u00c3\u00adut',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\\'n m\u00c3\u00adut',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 m\u00c3\u00aduts',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 m\u00c3\u00aduts',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\\'n \u00c3\u00beora',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\\'n \u00c3\u00beora',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00c3\u00beoras',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00c3\u00beoras',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00c3\u00beoras',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\\'n ziua',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\\'n ziua',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ziuas',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\\'n ziua',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ziuas',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ziuas',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\\'n mes',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\\'n mes',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\\'n mes',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesen',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesen',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesen',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\\'n mes',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesen',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\\'n ar',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ars',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\\'n ar',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ars',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'osprei viensas secunds',  'prefix');\n        assert.equal(moment(0).from(30000), 'ja\\'iensas secunds', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'ja\\'iensas secunds',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'osprei viensas secunds', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'osprei 5 ziuas', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'oxhi \u00c3\u00a0 12.00',      'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'oxhi \u00c3\u00a0 12.25',      'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'oxhi \u00c3\u00a0 13.00',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'dem\u00c3\u00a0 \u00c3\u00a0 12.00',      'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'oxhi \u00c3\u00a0 11.00',      'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ieiri \u00c3\u00a0 12.00',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a0] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[s\u00c3\u00bcr el] dddd [lasteu \u00c3\u00a0] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[s\u00c3\u00bcr el] dddd [lasteu \u00c3\u00a0] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[s\u00c3\u00bcr el] dddd [lasteu \u00c3\u00a0] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    // Monday is the first day of the week.\n    // The week that contains Jan 4th is the first week of the year.\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('tzm-latn');\n\n    test('parse', function (assert) {\n        var tests = 'innayr innayr_br\u00cb\u00a4ayr\u00cb\u00a4 br\u00cb\u00a4ayr\u00cb\u00a4_mar\u00cb\u00a4s\u00cb\u00a4 mar\u00cb\u00a4s\u00cb\u00a4_ibrir ibrir_mayyw mayyw_ywnyw ywnyw_ywlywz ywlywz_\u00c9\u00a3w\u00c5\u00a1t \u00c9\u00a3w\u00c5\u00a1t_\u00c5\u00a1wtanbir \u00c5\u00a1wtanbir_kt\u00cb\u00a4wbr\u00cb\u00a4 kt\u00cb\u00a4wbr\u00cb\u00a4_nwwanbir nwwanbir_dwjnbir dwjnbir'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'asamas, br\u00cb\u00a4ayr\u00cb\u00a4 14 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'asamas, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 br\u00cb\u00a4ayr\u00cb\u00a4 br\u00cb\u00a4ayr\u00cb\u00a4'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 asamas asamas asamas'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '8 8 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45 day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 br\u00cb\u00a4ayr\u00cb\u00a4 2010'],\n                ['LLL',                                '14 br\u00cb\u00a4ayr\u00cb\u00a4 2010 15:25'],\n                ['LLLL',                               'asamas 14 br\u00cb\u00a4ayr\u00cb\u00a4 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 br\u00cb\u00a4ayr\u00cb\u00a4 2010'],\n                ['lll',                                '14 br\u00cb\u00a4ayr\u00cb\u00a4 2010 15:25'],\n                ['llll',                               'asamas 14 br\u00cb\u00a4ayr\u00cb\u00a4 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'innayr innayr_br\u00cb\u00a4ayr\u00cb\u00a4 br\u00cb\u00a4ayr\u00cb\u00a4_mar\u00cb\u00a4s\u00cb\u00a4 mar\u00cb\u00a4s\u00cb\u00a4_ibrir ibrir_mayyw mayyw_ywnyw ywnyw_ywlywz ywlywz_\u00c9\u00a3w\u00c5\u00a1t \u00c9\u00a3w\u00c5\u00a1t_\u00c5\u00a1wtanbir \u00c5\u00a1wtanbir_kt\u00cb\u00a4wbr\u00cb\u00a4 kt\u00cb\u00a4wbr\u00cb\u00a4_nwwanbir nwwanbir_dwjnbir dwjnbir'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'asamas asamas asamas_aynas aynas aynas_asinas asinas asinas_akras akras akras_akwas akwas akwas_asimwas asimwas asimwas_asi\u00e1\u00b8\u008dyas asi\u00e1\u00b8\u008dyas asi\u00e1\u00b8\u008dyas'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'imik', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minu\u00e1\u00b8\u008d',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minu\u00e1\u00b8\u008d',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minu\u00e1\u00b8\u008d',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minu\u00e1\u00b8\u008d',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sa\u00c9\u009ba',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sa\u00c9\u009ba',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 tassa\u00c9\u009bin',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 tassa\u00c9\u009bin',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tassa\u00c9\u009bin',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ass',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ass',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ossan',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ass',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ossan',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ossan',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ayowr',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ayowr',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ayowr',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 iyyirn',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 iyyirn',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 iyyirn',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ayowr',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 iyyirn',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'asgas',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 isgasn',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'asgas',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 isgasn',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'dadkh s yan imik',  'prefix');\n        assert.equal(moment(0).from(30000), 'yan imik', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'yan imik',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'dadkh s yan imik', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), 'dadkh s yan 5 ossan', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'asdkh g 12:00',   'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'asdkh g 12:25',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'asdkh g 13:00',   'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'aska g 12:00',    'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'asdkh g 11:00',   'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'assant g 12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '1 01 1', 'Dec 31 2011 should be week 1');\n        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '1 01 1', 'Jan  6 2012 should be week 1');\n        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 should be week 2');\n        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '2 02 2', 'Jan 13 2012 should be week 2');\n        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('tzm');\n\n    test('parse', function (assert) {\n        var tests = '\u00e2\u00b5\u0089\u00e2\u00b5\u008f\u00e2\u00b5\u008f\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0094 \u00e2\u00b5\u0089\u00e2\u00b5\u008f\u00e2\u00b5\u008f\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0094_\u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095 \u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095_\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0095\u00e2\u00b5\u009a \u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0095\u00e2\u00b5\u009a_\u00e2\u00b5\u0089\u00e2\u00b4\u00b1\u00e2\u00b5\u0094\u00e2\u00b5\u0089\u00e2\u00b5\u0094 \u00e2\u00b5\u0089\u00e2\u00b4\u00b1\u00e2\u00b5\u0094\u00e2\u00b5\u0089\u00e2\u00b5\u0094_\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u00a2\u00e2\u00b5\u0093 \u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u00a2\u00e2\u00b5\u0093_\u00e2\u00b5\u00a2\u00e2\u00b5\u0093\u00e2\u00b5\u008f\u00e2\u00b5\u00a2\u00e2\u00b5\u0093 \u00e2\u00b5\u00a2\u00e2\u00b5\u0093\u00e2\u00b5\u008f\u00e2\u00b5\u00a2\u00e2\u00b5\u0093_\u00e2\u00b5\u00a2\u00e2\u00b5\u0093\u00e2\u00b5\u008d\u00e2\u00b5\u00a2\u00e2\u00b5\u0093\u00e2\u00b5\u00a3 \u00e2\u00b5\u00a2\u00e2\u00b5\u0093\u00e2\u00b5\u008d\u00e2\u00b5\u00a2\u00e2\u00b5\u0093\u00e2\u00b5\u00a3_\u00e2\u00b5\u0096\u00e2\u00b5\u0093\u00e2\u00b5\u009b\u00e2\u00b5\u009c \u00e2\u00b5\u0096\u00e2\u00b5\u0093\u00e2\u00b5\u009b\u00e2\u00b5\u009c_\u00e2\u00b5\u009b\u00e2\u00b5\u0093\u00e2\u00b5\u009c\u00e2\u00b4\u00b0\u00e2\u00b5\u008f\u00e2\u00b4\u00b1\u00e2\u00b5\u0089\u00e2\u00b5\u0094 \u00e2\u00b5\u009b\u00e2\u00b5\u0093\u00e2\u00b5\u009c\u00e2\u00b4\u00b0\u00e2\u00b5\u008f\u00e2\u00b4\u00b1\u00e2\u00b5\u0089\u00e2\u00b5\u0094_\u00e2\u00b4\u00bd\u00e2\u00b5\u009f\u00e2\u00b5\u0093\u00e2\u00b4\u00b1\u00e2\u00b5\u0095 \u00e2\u00b4\u00bd\u00e2\u00b5\u009f\u00e2\u00b5\u0093\u00e2\u00b4\u00b1\u00e2\u00b5\u0095_\u00e2\u00b5\u008f\u00e2\u00b5\u0093\u00e2\u00b5\u00a1\u00e2\u00b4\u00b0\u00e2\u00b5\u008f\u00e2\u00b4\u00b1\u00e2\u00b5\u0089\u00e2\u00b5\u0094 \u00e2\u00b5\u008f\u00e2\u00b5\u0093\u00e2\u00b5\u00a1\u00e2\u00b4\u00b0\u00e2\u00b5\u008f\u00e2\u00b4\u00b1\u00e2\u00b5\u0089\u00e2\u00b5\u0094_\u00e2\u00b4\u00b7\u00e2\u00b5\u0093\u00e2\u00b5\u008a\u00e2\u00b5\u008f\u00e2\u00b4\u00b1\u00e2\u00b5\u0089\u00e2\u00b5\u0094 \u00e2\u00b4\u00b7\u00e2\u00b5\u0093\u00e2\u00b5\u008a\u00e2\u00b5\u008f\u00e2\u00b4\u00b1\u00e2\u00b5\u0089\u00e2\u00b5\u0094'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0099, \u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095 14 2010, 3:25:50 pm'],\n                ['ddd, hA',                            '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0099, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 \u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095 \u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 \u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0099'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '8 8 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45 day of the year'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 \u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095 2010'],\n                ['LLL',                                '14 \u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095 2010 15:25'],\n                ['LLLL',                               '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 14 \u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 \u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095 2010'],\n                ['lll',                                '14 \u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095 2010 15:25'],\n                ['llll',                               '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 14 \u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e2\u00b5\u0089\u00e2\u00b5\u008f\u00e2\u00b5\u008f\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0094 \u00e2\u00b5\u0089\u00e2\u00b5\u008f\u00e2\u00b5\u008f\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0094_\u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095 \u00e2\u00b4\u00b1\u00e2\u00b5\u0095\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u0095_\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0095\u00e2\u00b5\u009a \u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0095\u00e2\u00b5\u009a_\u00e2\u00b5\u0089\u00e2\u00b4\u00b1\u00e2\u00b5\u0094\u00e2\u00b5\u0089\u00e2\u00b5\u0094 \u00e2\u00b5\u0089\u00e2\u00b4\u00b1\u00e2\u00b5\u0094\u00e2\u00b5\u0089\u00e2\u00b5\u0094_\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u00a2\u00e2\u00b5\u0093 \u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u00a2\u00e2\u00b5\u0093_\u00e2\u00b5\u00a2\u00e2\u00b5\u0093\u00e2\u00b5\u008f\u00e2\u00b5\u00a2\u00e2\u00b5\u0093 \u00e2\u00b5\u00a2\u00e2\u00b5\u0093\u00e2\u00b5\u008f\u00e2\u00b5\u00a2\u00e2\u00b5\u0093_\u00e2\u00b5\u00a2\u00e2\u00b5\u0093\u00e2\u00b5\u008d\u00e2\u00b5\u00a2\u00e2\u00b5\u0093\u00e2\u00b5\u00a3 \u00e2\u00b5\u00a2\u00e2\u00b5\u0093\u00e2\u00b5\u008d\u00e2\u00b5\u00a2\u00e2\u00b5\u0093\u00e2\u00b5\u00a3_\u00e2\u00b5\u0096\u00e2\u00b5\u0093\u00e2\u00b5\u009b\u00e2\u00b5\u009c \u00e2\u00b5\u0096\u00e2\u00b5\u0093\u00e2\u00b5\u009b\u00e2\u00b5\u009c_\u00e2\u00b5\u009b\u00e2\u00b5\u0093\u00e2\u00b5\u009c\u00e2\u00b4\u00b0\u00e2\u00b5\u008f\u00e2\u00b4\u00b1\u00e2\u00b5\u0089\u00e2\u00b5\u0094 \u00e2\u00b5\u009b\u00e2\u00b5\u0093\u00e2\u00b5\u009c\u00e2\u00b4\u00b0\u00e2\u00b5\u008f\u00e2\u00b4\u00b1\u00e2\u00b5\u0089\u00e2\u00b5\u0094_\u00e2\u00b4\u00bd\u00e2\u00b5\u009f\u00e2\u00b5\u0093\u00e2\u00b4\u00b1\u00e2\u00b5\u0095 \u00e2\u00b4\u00bd\u00e2\u00b5\u009f\u00e2\u00b5\u0093\u00e2\u00b4\u00b1\u00e2\u00b5\u0095_\u00e2\u00b5\u008f\u00e2\u00b5\u0093\u00e2\u00b5\u00a1\u00e2\u00b4\u00b0\u00e2\u00b5\u008f\u00e2\u00b4\u00b1\u00e2\u00b5\u0089\u00e2\u00b5\u0094 \u00e2\u00b5\u008f\u00e2\u00b5\u0093\u00e2\u00b5\u00a1\u00e2\u00b4\u00b0\u00e2\u00b5\u008f\u00e2\u00b4\u00b1\u00e2\u00b5\u0089\u00e2\u00b5\u0094_\u00e2\u00b4\u00b7\u00e2\u00b5\u0093\u00e2\u00b5\u008a\u00e2\u00b5\u008f\u00e2\u00b4\u00b1\u00e2\u00b5\u0089\u00e2\u00b5\u0094 \u00e2\u00b4\u00b7\u00e2\u00b5\u0093\u00e2\u00b5\u008a\u00e2\u00b5\u008f\u00e2\u00b4\u00b1\u00e2\u00b5\u0089\u00e2\u00b5\u0094'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008e\u00e2\u00b4\u00b0\u00e2\u00b5\u0099_\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u008f\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u008f\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b5\u00a2\u00e2\u00b5\u008f\u00e2\u00b4\u00b0\u00e2\u00b5\u0099_\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0089\u00e2\u00b5\u008f\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0089\u00e2\u00b5\u008f\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0089\u00e2\u00b5\u008f\u00e2\u00b4\u00b0\u00e2\u00b5\u0099_\u00e2\u00b4\u00b0\u00e2\u00b4\u00bd\u00e2\u00b5\u0094\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b4\u00bd\u00e2\u00b5\u0094\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b4\u00bd\u00e2\u00b5\u0094\u00e2\u00b4\u00b0\u00e2\u00b5\u0099_\u00e2\u00b4\u00b0\u00e2\u00b4\u00bd\u00e2\u00b5\u00a1\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b4\u00bd\u00e2\u00b5\u00a1\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b4\u00bd\u00e2\u00b5\u00a1\u00e2\u00b4\u00b0\u00e2\u00b5\u0099_\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0089\u00e2\u00b5\u008e\u00e2\u00b5\u00a1\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0089\u00e2\u00b5\u008e\u00e2\u00b5\u00a1\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0089\u00e2\u00b5\u008e\u00e2\u00b5\u00a1\u00e2\u00b4\u00b0\u00e2\u00b5\u0099_\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0089\u00e2\u00b4\u00b9\u00e2\u00b5\u00a2\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0089\u00e2\u00b4\u00b9\u00e2\u00b5\u00a2\u00e2\u00b4\u00b0\u00e2\u00b5\u0099 \u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0089\u00e2\u00b4\u00b9\u00e2\u00b5\u00a2\u00e2\u00b4\u00b0\u00e2\u00b5\u0099'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e2\u00b5\u0089\u00e2\u00b5\u008e\u00e2\u00b5\u0089\u00e2\u00b4\u00bd', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00e2\u00b5\u008e\u00e2\u00b5\u0089\u00e2\u00b5\u008f\u00e2\u00b5\u0093\u00e2\u00b4\u00ba',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00e2\u00b5\u008e\u00e2\u00b5\u0089\u00e2\u00b5\u008f\u00e2\u00b5\u0093\u00e2\u00b4\u00ba',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00e2\u00b5\u008e\u00e2\u00b5\u0089\u00e2\u00b5\u008f\u00e2\u00b5\u0093\u00e2\u00b4\u00ba',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00e2\u00b5\u008e\u00e2\u00b5\u0089\u00e2\u00b5\u008f\u00e2\u00b5\u0093\u00e2\u00b4\u00ba',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u0084\u00e2\u00b4\u00b0',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u0084\u00e2\u00b4\u00b0',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00e2\u00b5\u009c\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u0084\u00e2\u00b5\u0089\u00e2\u00b5\u008f',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00e2\u00b5\u009c\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u0084\u00e2\u00b5\u0089\u00e2\u00b5\u008f',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00e2\u00b5\u009c\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u0084\u00e2\u00b5\u0089\u00e2\u00b5\u008f',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0099',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0099',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 o\u00e2\u00b5\u0099\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008f',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u0099',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 o\u00e2\u00b5\u0099\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008f',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 o\u00e2\u00b5\u0099\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008f',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2o\u00e2\u00b5\u0093\u00e2\u00b5\u0094',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2o\u00e2\u00b5\u0093\u00e2\u00b5\u0094',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2o\u00e2\u00b5\u0093\u00e2\u00b5\u0094',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00e2\u00b5\u0089\u00e2\u00b5\u00a2\u00e2\u00b5\u00a2\u00e2\u00b5\u0089\u00e2\u00b5\u0094\u00e2\u00b5\u008f',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00e2\u00b5\u0089\u00e2\u00b5\u00a2\u00e2\u00b5\u00a2\u00e2\u00b5\u0089\u00e2\u00b5\u0094\u00e2\u00b5\u008f',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00e2\u00b5\u0089\u00e2\u00b5\u00a2\u00e2\u00b5\u00a2\u00e2\u00b5\u0089\u00e2\u00b5\u0094\u00e2\u00b5\u008f',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00e2\u00b4\u00b0\u00e2\u00b5\u00a2o\u00e2\u00b5\u0093\u00e2\u00b5\u0094',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00e2\u00b5\u0089\u00e2\u00b5\u00a2\u00e2\u00b5\u00a2\u00e2\u00b5\u0089\u00e2\u00b5\u0094\u00e2\u00b5\u008f',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b3\u00e2\u00b4\u00b0\u00e2\u00b5\u0099',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00e2\u00b5\u0089\u00e2\u00b5\u0099\u00e2\u00b4\u00b3\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u008f',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b3\u00e2\u00b4\u00b0\u00e2\u00b5\u0099',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00e2\u00b5\u0089\u00e2\u00b5\u0099\u00e2\u00b4\u00b3\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b5\u008f',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e2\u00b4\u00b7\u00e2\u00b4\u00b0\u00e2\u00b4\u00b7\u00e2\u00b5\u0085 \u00e2\u00b5\u0099 \u00e2\u00b5\u00a2\u00e2\u00b4\u00b0\u00e2\u00b5\u008f \u00e2\u00b5\u0089\u00e2\u00b5\u008e\u00e2\u00b5\u0089\u00e2\u00b4\u00bd',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e2\u00b5\u00a2\u00e2\u00b4\u00b0\u00e2\u00b5\u008f \u00e2\u00b5\u0089\u00e2\u00b5\u008e\u00e2\u00b5\u0089\u00e2\u00b4\u00bd', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e2\u00b5\u00a2\u00e2\u00b4\u00b0\u00e2\u00b5\u008f \u00e2\u00b5\u0089\u00e2\u00b5\u008e\u00e2\u00b5\u0089\u00e2\u00b4\u00bd',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e2\u00b4\u00b7\u00e2\u00b4\u00b0\u00e2\u00b4\u00b7\u00e2\u00b5\u0085 \u00e2\u00b5\u0099 \u00e2\u00b5\u00a2\u00e2\u00b4\u00b0\u00e2\u00b5\u008f \u00e2\u00b5\u0089\u00e2\u00b5\u008e\u00e2\u00b5\u0089\u00e2\u00b4\u00bd', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00e2\u00b4\u00b7\u00e2\u00b4\u00b0\u00e2\u00b4\u00b7\u00e2\u00b5\u0085 \u00e2\u00b5\u0099 \u00e2\u00b5\u00a2\u00e2\u00b4\u00b0\u00e2\u00b5\u008f 5 o\u00e2\u00b5\u0099\u00e2\u00b5\u0099\u00e2\u00b4\u00b0\u00e2\u00b5\u008f', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b7\u00e2\u00b5\u0085 \u00e2\u00b4\u00b4 12:00',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b7\u00e2\u00b5\u0085 \u00e2\u00b4\u00b4 12:25',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b7\u00e2\u00b5\u0085 \u00e2\u00b4\u00b4 13:00',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00bd\u00e2\u00b4\u00b0 \u00e2\u00b4\u00b4 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e2\u00b4\u00b0\u00e2\u00b5\u0099\u00e2\u00b4\u00b7\u00e2\u00b5\u0085 \u00e2\u00b4\u00b4 11:00',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e2\u00b4\u00b0\u00e2\u00b5\u009a\u00e2\u00b4\u00b0\u00e2\u00b5\u008f\u00e2\u00b5\u009c \u00e2\u00b4\u00b4 12:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00e2\u00b4\u00b4] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00e2\u00b4\u00b4] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00e2\u00b4\u00b4] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00e2\u00b4\u00b4] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00e2\u00b4\u00b4] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00e2\u00b4\u00b4] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '1 01 1', 'Dec 31 2011 should be week 1');\n        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '1 01 1', 'Jan  6 2012 should be week 1');\n        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 should be week 2');\n        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '2 02 2', 'Jan 13 2012 should be week 2');\n        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('uk');\n\n    test('parse', function (assert) {\n        var tests = '\u00d1\u0081\u00d1\u0096\u00d1\u0087\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0081\u00d1\u0096\u00d1\u0087_\u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00b8\u00d0\u00b9 \u00d0\u00bb\u00d1\u008e\u00d1\u0082_\u00d0\u00b1\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b1\u00d0\u00b5\u00d1\u0080_\u00d0\u00ba\u00d0\u00b2\u00d1\u0096\u00d1\u0082\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00ba\u00d0\u00b2\u00d1\u0096\u00d1\u0082_\u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00b2_\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b2_\u00d0\u00bb\u00d0\u00b8\u00d0\u00bf\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00bb\u00d0\u00b8\u00d0\u00bf_\u00d1\u0081\u00d0\u00b5\u00d1\u0080\u00d0\u00bf\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0081\u00d0\u00b5\u00d1\u0080\u00d0\u00bf_\u00d0\u00b2\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b2\u00d0\u00b5\u00d1\u0080_\u00d0\u00b6\u00d0\u00be\u00d0\u00b2\u00d1\u0082\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b6\u00d0\u00be\u00d0\u00b2\u00d1\u0082_\u00d0\u00bb\u00d0\u00b8\u00d1\u0081\u00d1\u0082\u00d0\u00be\u00d0\u00bf\u00d0\u00b0\u00d0\u00b4 \u00d0\u00bb\u00d0\u00b8\u00d1\u0081\u00d1\u0082_\u00d0\u00b3\u00d1\u0080\u00d1\u0083\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b3\u00d1\u0080\u00d1\u0083\u00d0\u00b4'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do MMMM YYYY, HH:mm:ss',       '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d1\u0096\u00d0\u00bb\u00d1\u008f, 14-\u00d0\u00b3\u00d0\u00be \u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00be\u00d0\u00b3\u00d0\u00be 2010, 15:25:50'],\n                ['ddd, h A',                           '\u00d0\u00bd\u00d0\u00b4, 3 \u00d0\u00b4\u00d0\u00bd\u00d1\u008f'],\n                ['M Mo MM MMMM MMM',                   '2 2-\u00d0\u00b9 02 \u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00b8\u00d0\u00b9 \u00d0\u00bb\u00d1\u008e\u00d1\u0082'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14-\u00d0\u00b3\u00d0\u00be 14'],\n                ['d do dddd ddd dd',                   '0 0-\u00d0\u00b9 \u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d1\u0096\u00d0\u00bb\u00d1\u008f \u00d0\u00bd\u00d0\u00b4 \u00d0\u00bd\u00d0\u00b4'],\n                ['DDD DDDo DDDD',                      '45 45-\u00d0\u00b9 045'],\n                ['w wo ww',                            '7 7-\u00d0\u00b9 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00d0\u00b4\u00d0\u00bd\u00d1\u008f \u00d0\u00b4\u00d0\u00bd\u00d1\u008f'],\n                ['DDDo [\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0080\u00d0\u00be\u00d0\u00ba\u00d1\u0083]',                  '45-\u00d0\u00b9 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0080\u00d0\u00be\u00d0\u00ba\u00d1\u0083'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14.02.2010'],\n                ['LL',                                 '14 \u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00be\u00d0\u00b3\u00d0\u00be 2010 \u00d1\u0080.'],\n                ['LLL',                                '14 \u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00be\u00d0\u00b3\u00d0\u00be 2010 \u00d1\u0080., 15:25'],\n                ['LLLL',                               '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d1\u0096\u00d0\u00bb\u00d1\u008f, 14 \u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00be\u00d0\u00b3\u00d0\u00be 2010 \u00d1\u0080., 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format meridiem', function (assert) {\n        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), '\u00d0\u00bd\u00d0\u00be\u00d1\u0087\u00d1\u0096', 'night');\n        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), '\u00d0\u00bd\u00d0\u00be\u00d1\u0087\u00d1\u0096', 'night');\n        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), '\u00d1\u0080\u00d0\u00b0\u00d0\u00bd\u00d0\u00ba\u00d1\u0083', 'morning');\n        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), '\u00d1\u0080\u00d0\u00b0\u00d0\u00bd\u00d0\u00ba\u00d1\u0083', 'morning');\n        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), '\u00d0\u00b4\u00d0\u00bd\u00d1\u008f', 'afternoon');\n        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), '\u00d0\u00b4\u00d0\u00bd\u00d1\u008f', 'afternoon');\n        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), '\u00d0\u00b2\u00d0\u00b5\u00d1\u0087\u00d0\u00be\u00d1\u0080\u00d0\u00b0', 'evening');\n        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), '\u00d0\u00b2\u00d0\u00b5\u00d1\u0087\u00d0\u00be\u00d1\u0080\u00d0\u00b0', 'evening');\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-\u00d0\u00b9', '1-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-\u00d0\u00b9', '2-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-\u00d0\u00b9', '3-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-\u00d0\u00b9', '4-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-\u00d0\u00b9', '5-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-\u00d0\u00b9', '6-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-\u00d0\u00b9', '7-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-\u00d0\u00b9', '8-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-\u00d0\u00b9', '9-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-\u00d0\u00b9', '10-\u00d0\u00b9');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-\u00d0\u00b9', '11-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-\u00d0\u00b9', '12-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-\u00d0\u00b9', '13-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-\u00d0\u00b9', '14-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-\u00d0\u00b9', '15-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-\u00d0\u00b9', '16-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-\u00d0\u00b9', '17-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-\u00d0\u00b9', '18-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-\u00d0\u00b9', '19-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-\u00d0\u00b9', '20-\u00d0\u00b9');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-\u00d0\u00b9', '21-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-\u00d0\u00b9', '22-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-\u00d0\u00b9', '23-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-\u00d0\u00b9', '24-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-\u00d0\u00b9', '25-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-\u00d0\u00b9', '26-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-\u00d0\u00b9', '27-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-\u00d0\u00b9', '28-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-\u00d0\u00b9', '29-\u00d0\u00b9');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-\u00d0\u00b9', '30-\u00d0\u00b9');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-\u00d0\u00b9', '31-\u00d0\u00b9');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d1\u0081\u00d1\u0096\u00d1\u0087\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0081\u00d1\u0096\u00d1\u0087_\u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00b8\u00d0\u00b9 \u00d0\u00bb\u00d1\u008e\u00d1\u0082_\u00d0\u00b1\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b1\u00d0\u00b5\u00d1\u0080_\u00d0\u00ba\u00d0\u00b2\u00d1\u0096\u00d1\u0082\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00ba\u00d0\u00b2\u00d1\u0096\u00d1\u0082_\u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00b2_\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b2_\u00d0\u00bb\u00d0\u00b8\u00d0\u00bf\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00bb\u00d0\u00b8\u00d0\u00bf_\u00d1\u0081\u00d0\u00b5\u00d1\u0080\u00d0\u00bf\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d1\u0081\u00d0\u00b5\u00d1\u0080\u00d0\u00bf_\u00d0\u00b2\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b2\u00d0\u00b5\u00d1\u0080_\u00d0\u00b6\u00d0\u00be\u00d0\u00b2\u00d1\u0082\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b6\u00d0\u00be\u00d0\u00b2\u00d1\u0082_\u00d0\u00bb\u00d0\u00b8\u00d1\u0081\u00d1\u0082\u00d0\u00be\u00d0\u00bf\u00d0\u00b0\u00d0\u00b4 \u00d0\u00bb\u00d0\u00b8\u00d1\u0081\u00d1\u0082_\u00d0\u00b3\u00d1\u0080\u00d1\u0083\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c \u00d0\u00b3\u00d1\u0080\u00d1\u0083\u00d0\u00b4'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format month case', function (assert) {\n        var months = {\n            'nominative': '\u00d1\u0081\u00d1\u0096\u00d1\u0087\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00b8\u00d0\u00b9_\u00d0\u00b1\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d0\u00b7\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00ba\u00d0\u00b2\u00d1\u0096\u00d1\u0082\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b2\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00bb\u00d0\u00b8\u00d0\u00bf\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d1\u0081\u00d0\u00b5\u00d1\u0080\u00d0\u00bf\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00b2\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00b6\u00d0\u00be\u00d0\u00b2\u00d1\u0082\u00d0\u00b5\u00d0\u00bd\u00d1\u008c_\u00d0\u00bb\u00d0\u00b8\u00d1\u0081\u00d1\u0082\u00d0\u00be\u00d0\u00bf\u00d0\u00b0\u00d0\u00b4_\u00d0\u00b3\u00d1\u0080\u00d1\u0083\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c'.split('_'),\n            'accusative': '\u00d1\u0081\u00d1\u0096\u00d1\u0087\u00d0\u00bd\u00d1\u008f_\u00d0\u00bb\u00d1\u008e\u00d1\u0082\u00d0\u00be\u00d0\u00b3\u00d0\u00be_\u00d0\u00b1\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d0\u00b7\u00d0\u00bd\u00d1\u008f_\u00d0\u00ba\u00d0\u00b2\u00d1\u0096\u00d1\u0082\u00d0\u00bd\u00d1\u008f_\u00d1\u0082\u00d1\u0080\u00d0\u00b0\u00d0\u00b2\u00d0\u00bd\u00d1\u008f_\u00d1\u0087\u00d0\u00b5\u00d1\u0080\u00d0\u00b2\u00d0\u00bd\u00d1\u008f_\u00d0\u00bb\u00d0\u00b8\u00d0\u00bf\u00d0\u00bd\u00d1\u008f_\u00d1\u0081\u00d0\u00b5\u00d1\u0080\u00d0\u00bf\u00d0\u00bd\u00d1\u008f_\u00d0\u00b2\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d1\u0081\u00d0\u00bd\u00d1\u008f_\u00d0\u00b6\u00d0\u00be\u00d0\u00b2\u00d1\u0082\u00d0\u00bd\u00d1\u008f_\u00d0\u00bb\u00d0\u00b8\u00d1\u0081\u00d1\u0082\u00d0\u00be\u00d0\u00bf\u00d0\u00b0\u00d0\u00b4\u00d0\u00b0_\u00d0\u00b3\u00d1\u0080\u00d1\u0083\u00d0\u00b4\u00d0\u00bd\u00d1\u008f'.split('_')\n        }, i;\n        for (i = 0; i < 12; i++) {\n            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);\n            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d1\u0096\u00d0\u00bb\u00d1\u008f \u00d0\u00bd\u00d0\u00b4 \u00d0\u00bd\u00d0\u00b4_\u00d0\u00bf\u00d0\u00be\u00d0\u00bd\u00d0\u00b5\u00d0\u00b4\u00d1\u0096\u00d0\u00bb\u00d0\u00be\u00d0\u00ba \u00d0\u00bf\u00d0\u00bd \u00d0\u00bf\u00d0\u00bd_\u00d0\u00b2\u00d1\u0096\u00d0\u00b2\u00d1\u0082\u00d0\u00be\u00d1\u0080\u00d0\u00be\u00d0\u00ba \u00d0\u00b2\u00d1\u0082 \u00d0\u00b2\u00d1\u0082_\u00d1\u0081\u00d0\u00b5\u00d1\u0080\u00d0\u00b5\u00d0\u00b4\u00d0\u00b0 \u00d1\u0081\u00d1\u0080 \u00d1\u0081\u00d1\u0080_\u00d1\u0087\u00d0\u00b5\u00d1\u0082\u00d0\u00b2\u00d0\u00b5\u00d1\u0080 \u00d1\u0087\u00d1\u0082 \u00d1\u0087\u00d1\u0082_\u00d0\u00bf\u00e2\u0080\u0099\u00d1\u008f\u00d1\u0082\u00d0\u00bd\u00d0\u00b8\u00d1\u0086\u00d1\u008f \u00d0\u00bf\u00d1\u0082 \u00d0\u00bf\u00d1\u0082_\u00d1\u0081\u00d1\u0083\u00d0\u00b1\u00d0\u00be\u00d1\u0082\u00d0\u00b0 \u00d1\u0081\u00d0\u00b1 \u00d1\u0081\u00d0\u00b1'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d1\u0096\u00d0\u00bb\u00d1\u008c\u00d0\u00ba\u00d0\u00b0 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4',    '44 seconds = seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d1\u0085\u00d0\u00b2\u00d0\u00b8\u00d0\u00bb\u00d0\u00b8\u00d0\u00bd\u00d0\u00b0',   '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d1\u0085\u00d0\u00b2\u00d0\u00b8\u00d0\u00bb\u00d0\u00b8\u00d0\u00bd\u00d0\u00b0',   '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d1\u0085\u00d0\u00b2\u00d0\u00b8\u00d0\u00bb\u00d0\u00b8\u00d0\u00bd\u00d0\u00b8',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d1\u0085\u00d0\u00b2\u00d0\u00b8\u00d0\u00bb\u00d0\u00b8\u00d0\u00bd\u00d0\u00b8', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d1\u0083',    '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d1\u0083',    '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d0\u00b8',    '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd',    '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd\u00d0\u00b0',   '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c',      '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c',      '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00d0\u00b4\u00d0\u00bd\u00d1\u0096',     '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c',      '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d0\u00b4\u00d0\u00bd\u00d1\u0096\u00d0\u00b2',     '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 \u00d0\u00b4\u00d0\u00bd\u00d1\u0096\u00d0\u00b2',     '11 days = 11 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 \u00d0\u00b4\u00d0\u00b5\u00d0\u00bd\u00d1\u008c',     '21 days = 21 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d0\u00b4\u00d0\u00bd\u00d1\u0096\u00d0\u00b2',    '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d0\u00bc\u00d1\u0096\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d1\u008c',    '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d0\u00bc\u00d1\u0096\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d1\u008c',    '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d0\u00bc\u00d1\u0096\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d1\u008c',    '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00d0\u00bc\u00d1\u0096\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d1\u0096',   '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00d0\u00bc\u00d1\u0096\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d1\u0096',   '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d0\u00bc\u00d1\u0096\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d1\u0096',   '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d0\u00bc\u00d1\u0096\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d1\u008c',    '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d0\u00bc\u00d1\u0096\u00d1\u0081\u00d1\u008f\u00d1\u0086\u00d1\u0096\u00d0\u00b2',   '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d1\u0080\u00d1\u0096\u00d0\u00ba',     '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00d1\u0080\u00d0\u00be\u00d0\u00ba\u00d0\u00b8',    '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d1\u0080\u00d1\u0096\u00d0\u00ba',     '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d1\u0080\u00d0\u00be\u00d0\u00ba\u00d1\u0096\u00d0\u00b2',    '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d0\u00b7\u00d0\u00b0 \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d1\u0096\u00d0\u00bb\u00d1\u008c\u00d0\u00ba\u00d0\u00b0 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4', 'prefix');\n        assert.equal(moment(0).from(30000), '\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d1\u0096\u00d0\u00bb\u00d1\u008c\u00d0\u00ba\u00d0\u00b0 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 \u00d1\u0082\u00d0\u00be\u00d0\u00bc\u00d1\u0083', 'suffix');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d0\u00b7\u00d0\u00b0 \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d1\u0096\u00d0\u00bb\u00d1\u008c\u00d0\u00ba\u00d0\u00b0 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4', 'in seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00d0\u00b7\u00d0\u00b0 5 \u00d0\u00b4\u00d0\u00bd\u00d1\u0096\u00d0\u00b2', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d0\u00a1\u00d1\u008c\u00d0\u00be\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00bd\u00d1\u0096 \u00d0\u00be 12:00',   'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d0\u00a1\u00d1\u008c\u00d0\u00be\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00bd\u00d1\u0096 \u00d0\u00be 12:25',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d0\u00a1\u00d1\u008c\u00d0\u00be\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00bd\u00d1\u0096 \u00d0\u00be 13:00',   'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d0\u0097\u00d0\u00b0\u00d0\u00b2\u00d1\u0082\u00d1\u0080\u00d0\u00b0 \u00d0\u00be 12:00',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 2}).calendar(),  '\u00d0\u00a1\u00d1\u008c\u00d0\u00be\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00bd\u00d1\u0096 \u00d0\u00be 10:00',   'Now minus 2 hours');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d0\u0092\u00d1\u0087\u00d0\u00be\u00d1\u0080\u00d0\u00b0 \u00d0\u00be 12:00',      'yesterday at the same time');\n        // A special case for Ukrainian since 11 hours have different preposition\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d0\u00a1\u00d1\u008c\u00d0\u00be\u00d0\u00b3\u00d0\u00be\u00d0\u00b4\u00d0\u00bd\u00d1\u0096 \u00d0\u00be\u00d0\u00b1 11:00',  'same day at 11 o\\'clock');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00d0\u00a3] dddd [\u00d0\u00be' + (m.hours() === 11 ? '\u00d0\u00b1' : '') + '] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00d0\u00a3] dddd [\u00d0\u00be] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00d0\u00a3] dddd [\u00d0\u00be] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        function makeFormat(d) {\n            switch (d.day()) {\n            case 0:\n            case 3:\n            case 5:\n            case 6:\n                return '[\u00d0\u009c\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d0\u00bb\u00d0\u00be\u00d1\u0097] dddd [\u00d0\u00be' + (d.hours() === 11 ? '\u00d0\u00b1' : '') + '] LT';\n            case 1:\n            case 2:\n            case 4:\n                return '[\u00d0\u009c\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d0\u00bb\u00d0\u00be\u00d0\u00b3\u00d0\u00be] dddd [\u00d0\u00be' + (d.hours() === 11 ? '\u00d0\u00b1' : '') + '] LT';\n            }\n        }\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-\u00d0\u00b9', 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-\u00d0\u00b9', 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-\u00d0\u00b9', 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-\u00d0\u00b9', 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-\u00d0\u00b9', 'Jan  9 2012 should be week 3');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('uz');\n\n    test('parse', function (assert) {\n        var tests = '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2\u00d0\u00b0\u00d1\u0080 \u00d1\u008f\u00d0\u00bd\u00d0\u00b2_\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb \u00d1\u0084\u00d0\u00b5\u00d0\u00b2_\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00bb \u00d0\u00b0\u00d0\u00bf\u00d1\u0080_\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9 \u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd \u00d0\u00b8\u00d1\u008e\u00d0\u00bd_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb \u00d0\u00b8\u00d1\u008e\u00d0\u00bb_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3_\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080 \u00d1\u0081\u00d0\u00b5\u00d0\u00bd_\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080 \u00d0\u00be\u00d0\u00ba\u00d1\u0082_\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1\u00d1\u0080 \u00d0\u00bd\u00d0\u00be\u00d1\u008f_\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00b1\u00d1\u0080 \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, Do-MMMM YYYY, h:mm:ss',        '\u00d0\u00af\u00d0\u00ba\u00d1\u0088\u00d0\u00b0\u00d0\u00bd\u00d0\u00b1\u00d0\u00b0, 14-\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb 2010, 3:25:50'],\n                ['ddd, h:mm',                          '\u00d0\u00af\u00d0\u00ba\u00d1\u0088, 3:25'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb \u00d1\u0084\u00d0\u00b5\u00d0\u00b2'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 \u00d0\u00af\u00d0\u00ba\u00d1\u0088\u00d0\u00b0\u00d0\u00bd\u00d0\u00b1\u00d0\u00b0 \u00d0\u00af\u00d0\u00ba\u00d1\u0088 \u00d0\u00af\u00d0\u00ba'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '7 7 07'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[\u00d0\u00b9\u00d0\u00b8\u00d0\u00bb\u00d0\u00bd\u00d0\u00b8\u00d0\u00bd\u00d0\u00b3] DDDo-[\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b8]',             '\u00d0\u00b9\u00d0\u00b8\u00d0\u00bb\u00d0\u00bd\u00d0\u00b8\u00d0\u00bd\u00d0\u00b3 45-\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b8'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb 2010'],\n                ['LLL',                                '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb 2010 15:25'],\n                ['LLLL',                               '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb 2010, \u00d0\u00af\u00d0\u00ba\u00d1\u0088\u00d0\u00b0\u00d0\u00bd\u00d0\u00b1\u00d0\u00b0 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2 2010'],\n                ['lll',                                '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2 2010 15:25'],\n                ['llll',                               '14 \u00d1\u0084\u00d0\u00b5\u00d0\u00b2 2010, \u00d0\u00af\u00d0\u00ba\u00d1\u0088 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00d1\u008f\u00d0\u00bd\u00d0\u00b2\u00d0\u00b0\u00d1\u0080 \u00d1\u008f\u00d0\u00bd\u00d0\u00b2_\u00d1\u0084\u00d0\u00b5\u00d0\u00b2\u00d1\u0080\u00d0\u00b0\u00d0\u00bb \u00d1\u0084\u00d0\u00b5\u00d0\u00b2_\u00d0\u00bc\u00d0\u00b0\u00d1\u0080\u00d1\u0082 \u00d0\u00bc\u00d0\u00b0\u00d1\u0080_\u00d0\u00b0\u00d0\u00bf\u00d1\u0080\u00d0\u00b5\u00d0\u00bb \u00d0\u00b0\u00d0\u00bf\u00d1\u0080_\u00d0\u00bc\u00d0\u00b0\u00d0\u00b9 \u00d0\u00bc\u00d0\u00b0\u00d0\u00b9_\u00d0\u00b8\u00d1\u008e\u00d0\u00bd \u00d0\u00b8\u00d1\u008e\u00d0\u00bd_\u00d0\u00b8\u00d1\u008e\u00d0\u00bb \u00d0\u00b8\u00d1\u008e\u00d0\u00bb_\u00d0\u00b0\u00d0\u00b2\u00d0\u00b3\u00d1\u0083\u00d1\u0081\u00d1\u0082 \u00d0\u00b0\u00d0\u00b2\u00d0\u00b3_\u00d1\u0081\u00d0\u00b5\u00d0\u00bd\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080 \u00d1\u0081\u00d0\u00b5\u00d0\u00bd_\u00d0\u00be\u00d0\u00ba\u00d1\u0082\u00d1\u008f\u00d0\u00b1\u00d1\u0080 \u00d0\u00be\u00d0\u00ba\u00d1\u0082_\u00d0\u00bd\u00d0\u00be\u00d1\u008f\u00d0\u00b1\u00d1\u0080 \u00d0\u00bd\u00d0\u00be\u00d1\u008f_\u00d0\u00b4\u00d0\u00b5\u00d0\u00ba\u00d0\u00b0\u00d0\u00b1\u00d1\u0080 \u00d0\u00b4\u00d0\u00b5\u00d0\u00ba'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00d0\u00af\u00d0\u00ba\u00d1\u0088\u00d0\u00b0\u00d0\u00bd\u00d0\u00b1\u00d0\u00b0 \u00d0\u00af\u00d0\u00ba\u00d1\u0088 \u00d0\u00af\u00d0\u00ba_\u00d0\u0094\u00d1\u0083\u00d1\u0088\u00d0\u00b0\u00d0\u00bd\u00d0\u00b1\u00d0\u00b0 \u00d0\u0094\u00d1\u0083\u00d1\u0088 \u00d0\u0094\u00d1\u0083_\u00d0\u00a1\u00d0\u00b5\u00d1\u0088\u00d0\u00b0\u00d0\u00bd\u00d0\u00b1\u00d0\u00b0 \u00d0\u00a1\u00d0\u00b5\u00d1\u0088 \u00d0\u00a1\u00d0\u00b5_\u00d0\u00a7\u00d0\u00be\u00d1\u0080\u00d1\u0088\u00d0\u00b0\u00d0\u00bd\u00d0\u00b1\u00d0\u00b0 \u00d0\u00a7\u00d0\u00be\u00d1\u0080 \u00d0\u00a7\u00d0\u00be_\u00d0\u009f\u00d0\u00b0\u00d0\u00b9\u00d1\u0088\u00d0\u00b0\u00d0\u00bd\u00d0\u00b1\u00d0\u00b0 \u00d0\u009f\u00d0\u00b0\u00d0\u00b9 \u00d0\u009f\u00d0\u00b0_\u00d0\u0096\u00d1\u0083\u00d0\u00bc\u00d0\u00b0 \u00d0\u0096\u00d1\u0083\u00d0\u00bc \u00d0\u0096\u00d1\u0083_\u00d0\u00a8\u00d0\u00b0\u00d0\u00bd\u00d0\u00b1\u00d0\u00b0 \u00d0\u00a8\u00d0\u00b0\u00d0\u00bd \u00d0\u00a8\u00d0\u00b0'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00d1\u0084\u00d1\u0083\u00d1\u0080\u00d1\u0081\u00d0\u00b0\u00d1\u0082', '44 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 = \u00d1\u0084\u00d1\u0083\u00d1\u0080\u00d1\u0081\u00d0\u00b0\u00d1\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b4\u00d0\u00b0\u00d0\u00ba\u00d0\u00b8\u00d0\u00ba\u00d0\u00b0',      '45 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 = \u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b4\u00d0\u00b0\u00d0\u00ba\u00d0\u00b8\u00d0\u00ba\u00d0\u00b0');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b4\u00d0\u00b0\u00d0\u00ba\u00d0\u00b8\u00d0\u00ba\u00d0\u00b0',      '89 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 = \u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b4\u00d0\u00b0\u00d0\u00ba\u00d0\u00b8\u00d0\u00ba\u00d0\u00b0');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00d0\u00b4\u00d0\u00b0\u00d0\u00ba\u00d0\u00b8\u00d0\u00ba\u00d0\u00b0',     '90 \u00d1\u0081\u00d0\u00b5\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b4 = 2 \u00d0\u00b4\u00d0\u00b0\u00d0\u00ba\u00d0\u00b8\u00d0\u00ba\u00d0\u00b0');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00d0\u00b4\u00d0\u00b0\u00d0\u00ba\u00d0\u00b8\u00d0\u00ba\u00d0\u00b0',    '44 \u00d0\u00b4\u00d0\u00b0\u00d0\u00ba\u00d0\u00b8\u00d0\u00ba\u00d0\u00b0 = 44 \u00d0\u00b4\u00d0\u00b0\u00d0\u00ba\u00d0\u00b8\u00d0\u00ba\u00d0\u00b0');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082',       '45 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082 = \u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082',       '90 \u00d0\u00bc\u00d0\u00b8\u00d0\u00bd\u00d1\u0083\u00d1\u0082 = 2 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082',       '5 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082 = 5 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082',      '21 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082 = 21 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd',         '22 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082 = \u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd',         '35 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082 = \u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd',        '36 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082 = 2 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd',         '1 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd = 1 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd',        '5 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd = 5 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd',       '25 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd = 25 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00be\u00d0\u00b9',       '26 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd = \u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00be\u00d0\u00b9');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00be\u00d0\u00b9',       '30 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd = \u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00be\u00d0\u00b9');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00be\u00d0\u00b9',       '45 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd = \u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00be\u00d0\u00b9');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00d0\u00be\u00d0\u00b9',      '46 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd = 2 \u00d0\u00be\u00d0\u00b9');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00d0\u00be\u00d0\u00b9',      '75 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd = 2 \u00d0\u00be\u00d0\u00b9');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00d0\u00be\u00d0\u00b9',      '76 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd = 3 \u00d0\u00be\u00d0\u00b9');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00be\u00d0\u00b9',       '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00be\u00d0\u00b9 = \u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00be\u00d0\u00b9');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00d0\u00be\u00d0\u00b9',      '5 \u00d0\u00be\u00d0\u00b9 = 5 \u00d0\u00be\u00d0\u00b9');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b9\u00d0\u00b8\u00d0\u00bb',        '345 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd = \u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b9\u00d0\u00b8\u00d0\u00bb');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00d0\u00b9\u00d0\u00b8\u00d0\u00bb',       '548 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd = 2 \u00d0\u00b9\u00d0\u00b8\u00d0\u00bb');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b9\u00d0\u00b8\u00d0\u00bb',        '1 \u00d0\u00b9\u00d0\u00b8\u00d0\u00bb = \u00d0\u00b1\u00d0\u00b8\u00d1\u0080 \u00d0\u00b9\u00d0\u00b8\u00d0\u00bb');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00d0\u00b9\u00d0\u00b8\u00d0\u00bb',       '5 \u00d0\u00b9\u00d0\u00b8\u00d0\u00bb = 5 \u00d0\u00b9\u00d0\u00b8\u00d0\u00bb');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00d0\u00af\u00d0\u00ba\u00d0\u00b8\u00d0\u00bd \u00d1\u0084\u00d1\u0083\u00d1\u0080\u00d1\u0081\u00d0\u00b0\u00d1\u0082 \u00d0\u00b8\u00d1\u0087\u00d0\u00b8\u00d0\u00b4\u00d0\u00b0',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00d0\u0091\u00d0\u00b8\u00d1\u0080 \u00d0\u00bd\u00d0\u00b5\u00d1\u0087\u00d0\u00b0 \u00d1\u0084\u00d1\u0083\u00d1\u0080\u00d1\u0081\u00d0\u00b0\u00d1\u0082 \u00d0\u00be\u00d0\u00bb\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00d0\u0091\u00d0\u00b8\u00d1\u0080 \u00d0\u00bd\u00d0\u00b5\u00d1\u0087\u00d0\u00b0 \u00d1\u0084\u00d1\u0083\u00d1\u0080\u00d1\u0081\u00d0\u00b0\u00d1\u0082 \u00d0\u00be\u00d0\u00bb\u00d0\u00b4\u00d0\u00b8\u00d0\u00bd',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00d0\u00af\u00d0\u00ba\u00d0\u00b8\u00d0\u00bd \u00d1\u0084\u00d1\u0083\u00d1\u0080\u00d1\u0081\u00d0\u00b0\u00d1\u0082 \u00d0\u00b8\u00d1\u0087\u00d0\u00b8\u00d0\u00b4\u00d0\u00b0', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00d0\u00af\u00d0\u00ba\u00d0\u00b8\u00d0\u00bd 5 \u00d0\u00ba\u00d1\u0083\u00d0\u00bd \u00d0\u00b8\u00d1\u0087\u00d0\u00b8\u00d0\u00b4\u00d0\u00b0', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00d0\u0091\u00d1\u0083\u00d0\u00b3\u00d1\u0083\u00d0\u00bd \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082 12:00 \u00d0\u00b4\u00d0\u00b0',  'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00d0\u0091\u00d1\u0083\u00d0\u00b3\u00d1\u0083\u00d0\u00bd \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082 12:25 \u00d0\u00b4\u00d0\u00b0',  'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00d0\u0091\u00d1\u0083\u00d0\u00b3\u00d1\u0083\u00d0\u00bd \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082 13:00 \u00d0\u00b4\u00d0\u00b0',  'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00d0\u00ad\u00d1\u0080\u00d1\u0082\u00d0\u00b0\u00d0\u00b3\u00d0\u00b0 12:00 \u00d0\u00b4\u00d0\u00b0',      'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00d0\u0091\u00d1\u0083\u00d0\u00b3\u00d1\u0083\u00d0\u00bd \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082 11:00 \u00d0\u00b4\u00d0\u00b0',  'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00d0\u009a\u00d0\u00b5\u00d1\u0087\u00d0\u00b0 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082 12:00 \u00d0\u00b4\u00d0\u00b0',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b8 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082] LT [\u00d0\u00b4\u00d0\u00b0]'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b8 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082] LT [\u00d0\u00b4\u00d0\u00b0]'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b8 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082] LT [\u00d0\u00b4\u00d0\u00b0]'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00d0\u00a3\u00d1\u0082\u00d0\u00b3\u00d0\u00b0\u00d0\u00bd] dddd [\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b8 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082] LT [\u00d0\u00b4\u00d0\u00b0]'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00d0\u00a3\u00d1\u0082\u00d0\u00b3\u00d0\u00b0\u00d0\u00bd] dddd [\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b8 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082] LT [\u00d0\u00b4\u00d0\u00b0]'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00d0\u00a3\u00d1\u0082\u00d0\u00b3\u00d0\u00b0\u00d0\u00bd] dddd [\u00d0\u00ba\u00d1\u0083\u00d0\u00bd\u00d0\u00b8 \u00d1\u0081\u00d0\u00be\u00d0\u00b0\u00d1\u0082] LT [\u00d0\u00b4\u00d0\u00b0]'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '2 02 2', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '2 02 2', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '3 03 3', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '3 03 3', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('vi');\n\n    test('parse', function (assert) {\n        var i,\n            tests = 'th\u00c3\u00a1ng 1,Th01_th\u00c3\u00a1ng 2,Th02_th\u00c3\u00a1ng 3,Th03_th\u00c3\u00a1ng 4,Th04_th\u00c3\u00a1ng 5,Th05_th\u00c3\u00a1ng 6,Th06_th\u00c3\u00a1ng 7,Th07_th\u00c3\u00a1ng 8,Th08_th\u00c3\u00a1ng 9,Th09_th\u00c3\u00a1ng 10,Th10_th\u00c3\u00a1ng 11,Th11_th\u00c3\u00a1ng 12,Th12'.split('_');\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + i);\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(',');\n            equalTest(tests[i][0], '[th\u00c3\u00a1ng] M', i);\n            equalTest(tests[i][1], '[Th]M', i);\n            equalTest(tests[i][0], '[th\u00c3\u00a1ng] MM', i);\n            equalTest(tests[i][1], '[Th]MM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), '[TH\u00c3\u0081NG] M', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), '[TH]M', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), '[TH\u00c3\u0081NG] MM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), '[TH]MM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'ch\u00e1\u00bb\u00a7 nh\u00e1\u00ba\u00adt, th\u00c3\u00a1ng 2 14 2010, 3:25:50 ch'],\n                ['ddd, hA',                            'CN, 3CH'],\n                ['M Mo MM MMMM MMM',                   '2 2 02 th\u00c3\u00a1ng 2 Th02'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14 14'],\n                ['d do dddd ddd dd',                   '0 0 ch\u00e1\u00bb\u00a7 nh\u00e1\u00ba\u00adt CN CN'],\n                ['DDD DDDo DDDD',                      '45 45 045'],\n                ['w wo ww',                            '6 6 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'ch CH'],\n                ['[ng\u00c3\u00a0y th\u00e1\u00bb\u00a9] DDDo [c\u00e1\u00bb\u00a7a n\u00c4\u0083m]',          'ng\u00c3\u00a0y th\u00e1\u00bb\u00a9 45 c\u00e1\u00bb\u00a7a n\u00c4\u0083m'],\n                ['LTS',                                '15:25:50'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 th\u00c3\u00a1ng 2 n\u00c4\u0083m 2010'],\n                ['LLL',                                '14 th\u00c3\u00a1ng 2 n\u00c4\u0083m 2010 15:25'],\n                ['LLLL',                               'ch\u00e1\u00bb\u00a7 nh\u00e1\u00ba\u00adt, 14 th\u00c3\u00a1ng 2 n\u00c4\u0083m 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 Th02 2010'],\n                ['lll',                                '14 Th02 2010 15:25'],\n                ['llll',                               'CN, 14 Th02 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');\n    });\n\n    test('format month', function (assert) {\n        var i,\n            expected = 'th\u00c3\u00a1ng 1,Th01_th\u00c3\u00a1ng 2,Th02_th\u00c3\u00a1ng 3,Th03_th\u00c3\u00a1ng 4,Th04_th\u00c3\u00a1ng 5,Th05_th\u00c3\u00a1ng 6,Th06_th\u00c3\u00a1ng 7,Th07_th\u00c3\u00a1ng 8,Th08_th\u00c3\u00a1ng 9,Th09_th\u00c3\u00a1ng 10,Th10_th\u00c3\u00a1ng 11,Th11_th\u00c3\u00a1ng 12,Th12'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM,MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var i,\n            expected = 'ch\u00e1\u00bb\u00a7 nh\u00e1\u00ba\u00adt CN CN_th\u00e1\u00bb\u00a9 hai T2 T2_th\u00e1\u00bb\u00a9 ba T3 T3_th\u00e1\u00bb\u00a9 t\u00c6\u00b0 T4 T4_th\u00e1\u00bb\u00a9 n\u00c4\u0083m T5 T5_th\u00e1\u00bb\u00a9 s\u00c3\u00a1u T6 T6_th\u00e1\u00bb\u00a9 b\u00e1\u00ba\u00a3y T7 T7'.split('_');\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'v\u00c3\u00a0i gi\u00c3\u00a2y', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'm\u00e1\u00bb\u0099t ph\u00c3\u00bat',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'm\u00e1\u00bb\u0099t ph\u00c3\u00bat',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ph\u00c3\u00bat',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ph\u00c3\u00bat',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'm\u00e1\u00bb\u0099t gi\u00e1\u00bb\u009d',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'm\u00e1\u00bb\u0099t gi\u00e1\u00bb\u009d',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 gi\u00e1\u00bb\u009d',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 gi\u00e1\u00bb\u009d',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 gi\u00e1\u00bb\u009d',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'm\u00e1\u00bb\u0099t ng\u00c3\u00a0y',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'm\u00e1\u00bb\u0099t ng\u00c3\u00a0y',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ng\u00c3\u00a0y',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'm\u00e1\u00bb\u0099t ng\u00c3\u00a0y',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ng\u00c3\u00a0y',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ng\u00c3\u00a0y',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'm\u00e1\u00bb\u0099t th\u00c3\u00a1ng',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'm\u00e1\u00bb\u0099t th\u00c3\u00a1ng',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'm\u00e1\u00bb\u0099t th\u00c3\u00a1ng',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 th\u00c3\u00a1ng',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 th\u00c3\u00a1ng',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 th\u00c3\u00a1ng',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'm\u00e1\u00bb\u0099t th\u00c3\u00a1ng',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 th\u00c3\u00a1ng',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'm\u00e1\u00bb\u0099t n\u00c4\u0083m',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 n\u00c4\u0083m',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'm\u00e1\u00bb\u0099t n\u00c4\u0083m',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 n\u00c4\u0083m',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), 'v\u00c3\u00a0i gi\u00c3\u00a2y t\u00e1\u00bb\u009bi',  'prefix');\n        assert.equal(moment(0).from(30000), 'v\u00c3\u00a0i gi\u00c3\u00a2y tr\u00c6\u00b0\u00e1\u00bb\u009bc', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), 'v\u00c3\u00a0i gi\u00c3\u00a2y tr\u00c6\u00b0\u00e1\u00bb\u009bc',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), 'v\u00c3\u00a0i gi\u00c3\u00a2y t\u00e1\u00bb\u009bi', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 ng\u00c3\u00a0y t\u00e1\u00bb\u009bi', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'H\u00c3\u00b4m nay l\u00c3\u00bac 12:00',   'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'H\u00c3\u00b4m nay l\u00c3\u00bac 12:25',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'H\u00c3\u00b4m nay l\u00c3\u00bac 13:00',   'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Ng\u00c3\u00a0y mai l\u00c3\u00bac 12:00',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'H\u00c3\u00b4m nay l\u00c3\u00bac 11:00',   'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'H\u00c3\u00b4m qua l\u00c3\u00bac 12:00',   'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [tu\u00e1\u00ba\u00a7n t\u00e1\u00bb\u009bi l\u00c3\u00bac] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [tu\u00e1\u00ba\u00a7n t\u00e1\u00bb\u009bi l\u00c3\u00bac] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [tu\u00e1\u00ba\u00a7n t\u00e1\u00bb\u009bi l\u00c3\u00bac] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [tu\u00e1\u00ba\u00a7n r\u00e1\u00bb\u0093i l\u00c3\u00bac] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [tu\u00e1\u00ba\u00a7n r\u00e1\u00bb\u0093i l\u00c3\u00bac] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [tu\u00e1\u00ba\u00a7n r\u00e1\u00bb\u0093i l\u00c3\u00bac] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('x-pseudo');\n\n    test('parse', function (assert) {\n        var tests = 'J~\u00c3\u00a1\u00c3\u00b1\u00c3\u00ba\u00c3\u00a1~r\u00c3\u00bd J~\u00c3\u00a1\u00c3\u00b1_F~\u00c3\u00a9br\u00c3\u00ba~\u00c3\u00a1r\u00c3\u00bd ~F\u00c3\u00a9b_~M\u00c3\u00a1rc~h ~M\u00c3\u00a1r_\u00c3\u0081p~r\u00c3\u00adl ~\u00c3\u0081pr_~M\u00c3\u00a1\u00c3\u00bd ~M\u00c3\u00a1\u00c3\u00bd_~J\u00c3\u00ba\u00c3\u00b1\u00c3\u00a9~ ~J\u00c3\u00ba\u00c3\u00b1_J\u00c3\u00bal~\u00c3\u00bd ~J\u00c3\u00bal_\u00c3\u0081\u00c3\u00ba~g\u00c3\u00bast~ ~\u00c3\u0081\u00c3\u00bag_S\u00c3\u00a9p~t\u00c3\u00a9mb~\u00c3\u00a9r ~S\u00c3\u00a9p_\u00c3\u0093~ct\u00c3\u00b3b~\u00c3\u00a9r ~\u00c3\u0093ct_\u00c3\u0091~\u00c3\u00b3v\u00c3\u00a9m~b\u00c3\u00a9r ~\u00c3\u0091\u00c3\u00b3v_~D\u00c3\u00a9c\u00c3\u00a9~mb\u00c3\u00a9r ~D\u00c3\u00a9c'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, h:mm:ss a',      'S~\u00c3\u00ba\u00c3\u00b1d\u00c3\u00a1~\u00c3\u00bd, F~\u00c3\u00a9br\u00c3\u00ba~\u00c3\u00a1r\u00c3\u00bd 14th 2010, 3:25:50 pm'],\n                ['ddd, hA',                            'S~\u00c3\u00ba\u00c3\u00b1, 3PM'],\n                ['M Mo MM MMMM MMM',                   '2 2nd 02 F~\u00c3\u00a9br\u00c3\u00ba~\u00c3\u00a1r\u00c3\u00bd ~F\u00c3\u00a9b'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14th 14'],\n                ['d do dddd ddd dd',                   '0 0th S~\u00c3\u00ba\u00c3\u00b1d\u00c3\u00a1~\u00c3\u00bd S~\u00c3\u00ba\u00c3\u00b1 S~\u00c3\u00ba'],\n                ['DDD DDDo DDDD',                      '45 45th 045'],\n                ['w wo ww',                            '6 6th 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                'pm PM'],\n                ['[the] DDDo [day of the year]',       'the 45th day of the year'],\n                ['LT',                                 '15:25'],\n                ['L',                                  '14/02/2010'],\n                ['LL',                                 '14 F~\u00c3\u00a9br\u00c3\u00ba~\u00c3\u00a1r\u00c3\u00bd 2010'],\n                ['LLL',                                '14 F~\u00c3\u00a9br\u00c3\u00ba~\u00c3\u00a1r\u00c3\u00bd 2010 15:25'],\n                ['LLLL',                               'S~\u00c3\u00ba\u00c3\u00b1d\u00c3\u00a1~\u00c3\u00bd, 14 F~\u00c3\u00a9br\u00c3\u00ba~\u00c3\u00a1r\u00c3\u00bd 2010 15:25'],\n                ['l',                                  '14/2/2010'],\n                ['ll',                                 '14 ~F\u00c3\u00a9b 2010'],\n                ['lll',                                '14 ~F\u00c3\u00a9b 2010 15:25'],\n                ['llll',                               'S~\u00c3\u00ba\u00c3\u00b1, 14 ~F\u00c3\u00a9b 2010 15:25']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format ordinal', function (assert) {\n        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');\n        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');\n        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');\n        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');\n        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');\n        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');\n        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');\n        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');\n        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');\n        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');\n\n        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');\n        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');\n        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');\n        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');\n        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');\n        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');\n        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');\n        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');\n        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');\n        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');\n\n        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');\n        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');\n        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');\n        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');\n        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');\n        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');\n        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');\n        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');\n        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');\n        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');\n\n        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');\n    });\n\n    test('format month', function (assert) {\n        var expected = 'J~\u00c3\u00a1\u00c3\u00b1\u00c3\u00ba\u00c3\u00a1~r\u00c3\u00bd J~\u00c3\u00a1\u00c3\u00b1_F~\u00c3\u00a9br\u00c3\u00ba~\u00c3\u00a1r\u00c3\u00bd ~F\u00c3\u00a9b_~M\u00c3\u00a1rc~h ~M\u00c3\u00a1r_\u00c3\u0081p~r\u00c3\u00adl ~\u00c3\u0081pr_~M\u00c3\u00a1\u00c3\u00bd ~M\u00c3\u00a1\u00c3\u00bd_~J\u00c3\u00ba\u00c3\u00b1\u00c3\u00a9~ ~J\u00c3\u00ba\u00c3\u00b1_J\u00c3\u00bal~\u00c3\u00bd ~J\u00c3\u00bal_\u00c3\u0081\u00c3\u00ba~g\u00c3\u00bast~ ~\u00c3\u0081\u00c3\u00bag_S\u00c3\u00a9p~t\u00c3\u00a9mb~\u00c3\u00a9r ~S\u00c3\u00a9p_\u00c3\u0093~ct\u00c3\u00b3b~\u00c3\u00a9r ~\u00c3\u0093ct_\u00c3\u0091~\u00c3\u00b3v\u00c3\u00a9m~b\u00c3\u00a9r ~\u00c3\u0091\u00c3\u00b3v_~D\u00c3\u00a9c\u00c3\u00a9~mb\u00c3\u00a9r ~D\u00c3\u00a9c'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = 'S~\u00c3\u00ba\u00c3\u00b1d\u00c3\u00a1~\u00c3\u00bd S~\u00c3\u00ba\u00c3\u00b1 S~\u00c3\u00ba_M\u00c3\u00b3~\u00c3\u00b1d\u00c3\u00a1\u00c3\u00bd~ ~M\u00c3\u00b3\u00c3\u00b1 M\u00c3\u00b3~_T\u00c3\u00ba\u00c3\u00a9~sd\u00c3\u00a1\u00c3\u00bd~ ~T\u00c3\u00ba\u00c3\u00a9 T\u00c3\u00ba_W\u00c3\u00a9d~\u00c3\u00b1\u00c3\u00a9sd~\u00c3\u00a1\u00c3\u00bd ~W\u00c3\u00a9d ~W\u00c3\u00a9_T~h\u00c3\u00bars~d\u00c3\u00a1\u00c3\u00bd ~Th\u00c3\u00ba T~h_~Fr\u00c3\u00add~\u00c3\u00a1\u00c3\u00bd ~Fr\u00c3\u00ad Fr~_S~\u00c3\u00a1t\u00c3\u00bar~d\u00c3\u00a1\u00c3\u00bd ~S\u00c3\u00a1t S\u00c3\u00a1'.split('_'), i;\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00c3\u00a1 ~f\u00c3\u00a9w ~s\u00c3\u00a9c\u00c3\u00b3~\u00c3\u00b1ds', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\u00c3\u00a1 ~m\u00c3\u00ad\u00c3\u00b1~\u00c3\u00bat\u00c3\u00a9',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\u00c3\u00a1 ~m\u00c3\u00ad\u00c3\u00b1~\u00c3\u00bat\u00c3\u00a9',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 m~\u00c3\u00ad\u00c3\u00b1\u00c3\u00ba~t\u00c3\u00a9s',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 m~\u00c3\u00ad\u00c3\u00b1\u00c3\u00ba~t\u00c3\u00a9s',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\u00c3\u00a1~\u00c3\u00b1 h\u00c3\u00b3~\u00c3\u00bar',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\u00c3\u00a1~\u00c3\u00b1 h\u00c3\u00b3~\u00c3\u00bar',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 h~\u00c3\u00b3\u00c3\u00bars',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 h~\u00c3\u00b3\u00c3\u00bars',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 h~\u00c3\u00b3\u00c3\u00bars',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\u00c3\u00a1 ~d\u00c3\u00a1\u00c3\u00bd',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\u00c3\u00a1 ~d\u00c3\u00a1\u00c3\u00bd',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 d~\u00c3\u00a1\u00c3\u00bds',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\u00c3\u00a1 ~d\u00c3\u00a1\u00c3\u00bd',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 d~\u00c3\u00a1\u00c3\u00bds',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 d~\u00c3\u00a1\u00c3\u00bds',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\u00c3\u00a1 ~m\u00c3\u00b3\u00c3\u00b1~th',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\u00c3\u00a1 ~m\u00c3\u00b3\u00c3\u00b1~th',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\u00c3\u00a1 ~m\u00c3\u00b3\u00c3\u00b1~th',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 m~\u00c3\u00b3\u00c3\u00b1t~hs',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 m~\u00c3\u00b3\u00c3\u00b1t~hs',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 m~\u00c3\u00b3\u00c3\u00b1t~hs',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\u00c3\u00a1 ~m\u00c3\u00b3\u00c3\u00b1~th',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 m~\u00c3\u00b3\u00c3\u00b1t~hs',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\u00c3\u00a1 ~\u00c3\u00bd\u00c3\u00a9\u00c3\u00a1r',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00c3\u00bd~\u00c3\u00a9\u00c3\u00a1rs',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\u00c3\u00a1 ~\u00c3\u00bd\u00c3\u00a9\u00c3\u00a1r',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00c3\u00bd~\u00c3\u00a9\u00c3\u00a1rs',       '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00c3\u00ad~\u00c3\u00b1 \u00c3\u00a1 ~f\u00c3\u00a9w ~s\u00c3\u00a9c\u00c3\u00b3~\u00c3\u00b1ds',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00c3\u00a1 ~f\u00c3\u00a9w ~s\u00c3\u00a9c\u00c3\u00b3~\u00c3\u00b1ds \u00c3\u00a1~g\u00c3\u00b3', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00c3\u00a1 ~f\u00c3\u00a9w ~s\u00c3\u00a9c\u00c3\u00b3~\u00c3\u00b1ds \u00c3\u00a1~g\u00c3\u00b3',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00c3\u00ad~\u00c3\u00b1 \u00c3\u00a1 ~f\u00c3\u00a9w ~s\u00c3\u00a9c\u00c3\u00b3~\u00c3\u00b1ds', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '\u00c3\u00ad~\u00c3\u00b1 5 d~\u00c3\u00a1\u00c3\u00bds', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(2).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                     'T~\u00c3\u00b3d\u00c3\u00a1~\u00c3\u00bd \u00c3\u00a1t 02:00',      'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'T~\u00c3\u00b3d\u00c3\u00a1~\u00c3\u00bd \u00c3\u00a1t 02:25',      'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'T~\u00c3\u00b3d\u00c3\u00a1~\u00c3\u00bd \u00c3\u00a1t 03:00',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'T~\u00c3\u00b3m\u00c3\u00b3~rr\u00c3\u00b3~w \u00c3\u00a1t 02:00',   'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'T~\u00c3\u00b3d\u00c3\u00a1~\u00c3\u00bd \u00c3\u00a1t 01:00',      'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00c3\u009d~\u00c3\u00a9st~\u00c3\u00a9rd\u00c3\u00a1~\u00c3\u00bd \u00c3\u00a1t 02:00',  'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a1t] LT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a1t] LT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('dddd [\u00c3\u00a1t] LT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[L~\u00c3\u00a1st] dddd [\u00c3\u00a1t] LT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[L~\u00c3\u00a1st] dddd [\u00c3\u00a1t] LT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[L~\u00c3\u00a1st] dddd [\u00c3\u00a1t] LT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('zh-cn');\n\n    test('parse', function (assert) {\n        var tests = '\u00e4\u00b8\u0080\u00e6\u009c\u0088 1\u00e6\u009c\u0088_\u00e4\u00ba\u008c\u00e6\u009c\u0088 2\u00e6\u009c\u0088_\u00e4\u00b8\u0089\u00e6\u009c\u0088 3\u00e6\u009c\u0088_\u00e5\u009b\u009b\u00e6\u009c\u0088 4\u00e6\u009c\u0088_\u00e4\u00ba\u0094\u00e6\u009c\u0088 5\u00e6\u009c\u0088_\u00e5\u0085\u00ad\u00e6\u009c\u0088 6\u00e6\u009c\u0088_\u00e4\u00b8\u0083\u00e6\u009c\u0088 7\u00e6\u009c\u0088_\u00e5\u0085\u00ab\u00e6\u009c\u0088 8\u00e6\u009c\u0088_\u00e4\u00b9\u009d\u00e6\u009c\u0088 9\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e6\u009c\u0088 10\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e4\u00b8\u0080\u00e6\u009c\u0088 11\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e4\u00ba\u008c\u00e6\u009c\u0088 12\u00e6\u009c\u0088'.split('_'), i;\n\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, a h:mm:ss',      '\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e6\u0097\u00a5, \u00e4\u00ba\u008c\u00e6\u009c\u0088 14\u00e6\u0097\u00a5 2010, \u00e4\u00b8\u008b\u00e5\u008d\u0088 3:25:50'],\n                ['ddd, Ah',                            '\u00e5\u0091\u00a8\u00e6\u0097\u00a5, \u00e4\u00b8\u008b\u00e5\u008d\u00883'],\n                ['M Mo MM MMMM MMM',                   '2 2\u00e6\u009c\u0088 02 \u00e4\u00ba\u008c\u00e6\u009c\u0088 2\u00e6\u009c\u0088'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\u00e6\u0097\u00a5 14'],\n                ['d do dddd ddd dd',                   '0 0\u00e6\u0097\u00a5 \u00e6\u0098\u009f\u00e6\u009c\u009f\u00e6\u0097\u00a5 \u00e5\u0091\u00a8\u00e6\u0097\u00a5 \u00e6\u0097\u00a5'],\n                ['DDD DDDo DDDD',                      '45 45\u00e6\u0097\u00a5 045'],\n                ['w wo ww',                            '6 6\u00e5\u0091\u00a8 06'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00e4\u00b8\u008b\u00e5\u008d\u0088 \u00e4\u00b8\u008b\u00e5\u008d\u0088'],\n                ['[\u00e8\u00bf\u0099\u00e5\u00b9\u00b4\u00e7\u009a\u0084\u00e7\u00ac\u00ac] DDDo',                    '\u00e8\u00bf\u0099\u00e5\u00b9\u00b4\u00e7\u009a\u0084\u00e7\u00ac\u00ac 45\u00e6\u0097\u00a5'],\n                ['LTS',                                '\u00e4\u00b8\u008b\u00e5\u008d\u00883\u00e7\u0082\u00b925\u00e5\u0088\u008650\u00e7\u00a7\u0092'],\n                ['L',                                  '2010-02-14'],\n                ['LL',                                 '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5'],\n                ['LLL',                                '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5\u00e4\u00b8\u008b\u00e5\u008d\u00883\u00e7\u0082\u00b925\u00e5\u0088\u0086'],\n                ['LLLL',                               '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e6\u0097\u00a5\u00e4\u00b8\u008b\u00e5\u008d\u00883\u00e7\u0082\u00b925\u00e5\u0088\u0086'],\n                ['l',                                  '2010-02-14'],\n                ['ll',                                 '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5'],\n                ['lll',                                '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5\u00e4\u00b8\u008b\u00e5\u008d\u00883\u00e7\u0082\u00b925\u00e5\u0088\u0086'],\n                ['llll',                               '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e6\u0097\u00a5\u00e4\u00b8\u008b\u00e5\u008d\u00883\u00e7\u0082\u00b925\u00e5\u0088\u0086']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e4\u00b8\u0080\u00e6\u009c\u0088 1\u00e6\u009c\u0088_\u00e4\u00ba\u008c\u00e6\u009c\u0088 2\u00e6\u009c\u0088_\u00e4\u00b8\u0089\u00e6\u009c\u0088 3\u00e6\u009c\u0088_\u00e5\u009b\u009b\u00e6\u009c\u0088 4\u00e6\u009c\u0088_\u00e4\u00ba\u0094\u00e6\u009c\u0088 5\u00e6\u009c\u0088_\u00e5\u0085\u00ad\u00e6\u009c\u0088 6\u00e6\u009c\u0088_\u00e4\u00b8\u0083\u00e6\u009c\u0088 7\u00e6\u009c\u0088_\u00e5\u0085\u00ab\u00e6\u009c\u0088 8\u00e6\u009c\u0088_\u00e4\u00b9\u009d\u00e6\u009c\u0088 9\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e6\u009c\u0088 10\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e4\u00b8\u0080\u00e6\u009c\u0088 11\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e4\u00ba\u008c\u00e6\u009c\u0088 12\u00e6\u009c\u0088'.split('_'), i;\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e6\u0097\u00a5 \u00e5\u0091\u00a8\u00e6\u0097\u00a5 \u00e6\u0097\u00a5_\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e4\u00b8\u0080 \u00e5\u0091\u00a8\u00e4\u00b8\u0080 \u00e4\u00b8\u0080_\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e4\u00ba\u008c \u00e5\u0091\u00a8\u00e4\u00ba\u008c \u00e4\u00ba\u008c_\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e4\u00b8\u0089 \u00e5\u0091\u00a8\u00e4\u00b8\u0089 \u00e4\u00b8\u0089_\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e5\u009b\u009b \u00e5\u0091\u00a8\u00e5\u009b\u009b \u00e5\u009b\u009b_\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e4\u00ba\u0094 \u00e5\u0091\u00a8\u00e4\u00ba\u0094 \u00e4\u00ba\u0094_\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e5\u0085\u00ad \u00e5\u0091\u00a8\u00e5\u0085\u00ad \u00e5\u0085\u00ad'.split('_'), i;\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e5\u0087\u00a0\u00e7\u00a7\u0092',   '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1 \u00e5\u0088\u0086\u00e9\u0092\u009f', '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1 \u00e5\u0088\u0086\u00e9\u0092\u009f', '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 \u00e5\u0088\u0086\u00e9\u0092\u009f',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 \u00e5\u0088\u0086\u00e9\u0092\u009f', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1 \u00e5\u00b0\u008f\u00e6\u0097\u00b6', '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1 \u00e5\u00b0\u008f\u00e6\u0097\u00b6', '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 \u00e5\u00b0\u008f\u00e6\u0097\u00b6',  '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 \u00e5\u00b0\u008f\u00e6\u0097\u00b6',  '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 \u00e5\u00b0\u008f\u00e6\u0097\u00b6', '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 \u00e5\u00a4\u00a9',   '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 \u00e5\u00a4\u00a9',   '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 \u00e5\u00a4\u00a9',   '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 \u00e5\u00a4\u00a9',   '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 \u00e5\u00a4\u00a9',   '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 \u00e5\u00a4\u00a9',  '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1 \u00e4\u00b8\u00aa\u00e6\u009c\u0088', '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1 \u00e4\u00b8\u00aa\u00e6\u009c\u0088', '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1 \u00e4\u00b8\u00aa\u00e6\u009c\u0088', '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 \u00e4\u00b8\u00aa\u00e6\u009c\u0088',  '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 \u00e4\u00b8\u00aa\u00e6\u009c\u0088',  '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 \u00e4\u00b8\u00aa\u00e6\u009c\u0088',  '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1 \u00e4\u00b8\u00aa\u00e6\u009c\u0088', '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 \u00e4\u00b8\u00aa\u00e6\u009c\u0088',  '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1 \u00e5\u00b9\u00b4',   '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 \u00e5\u00b9\u00b4',   '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1 \u00e5\u00b9\u00b4',   '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 \u00e5\u00b9\u00b4',   '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e5\u0087\u00a0\u00e7\u00a7\u0092\u00e5\u0086\u0085',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e5\u0087\u00a0\u00e7\u00a7\u0092\u00e5\u0089\u008d', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e5\u0087\u00a0\u00e7\u00a7\u0092\u00e5\u0089\u008d',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e5\u0087\u00a0\u00e7\u00a7\u0092\u00e5\u0086\u0085', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5 \u00e5\u00a4\u00a9\u00e5\u0086\u0085', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e4\u00bb\u008a\u00e5\u00a4\u00a9\u00e4\u00b8\u00ad\u00e5\u008d\u008812\u00e7\u0082\u00b9\u00e6\u0095\u00b4',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e4\u00bb\u008a\u00e5\u00a4\u00a9\u00e4\u00b8\u00ad\u00e5\u008d\u008812\u00e7\u0082\u00b925\u00e5\u0088\u0086',   'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00e4\u00bb\u008a\u00e5\u00a4\u00a9\u00e4\u00b8\u008b\u00e5\u008d\u00881\u00e7\u0082\u00b9\u00e6\u0095\u00b4',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e6\u0098\u008e\u00e5\u00a4\u00a9\u00e4\u00b8\u00ad\u00e5\u008d\u008812\u00e7\u0082\u00b9\u00e6\u0095\u00b4',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e4\u00bb\u008a\u00e5\u00a4\u00a9\u00e4\u00b8\u008a\u00e5\u008d\u008811\u00e7\u0082\u00b9\u00e6\u0095\u00b4',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e6\u0098\u00a8\u00e5\u00a4\u00a9\u00e4\u00b8\u00ad\u00e5\u008d\u008812\u00e7\u0082\u00b9\u00e6\u0095\u00b4',     'yesterday at the same time');\n    });\n\n    test('calendar current week', function (assert) {\n        var i, m,\n            today = moment().startOf('day');\n\n        for (i = 0; i < 7; i++) {\n            m = moment().startOf('week').add({d: i});\n            if (Math.abs(m.diff(today, 'days')) <= 1) {\n                continue; // skip today, yesterday, tomorrow\n            }\n            assert.equal(m.calendar(),       m.format('[\u00e6\u009c\u00ac]ddd\u00e5\u0087\u008c\u00e6\u0099\u00a812\u00e7\u0082\u00b9\u00e6\u0095\u00b4'),  'Monday + ' + i + ' days current time');\n        }\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m,\n            today = moment().startOf('day');\n\n        for (i = 7; i < 14; i++) {\n            m = moment().startOf('week').add({d: i});\n            if (Math.abs(m.diff(today, 'days')) >= 7) {\n                continue;\n            }\n            if (Math.abs(m.diff(today, 'days')) <= 1) {\n                continue; // skip today, yesterday, tomorrow\n            }\n            assert.equal(m.calendar(),  m.format('[\u00e4\u00b8\u008b]ddd\u00e5\u0087\u008c\u00e6\u0099\u00a812\u00e7\u0082\u00b9\u00e6\u0095\u00b4'), 'Today + ' + i + ' days beginning of day');\n        }\n        assert.equal(42, 42, 'at least one assert');\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m,\n            today = moment().startOf('day');\n\n        for (i = 1; i < 8; i++) {\n            m = moment().startOf('week').subtract({d: i});\n            if ((Math.abs(m.diff(today, 'days')) >= 7) || (Math.abs(m.diff(today, 'days')) <= 1)) {\n                continue;\n            }\n            assert.equal(m.calendar(),  m.format('[\u00e4\u00b8\u008a]ddd\u00e5\u0087\u008c\u00e6\u0099\u00a812\u00e7\u0082\u00b9\u00e6\u0095\u00b4'),  'Monday - ' + i + ' days next week');\n        }\n        assert.equal(42, 42, 'at least one assert');\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('LL'),      '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('LL'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('LL'),      '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('LL'),  'in 2 weeks');\n    });\n\n    test('meridiem', function (assert) {\n        assert.equal(moment([2011, 2, 23,  0, 0]).format('A'), '\u00e5\u0087\u008c\u00e6\u0099\u00a8', 'before dawn');\n        assert.equal(moment([2011, 2, 23,  6, 0]).format('A'), '\u00e6\u0097\u00a9\u00e4\u00b8\u008a', 'morning');\n        assert.equal(moment([2011, 2, 23,  9, 0]).format('A'), '\u00e4\u00b8\u008a\u00e5\u008d\u0088', 'before noon');\n        assert.equal(moment([2011, 2, 23, 12, 0]).format('A'), '\u00e4\u00b8\u00ad\u00e5\u008d\u0088', 'noon');\n        assert.equal(moment([2011, 2, 23, 13, 0]).format('A'), '\u00e4\u00b8\u008b\u00e5\u008d\u0088', 'afternoon');\n        assert.equal(moment([2011, 2, 23, 18, 0]).format('A'), '\u00e6\u0099\u009a\u00e4\u00b8\u008a', 'night');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52\u00e5\u0091\u00a8', 'Jan  1 2012 \u00e5\u00ba\u0094\u00e8\u00af\u00a5\u00e6\u0098\u00af\u00e7\u00ac\u00ac52\u00e5\u0091\u00a8');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1\u00e5\u0091\u00a8', 'Jan  7 2012 \u00e5\u00ba\u0094\u00e8\u00af\u00a5\u00e6\u0098\u00af\u00e7\u00ac\u00ac 1\u00e5\u0091\u00a8');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2\u00e5\u0091\u00a8', 'Jan 14 2012 \u00e5\u00ba\u0094\u00e8\u00af\u00a5\u00e6\u0098\u00af\u00e7\u00ac\u00ac 2\u00e5\u0091\u00a8');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    localeModule('zh-tw');\n\n    test('parse', function (assert) {\n        var tests = '\u00e4\u00b8\u0080\u00e6\u009c\u0088 1\u00e6\u009c\u0088_\u00e4\u00ba\u008c\u00e6\u009c\u0088 2\u00e6\u009c\u0088_\u00e4\u00b8\u0089\u00e6\u009c\u0088 3\u00e6\u009c\u0088_\u00e5\u009b\u009b\u00e6\u009c\u0088 4\u00e6\u009c\u0088_\u00e4\u00ba\u0094\u00e6\u009c\u0088 5\u00e6\u009c\u0088_\u00e5\u0085\u00ad\u00e6\u009c\u0088 6\u00e6\u009c\u0088_\u00e4\u00b8\u0083\u00e6\u009c\u0088 7\u00e6\u009c\u0088_\u00e5\u0085\u00ab\u00e6\u009c\u0088 8\u00e6\u009c\u0088_\u00e4\u00b9\u009d\u00e6\u009c\u0088 9\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e6\u009c\u0088 10\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e4\u00b8\u0080\u00e6\u009c\u0088 11\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e4\u00ba\u008c\u00e6\u009c\u0088 12\u00e6\u009c\u0088'.split('_'), i;\n        function equalTest(input, mmm, i) {\n            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));\n        }\n        for (i = 0; i < 12; i++) {\n            tests[i] = tests[i].split(' ');\n            equalTest(tests[i][0], 'MMM', i);\n            equalTest(tests[i][1], 'MMM', i);\n            equalTest(tests[i][0], 'MMMM', i);\n            equalTest(tests[i][1], 'MMMM', i);\n            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);\n            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);\n            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);\n        }\n    });\n\n    test('format', function (assert) {\n        var a = [\n                ['dddd, MMMM Do YYYY, a h:mm:ss',      '\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e6\u0097\u00a5, \u00e4\u00ba\u008c\u00e6\u009c\u0088 14\u00e6\u0097\u00a5 2010, \u00e4\u00b8\u008b\u00e5\u008d\u0088 3:25:50'],\n                ['ddd, Ah',                            '\u00e9\u0080\u00b1\u00e6\u0097\u00a5, \u00e4\u00b8\u008b\u00e5\u008d\u00883'],\n                ['M Mo MM MMMM MMM',                   '2 2\u00e6\u009c\u0088 02 \u00e4\u00ba\u008c\u00e6\u009c\u0088 2\u00e6\u009c\u0088'],\n                ['YYYY YY',                            '2010 10'],\n                ['D Do DD',                            '14 14\u00e6\u0097\u00a5 14'],\n                ['d do dddd ddd dd',                   '0 0\u00e6\u0097\u00a5 \u00e6\u0098\u009f\u00e6\u009c\u009f\u00e6\u0097\u00a5 \u00e9\u0080\u00b1\u00e6\u0097\u00a5 \u00e6\u0097\u00a5'],\n                ['DDD DDDo DDDD',                      '45 45\u00e6\u0097\u00a5 045'],\n                ['w wo ww',                            '8 8\u00e9\u0080\u00b1 08'],\n                ['h hh',                               '3 03'],\n                ['H HH',                               '15 15'],\n                ['m mm',                               '25 25'],\n                ['s ss',                               '50 50'],\n                ['a A',                                '\u00e4\u00b8\u008b\u00e5\u008d\u0088 \u00e4\u00b8\u008b\u00e5\u008d\u0088'],\n                ['[\u00e9\u0080\u0099\u00e5\u00b9\u00b4\u00e7\u009a\u0084\u00e7\u00ac\u00ac] DDDo',                    '\u00e9\u0080\u0099\u00e5\u00b9\u00b4\u00e7\u009a\u0084\u00e7\u00ac\u00ac 45\u00e6\u0097\u00a5'],\n                ['LTS',                                '\u00e4\u00b8\u008b\u00e5\u008d\u00883\u00e9\u00bb\u009e25\u00e5\u0088\u008650\u00e7\u00a7\u0092'],\n                ['L',                                  '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5'],\n                ['LL',                                 '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5'],\n                ['LLL',                                '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5\u00e4\u00b8\u008b\u00e5\u008d\u00883\u00e9\u00bb\u009e25\u00e5\u0088\u0086'],\n                ['LLLL',                               '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e6\u0097\u00a5\u00e4\u00b8\u008b\u00e5\u008d\u00883\u00e9\u00bb\u009e25\u00e5\u0088\u0086'],\n                ['l',                                  '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5'],\n                ['ll',                                 '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5'],\n                ['lll',                                '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5\u00e4\u00b8\u008b\u00e5\u008d\u00883\u00e9\u00bb\u009e25\u00e5\u0088\u0086'],\n                ['llll',                               '2010\u00e5\u00b9\u00b42\u00e6\u009c\u008814\u00e6\u0097\u00a5\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e6\u0097\u00a5\u00e4\u00b8\u008b\u00e5\u008d\u00883\u00e9\u00bb\u009e25\u00e5\u0088\u0086']\n            ],\n            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),\n            i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('format month', function (assert) {\n        var expected = '\u00e4\u00b8\u0080\u00e6\u009c\u0088 1\u00e6\u009c\u0088_\u00e4\u00ba\u008c\u00e6\u009c\u0088 2\u00e6\u009c\u0088_\u00e4\u00b8\u0089\u00e6\u009c\u0088 3\u00e6\u009c\u0088_\u00e5\u009b\u009b\u00e6\u009c\u0088 4\u00e6\u009c\u0088_\u00e4\u00ba\u0094\u00e6\u009c\u0088 5\u00e6\u009c\u0088_\u00e5\u0085\u00ad\u00e6\u009c\u0088 6\u00e6\u009c\u0088_\u00e4\u00b8\u0083\u00e6\u009c\u0088 7\u00e6\u009c\u0088_\u00e5\u0085\u00ab\u00e6\u009c\u0088 8\u00e6\u009c\u0088_\u00e4\u00b9\u009d\u00e6\u009c\u0088 9\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e6\u009c\u0088 10\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e4\u00b8\u0080\u00e6\u009c\u0088 11\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e4\u00ba\u008c\u00e6\u009c\u0088 12\u00e6\u009c\u0088'.split('_'), i;\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);\n        }\n    });\n\n    test('format week', function (assert) {\n        var expected = '\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e6\u0097\u00a5 \u00e9\u0080\u00b1\u00e6\u0097\u00a5 \u00e6\u0097\u00a5_\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e4\u00b8\u0080 \u00e9\u0080\u00b1\u00e4\u00b8\u0080 \u00e4\u00b8\u0080_\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e4\u00ba\u008c \u00e9\u0080\u00b1\u00e4\u00ba\u008c \u00e4\u00ba\u008c_\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e4\u00b8\u0089 \u00e9\u0080\u00b1\u00e4\u00b8\u0089 \u00e4\u00b8\u0089_\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e5\u009b\u009b \u00e9\u0080\u00b1\u00e5\u009b\u009b \u00e5\u009b\u009b_\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e4\u00ba\u0094 \u00e9\u0080\u00b1\u00e4\u00ba\u0094 \u00e4\u00ba\u0094_\u00e6\u0098\u009f\u00e6\u009c\u009f\u00e5\u0085\u00ad \u00e9\u0080\u00b1\u00e5\u0085\u00ad \u00e5\u0085\u00ad'.split('_'), i;\n\n        for (i = 0; i < expected.length; i++) {\n            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);\n        }\n    });\n\n    test('from', function (assert) {\n        var start = moment([2007, 1, 28]);\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\u00e5\u00b9\u00be\u00e7\u00a7\u0092',   '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1\u00e5\u0088\u0086\u00e9\u0090\u0098', '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1\u00e5\u0088\u0086\u00e9\u0090\u0098', '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2\u00e5\u0088\u0086\u00e9\u0090\u0098',  '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44\u00e5\u0088\u0086\u00e9\u0090\u0098', '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1\u00e5\u00b0\u008f\u00e6\u0099\u0082', '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1\u00e5\u00b0\u008f\u00e6\u0099\u0082', '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2\u00e5\u00b0\u008f\u00e6\u0099\u0082',  '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5\u00e5\u00b0\u008f\u00e6\u0099\u0082',  '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21\u00e5\u00b0\u008f\u00e6\u0099\u0082', '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1\u00e5\u00a4\u00a9',   '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1\u00e5\u00a4\u00a9',   '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2\u00e5\u00a4\u00a9',   '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1\u00e5\u00a4\u00a9',   '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5\u00e5\u00a4\u00a9',   '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25\u00e5\u00a4\u00a9',  '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1\u00e5\u0080\u008b\u00e6\u009c\u0088', '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1\u00e5\u0080\u008b\u00e6\u009c\u0088', '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1\u00e5\u0080\u008b\u00e6\u009c\u0088', '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2\u00e5\u0080\u008b\u00e6\u009c\u0088',  '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2\u00e5\u0080\u008b\u00e6\u009c\u0088',  '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3\u00e5\u0080\u008b\u00e6\u009c\u0088',  '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1\u00e5\u0080\u008b\u00e6\u009c\u0088', '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5\u00e5\u0080\u008b\u00e6\u009c\u0088',  '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1\u00e5\u00b9\u00b4',   '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2\u00e5\u00b9\u00b4',   '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1\u00e5\u00b9\u00b4',   '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5\u00e5\u00b9\u00b4',   '5 years = 5 years');\n    });\n\n    test('suffix', function (assert) {\n        assert.equal(moment(30000).from(0), '\u00e5\u00b9\u00be\u00e7\u00a7\u0092\u00e5\u0085\u00a7',  'prefix');\n        assert.equal(moment(0).from(30000), '\u00e5\u00b9\u00be\u00e7\u00a7\u0092\u00e5\u0089\u008d', 'suffix');\n    });\n\n    test('now from now', function (assert) {\n        assert.equal(moment().fromNow(), '\u00e5\u00b9\u00be\u00e7\u00a7\u0092\u00e5\u0089\u008d',  'now from now should display as in the past');\n    });\n\n    test('fromNow', function (assert) {\n        assert.equal(moment().add({s: 30}).fromNow(), '\u00e5\u00b9\u00be\u00e7\u00a7\u0092\u00e5\u0085\u00a7', 'in a few seconds');\n        assert.equal(moment().add({d: 5}).fromNow(), '5\u00e5\u00a4\u00a9\u00e5\u0085\u00a7', 'in 5 days');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   '\u00e4\u00bb\u008a\u00e5\u00a4\u00a9\u00e4\u00b8\u00ad\u00e5\u008d\u008812\u00e9\u00bb\u009e00\u00e5\u0088\u0086',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      '\u00e4\u00bb\u008a\u00e5\u00a4\u00a9\u00e4\u00b8\u00ad\u00e5\u008d\u008812\u00e9\u00bb\u009e25\u00e5\u0088\u0086',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       '\u00e4\u00bb\u008a\u00e5\u00a4\u00a9\u00e4\u00b8\u008b\u00e5\u008d\u00881\u00e9\u00bb\u009e00\u00e5\u0088\u0086',     'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       '\u00e6\u0098\u008e\u00e5\u00a4\u00a9\u00e4\u00b8\u00ad\u00e5\u008d\u008812\u00e9\u00bb\u009e00\u00e5\u0088\u0086',     'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  '\u00e4\u00bb\u008a\u00e5\u00a4\u00a9\u00e4\u00b8\u008a\u00e5\u008d\u008811\u00e9\u00bb\u009e00\u00e5\u0088\u0086',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  '\u00e6\u0098\u00a8\u00e5\u00a4\u00a9\u00e4\u00b8\u00ad\u00e5\u008d\u008812\u00e9\u00bb\u009e00\u00e5\u0088\u0086',     'yesterday at the same time');\n    });\n\n    test('calendar next week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().add({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e4\u00b8\u008b]ddddLT'),  'Today + ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e4\u00b8\u008b]ddddLT'),  'Today + ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e4\u00b8\u008b]ddddLT'),  'Today + ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar last week', function (assert) {\n        var i, m;\n        for (i = 2; i < 7; i++) {\n            m = moment().subtract({d: i});\n            assert.equal(m.calendar(),       m.format('[\u00e4\u00b8\u008a]ddddLT'),  'Today - ' + i + ' days current time');\n            m.hours(0).minutes(0).seconds(0).milliseconds(0);\n            assert.equal(m.calendar(),       m.format('[\u00e4\u00b8\u008a]ddddLT'),  'Today - ' + i + ' days beginning of day');\n            m.hours(23).minutes(59).seconds(59).milliseconds(999);\n            assert.equal(m.calendar(),       m.format('[\u00e4\u00b8\u008a]ddddLT'),  'Today - ' + i + ' days end of day');\n        }\n    });\n\n    test('calendar all else', function (assert) {\n        var weeksAgo = moment().subtract({w: 1}),\n            weeksFromNow = moment().add({w: 1});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');\n\n        weeksAgo = moment().subtract({w: 2});\n        weeksFromNow = moment().add({w: 2});\n\n        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '2 weeks ago');\n        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');\n    });\n\n    test('meridiem', function (assert) {\n        assert.equal(moment([2011, 2, 23,  0, 0]).format('a'), '\u00e6\u0097\u00a9\u00e4\u00b8\u008a', 'morning');\n        assert.equal(moment([2011, 2, 23,  9, 0]).format('a'), '\u00e4\u00b8\u008a\u00e5\u008d\u0088', 'before noon');\n        assert.equal(moment([2011, 2, 23, 12, 0]).format('a'), '\u00e4\u00b8\u00ad\u00e5\u008d\u0088', 'noon');\n        assert.equal(moment([2011, 2, 23, 13, 0]).format('a'), '\u00e4\u00b8\u008b\u00e5\u008d\u0088', 'after noon');\n        assert.equal(moment([2011, 2, 23, 18, 0]).format('a'), '\u00e6\u0099\u009a\u00e4\u00b8\u008a', 'night');\n\n        assert.equal(moment([2011, 2, 23,  0, 0]).format('A'), '\u00e6\u0097\u00a9\u00e4\u00b8\u008a', 'morning');\n        assert.equal(moment([2011, 2, 23,  9, 0]).format('A'), '\u00e4\u00b8\u008a\u00e5\u008d\u0088', 'before noon');\n        assert.equal(moment([2011, 2, 23, 12, 0]).format('A'), '\u00e4\u00b8\u00ad\u00e5\u008d\u0088', 'noon');\n        assert.equal(moment([2011, 2, 23, 13, 0]).format('A'), '\u00e4\u00b8\u008b\u00e5\u008d\u0088', 'afternoon');\n        assert.equal(moment([2011, 2, 23, 18, 0]).format('A'), '\u00e6\u0099\u009a\u00e4\u00b8\u008a', 'night');\n    });\n\n    test('weeks year starting sunday format', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1\u00e9\u0080\u00b1', 'Jan  1 2012 \u00e6\u0087\u0089\u00e8\u00a9\u00b2\u00e6\u0098\u00af\u00e7\u00ac\u00ac 1\u00e9\u0080\u00b1');\n        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1\u00e9\u0080\u00b1', 'Jan  7 2012 \u00e6\u0087\u0089\u00e8\u00a9\u00b2\u00e6\u0098\u00af\u00e7\u00ac\u00ac 1\u00e9\u0080\u00b1');\n        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2\u00e9\u0080\u00b1', 'Jan  8 2012 \u00e6\u0087\u0089\u00e8\u00a9\u00b2\u00e6\u0098\u00af\u00e7\u00ac\u00ac 2\u00e9\u0080\u00b1');\n        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2\u00e9\u0080\u00b1', 'Jan 14 2012 \u00e6\u0087\u0089\u00e8\u00a9\u00b2\u00e6\u0098\u00af\u00e7\u00ac\u00ac 2\u00e9\u0080\u00b1');\n        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3\u00e9\u0080\u00b1', 'Jan 15 2012 \u00e6\u0087\u0089\u00e8\u00a9\u00b2\u00e6\u0098\u00af\u00e7\u00ac\u00ac 3\u00e9\u0080\u00b1');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('add and subtract');\n\n    test('add short reverse args', function (assert) {\n        var a = moment(), b, c, d;\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        assert.equal(a.add({ms: 50}).milliseconds(), 550, 'Add milliseconds');\n        assert.equal(a.add({s: 1}).seconds(), 9, 'Add seconds');\n        assert.equal(a.add({m: 1}).minutes(), 8, 'Add minutes');\n        assert.equal(a.add({h: 1}).hours(), 7, 'Add hours');\n        assert.equal(a.add({d: 1}).date(), 13, 'Add date');\n        assert.equal(a.add({w: 1}).date(), 20, 'Add week');\n        assert.equal(a.add({M: 1}).month(), 10, 'Add month');\n        assert.equal(a.add({y: 1}).year(), 2012, 'Add year');\n        assert.equal(a.add({Q: 1}).month(), 1, 'Add quarter');\n\n        b = moment([2010, 0, 31]).add({M: 1});\n        c = moment([2010, 1, 28]).subtract({M: 1});\n        d = moment([2010, 1, 28]).subtract({Q: 1});\n\n        assert.equal(b.month(), 1, 'add month, jan 31st to feb 28th');\n        assert.equal(b.date(), 28, 'add month, jan 31st to feb 28th');\n        assert.equal(c.month(), 0, 'subtract month, feb 28th to jan 28th');\n        assert.equal(c.date(), 28, 'subtract month, feb 28th to jan 28th');\n        assert.equal(d.month(), 10, 'subtract quarter, feb 28th 2010 to nov 28th 2009');\n        assert.equal(d.date(), 28, 'subtract quarter, feb 28th 2010 to nov 28th 2009');\n        assert.equal(d.year(), 2009, 'subtract quarter, feb 28th 2010 to nov 28th 2009');\n    });\n\n    test('add long reverse args', function (assert) {\n        var a = moment();\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        assert.equal(a.add({milliseconds: 50}).milliseconds(), 550, 'Add milliseconds');\n        assert.equal(a.add({seconds: 1}).seconds(), 9, 'Add seconds');\n        assert.equal(a.add({minutes: 1}).minutes(), 8, 'Add minutes');\n        assert.equal(a.add({hours: 1}).hours(), 7, 'Add hours');\n        assert.equal(a.add({days: 1}).date(), 13, 'Add date');\n        assert.equal(a.add({weeks: 1}).date(), 20, 'Add week');\n        assert.equal(a.add({months: 1}).month(), 10, 'Add month');\n        assert.equal(a.add({years: 1}).year(), 2012, 'Add year');\n        assert.equal(a.add({quarters: 1}).month(), 1, 'Add quarter');\n    });\n\n    test('add long singular reverse args', function (assert) {\n        var a = moment();\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        assert.equal(a.add({millisecond: 50}).milliseconds(), 550, 'Add milliseconds');\n        assert.equal(a.add({second: 1}).seconds(), 9, 'Add seconds');\n        assert.equal(a.add({minute: 1}).minutes(), 8, 'Add minutes');\n        assert.equal(a.add({hour: 1}).hours(), 7, 'Add hours');\n        assert.equal(a.add({day: 1}).date(), 13, 'Add date');\n        assert.equal(a.add({week: 1}).date(), 20, 'Add week');\n        assert.equal(a.add({month: 1}).month(), 10, 'Add month');\n        assert.equal(a.add({year: 1}).year(), 2012, 'Add year');\n        assert.equal(a.add({quarter: 1}).month(), 1, 'Add quarter');\n    });\n\n    test('add string long reverse args', function (assert) {\n        var a = moment(), b;\n\n        test.expectedDeprecations('moment().add(period, number)');\n\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        b = a.clone();\n\n        assert.equal(a.add('millisecond', 50).milliseconds(), 550, 'Add milliseconds');\n        assert.equal(a.add('second', 1).seconds(), 9, 'Add seconds');\n        assert.equal(a.add('minute', 1).minutes(), 8, 'Add minutes');\n        assert.equal(a.add('hour', 1).hours(), 7, 'Add hours');\n        assert.equal(a.add('day', 1).date(), 13, 'Add date');\n        assert.equal(a.add('week', 1).date(), 20, 'Add week');\n        assert.equal(a.add('month', 1).month(), 10, 'Add month');\n        assert.equal(a.add('year', 1).year(), 2012, 'Add year');\n        assert.equal(b.add('day', '01').date(), 13, 'Add date');\n        assert.equal(a.add('quarter', 1).month(), 1, 'Add quarter');\n    });\n\n    test('add string long singular reverse args', function (assert) {\n        var a = moment(), b;\n\n        test.expectedDeprecations('moment().add(period, number)');\n\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        b = a.clone();\n\n        assert.equal(a.add('milliseconds', 50).milliseconds(), 550, 'Add milliseconds');\n        assert.equal(a.add('seconds', 1).seconds(), 9, 'Add seconds');\n        assert.equal(a.add('minutes', 1).minutes(), 8, 'Add minutes');\n        assert.equal(a.add('hours', 1).hours(), 7, 'Add hours');\n        assert.equal(a.add('days', 1).date(), 13, 'Add date');\n        assert.equal(a.add('weeks', 1).date(), 20, 'Add week');\n        assert.equal(a.add('months', 1).month(), 10, 'Add month');\n        assert.equal(a.add('years', 1).year(), 2012, 'Add year');\n        assert.equal(b.add('days', '01').date(), 13, 'Add date');\n        assert.equal(a.add('quarters', 1).month(), 1, 'Add quarter');\n    });\n\n    test('add string short reverse args', function (assert) {\n        var a = moment();\n        test.expectedDeprecations('moment().add(period, number)');\n\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        assert.equal(a.add('ms', 50).milliseconds(), 550, 'Add milliseconds');\n        assert.equal(a.add('s', 1).seconds(), 9, 'Add seconds');\n        assert.equal(a.add('m', 1).minutes(), 8, 'Add minutes');\n        assert.equal(a.add('h', 1).hours(), 7, 'Add hours');\n        assert.equal(a.add('d', 1).date(), 13, 'Add date');\n        assert.equal(a.add('w', 1).date(), 20, 'Add week');\n        assert.equal(a.add('M', 1).month(), 10, 'Add month');\n        assert.equal(a.add('y', 1).year(), 2012, 'Add year');\n        assert.equal(a.add('Q', 1).month(), 1, 'Add quarter');\n    });\n\n    test('add string long', function (assert) {\n        var a = moment();\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        assert.equal(a.add(50, 'millisecond').milliseconds(), 550, 'Add milliseconds');\n        assert.equal(a.add(1, 'second').seconds(), 9, 'Add seconds');\n        assert.equal(a.add(1, 'minute').minutes(), 8, 'Add minutes');\n        assert.equal(a.add(1, 'hour').hours(), 7, 'Add hours');\n        assert.equal(a.add(1, 'day').date(), 13, 'Add date');\n        assert.equal(a.add(1, 'week').date(), 20, 'Add week');\n        assert.equal(a.add(1, 'month').month(), 10, 'Add month');\n        assert.equal(a.add(1, 'year').year(), 2012, 'Add year');\n        assert.equal(a.add(1, 'quarter').month(), 1, 'Add quarter');\n    });\n\n    test('add string long singular', function (assert) {\n        var a = moment();\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        assert.equal(a.add(50, 'milliseconds').milliseconds(), 550, 'Add milliseconds');\n        assert.equal(a.add(1, 'seconds').seconds(), 9, 'Add seconds');\n        assert.equal(a.add(1, 'minutes').minutes(), 8, 'Add minutes');\n        assert.equal(a.add(1, 'hours').hours(), 7, 'Add hours');\n        assert.equal(a.add(1, 'days').date(), 13, 'Add date');\n        assert.equal(a.add(1, 'weeks').date(), 20, 'Add week');\n        assert.equal(a.add(1, 'months').month(), 10, 'Add month');\n        assert.equal(a.add(1, 'years').year(), 2012, 'Add year');\n        assert.equal(a.add(1, 'quarters').month(), 1, 'Add quarter');\n    });\n\n    test('add string short', function (assert) {\n        var a = moment();\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        assert.equal(a.add(50, 'ms').milliseconds(), 550, 'Add milliseconds');\n        assert.equal(a.add(1, 's').seconds(), 9, 'Add seconds');\n        assert.equal(a.add(1, 'm').minutes(), 8, 'Add minutes');\n        assert.equal(a.add(1, 'h').hours(), 7, 'Add hours');\n        assert.equal(a.add(1, 'd').date(), 13, 'Add date');\n        assert.equal(a.add(1, 'w').date(), 20, 'Add week');\n        assert.equal(a.add(1, 'M').month(), 10, 'Add month');\n        assert.equal(a.add(1, 'y').year(), 2012, 'Add year');\n        assert.equal(a.add(1, 'Q').month(), 1, 'Add quarter');\n    });\n\n    test('add strings string short reversed', function (assert) {\n        var a = moment();\n        test.expectedDeprecations('moment().add(period, number)');\n\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        assert.equal(a.add('ms', '50').milliseconds(), 550, 'Add milliseconds');\n        assert.equal(a.add('s', '1').seconds(), 9, 'Add seconds');\n        assert.equal(a.add('m', '1').minutes(), 8, 'Add minutes');\n        assert.equal(a.add('h', '1').hours(), 7, 'Add hours');\n        assert.equal(a.add('d', '1').date(), 13, 'Add date');\n        assert.equal(a.add('w', '1').date(), 20, 'Add week');\n        assert.equal(a.add('M', '1').month(), 10, 'Add month');\n        assert.equal(a.add('y', '1').year(), 2012, 'Add year');\n        assert.equal(a.add('Q', '1').month(), 1, 'Add quarter');\n    });\n\n    test('subtract strings string short reversed', function (assert) {\n        var a = moment();\n        test.expectedDeprecations('moment().subtract(period, number)');\n\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        assert.equal(a.subtract('ms', '50').milliseconds(), 450, 'Subtract milliseconds');\n        assert.equal(a.subtract('s', '1').seconds(), 7, 'Subtract seconds');\n        assert.equal(a.subtract('m', '1').minutes(), 6, 'Subtract minutes');\n        assert.equal(a.subtract('h', '1').hours(), 5, 'Subtract hours');\n        assert.equal(a.subtract('d', '1').date(), 11, 'Subtract date');\n        assert.equal(a.subtract('w', '1').date(), 4, 'Subtract week');\n        assert.equal(a.subtract('M', '1').month(), 8, 'Subtract month');\n        assert.equal(a.subtract('y', '1').year(), 2010, 'Subtract year');\n        assert.equal(a.subtract('Q', '1').month(), 5, 'Subtract quarter');\n    });\n\n    test('add strings string short', function (assert) {\n        var a = moment();\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        assert.equal(a.add('50', 'ms').milliseconds(), 550, 'Add milliseconds');\n        assert.equal(a.add('1', 's').seconds(), 9, 'Add seconds');\n        assert.equal(a.add('1', 'm').minutes(), 8, 'Add minutes');\n        assert.equal(a.add('1', 'h').hours(), 7, 'Add hours');\n        assert.equal(a.add('1', 'd').date(), 13, 'Add date');\n        assert.equal(a.add('1', 'w').date(), 20, 'Add week');\n        assert.equal(a.add('1', 'M').month(), 10, 'Add month');\n        assert.equal(a.add('1', 'y').year(), 2012, 'Add year');\n        assert.equal(a.add('1', 'Q').month(), 1, 'Add quarter');\n    });\n\n    test('subtract strings string short', function (assert) {\n        var a = moment();\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(500);\n\n        assert.equal(a.subtract('50', 'ms').milliseconds(), 450, 'Subtract milliseconds');\n        assert.equal(a.subtract('1', 's').seconds(), 7, 'Subtract seconds');\n        assert.equal(a.subtract('1', 'm').minutes(), 6, 'Subtract minutes');\n        assert.equal(a.subtract('1', 'h').hours(), 5, 'Subtract hours');\n        assert.equal(a.subtract('1', 'd').date(), 11, 'Subtract date');\n        assert.equal(a.subtract('1', 'w').date(), 4, 'Subtract week');\n        assert.equal(a.subtract('1', 'M').month(), 8, 'Subtract month');\n        assert.equal(a.subtract('1', 'y').year(), 2010, 'Subtract year');\n        assert.equal(a.subtract('1', 'Q').month(), 5, 'Subtract quarter');\n    });\n\n    test('add across DST', function (assert) {\n        // Detect Safari bug and bail. Hours on 13th March 2011 are shifted\n        // with 1 ahead.\n        if (new Date(2011, 2, 13, 5, 0, 0).getHours() !== 5) {\n            expect(0);\n            return;\n        }\n\n        var a = moment(new Date(2011, 2, 12, 5, 0, 0)),\n            b = moment(new Date(2011, 2, 12, 5, 0, 0)),\n            c = moment(new Date(2011, 2, 12, 5, 0, 0)),\n            d = moment(new Date(2011, 2, 12, 5, 0, 0)),\n            e = moment(new Date(2011, 2, 12, 5, 0, 0));\n        a.add(1, 'days');\n        b.add(24, 'hours');\n        c.add(1, 'months');\n        e.add(1, 'quarter');\n\n        assert.equal(a.hours(), 5, 'adding days over DST difference should result in the same hour');\n        if (b.isDST() && !d.isDST()) {\n            assert.equal(b.hours(), 6, 'adding hours over DST difference should result in a different hour');\n        } else if (!b.isDST() && d.isDST()) {\n            assert.equal(b.hours(), 4, 'adding hours over DST difference should result in a different hour');\n        } else {\n            assert.equal(b.hours(), 5, 'adding hours over DST difference should result in a same hour if the timezone does not have daylight savings time');\n        }\n        assert.equal(c.hours(), 5, 'adding months over DST difference should result in the same hour');\n        assert.equal(e.hours(), 5, 'adding quarters over DST difference should result in the same hour');\n    });\n\n    test('add decimal values of days and months', function (assert) {\n        assert.equal(moment([2016,3,3]).add(1.5, 'days').date(), 5, 'adding 1.5 days is rounded to adding 2 day');\n        assert.equal(moment([2016,3,3]).add(-1.5, 'days').date(), 1, 'adding -1.5 days is rounded to adding -2 day');\n        assert.equal(moment([2016,3,1]).add(-1.5, 'days').date(), 30, 'adding -1.5 days on first of month wraps around');\n        assert.equal(moment([2016,3,3]).add(1.5, 'months').month(), 5, 'adding 1.5 months adds 2 months');\n        assert.equal(moment([2016,3,3]).add(-1.5, 'months').month(), 1, 'adding -1.5 months adds -2 months');\n        assert.equal(moment([2016,0,3]).add(-1.5, 'months').month(), 10, 'adding -1.5 months at start of year wraps back');\n        assert.equal(moment([2016,3,3]).subtract(1.5, 'days').date(),1, 'subtract 1.5 days is rounded to subtract 2 day');\n        assert.equal(moment([2016,3,2]).subtract(1.5, 'days').date(), 31, 'subtract 1.5 days subtracts 2 days');\n        assert.equal(moment([2016,1,1]).subtract(1.1, 'days').date(), 31, 'subtract 1.1 days wraps to previous month');\n        assert.equal(moment([2016,3,3]).subtract(-1.5, 'days').date(), 5, 'subtract -1.5 days is rounded to subtract -2 day');\n        assert.equal(moment([2016,3,30]).subtract(-1.5, 'days').date(), 2, 'subtract -1.5 days on last of month wraps around');\n        assert.equal(moment([2016,3,3]).subtract(1.5, 'months').month(), 1, 'subtract 1.5 months subtract 2 months');\n        assert.equal(moment([2016,3,3]).subtract(-1.5, 'months').month(), 5, 'subtract -1.5 months subtract -2 month');\n        assert.equal(moment([2016,11,31]).subtract(-1.5, 'months').month(),1, 'subtract -1.5 months at end of year wraps back');\n        assert.equal(moment([2016, 0,1]).add(1.5, 'years').format('YYYY-MM-DD'), '2017-07-01', 'add 1.5 years adds 1 year six months');\n        assert.equal(moment([2016, 0,1]).add(1.6, 'years').format('YYYY-MM-DD'), '2017-08-01', 'add 1.6 years becomes 1.6*12 = 19.2, round, 19 months');\n        assert.equal(moment([2016,0,1]).add(1.1, 'quarters').format('YYYY-MM-DD'), '2016-04-01', 'add 1.1 quarters 1.1*3=3.3, round, 3 months');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    // These tests are for locale independent features\n    // locale dependent tests would be in locale test folder\n    module('calendar');\n\n    test('passing a function', function (assert) {\n        var a  = moment().hours(13).minutes(0).seconds(0);\n        assert.equal(moment(a).calendar(null, {\n            'sameDay': function () {\n                return 'h:mmA';\n            }\n        }), '1:00PM', 'should equate');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('create');\n\n    test('array', function (assert) {\n        assert.ok(moment([2010]).toDate() instanceof Date, '[2010]');\n        assert.ok(moment([2010, 1]).toDate() instanceof Date, '[2010, 1]');\n        assert.ok(moment([2010, 1, 12]).toDate() instanceof Date, '[2010, 1, 12]');\n        assert.ok(moment([2010, 1, 12, 1]).toDate() instanceof Date, '[2010, 1, 12, 1]');\n        assert.ok(moment([2010, 1, 12, 1, 1]).toDate() instanceof Date, '[2010, 1, 12, 1, 1]');\n        assert.ok(moment([2010, 1, 12, 1, 1, 1]).toDate() instanceof Date, '[2010, 1, 12, 1, 1, 1]');\n        assert.ok(moment([2010, 1, 12, 1, 1, 1, 1]).toDate() instanceof Date, '[2010, 1, 12, 1, 1, 1, 1]');\n        assert.equal(+moment(new Date(2010, 1, 14, 15, 25, 50, 125)), +moment([2010, 1, 14, 15, 25, 50, 125]), 'constructing with array === constructing with new Date()');\n    });\n\n    test('array with invalid arguments', function (assert) {\n        assert.ok(!moment([2010, null, null]).isValid(), '[2010, null, null]');\n        assert.ok(!moment([1945, null, null]).isValid(), '[1945, null, null] (pre-1970)');\n    });\n\n    test('array copying', function (assert) {\n        var importantArray = [2009, 11];\n        moment(importantArray);\n        assert.deepEqual(importantArray, [2009, 11], 'initializer should not mutate the original array');\n    });\n\n    test('object', function (assert) {\n        var fmt = 'YYYY-MM-DD HH:mm:ss.SSS',\n            tests = [\n                [{year: 2010}, '2010-01-01 00:00:00.000'],\n                [{year: 2010, month: 1}, '2010-02-01 00:00:00.000'],\n                [{year: 2010, month: 1, day: 12}, '2010-02-12 00:00:00.000'],\n                [{year: 2010, month: 1, date: 12}, '2010-02-12 00:00:00.000'],\n                [{year: 2010, month: 1, day: 12, hours: 1}, '2010-02-12 01:00:00.000'],\n                [{year: 2010, month: 1, date: 12, hours: 1}, '2010-02-12 01:00:00.000'],\n                [{year: 2010, month: 1, day: 12, hours: 1, minutes: 1}, '2010-02-12 01:01:00.000'],\n                [{year: 2010, month: 1, date: 12, hours: 1, minutes: 1}, '2010-02-12 01:01:00.000'],\n                [{year: 2010, month: 1, day: 12, hours: 1, minutes: 1, seconds: 1}, '2010-02-12 01:01:01.000'],\n                [{year: 2010, month: 1, day: 12, hours: 1, minutes: 1, seconds: 1, milliseconds: 1}, '2010-02-12 01:01:01.001'],\n                [{years: 2010, months: 1, days: 14, hours: 15, minutes: 25, seconds: 50, milliseconds: 125}, '2010-02-14 15:25:50.125'],\n                [{year: 2010, month: 1, day: 14, hour: 15, minute: 25, second: 50, millisecond: 125}, '2010-02-14 15:25:50.125'],\n                [{y: 2010, M: 1, d: 14, h: 15, m: 25, s: 50, ms: 125}, '2010-02-14 15:25:50.125']\n            ], i;\n        for (i = 0; i < tests.length; ++i) {\n            assert.equal(moment(tests[i][0]).format(fmt), tests[i][1]);\n        }\n    });\n\n    test('multi format array copying', function (assert) {\n        var importantArray = ['MM/DD/YYYY', 'YYYY-MM-DD', 'MM-DD-YYYY'];\n        moment('1999-02-13', importantArray);\n        assert.deepEqual(importantArray, ['MM/DD/YYYY', 'YYYY-MM-DD', 'MM-DD-YYYY'], 'initializer should not mutate the original array');\n    });\n\n    test('number', function (assert) {\n        assert.ok(moment(1000).toDate() instanceof Date, '1000');\n        assert.equal(moment(1000).valueOf(), 1000, 'asserting valueOf');\n        assert.equal(moment.utc(1000).valueOf(), 1000, 'asserting valueOf');\n    });\n\n    test('unix', function (assert) {\n        assert.equal(moment.unix(1).valueOf(), 1000, '1 unix timestamp == 1000 Date.valueOf');\n        assert.equal(moment(1000).unix(), 1, '1000 Date.valueOf == 1 unix timestamp');\n        assert.equal(moment.unix(1000).valueOf(), 1000000, '1000 unix timestamp == 1000000 Date.valueOf');\n        assert.equal(moment(1500).unix(), 1, '1500 Date.valueOf == 1 unix timestamp');\n        assert.equal(moment(1900).unix(), 1, '1900 Date.valueOf == 1 unix timestamp');\n        assert.equal(moment(2100).unix(), 2, '2100 Date.valueOf == 2 unix timestamp');\n        assert.equal(moment(1333129333524).unix(), 1333129333, '1333129333524 Date.valueOf == 1333129333 unix timestamp');\n        assert.equal(moment(1333129333524000).unix(), 1333129333524, '1333129333524000 Date.valueOf == 1333129333524 unix timestamp');\n    });\n\n    test('date', function (assert) {\n        assert.ok(moment(new Date()).toDate() instanceof Date, 'new Date()');\n    });\n\n    test('date mutation', function (assert) {\n        var a = new Date();\n        assert.ok(moment(a).toDate() !== a, 'the date moment uses should not be the date passed in');\n    });\n\n    test('moment', function (assert) {\n        assert.ok(moment(moment()).toDate() instanceof Date, 'moment(moment())');\n        assert.ok(moment(moment(moment())).toDate() instanceof Date, 'moment(moment(moment()))');\n    });\n\n    test('cloning moment should only copy own properties', function (assert) {\n        assert.ok(!moment().clone().hasOwnProperty('month'), 'Should not clone prototype methods');\n    });\n\n    test('cloning moment works with weird clones', function (assert) {\n        var extend = function (a, b) {\n            var i;\n            for (i in b) {\n                a[i] = b[i];\n            }\n            return a;\n        },\n        now = moment(),\n        nowu = moment.utc();\n\n        assert.equal(+extend({}, now).clone(), +now, 'cloning extend-ed now is now');\n        assert.equal(+extend({}, nowu).clone(), +nowu, 'cloning extend-ed utc now is utc now');\n    });\n\n    test('cloning respects moment.momentProperties', function (assert) {\n        var m = moment();\n\n        assert.equal(m.clone()._special, undefined, 'cloning ignores extra properties');\n        m._special = 'bacon';\n        moment.momentProperties.push('_special');\n        assert.equal(m.clone()._special, 'bacon', 'cloning respects momentProperties');\n        moment.momentProperties.pop();\n    });\n\n    test('undefined', function (assert) {\n        assert.ok(moment().toDate() instanceof Date, 'undefined');\n    });\n\n    test('iso with bad input', function (assert) {\n        assert.ok(!moment('a', moment.ISO_8601).isValid(), 'iso parsing with invalid string');\n        assert.ok(!moment('a', moment.ISO_8601, true).isValid(), 'iso parsing with invalid string, strict');\n    });\n\n    test('iso format 24hrs', function (assert) {\n        assert.equal(moment('2014-01-01T24:00:00.000').format('YYYY-MM-DD[T]HH:mm:ss.SSS'),\n                '2014-01-02T00:00:00.000', 'iso format with 24:00 localtime');\n        assert.equal(moment.utc('2014-01-01T24:00:00.000').format('YYYY-MM-DD[T]HH:mm:ss.SSS'),\n                '2014-01-02T00:00:00.000', 'iso format with 24:00 utc');\n    });\n\n    test('string without format - json', function (assert) {\n        assert.equal(moment('Date(1325132654000)').valueOf(), 1325132654000, 'Date(1325132654000)');\n        assert.equal(moment('Date(-1325132654000)').valueOf(), -1325132654000, 'Date(-1325132654000)');\n        assert.equal(moment('/Date(1325132654000)/').valueOf(), 1325132654000, '/Date(1325132654000)/');\n        assert.equal(moment('/Date(1325132654000+0700)/').valueOf(), 1325132654000, '/Date(1325132654000+0700)/');\n        assert.equal(moment('/Date(1325132654000-0700)/').valueOf(), 1325132654000, '/Date(1325132654000-0700)/');\n    });\n\n    test('string with format dropped am/pm bug', function (assert) {\n        moment.locale('en');\n\n        assert.equal(moment('05/1/2012 12:25:00', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');\n        assert.equal(moment('05/1/2012 12:25:00 am', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');\n        assert.equal(moment('05/1/2012 12:25:00 pm', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');\n\n        assert.ok(moment('05/1/2012 12:25:00', 'MM/DD/YYYY h:m:s a').isValid());\n        assert.ok(moment('05/1/2012 12:25:00 am', 'MM/DD/YYYY h:m:s a').isValid());\n        assert.ok(moment('05/1/2012 12:25:00 pm', 'MM/DD/YYYY h:m:s a').isValid());\n    });\n\n    test('empty string with formats', function (assert) {\n        assert.equal(moment('', 'MM').format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');\n        assert.equal(moment(' ', 'MM').format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');\n        assert.equal(moment(' ', 'DD').format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');\n        assert.equal(moment(' ', ['MM', 'DD']).format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');\n\n        assert.ok(!moment('', 'MM').isValid());\n        assert.ok(!moment(' ', 'MM').isValid());\n        assert.ok(!moment(' ', 'DD').isValid());\n        assert.ok(!moment(' ', ['MM', 'DD']).isValid());\n    });\n\n    test('defaulting to current date', function (assert) {\n        var now = moment();\n        assert.equal(moment('12:13:14', 'hh:mm:ss').format('YYYY-MM-DD hh:mm:ss'),\n                     now.clone().hour(12).minute(13).second(14).format('YYYY-MM-DD hh:mm:ss'),\n                     'given only time default to current date');\n        assert.equal(moment('05', 'DD').format('YYYY-MM-DD'),\n                     now.clone().date(5).format('YYYY-MM-DD'),\n                     'given day of month default to current month, year');\n        assert.equal(moment('05', 'MM').format('YYYY-MM-DD'),\n                     now.clone().month(4).date(1).format('YYYY-MM-DD'),\n                     'given month default to current year');\n        assert.equal(moment('1996', 'YYYY').format('YYYY-MM-DD'),\n                     now.clone().year(1996).month(0).date(1).format('YYYY-MM-DD'),\n                     'given year do not default');\n    });\n\n    test('matching am/pm', function (assert) {\n        assert.equal(moment('2012-09-03T03:00PM',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for PM');\n        assert.equal(moment('2012-09-03T03:00P.M.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for P.M.');\n        assert.equal(moment('2012-09-03T03:00P',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for P');\n        assert.equal(moment('2012-09-03T03:00pm',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for pm');\n        assert.equal(moment('2012-09-03T03:00p.m.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for p.m.');\n        assert.equal(moment('2012-09-03T03:00p',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for p');\n\n        assert.equal(moment('2012-09-03T03:00AM',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for AM');\n        assert.equal(moment('2012-09-03T03:00A.M.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for A.M.');\n        assert.equal(moment('2012-09-03T03:00A',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for A');\n        assert.equal(moment('2012-09-03T03:00am',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for am');\n        assert.equal(moment('2012-09-03T03:00a.m.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for a.m.');\n        assert.equal(moment('2012-09-03T03:00a',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for a');\n\n        assert.equal(moment('5:00p.m.March 4 2012', 'h:mmAMMMM D YYYY').format('YYYY-MM-DDThh:mmA'), '2012-03-04T05:00PM', 'am/pm should parse correctly before month names');\n    });\n\n    test('string with format', function (assert) {\n        moment.locale('en');\n        var a = [\n            ['YYYY-Q',              '2014-4'],\n            ['MM-DD-YYYY',          '12-02-1999'],\n            ['DD-MM-YYYY',          '12-02-1999'],\n            ['DD/MM/YYYY',          '12/02/1999'],\n            ['DD_MM_YYYY',          '12_02_1999'],\n            ['DD:MM:YYYY',          '12:02:1999'],\n            ['D-M-YY',              '2-2-99'],\n            ['YY',                  '99'],\n            ['DDD-YYYY',            '300-1999'],\n            ['DD-MM-YYYY h:m:s',    '12-02-1999 2:45:10'],\n            ['DD-MM-YYYY h:m:s a',  '12-02-1999 2:45:10 am'],\n            ['DD-MM-YYYY h:m:s a',  '12-02-1999 2:45:10 pm'],\n            ['h:mm a',              '12:00 pm'],\n            ['h:mm a',              '12:30 pm'],\n            ['h:mm a',              '12:00 am'],\n            ['h:mm a',              '12:30 am'],\n            ['HH:mm',               '12:00'],\n            ['YYYY-MM-DDTHH:mm:ss', '2011-11-11T11:11:11'],\n            ['MM-DD-YYYY [M]',      '12-02-1999 M'],\n            ['ddd MMM DD HH:mm:ss YYYY', 'Tue Apr 07 22:52:51 2009'],\n            ['HH:mm:ss',            '12:00:00'],\n            ['HH:mm:ss',            '12:30:00'],\n            ['HH:mm:ss',            '00:00:00'],\n            ['HH:mm:ss S',          '00:30:00 1'],\n            ['HH:mm:ss SS',         '00:30:00 12'],\n            ['HH:mm:ss SSS',        '00:30:00 123'],\n            ['HH:mm:ss S',          '00:30:00 7'],\n            ['HH:mm:ss SS',         '00:30:00 78'],\n            ['HH:mm:ss SSS',        '00:30:00 789'],\n            ['X',                   '1234567890'],\n            ['x',                   '1234567890123'],\n            ['LT',                  '12:30 AM'],\n            ['LTS',                 '12:30:29 AM'],\n            ['L',                   '09/02/1999'],\n            ['l',                   '9/2/1999'],\n            ['LL',                  'September 2, 1999'],\n            ['ll',                  'Sep 2, 1999'],\n            ['LLL',                 'September 2, 1999 12:30 AM'],\n            ['lll',                 'Sep 2, 1999 12:30 AM'],\n            ['LLLL',                'Thursday, September 2, 1999 12:30 AM'],\n            ['llll',                'Thu, Sep 2, 1999 12:30 AM']\n        ],\n        m,\n        i;\n\n        for (i = 0; i < a.length; i++) {\n            m = moment(a[i][1], a[i][0]);\n            assert.ok(m.isValid());\n            assert.equal(m.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('2 digit year with YYYY format', function (assert) {\n        assert.equal(moment('9/2/99', 'D/M/YYYY').format('DD/MM/YYYY'), '09/02/1999', 'D/M/YYYY ---> 9/2/99');\n        assert.equal(moment('9/2/1999', 'D/M/YYYY').format('DD/MM/YYYY'), '09/02/1999', 'D/M/YYYY ---> 9/2/1999');\n        assert.equal(moment('9/2/68', 'D/M/YYYY').format('DD/MM/YYYY'), '09/02/2068', 'D/M/YYYY ---> 9/2/68');\n        assert.equal(moment('9/2/69', 'D/M/YYYY').format('DD/MM/YYYY'), '09/02/1969', 'D/M/YYYY ---> 9/2/69');\n    });\n\n    test('unix timestamp format', function (assert) {\n        var formats = ['X', 'X.S', 'X.SS', 'X.SSS'], i, format;\n\n        for (i = 0; i < formats.length; i++) {\n            format = formats[i];\n            assert.equal(moment('1234567890',     format).valueOf(), 1234567890 * 1000,       format + ' matches timestamp without milliseconds');\n            assert.equal(moment('1234567890.1',   format).valueOf(), 1234567890 * 1000 + 100, format + ' matches timestamp with deciseconds');\n            assert.equal(moment('1234567890.12',  format).valueOf(), 1234567890 * 1000 + 120, format + ' matches timestamp with centiseconds');\n            assert.equal(moment('1234567890.123', format).valueOf(), 1234567890 * 1000 + 123, format + ' matches timestamp with milliseconds');\n        }\n    });\n\n    test('unix offset milliseconds', function (assert) {\n        assert.equal(moment('1234567890123', 'x').valueOf(), 1234567890123, 'x matches unix offset in milliseconds');\n    });\n\n    test('milliseconds format', function (assert) {\n        assert.equal(moment('1', 'S').get('ms'), 100, 'deciseconds');\n        // assert.equal(moment('10', 'S', true).isValid(), false, 'deciseconds with two digits');\n        // assert.equal(moment('1', 'SS', true).isValid(), false, 'centiseconds with one digits');\n        assert.equal(moment('12', 'SS').get('ms'), 120, 'centiseconds');\n        // assert.equal(moment('123', 'SS', true).isValid(), false, 'centiseconds with three digits');\n        assert.equal(moment('123', 'SSS').get('ms'), 123, 'milliseconds');\n        assert.equal(moment('1234', 'SSSS').get('ms'), 123, 'milliseconds with SSSS');\n        assert.equal(moment('123456789101112', 'SSSS').get('ms'), 123, 'milliseconds with SSSS');\n    });\n\n    test('string with format no separators', function (assert) {\n        moment.locale('en');\n        var a = [\n            ['MMDDYYYY',          '12021999'],\n            ['DDMMYYYY',          '12021999'],\n            ['YYYYMMDD',          '19991202'],\n            ['DDMMMYYYY',         '10Sep2001']\n        ], i;\n\n        for (i = 0; i < a.length; i++) {\n            assert.equal(moment(a[i][1], a[i][0]).format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);\n        }\n    });\n\n    test('string with format (timezone)', function (assert) {\n        assert.equal(moment('5 -0700', 'H ZZ').toDate().getUTCHours(), 12, 'parse hours \\'5 -0700\\' ---> \\'H ZZ\\'');\n        assert.equal(moment('5 -07:00', 'H Z').toDate().getUTCHours(), 12, 'parse hours \\'5 -07:00\\' ---> \\'H Z\\'');\n        assert.equal(moment('5 -0730', 'H ZZ').toDate().getUTCMinutes(), 30, 'parse hours \\'5 -0730\\' ---> \\'H ZZ\\'');\n        assert.equal(moment('5 -07:30', 'H Z').toDate().getUTCMinutes(), 30, 'parse hours \\'5 -07:0\\' ---> \\'H Z\\'');\n        assert.equal(moment('5 +0100', 'H ZZ').toDate().getUTCHours(), 4, 'parse hours \\'5 +0100\\' ---> \\'H ZZ\\'');\n        assert.equal(moment('5 +01:00', 'H Z').toDate().getUTCHours(), 4, 'parse hours \\'5 +01:00\\' ---> \\'H Z\\'');\n        assert.equal(moment('5 +0130', 'H ZZ').toDate().getUTCMinutes(), 30, 'parse hours \\'5 +0130\\' ---> \\'H ZZ\\'');\n        assert.equal(moment('5 +01:30', 'H Z').toDate().getUTCMinutes(), 30, 'parse hours \\'5 +01:30\\' ---> \\'H Z\\'');\n    });\n\n    test('string with format (timezone offset)', function (assert) {\n        var a, b, c, d, e, f;\n        a = new Date(Date.UTC(2011, 0, 1, 1));\n        b = moment('2011 1 1 0 -01:00', 'YYYY MM DD HH Z');\n        assert.equal(a.getHours(), b.hours(), 'date created with utc == parsed string with timezone offset');\n        assert.equal(+a, +b, 'date created with utc == parsed string with timezone offset');\n        c = moment('2011 2 1 10 -05:00', 'YYYY MM DD HH Z');\n        d = moment('2011 2 1 8 -07:00', 'YYYY MM DD HH Z');\n        assert.equal(c.hours(), d.hours(), '10 am central time == 8 am pacific time');\n        e = moment.utc('Fri, 20 Jul 2012 17:15:00', 'ddd, DD MMM YYYY HH:mm:ss');\n        f = moment.utc('Fri, 20 Jul 2012 10:15:00 -0700', 'ddd, DD MMM YYYY HH:mm:ss ZZ');\n        assert.equal(e.hours(), f.hours(), 'parse timezone offset in utc');\n    });\n\n    test('string with timezone around start of year', function (assert) {\n        assert.equal(moment('2000-01-01T00:00:00.000+01:00').toISOString(), '1999-12-31T23:00:00.000Z', '+1:00 around 2000');\n        assert.equal(moment('2000-01-01T00:00:00.000-01:00').toISOString(), '2000-01-01T01:00:00.000Z', '-1:00 around 2000');\n        assert.equal(moment('1970-01-01T00:00:00.000+01:00').toISOString(), '1969-12-31T23:00:00.000Z', '+1:00 around 1970');\n        assert.equal(moment('1970-01-01T00:00:00.000-01:00').toISOString(), '1970-01-01T01:00:00.000Z', '-1:00 around 1970');\n        assert.equal(moment('1200-01-01T00:00:00.000+01:00').toISOString(), '1199-12-31T23:00:00.000Z', '+1:00 around 1200');\n        assert.equal(moment('1200-01-01T00:00:00.000-01:00').toISOString(), '1200-01-01T01:00:00.000Z', '-1:00 around 1200');\n    });\n\n    test('string with array of formats', function (assert) {\n        assert.equal(moment('11-02-1999', ['MM-DD-YYYY', 'DD-MM-YYYY']).format('MM DD YYYY'), '11 02 1999', 'switching month and day');\n        assert.equal(moment('02-11-1999', ['MM/DD/YYYY', 'YYYY MM DD', 'MM-DD-YYYY']).format('MM DD YYYY'), '02 11 1999', 'year last');\n        assert.equal(moment('1999-02-11', ['MM/DD/YYYY', 'YYYY MM DD', 'MM-DD-YYYY']).format('MM DD YYYY'), '02 11 1999', 'year first');\n\n        assert.equal(moment('02-11-1999', ['MM/DD/YYYY', 'YYYY MM DD']).format('MM DD YYYY'), '02 11 1999', 'year last');\n        assert.equal(moment('1999-02-11', ['MM/DD/YYYY', 'YYYY MM DD']).format('MM DD YYYY'), '02 11 1999', 'year first');\n        assert.equal(moment('02-11-1999', ['YYYY MM DD', 'MM/DD/YYYY']).format('MM DD YYYY'), '02 11 1999', 'year last');\n        assert.equal(moment('1999-02-11', ['YYYY MM DD', 'MM/DD/YYYY']).format('MM DD YYYY'), '02 11 1999', 'year first');\n\n        assert.equal(moment('13-11-1999', ['MM/DD/YYYY', 'DD/MM/YYYY']).format('MM DD YYYY'), '11 13 1999', 'second must be month');\n        assert.equal(moment('11-13-1999', ['MM/DD/YYYY', 'DD/MM/YYYY']).format('MM DD YYYY'), '11 13 1999', 'first must be month');\n        assert.equal(moment('01-02-2000', ['MM/DD/YYYY', 'DD/MM/YYYY']).format('MM DD YYYY'), '01 02 2000', 'either can be a month, month first format');\n        assert.equal(moment('02-01-2000', ['DD/MM/YYYY', 'MM/DD/YYYY']).format('MM DD YYYY'), '01 02 2000', 'either can be a month, day first format');\n\n        assert.equal(moment('11-02-10', ['MM/DD/YY', 'YY MM DD', 'DD-MM-YY']).format('MM DD YYYY'), '02 11 2010', 'all unparsed substrings have influence on format penalty');\n        assert.equal(moment('11-02-10', ['MM-DD-YY HH:mm', 'YY MM DD']).format('MM DD YYYY'), '02 10 2011', 'prefer formats without extra tokens');\n        assert.equal(moment('11-02-10 junk', ['MM-DD-YY', 'YY.MM.DD junk']).format('MM DD YYYY'), '02 10 2011', 'prefer formats that dont result in extra characters');\n        assert.equal(moment('11-22-10', ['YY-MM-DD', 'YY-DD-MM']).format('MM DD YYYY'), '10 22 2011', 'prefer valid results');\n\n        assert.equal(moment('gibberish', ['YY-MM-DD', 'YY-DD-MM']).format('MM DD YYYY'), 'Invalid date', 'doest throw for invalid strings');\n        assert.equal(moment('gibberish', []).format('MM DD YYYY'), 'Invalid date', 'doest throw for an empty array');\n\n        //https://github.com/moment/moment/issues/1143\n        assert.equal(moment(\n            'System Administrator and Database Assistant (7/1/2011), System Administrator and Database Assistant (7/1/2011), Database Coordinator (7/1/2011), Vice President (7/1/2011), System Administrator and Database Assistant (5/31/2012), Database Coordinator (7/1/2012), System Administrator and Database Assistant (7/1/2013)',\n            ['MM/DD/YYYY', 'MM-DD-YYYY', 'YYYY-MM-DD', 'YYYY-MM-DDTHH:mm:ssZ'])\n            .format('YYYY-MM-DD'), '2011-07-01', 'Works for long strings');\n\n        assert.equal(moment('11-02-10', ['MM.DD.YY', 'DD-MM-YY']).format('MM DD YYYY'), '02 11 2010', 'escape RegExp special characters on comparing');\n\n        assert.equal(moment('13-10-98', ['DD MM YY', 'DD MM YYYY'])._f, 'DD MM YY', 'use two digit year');\n        assert.equal(moment('13-10-1998', ['DD MM YY', 'DD MM YYYY'])._f, 'DD MM YYYY', 'use four digit year');\n\n        assert.equal(moment('01', ['MM', 'DD'])._f, 'MM', 'Should use first valid format');\n    });\n\n    test('string with array of formats + ISO', function (assert) {\n        assert.equal(moment('1994', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).year(), 1994, 'iso: assert parse YYYY');\n        assert.equal(moment('17:15', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).hour(), 17, 'iso: assert parse HH:mm (1)');\n        assert.equal(moment('17:15', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).minutes(), 15, 'iso: assert parse HH:mm (2)');\n        assert.equal(moment('06', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).month(), 6 - 1, 'iso: assert parse MM');\n        assert.equal(moment('2012-06-01', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).parsingFlags().iso, true, 'iso: assert parse iso');\n        assert.equal(moment('2014-05-05', [moment.ISO_8601, 'YYYY-MM-DD']).parsingFlags().iso, true, 'iso: edge case array precedence iso');\n        assert.equal(moment('2014-05-05', ['YYYY-MM-DD', moment.ISO_8601]).parsingFlags().iso, false, 'iso: edge case array precedence not iso');\n    });\n\n    test('string with format - years', function (assert) {\n        assert.equal(moment('67', 'YY').format('YYYY'), '2067', '67 > 2067');\n        assert.equal(moment('68', 'YY').format('YYYY'), '2068', '68 > 2068');\n        assert.equal(moment('69', 'YY').format('YYYY'), '1969', '69 > 1969');\n        assert.equal(moment('70', 'YY').format('YYYY'), '1970', '70 > 1970');\n    });\n\n    test('implicit cloning', function (assert) {\n        var momentA = moment([2011, 10, 10]),\n        momentB = moment(momentA);\n        momentA.month(5);\n        assert.equal(momentB.month(), 10, 'Calling moment() on a moment will create a clone');\n        assert.equal(momentA.month(), 5, 'Calling moment() on a moment will create a clone');\n    });\n\n    test('explicit cloning', function (assert) {\n        var momentA = moment([2011, 10, 10]),\n        momentB = momentA.clone();\n        momentA.month(5);\n        assert.equal(momentB.month(), 10, 'Calling moment() on a moment will create a clone');\n        assert.equal(momentA.month(), 5, 'Calling moment() on a moment will create a clone');\n    });\n\n    test('cloning carrying over utc mode', function (assert) {\n        assert.equal(moment().local().clone()._isUTC, false, 'An explicit cloned local moment should have _isUTC == false');\n        assert.equal(moment().utc().clone()._isUTC, true, 'An cloned utc moment should have _isUTC == true');\n        assert.equal(moment().clone()._isUTC, false, 'An explicit cloned local moment should have _isUTC == false');\n        assert.equal(moment.utc().clone()._isUTC, true, 'An explicit cloned utc moment should have _isUTC == true');\n        assert.equal(moment(moment().local())._isUTC, false, 'An implicit cloned local moment should have _isUTC == false');\n        assert.equal(moment(moment().utc())._isUTC, true, 'An implicit cloned utc moment should have _isUTC == true');\n        assert.equal(moment(moment())._isUTC, false, 'An implicit cloned local moment should have _isUTC == false');\n        assert.equal(moment(moment.utc())._isUTC, true, 'An implicit cloned utc moment should have _isUTC == true');\n    });\n\n    test('parsing iso', function (assert) {\n        var offset = moment([2011, 9, 8]).utcOffset(),\n        pad = function (input) {\n            if (input < 10) {\n                return '0' + input;\n            }\n            return '' + input;\n        },\n        hourOffset = (offset > 0 ? Math.floor(offset / 60) : Math.ceil(offset / 60)),\n        minOffset = offset - (hourOffset * 60),\n        tz = (offset >= 0) ?\n            '+' + pad(hourOffset) + ':' + pad(minOffset) :\n            '-' + pad(-hourOffset) + ':' + pad(-minOffset),\n        tz2 = tz.replace(':', ''),\n        tz3 = tz2.slice(0, 3),\n        //Tz3 removes minutes digit so will break the tests when parsed if they all use the same minutes digit\n        minutesForTz3 = pad((4 + minOffset) % 60),\n        minute = pad(4 + minOffset),\n\n        formats = [\n            ['2011-10-08',                    '2011-10-08T00:00:00.000' + tz],\n            ['2011-10-08T18',                 '2011-10-08T18:00:00.000' + tz],\n            ['2011-10-08T18:04',              '2011-10-08T18:04:00.000' + tz],\n            ['2011-10-08T18:04:20',           '2011-10-08T18:04:20.000' + tz],\n            ['2011-10-08T18:04' + tz,         '2011-10-08T18:04:00.000' + tz],\n            ['2011-10-08T18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],\n            ['2011-10-08T18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],\n            ['2011-10-08T18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],\n            ['2011-10-08T18:04' + tz3,        '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],\n            ['2011-10-08T18:04:20' + tz3,     '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],\n            ['2011-10-08T18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],\n            ['2011-10-08T18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],\n            ['2011-10-08T18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],\n            ['2011-10-08 18',                 '2011-10-08T18:00:00.000' + tz],\n            ['2011-10-08 18:04',              '2011-10-08T18:04:00.000' + tz],\n            ['2011-10-08 18:04:20',           '2011-10-08T18:04:20.000' + tz],\n            ['2011-10-08 18:04' + tz,         '2011-10-08T18:04:00.000' + tz],\n            ['2011-10-08 18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],\n            ['2011-10-08 18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],\n            ['2011-10-08 18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],\n            ['2011-10-08 18:04' + tz3,        '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],\n            ['2011-10-08 18:04:20' + tz3,     '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],\n            ['2011-10-08 18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],\n            ['2011-10-08 18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],\n            ['2011-10-08 18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],\n            ['2011-W40',                      '2011-10-03T00:00:00.000' + tz],\n            ['2011-W40-6',                    '2011-10-08T00:00:00.000' + tz],\n            ['2011-W40-6T18',                 '2011-10-08T18:00:00.000' + tz],\n            ['2011-W40-6T18:04',              '2011-10-08T18:04:00.000' + tz],\n            ['2011-W40-6T18:04:20',           '2011-10-08T18:04:20.000' + tz],\n            ['2011-W40-6T18:04' + tz,         '2011-10-08T18:04:00.000' + tz],\n            ['2011-W40-6T18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],\n            ['2011-W40-6T18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],\n            ['2011-W40-6T18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],\n            ['2011-W40-6T18:04' + tz3,        '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],\n            ['2011-W40-6T18:04:20' + tz3,     '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],\n            ['2011-W40-6T18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],\n            ['2011-W40-6T18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],\n            ['2011-W40-6T18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],\n            ['2011-W40-6 18',                 '2011-10-08T18:00:00.000' + tz],\n            ['2011-W40-6 18:04',              '2011-10-08T18:04:00.000' + tz],\n            ['2011-W40-6 18:04:20',           '2011-10-08T18:04:20.000' + tz],\n            ['2011-W40-6 18:04' + tz,         '2011-10-08T18:04:00.000' + tz],\n            ['2011-W40-6 18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],\n            ['2011-W40-6 18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],\n            ['2011-W40-6 18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],\n            ['2011-W40-6 18:04' + tz3,        '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],\n            ['2011-W40-6 18:04:20' + tz3,     '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],\n            ['2011-W40-6 18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],\n            ['2011-W40-6 18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],\n            ['2011-W40-6 18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],\n            ['2011-281',                      '2011-10-08T00:00:00.000' + tz],\n            ['2011-281T18',                   '2011-10-08T18:00:00.000' + tz],\n            ['2011-281T18:04',                '2011-10-08T18:04:00.000' + tz],\n            ['2011-281T18:04:20',             '2011-10-08T18:04:20.000' + tz],\n            ['2011-281T18:04' + tz,           '2011-10-08T18:04:00.000' + tz],\n            ['2011-281T18:04:20' + tz,        '2011-10-08T18:04:20.000' + tz],\n            ['2011-281T18:04' + tz2,          '2011-10-08T18:04:00.000' + tz],\n            ['2011-281T18:04:20' + tz2,       '2011-10-08T18:04:20.000' + tz],\n            ['2011-281T18:04' + tz3,          '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],\n            ['2011-281T18:04:20' + tz3,       '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],\n            ['2011-281T18:04:20.1' + tz2,     '2011-10-08T18:04:20.100' + tz],\n            ['2011-281T18:04:20.11' + tz2,    '2011-10-08T18:04:20.110' + tz],\n            ['2011-281T18:04:20.111' + tz2,   '2011-10-08T18:04:20.111' + tz],\n            ['2011-281 18',                   '2011-10-08T18:00:00.000' + tz],\n            ['2011-281 18:04',                '2011-10-08T18:04:00.000' + tz],\n            ['2011-281 18:04:20',             '2011-10-08T18:04:20.000' + tz],\n            ['2011-281 18:04' + tz,           '2011-10-08T18:04:00.000' + tz],\n            ['2011-281 18:04:20' + tz,        '2011-10-08T18:04:20.000' + tz],\n            ['2011-281 18:04' + tz2,          '2011-10-08T18:04:00.000' + tz],\n            ['2011-281 18:04:20' + tz2,       '2011-10-08T18:04:20.000' + tz],\n            ['2011-281 18:04' + tz3,          '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],\n            ['2011-281 18:04:20' + tz3,       '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],\n            ['2011-281 18:04:20.1' + tz2,     '2011-10-08T18:04:20.100' + tz],\n            ['2011-281 18:04:20.11' + tz2,    '2011-10-08T18:04:20.110' + tz],\n            ['2011-281 18:04:20.111' + tz2,   '2011-10-08T18:04:20.111' + tz],\n            ['20111008T18',                   '2011-10-08T18:00:00.000' + tz],\n            ['20111008T1804',                 '2011-10-08T18:04:00.000' + tz],\n            ['20111008T180420',               '2011-10-08T18:04:20.000' + tz],\n            ['20111008T1804' + tz,            '2011-10-08T18:04:00.000' + tz],\n            ['20111008T180420' + tz,          '2011-10-08T18:04:20.000' + tz],\n            ['20111008T1804' + tz2,           '2011-10-08T18:04:00.000' + tz],\n            ['20111008T180420' + tz2,         '2011-10-08T18:04:20.000' + tz],\n            ['20111008T1804' + tz3,           '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],\n            ['20111008T180420' + tz3,         '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],\n            ['20111008T180420,1' + tz2,       '2011-10-08T18:04:20.100' + tz],\n            ['20111008T180420,11' + tz2,      '2011-10-08T18:04:20.110' + tz],\n            ['20111008T180420,111' + tz2,     '2011-10-08T18:04:20.111' + tz],\n            ['20111008 18',                   '2011-10-08T18:00:00.000' + tz],\n            ['20111008 1804',                 '2011-10-08T18:04:00.000' + tz],\n            ['20111008 180420',               '2011-10-08T18:04:20.000' + tz],\n            ['20111008 1804' + tz,            '2011-10-08T18:04:00.000' + tz],\n            ['20111008 180420' + tz,          '2011-10-08T18:04:20.000' + tz],\n            ['20111008 1804' + tz2,           '2011-10-08T18:04:00.000' + tz],\n            ['20111008 180420' + tz2,         '2011-10-08T18:04:20.000' + tz],\n            ['20111008 1804' + tz3,           '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],\n            ['20111008 180420' + tz3,         '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],\n            ['20111008 180420,1' + tz2,       '2011-10-08T18:04:20.100' + tz],\n            ['20111008 180420,11' + tz2,      '2011-10-08T18:04:20.110' + tz],\n            ['20111008 180420,111' + tz2,     '2011-10-08T18:04:20.111' + tz],\n            ['2011W40',                       '2011-10-03T00:00:00.000' + tz],\n            ['2011W406',                      '2011-10-08T00:00:00.000' + tz],\n            ['2011W406T18',                   '2011-10-08T18:00:00.000' + tz],\n            ['2011W406T1804',                 '2011-10-08T18:04:00.000' + tz],\n            ['2011W406T180420',               '2011-10-08T18:04:20.000' + tz],\n            ['2011W406 1804' + tz2,           '2011-10-08T18:04:00.000' + tz],\n            ['2011W406T1804' + tz,            '2011-10-08T18:04:00.000' + tz],\n            ['2011W406T180420' + tz,          '2011-10-08T18:04:20.000' + tz],\n            ['2011W406T1804' + tz2,           '2011-10-08T18:04:00.000' + tz],\n            ['2011W406T180420' + tz2,         '2011-10-08T18:04:20.000' + tz],\n            ['2011W406T1804' + tz3,           '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],\n            ['2011W406T180420' + tz3,         '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],\n            ['2011W406T180420,1' + tz2,       '2011-10-08T18:04:20.100' + tz],\n            ['2011W406T180420,11' + tz2,      '2011-10-08T18:04:20.110' + tz],\n            ['2011W406T180420,111' + tz2,     '2011-10-08T18:04:20.111' + tz],\n            ['2011W406 18',                   '2011-10-08T18:00:00.000' + tz],\n            ['2011W406 1804',                 '2011-10-08T18:04:00.000' + tz],\n            ['2011W406 180420',               '2011-10-08T18:04:20.000' + tz],\n            ['2011W406 1804' + tz,            '2011-10-08T18:04:00.000' + tz],\n            ['2011W406 180420' + tz,          '2011-10-08T18:04:20.000' + tz],\n            ['2011W406 180420' + tz2,         '2011-10-08T18:04:20.000' + tz],\n            ['2011W406 1804' + tz3,           '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],\n            ['2011W406 180420' + tz3,         '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],\n            ['2011W406 180420,1' + tz2,       '2011-10-08T18:04:20.100' + tz],\n            ['2011W406 180420,11' + tz2,      '2011-10-08T18:04:20.110' + tz],\n            ['2011W406 180420,111' + tz2,     '2011-10-08T18:04:20.111' + tz],\n            ['2011281',                       '2011-10-08T00:00:00.000' + tz],\n            ['2011281T18',                    '2011-10-08T18:00:00.000' + tz],\n            ['2011281T1804',                  '2011-10-08T18:04:00.000' + tz],\n            ['2011281T180420',                '2011-10-08T18:04:20.000' + tz],\n            ['2011281T1804' + tz,             '2011-10-08T18:04:00.000' + tz],\n            ['2011281T180420' + tz,           '2011-10-08T18:04:20.000' + tz],\n            ['2011281T1804' + tz2,            '2011-10-08T18:04:00.000' + tz],\n            ['2011281T180420' + tz2,          '2011-10-08T18:04:20.000' + tz],\n            ['2011281T1804' + tz3,            '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],\n            ['2011281T180420' + tz3,          '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],\n            ['2011281T180420,1' + tz2,        '2011-10-08T18:04:20.100' + tz],\n            ['2011281T180420,11' + tz2,       '2011-10-08T18:04:20.110' + tz],\n            ['2011281T180420,111' + tz2,      '2011-10-08T18:04:20.111' + tz],\n            ['2011281 18',                    '2011-10-08T18:00:00.000' + tz],\n            ['2011281 1804',                  '2011-10-08T18:04:00.000' + tz],\n            ['2011281 180420',                '2011-10-08T18:04:20.000' + tz],\n            ['2011281 1804' + tz,             '2011-10-08T18:04:00.000' + tz],\n            ['2011281 180420' + tz,           '2011-10-08T18:04:20.000' + tz],\n            ['2011281 1804' + tz2,            '2011-10-08T18:04:00.000' + tz],\n            ['2011281 180420' + tz2,          '2011-10-08T18:04:20.000' + tz],\n            ['2011281 1804' + tz3,            '2011-10-08T18:' + minutesForTz3 + ':00.000' + tz],\n            ['2011281 180420' + tz3,          '2011-10-08T18:' + minutesForTz3 + ':20.000' + tz],\n            ['2011281 180420,1' + tz2,        '2011-10-08T18:04:20.100' + tz],\n            ['2011281 180420,11' + tz2,       '2011-10-08T18:04:20.110' + tz],\n            ['2011281 180420,111' + tz2,      '2011-10-08T18:04:20.111' + tz]\n        ], i;\n        for (i = 0; i < formats.length; i++) {\n            assert.equal(moment(formats[i][0]).format('YYYY-MM-DDTHH:mm:ss.SSSZ'),\n                    formats[i][1], 'moment should be able to parse ISO ' + formats[i][0]);\n            assert.equal(moment(formats[i][0], moment.ISO_8601).format('YYYY-MM-DDTHH:mm:ss.SSSZ'),\n                    formats[i][1], 'moment should be able to parse specified ISO ' + formats[i][0]);\n            assert.equal(moment(formats[i][0], moment.ISO_8601, true).format('YYYY-MM-DDTHH:mm:ss.SSSZ'),\n                    formats[i][1], 'moment should be able to parse specified strict ISO ' + formats[i][0]);\n        }\n    });\n\n    test('non iso 8601 strings', function (assert) {\n        assert.ok(!moment('2015-10T10:15', moment.ISO_8601, true).isValid(), 'incomplete date with time');\n        assert.ok(!moment('2015-W10T10:15', moment.ISO_8601, true).isValid(), 'incomplete week date with time');\n        assert.ok(!moment('201510', moment.ISO_8601, true).isValid(), 'basic YYYYMM is not allowed');\n        assert.ok(!moment('2015W10T1015', moment.ISO_8601, true).isValid(), 'incomplete week date with time (basic)');\n        assert.ok(!moment('2015-10-08T1015', moment.ISO_8601, true).isValid(), 'mixing extended and basic format');\n        assert.ok(!moment('20151008T10:15', moment.ISO_8601, true).isValid(), 'mixing basic and extended format');\n    });\n\n    test('parsing iso week year/week/weekday', function (assert) {\n        assert.equal(moment.utc('2007-W01').format(), '2007-01-01T00:00:00Z', '2008 week 1 (1st Jan Mon)');\n        assert.equal(moment.utc('2008-W01').format(), '2007-12-31T00:00:00Z', '2008 week 1 (1st Jan Tue)');\n        assert.equal(moment.utc('2003-W01').format(), '2002-12-30T00:00:00Z', '2008 week 1 (1st Jan Wed)');\n        assert.equal(moment.utc('2009-W01').format(), '2008-12-29T00:00:00Z', '2009 week 1 (1st Jan Thu)');\n        assert.equal(moment.utc('2010-W01').format(), '2010-01-04T00:00:00Z', '2010 week 1 (1st Jan Fri)');\n        assert.equal(moment.utc('2011-W01').format(), '2011-01-03T00:00:00Z', '2011 week 1 (1st Jan Sat)');\n        assert.equal(moment.utc('2012-W01').format(), '2012-01-02T00:00:00Z', '2012 week 1 (1st Jan Sun)');\n    });\n\n    test('parsing week year/week/weekday (dow 1, doy 4)', function (assert) {\n        moment.locale('dow:1,doy:4', {week: {dow: 1, doy: 4}});\n\n        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2007-01-01T00:00:00Z', '2007 week 1 (1st Jan Mon)');\n        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-31T00:00:00Z', '2008 week 1 (1st Jan Tue)');\n        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-30T00:00:00Z', '2003 week 1 (1st Jan Wed)');\n        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-29T00:00:00Z', '2009 week 1 (1st Jan Thu)');\n        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2010-01-04T00:00:00Z', '2010 week 1 (1st Jan Fri)');\n        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2011-01-03T00:00:00Z', '2011 week 1 (1st Jan Sat)');\n        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2012-01-02T00:00:00Z', '2012 week 1 (1st Jan Sun)');\n\n        moment.defineLocale('dow:1,doy:4', null);\n    });\n\n    test('parsing week year/week/weekday (dow 1, doy 7)', function (assert) {\n        moment.locale('dow:1,doy:7', {week: {dow: 1, doy: 7}});\n\n        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2007-01-01T00:00:00Z', '2007 week 1 (1st Jan Mon)');\n        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-31T00:00:00Z', '2008 week 1 (1st Jan Tue)');\n        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-30T00:00:00Z', '2003 week 1 (1st Jan Wed)');\n        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-29T00:00:00Z', '2009 week 1 (1st Jan Thu)');\n        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2009-12-28T00:00:00Z', '2010 week 1 (1st Jan Fri)');\n        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2010-12-27T00:00:00Z', '2011 week 1 (1st Jan Sat)');\n        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2011-12-26T00:00:00Z', '2012 week 1 (1st Jan Sun)');\n        moment.defineLocale('dow:1,doy:7', null);\n    });\n\n    test('parsing week year/week/weekday (dow 0, doy 6)', function (assert) {\n        moment.locale('dow:0,doy:6', {week: {dow: 0, doy: 6}});\n\n        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2006-12-31T00:00:00Z', '2007 week 1 (1st Jan Mon)');\n        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-30T00:00:00Z', '2008 week 1 (1st Jan Tue)');\n        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-29T00:00:00Z', '2003 week 1 (1st Jan Wed)');\n        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-28T00:00:00Z', '2009 week 1 (1st Jan Thu)');\n        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2009-12-27T00:00:00Z', '2010 week 1 (1st Jan Fri)');\n        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2010-12-26T00:00:00Z', '2011 week 1 (1st Jan Sat)');\n        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2012-01-01T00:00:00Z', '2012 week 1 (1st Jan Sun)');\n        moment.defineLocale('dow:0,doy:6', null);\n    });\n\n    test('parsing week year/week/weekday (dow 6, doy 12)', function (assert) {\n        moment.locale('dow:6,doy:12', {week: {dow: 6, doy: 12}});\n\n        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2006-12-30T00:00:00Z', '2007 week 1 (1st Jan Mon)');\n        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-29T00:00:00Z', '2008 week 1 (1st Jan Tue)');\n        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-28T00:00:00Z', '2003 week 1 (1st Jan Wed)');\n        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-27T00:00:00Z', '2009 week 1 (1st Jan Thu)');\n        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2009-12-26T00:00:00Z', '2010 week 1 (1st Jan Fri)');\n        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2011-01-01T00:00:00Z', '2011 week 1 (1st Jan Sat)');\n        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2011-12-31T00:00:00Z', '2012 week 1 (1st Jan Sun)');\n        moment.defineLocale('dow:6,doy:12', null);\n    });\n\n    test('parsing ISO with Z', function (assert) {\n        var i, mom, formats = [\n            ['2011-10-08T18:04',             '2011-10-08T18:04:00.000'],\n            ['2011-10-08T18:04:20',          '2011-10-08T18:04:20.000'],\n            ['2011-10-08T18:04:20.1',        '2011-10-08T18:04:20.100'],\n            ['2011-10-08T18:04:20.11',       '2011-10-08T18:04:20.110'],\n            ['2011-10-08T18:04:20.111',      '2011-10-08T18:04:20.111'],\n            ['2011-W40-6T18',                '2011-10-08T18:00:00.000'],\n            ['2011-W40-6T18:04',             '2011-10-08T18:04:00.000'],\n            ['2011-W40-6T18:04:20',          '2011-10-08T18:04:20.000'],\n            ['2011-W40-6T18:04:20.1',        '2011-10-08T18:04:20.100'],\n            ['2011-W40-6T18:04:20.11',       '2011-10-08T18:04:20.110'],\n            ['2011-W40-6T18:04:20.111',      '2011-10-08T18:04:20.111'],\n            ['2011-281T18',                  '2011-10-08T18:00:00.000'],\n            ['2011-281T18:04',               '2011-10-08T18:04:00.000'],\n            ['2011-281T18:04:20',            '2011-10-08T18:04:20.000'],\n            ['2011-281T18:04:20',            '2011-10-08T18:04:20.000'],\n            ['2011-281T18:04:20.1',          '2011-10-08T18:04:20.100'],\n            ['2011-281T18:04:20.11',         '2011-10-08T18:04:20.110'],\n            ['2011-281T18:04:20.111',        '2011-10-08T18:04:20.111']\n        ];\n\n        for (i = 0; i < formats.length; i++) {\n            mom = moment(formats[i][0] + 'Z').utc();\n            assert.equal(mom.format('YYYY-MM-DDTHH:mm:ss.SSS'), formats[i][1], 'moment should be able to parse ISO in UTC ' + formats[i][0] + 'Z');\n\n            mom = moment(formats[i][0] + ' Z').utc();\n            assert.equal(mom.format('YYYY-MM-DDTHH:mm:ss.SSS'), formats[i][1], 'moment should be able to parse ISO in UTC ' + formats[i][0] + ' Z');\n        }\n    });\n\n    test('parsing iso with T', function (assert) {\n        assert.equal(moment('2011-10-08T18')._f, 'YYYY-MM-DDTHH', 'should include \\'T\\' in the format');\n        assert.equal(moment('2011-10-08T18:20')._f, 'YYYY-MM-DDTHH:mm', 'should include \\'T\\' in the format');\n        assert.equal(moment('2011-10-08T18:20:13')._f, 'YYYY-MM-DDTHH:mm:ss', 'should include \\'T\\' in the format');\n        assert.equal(moment('2011-10-08T18:20:13.321')._f, 'YYYY-MM-DDTHH:mm:ss.SSSS', 'should include \\'T\\' in the format');\n\n        assert.equal(moment('2011-10-08 18')._f, 'YYYY-MM-DD HH', 'should not include \\'T\\' in the format');\n        assert.equal(moment('2011-10-08 18:20')._f, 'YYYY-MM-DD HH:mm', 'should not include \\'T\\' in the format');\n        assert.equal(moment('2011-10-08 18:20:13')._f, 'YYYY-MM-DD HH:mm:ss', 'should not include \\'T\\' in the format');\n        assert.equal(moment('2011-10-08 18:20:13.321')._f, 'YYYY-MM-DD HH:mm:ss.SSSS', 'should not include \\'T\\' in the format');\n    });\n\n    test('parsing iso Z timezone', function (assert) {\n        var i,\n        formats = [\n            ['2011-10-08T18:04Z',             '2011-10-08T18:04:00.000+00:00'],\n            ['2011-10-08T18:04:20Z',          '2011-10-08T18:04:20.000+00:00'],\n            ['2011-10-08T18:04:20.111Z',      '2011-10-08T18:04:20.111+00:00']\n        ];\n        for (i = 0; i < formats.length; i++) {\n            assert.equal(moment.utc(formats[i][0]).format('YYYY-MM-DDTHH:mm:ss.SSSZ'), formats[i][1], 'moment should be able to parse ISO ' + formats[i][0]);\n        }\n    });\n\n    test('parsing iso Z timezone into local', function (assert) {\n        var m = moment('2011-10-08T18:04:20.111Z');\n\n        assert.equal(m.utc().format('YYYY-MM-DDTHH:mm:ss.SSS'), '2011-10-08T18:04:20.111', 'moment should be able to parse ISO 2011-10-08T18:04:20.111Z');\n    });\n\n    test('parsing iso with more subsecond precision digits', function (assert) {\n        assert.equal(moment.utc('2013-07-31T22:00:00.0000000Z').format(), '2013-07-31T22:00:00Z', 'more than 3 subsecond digits');\n    });\n\n    test('null or empty', function (assert) {\n        assert.equal(moment('').isValid(), false, 'moment(\\'\\') is not valid');\n        assert.equal(moment(null).isValid(), false, 'moment(null) is not valid');\n        assert.equal(moment(null, 'YYYY-MM-DD').isValid(), false, 'moment(\\'\\', \\'format\\') is not valid');\n        assert.equal(moment('', 'YYYY-MM-DD').isValid(), false, 'moment(\\'\\', \\'format\\') is not valid');\n        assert.equal(moment.utc('').isValid(), false, 'moment.utc(\\'\\') is not valid');\n        assert.equal(moment.utc(null).isValid(), false, 'moment.utc(null) is not valid');\n        assert.equal(moment.utc(null, 'YYYY-MM-DD').isValid(), false, 'moment.utc(null) is not valid');\n        assert.equal(moment.utc('', 'YYYY-MM-DD').isValid(), false, 'moment.utc(\\'\\', \\'YYYY-MM-DD\\') is not valid');\n    });\n\n    test('first century', function (assert) {\n        assert.equal(moment([0, 0, 1]).format('YYYY-MM-DD'), '0000-01-01', 'Year AD 0');\n        assert.equal(moment([99, 0, 1]).format('YYYY-MM-DD'), '0099-01-01', 'Year AD 99');\n        assert.equal(moment([999, 0, 1]).format('YYYY-MM-DD'), '0999-01-01', 'Year AD 999');\n        assert.equal(moment('0 1 1', 'YYYY MM DD').format('YYYY-MM-DD'), '0000-01-01', 'Year AD 0');\n        assert.equal(moment('999 1 1', 'YYYY MM DD').format('YYYY-MM-DD'), '0999-01-01', 'Year AD 999');\n        assert.equal(moment('0 1 1', 'YYYYY MM DD').format('YYYYY-MM-DD'), '00000-01-01', 'Year AD 0');\n        assert.equal(moment('99 1 1', 'YYYYY MM DD').format('YYYYY-MM-DD'), '00099-01-01', 'Year AD 99');\n        assert.equal(moment('999 1 1', 'YYYYY MM DD').format('YYYYY-MM-DD'), '00999-01-01', 'Year AD 999');\n    });\n\n    test('six digit years', function (assert) {\n        assert.equal(moment([-270000, 0, 1]).format('YYYYY-MM-DD'), '-270000-01-01', 'format BC 270,001');\n        assert.equal(moment([270000, 0, 1]).format('YYYYY-MM-DD'), '270000-01-01', 'format AD 270,000');\n        assert.equal(moment('-270000-01-01', 'YYYYY-MM-DD').toDate().getFullYear(), -270000, 'parse BC 270,001');\n        assert.equal(moment('270000-01-01',  'YYYYY-MM-DD').toDate().getFullYear(), 270000, 'parse AD 270,000');\n        assert.equal(moment('+270000-01-01', 'YYYYY-MM-DD').toDate().getFullYear(), 270000, 'parse AD +270,000');\n        assert.equal(moment.utc('-270000-01-01', 'YYYYY-MM-DD').toDate().getUTCFullYear(), -270000, 'parse utc BC 270,001');\n        assert.equal(moment.utc('270000-01-01',  'YYYYY-MM-DD').toDate().getUTCFullYear(), 270000, 'parse utc AD 270,000');\n        assert.equal(moment.utc('+270000-01-01', 'YYYYY-MM-DD').toDate().getUTCFullYear(), 270000, 'parse utc AD +270,000');\n    });\n\n    test('negative four digit years', function (assert) {\n        assert.equal(moment('-1000-01-01', 'YYYYY-MM-DD').toDate().getFullYear(), -1000, 'parse BC 1,001');\n        assert.equal(moment.utc('-1000-01-01', 'YYYYY-MM-DD').toDate().getUTCFullYear(), -1000, 'parse utc BC 1,001');\n    });\n\n    test('strict parsing', function (assert) {\n        assert.equal(moment('2014-', 'YYYY-Q', true).isValid(), false, 'fail missing quarter');\n\n        assert.equal(moment('2012-05', 'YYYY-MM', true).format('YYYY-MM'), '2012-05', 'parse correct string');\n        assert.equal(moment(' 2012-05', 'YYYY-MM', true).isValid(), false, 'fail on extra whitespace');\n        assert.equal(moment('foo 2012-05', '[foo] YYYY-MM', true).format('YYYY-MM'), '2012-05', 'handle fixed text');\n        assert.equal(moment('2012 05', 'YYYY-MM', true).isValid(), false, 'fail on different separator');\n        assert.equal(moment('2012 05', 'YYYY MM DD', true).isValid(), false, 'fail on too many tokens');\n\n        assert.equal(moment('05 30 2010', ['DD MM YYYY', 'MM DD YYYY'], true).format('MM DD YYYY'), '05 30 2010', 'array with bad date');\n        assert.equal(moment('05 30 2010', ['', 'MM DD YYYY'], true).format('MM DD YYYY'), '05 30 2010', 'array with invalid format');\n        assert.equal(moment('05 30 2010', [' DD MM YYYY', 'MM DD YYYY'], true).format('MM DD YYYY'), '05 30 2010', 'array with non-matching format');\n\n        assert.equal(moment('2010.*...', 'YYYY.*', true).isValid(), false, 'invalid format with regex chars');\n        assert.equal(moment('2010.*', 'YYYY.*', true).year(), 2010, 'valid format with regex chars');\n        assert.equal(moment('.*2010.*', '.*YYYY.*', true).year(), 2010, 'valid format with regex chars on both sides');\n\n        //strict tokens\n        assert.equal(moment('-5-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid negative year');\n        assert.equal(moment('2-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid one-digit year');\n        assert.equal(moment('20-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid two-digit year');\n        assert.equal(moment('201-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid three-digit year');\n        assert.equal(moment('2010-05-25', 'YYYY-MM-DD', true).isValid(), true, 'valid four-digit year');\n        assert.equal(moment('22010-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid five-digit year');\n\n        assert.equal(moment('12-05-25', 'YY-MM-DD', true).isValid(), true, 'valid two-digit year');\n        assert.equal(moment('2012-05-25', 'YY-MM-DD', true).isValid(), false, 'invalid four-digit year');\n\n        assert.equal(moment('-5-05-25', 'Y-MM-DD', true).isValid(), true, 'valid negative year');\n        assert.equal(moment('2-05-25', 'Y-MM-DD', true).isValid(), true, 'valid one-digit year');\n        assert.equal(moment('20-05-25', 'Y-MM-DD', true).isValid(), true, 'valid two-digit year');\n        assert.equal(moment('201-05-25', 'Y-MM-DD', true).isValid(), true, 'valid three-digit year');\n\n        assert.equal(moment('2012-5-25', 'YYYY-M-DD', true).isValid(), true, 'valid one-digit month');\n        assert.equal(moment('2012-5-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid one-digit month');\n        assert.equal(moment('2012-05-25', 'YYYY-M-DD', true).isValid(), true, 'valid one-digit month');\n        assert.equal(moment('2012-05-25', 'YYYY-MM-DD', true).isValid(), true, 'valid one-digit month');\n\n        assert.equal(moment('2012-05-2', 'YYYY-MM-D', true).isValid(), true, 'valid one-digit day');\n        assert.equal(moment('2012-05-2', 'YYYY-MM-DD', true).isValid(), false, 'invalid one-digit day');\n        assert.equal(moment('2012-05-02', 'YYYY-MM-D', true).isValid(), true, 'valid two-digit day');\n        assert.equal(moment('2012-05-02', 'YYYY-MM-DD', true).isValid(), true, 'valid two-digit day');\n\n        assert.equal(moment('+002012-05-25', 'YYYYY-MM-DD', true).isValid(), true, 'valid six-digit year');\n        assert.equal(moment('+2012-05-25', 'YYYYY-MM-DD', true).isValid(), false, 'invalid four-digit year');\n\n        //thse are kinda pointless, but they should work as expected\n        assert.equal(moment('1', 'S', true).isValid(), true, 'valid one-digit milisecond');\n        assert.equal(moment('12', 'S', true).isValid(), false, 'invalid two-digit milisecond');\n        assert.equal(moment('123', 'S', true).isValid(), false, 'invalid three-digit milisecond');\n\n        assert.equal(moment('1', 'SS', true).isValid(), false, 'invalid one-digit milisecond');\n        assert.equal(moment('12', 'SS', true).isValid(), true, 'valid two-digit milisecond');\n        assert.equal(moment('123', 'SS', true).isValid(), false, 'invalid three-digit milisecond');\n\n        assert.equal(moment('1', 'SSS', true).isValid(), false, 'invalid one-digit milisecond');\n        assert.equal(moment('12', 'SSS', true).isValid(), false, 'invalid two-digit milisecond');\n        assert.equal(moment('123', 'SSS', true).isValid(), true, 'valid three-digit milisecond');\n\n        // strict parsing respects month length\n        assert.ok(moment('1 January 2000', 'D MMMM YYYY', true).isValid(), 'capital long-month + MMMM');\n        assert.ok(!moment('1 January 2000', 'D MMM YYYY', true).isValid(), 'capital long-month + MMM');\n        assert.ok(!moment('1 Jan 2000', 'D MMMM YYYY', true).isValid(), 'capital short-month + MMMM');\n        assert.ok(moment('1 Jan 2000', 'D MMM YYYY', true).isValid(), 'capital short-month + MMM');\n        assert.ok(moment('1 january 2000', 'D MMMM YYYY', true).isValid(), 'lower long-month + MMMM');\n        assert.ok(!moment('1 january 2000', 'D MMM YYYY', true).isValid(), 'lower long-month + MMM');\n        assert.ok(!moment('1 jan 2000', 'D MMMM YYYY', true).isValid(), 'lower short-month + MMMM');\n        assert.ok(moment('1 jan 2000', 'D MMM YYYY', true).isValid(), 'lower short-month + MMM');\n    });\n\n    test('parsing into a locale', function (assert) {\n        moment.defineLocale('parselocale', {\n            months : 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_'),\n            monthsShort : 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_')\n        });\n\n        moment.locale('en');\n\n        assert.equal(moment('2012 seven', 'YYYY MMM', 'parselocale').month(), 6, 'should be able to parse in a specific locale');\n\n        moment.locale('parselocale');\n\n        assert.equal(moment('2012 july', 'YYYY MMM', 'en').month(), 6, 'should be able to parse in a specific locale');\n\n        moment.defineLocale('parselocale', null);\n    });\n\n    function getVerifier(test) {\n        return function (input, format, expected, description, asymetrical) {\n            var m = moment(input, format);\n            test.equal(m.format('YYYY MM DD'), expected, 'compare: ' + description);\n\n            //test round trip\n            if (!asymetrical) {\n                test.equal(m.format(format), input, 'round trip: ' + description);\n            }\n        };\n    }\n\n    test('parsing week and weekday information', function (assert) {\n        var ver = getVerifier(assert);\n\n        // year\n        ver('12', 'gg', '2012 01 01', 'week-year two digits');\n        ver('2012', 'gggg', '2012 01 01', 'week-year four digits');\n\n        ver('99', 'gg', '1998 12 27', 'week-year two digits previous year');\n        ver('1999', 'gggg', '1998 12 27', 'week-year four digits previous year');\n\n        ver('99', 'GG', '1999 01 04', 'iso week-year two digits');\n        ver('1999', 'GGGG', '1999 01 04', 'iso week-year four digits');\n\n        ver('13', 'GG', '2012 12 31', 'iso week-year two digits previous year');\n        ver('2013', 'GGGG', '2012 12 31', 'iso week-year four digits previous year');\n\n        // year + week\n        ver('1999 37', 'gggg w', '1999 09 05', 'week');\n        ver('1999 37', 'gggg ww', '1999 09 05', 'week double');\n        ver('1999 37', 'GGGG W', '1999 09 13', 'iso week');\n        ver('1999 37', 'GGGG WW', '1999 09 13', 'iso week double');\n\n        ver('1999 37 4', 'GGGG WW E', '1999 09 16', 'iso day');\n        ver('1999 37 04', 'GGGG WW E', '1999 09 16', 'iso day wide', true);\n\n        ver('1999 37 4', 'gggg ww e', '1999 09 09', 'day');\n        ver('1999 37 04', 'gggg ww e', '1999 09 09', 'day wide', true);\n\n        // year + week + day\n        ver('1999 37 4', 'gggg ww d', '1999 09 09', 'd');\n        ver('1999 37 Th', 'gggg ww dd', '1999 09 09', 'dd');\n        ver('1999 37 Thu', 'gggg ww ddd', '1999 09 09', 'ddd');\n        ver('1999 37 Thursday', 'gggg ww dddd', '1999 09 09', 'dddd');\n\n        // lower-order only\n        assert.equal(moment('22', 'ww').week(), 22, 'week sets the week by itself');\n        assert.equal(moment('22', 'ww').weekYear(), moment().weekYear(), 'week keeps this year');\n        assert.equal(moment('2012 22', 'YYYY ww').weekYear(), 2012, 'week keeps parsed year');\n\n        assert.equal(moment('22', 'WW').isoWeek(), 22, 'iso week sets the week by itself');\n        assert.equal(moment('2012 22', 'YYYY WW').weekYear(), 2012, 'iso week keeps parsed year');\n        assert.equal(moment('22', 'WW').isoWeekYear(), moment().isoWeekYear(), 'iso week keeps this year');\n\n        // order\n        ver('6 2013 2', 'e gggg w', '2013 01 12', 'order doesn\\'t matter');\n        ver('6 2013 2', 'E GGGG W', '2013 01 12', 'iso order doesn\\'t matter');\n\n        //can parse other stuff too\n        assert.equal(moment('1999-W37-4 3:30', 'GGGG-[W]WW-E HH:mm').format('YYYY MM DD HH:mm'), '1999 09 16 03:30', 'parsing weeks and hours');\n\n        // In safari, all years before 1300 are shifted back with one day.\n        // http://stackoverflow.com/questions/20768975/safari-subtracts-1-day-from-dates-before-1300\n        if (new Date('1300-01-01').getUTCFullYear() === 1300) {\n            // Years less than 100\n            ver('0098-06', 'GGGG-WW', '0098 02 03', 'small years work', true);\n        }\n    });\n\n    test('parsing localized weekdays', function (assert) {\n        var ver = getVerifier(assert);\n        try {\n            moment.locale('dow:1,doy:4', {\n                weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),\n                weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),\n                weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),\n                week: {dow: 1, doy: 4}\n            });\n            ver('1999 37 4', 'GGGG WW E', '1999 09 16', 'iso ignores locale');\n            ver('1999 37 7', 'GGGG WW E', '1999 09 19', 'iso ignores locale');\n\n            ver('1999 37 0', 'gggg ww e', '1999 09 13', 'localized e uses local doy and dow: 0 = monday');\n            ver('1999 37 4', 'gggg ww e', '1999 09 17', 'localized e uses local doy and dow: 4 = friday');\n\n            ver('1999 37 1', 'gggg ww d', '1999 09 13', 'localized d uses 0-indexed days: 1 = monday');\n            ver('1999 37 Lu', 'gggg ww dd', '1999 09 13', 'localized d uses 0-indexed days: Mo');\n            ver('1999 37 lun.', 'gggg ww ddd', '1999 09 13', 'localized d uses 0-indexed days: Mon');\n            ver('1999 37 lundi', 'gggg ww dddd', '1999 09 13', 'localized d uses 0-indexed days: Monday');\n            ver('1999 37 4', 'gggg ww d', '1999 09 16', 'localized d uses 0-indexed days: 4');\n\n            //sunday goes at the end of the week\n            ver('1999 37 0', 'gggg ww d', '1999 09 19', 'localized d uses 0-indexed days: 0 = sund');\n            ver('1999 37 Di', 'gggg ww dd', '1999 09 19', 'localized d uses 0-indexed days: 0 = sund');\n        }\n        finally {\n            moment.defineLocale('dow:1,doy:4', null);\n            moment.locale('en');\n        }\n    });\n\n    test('parsing with customized two-digit year', function (assert) {\n        var original = moment.parseTwoDigitYear;\n        try {\n            assert.equal(moment('68', 'YY').year(), 2068);\n            assert.equal(moment('69', 'YY').year(), 1969);\n            moment.parseTwoDigitYear = function (input) {\n                return +input + (+input > 30 ? 1900 : 2000);\n            };\n            assert.equal(moment('68', 'YY').year(), 1968);\n            assert.equal(moment('67', 'YY').year(), 1967);\n            assert.equal(moment('31', 'YY').year(), 1931);\n            assert.equal(moment('30', 'YY').year(), 2030);\n        }\n        finally {\n            moment.parseTwoDigitYear = original;\n        }\n    });\n\n    test('array with strings', function (assert) {\n        assert.equal(moment(['2014', '7', '31']).isValid(), true, 'string array + isValid');\n    });\n\n    test('object with strings', function (assert) {\n        assert.equal(moment({year: '2014', month: '7', day: '31'}).isValid(), true, 'string object + isValid');\n    });\n\n    test('utc with array of formats', function (assert) {\n        assert.equal(moment.utc('2014-01-01', ['YYYY-MM-DD', 'YYYY-MM']).format(), '2014-01-01T00:00:00Z', 'moment.utc works with array of formats');\n    });\n\n    test('parsing invalid string weekdays', function (assert) {\n        assert.equal(false, moment('a', 'dd').isValid(),\n                'dd with invalid weekday, non-strict');\n        assert.equal(false, moment('a', 'dd', true).isValid(),\n                'dd with invalid weekday, strict');\n        assert.equal(false, moment('a', 'ddd').isValid(),\n                'ddd with invalid weekday, non-strict');\n        assert.equal(false, moment('a', 'ddd', true).isValid(),\n                'ddd with invalid weekday, strict');\n        assert.equal(false, moment('a', 'dddd').isValid(),\n                'dddd with invalid weekday, non-strict');\n        assert.equal(false, moment('a', 'dddd', true).isValid(),\n                'dddd with invalid weekday, strict');\n    });\n\n    test('milliseconds', function (assert) {\n        assert.equal(moment('1', 'S').millisecond(), 100);\n        assert.equal(moment('12', 'SS').millisecond(), 120);\n        assert.equal(moment('123', 'SSS').millisecond(), 123);\n        assert.equal(moment('1234', 'SSSS').millisecond(), 123);\n        assert.equal(moment('12345', 'SSSSS').millisecond(), 123);\n        assert.equal(moment('123456', 'SSSSSS').millisecond(), 123);\n        assert.equal(moment('1234567', 'SSSSSSS').millisecond(), 123);\n        assert.equal(moment('12345678', 'SSSSSSSS').millisecond(), 123);\n        assert.equal(moment('123456789', 'SSSSSSSSS').millisecond(), 123);\n    });\n\n    test('hmm', function (assert) {\n        assert.equal(moment('123', 'hmm', true).format('HH:mm:ss'), '01:23:00', '123 with hmm');\n        assert.equal(moment('123a', 'hmmA', true).format('HH:mm:ss'), '01:23:00', '123a with hmmA');\n        assert.equal(moment('123p', 'hmmA', true).format('HH:mm:ss'), '13:23:00', '123p with hmmA');\n\n        assert.equal(moment('1234', 'hmm', true).format('HH:mm:ss'), '12:34:00', '1234 with hmm');\n        assert.equal(moment('1234a', 'hmmA', true).format('HH:mm:ss'), '00:34:00', '1234a with hmmA');\n        assert.equal(moment('1234p', 'hmmA', true).format('HH:mm:ss'), '12:34:00', '1234p with hmmA');\n\n        assert.equal(moment('12345', 'hmmss', true).format('HH:mm:ss'), '01:23:45', '12345 with hmmss');\n        assert.equal(moment('12345a', 'hmmssA', true).format('HH:mm:ss'), '01:23:45', '12345a with hmmssA');\n        assert.equal(moment('12345p', 'hmmssA', true).format('HH:mm:ss'), '13:23:45', '12345p with hmmssA');\n        assert.equal(moment('112345', 'hmmss', true).format('HH:mm:ss'), '11:23:45', '112345 with hmmss');\n        assert.equal(moment('112345a', 'hmmssA', true).format('HH:mm:ss'), '11:23:45', '112345a with hmmssA');\n        assert.equal(moment('112345p', 'hmmssA', true).format('HH:mm:ss'), '23:23:45', '112345p with hmmssA');\n\n        assert.equal(moment('023', 'Hmm', true).format('HH:mm:ss'), '00:23:00', '023 with Hmm');\n        assert.equal(moment('123', 'Hmm', true).format('HH:mm:ss'), '01:23:00', '123 with Hmm');\n        assert.equal(moment('1234', 'Hmm', true).format('HH:mm:ss'), '12:34:00', '1234 with Hmm');\n        assert.equal(moment('1534', 'Hmm', true).format('HH:mm:ss'), '15:34:00', '1234 with Hmm');\n        assert.equal(moment('12345', 'Hmmss', true).format('HH:mm:ss'), '01:23:45', '12345 with Hmmss');\n        assert.equal(moment('112345', 'Hmmss', true).format('HH:mm:ss'), '11:23:45', '112345 with Hmmss');\n        assert.equal(moment('172345', 'Hmmss', true).format('HH:mm:ss'), '17:23:45', '112345 with Hmmss');\n    });\n\n    test('Y token', function (assert) {\n        assert.equal(moment('1-1-2010', 'M-D-Y', true).year(), 2010, 'parsing Y');\n    });\n\n    test('parsing flags retain parsed date parts', function (assert) {\n        var a = moment('10 p', 'hh:mm a');\n        assert.equal(a.parsingFlags().parsedDateParts[3], 10, 'parsed 10 as the hour');\n        assert.equal(a.parsingFlags().parsedDateParts[0], undefined, 'year was not parsed');\n        assert.equal(a.parsingFlags().meridiem, 'p', 'meridiem flag was added');\n        var b = moment('10:30', ['MMDDYY', 'HH:mm']);\n        assert.equal(b.parsingFlags().parsedDateParts[3], 10, 'multiple format parshing matched hour');\n        assert.equal(b.parsingFlags().parsedDateParts[0], undefined, 'array is properly copied, no residual data from first token parse');\n    });\n\n    test('parsing only meridiem results in invalid date', function (assert) {\n        assert.ok(!moment('alkj', 'hh:mm a').isValid(), 'because an a token is used, a meridiem will be parsed but nothing else was so invalid');\n        assert.ok(moment('02:30 p more extra stuff', 'hh:mm a').isValid(), 'because other tokens were parsed, date is valid');\n        assert.ok(moment('1/1/2016 extra data', ['a', 'M/D/YYYY']).isValid(), 'took second format, does not pick up on meridiem parsed from first format (good copy)');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('creation data');\n\n    test('valid date', function (assert) {\n        var dat = moment('1992-10-22');\n        var orig = dat.creationData();\n\n        assert.equal(dat.isValid(), true, '1992-10-22 is valid');\n        assert.equal(orig.input, '1992-10-22', 'original input is not correct.');\n        assert.equal(orig.format, 'YYYY-MM-DD', 'original format is defined.');\n        assert.equal(orig.locale._abbr, 'en', 'default locale is en');\n        assert.equal(orig.isUTC, false, 'not a UTC date');\n    });\n\n    test('valid date at fr locale', function (assert) {\n        var dat = moment('1992-10-22', 'YYYY-MM-DD', 'fr');\n        var orig = dat.creationData();\n\n        assert.equal(orig.locale._abbr, 'fr', 'locale is fr');\n    });\n\n    test('valid date with formats', function (assert) {\n        var dat = moment('29-06-1995', ['MM-DD-YYYY', 'DD-MM', 'DD-MM-YYYY']);\n        var orig = dat.creationData();\n\n        assert.equal(orig.format, 'DD-MM-YYYY', 'DD-MM-YYYY format is defined.');\n    });\n\n    test('strict', function (assert) {\n        assert.ok(moment('2015-01-02', 'YYYY-MM-DD', true).creationData().strict, 'strict is true');\n        assert.ok(!moment('2015-01-02', 'YYYY-MM-DD').creationData().strict, 'strict is true');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('days in month');\n\n    test('days in month', function (assert) {\n        each([31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], function (days, i) {\n            var firstDay = moment([2012, i]),\n                lastDay  = moment([2012, i, days]);\n            assert.equal(firstDay.daysInMonth(), days, firstDay.format('L') + ' should have ' + days + ' days.');\n            assert.equal(lastDay.daysInMonth(), days, lastDay.format('L') + ' should have ' + days + ' days.');\n        });\n    });\n\n    test('days in month leap years', function (assert) {\n        assert.equal(moment([2010, 1]).daysInMonth(), 28, 'Feb 2010 should have 28 days');\n        assert.equal(moment([2100, 1]).daysInMonth(), 28, 'Feb 2100 should have 28 days');\n        assert.equal(moment([2008, 1]).daysInMonth(), 29, 'Feb 2008 should have 29 days');\n        assert.equal(moment([2000, 1]).daysInMonth(), 29, 'Feb 2000 should have 29 days');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    var hookCallback;\n\n    function hooks () {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback (callback) {\n        hookCallback = callback;\n    }\n\n    function isUndefined(input) {\n        return input === void 0;\n    }\n\n    function warn(msg) {\n        if (hooks.suppressDeprecationWarnings === false &&\n                (typeof console !==  'undefined') && console.warn) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                warn(msg + '\\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\\n' + (new Error()).stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n\n    module('deprecate');\n\n    test('deprecate', function (assert) {\n        // NOTE: hooks inside deprecate.js and moment are different, so this is can\n        // not be test.expectedDeprecations(...)\n        var fn = function () {};\n        var deprecatedFn = deprecate('testing deprecation', fn);\n        deprecatedFn();\n\n        expect(0);\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    function equal(assert, a, b, message) {\n        assert.ok(Math.abs(a - b) < 0.00000001, '(' + a + ' === ' + b + ') ' + message);\n    }\n\n    function dstForYear(year) {\n        var start = moment([year]),\n            end = moment([year + 1]),\n            current = start.clone(),\n            last;\n\n        while (current < end) {\n            last = current.clone();\n            current.add(24, 'hour');\n            if (last.utcOffset() !== current.utcOffset()) {\n                end = current.clone();\n                current = last.clone();\n                break;\n            }\n        }\n\n        while (current < end) {\n            last = current.clone();\n            current.add(1, 'hour');\n            if (last.utcOffset() !== current.utcOffset()) {\n                return {\n                    moment : last,\n                    diff : -(current.utcOffset() - last.utcOffset()) / 60\n                };\n            }\n        }\n    }\n\n    module('diff');\n\n    test('diff', function (assert) {\n        assert.equal(moment(1000).diff(0), 1000, '1 second - 0 = 1000');\n        assert.equal(moment(1000).diff(500), 500, '1 second - 0.5 seconds = 500');\n        assert.equal(moment(0).diff(1000), -1000, '0 - 1 second = -1000');\n        assert.equal(moment(new Date(1000)).diff(1000), 0, '1 second - 1 second = 0');\n        var oneHourDate = new Date(2015, 5, 21),\n        nowDate = new Date(+oneHourDate);\n        oneHourDate.setHours(oneHourDate.getHours() + 1);\n        assert.equal(moment(oneHourDate).diff(nowDate), 60 * 60 * 1000, '1 hour from now = 3600000');\n    });\n\n    test('diff key after', function (assert) {\n        assert.equal(moment([2010]).diff([2011], 'years'), -1, 'year diff');\n        assert.equal(moment([2010]).diff([2010, 2], 'months'), -2, 'month diff');\n        assert.equal(moment([2010]).diff([2010, 0, 7], 'weeks'), 0, 'week diff');\n        assert.equal(moment([2010]).diff([2010, 0, 8], 'weeks'), -1, 'week diff');\n        assert.equal(moment([2010]).diff([2010, 0, 21], 'weeks'), -2, 'week diff');\n        assert.equal(moment([2010]).diff([2010, 0, 22], 'weeks'), -3, 'week diff');\n        assert.equal(moment([2010]).diff([2010, 0, 4], 'days'), -3, 'day diff');\n        assert.equal(moment([2010]).diff([2010, 0, 1, 4], 'hours'), -4, 'hour diff');\n        assert.equal(moment([2010]).diff([2010, 0, 1, 0, 5], 'minutes'), -5, 'minute diff');\n        assert.equal(moment([2010]).diff([2010, 0, 1, 0, 0, 6], 'seconds'), -6, 'second diff');\n    });\n\n    test('diff key before', function (assert) {\n        assert.equal(moment([2011]).diff([2010], 'years'), 1, 'year diff');\n        assert.equal(moment([2010, 2]).diff([2010], 'months'), 2, 'month diff');\n        assert.equal(moment([2010, 0, 4]).diff([2010], 'days'), 3, 'day diff');\n        assert.equal(moment([2010, 0, 7]).diff([2010], 'weeks'), 0, 'week diff');\n        assert.equal(moment([2010, 0, 8]).diff([2010], 'weeks'), 1, 'week diff');\n        assert.equal(moment([2010, 0, 21]).diff([2010], 'weeks'), 2, 'week diff');\n        assert.equal(moment([2010, 0, 22]).diff([2010], 'weeks'), 3, 'week diff');\n        assert.equal(moment([2010, 0, 1, 4]).diff([2010], 'hours'), 4, 'hour diff');\n        assert.equal(moment([2010, 0, 1, 0, 5]).diff([2010], 'minutes'), 5, 'minute diff');\n        assert.equal(moment([2010, 0, 1, 0, 0, 6]).diff([2010], 'seconds'), 6, 'second diff');\n    });\n\n    test('diff key before singular', function (assert) {\n        assert.equal(moment([2011]).diff([2010], 'year'), 1, 'year diff singular');\n        assert.equal(moment([2010, 2]).diff([2010], 'month'), 2, 'month diff singular');\n        assert.equal(moment([2010, 0, 4]).diff([2010], 'day'), 3, 'day diff singular');\n        assert.equal(moment([2010, 0, 7]).diff([2010], 'week'), 0, 'week diff singular');\n        assert.equal(moment([2010, 0, 8]).diff([2010], 'week'), 1, 'week diff singular');\n        assert.equal(moment([2010, 0, 21]).diff([2010], 'week'), 2, 'week diff singular');\n        assert.equal(moment([2010, 0, 22]).diff([2010], 'week'), 3, 'week diff singular');\n        assert.equal(moment([2010, 0, 1, 4]).diff([2010], 'hour'), 4, 'hour diff singular');\n        assert.equal(moment([2010, 0, 1, 0, 5]).diff([2010], 'minute'), 5, 'minute diff singular');\n        assert.equal(moment([2010, 0, 1, 0, 0, 6]).diff([2010], 'second'), 6, 'second diff singular');\n    });\n\n    test('diff key before abbreviated', function (assert) {\n        assert.equal(moment([2011]).diff([2010], 'y'), 1, 'year diff abbreviated');\n        assert.equal(moment([2010, 2]).diff([2010], 'M'), 2, 'month diff abbreviated');\n        assert.equal(moment([2010, 0, 4]).diff([2010], 'd'), 3, 'day diff abbreviated');\n        assert.equal(moment([2010, 0, 7]).diff([2010], 'w'), 0, 'week diff abbreviated');\n        assert.equal(moment([2010, 0, 8]).diff([2010], 'w'), 1, 'week diff abbreviated');\n        assert.equal(moment([2010, 0, 21]).diff([2010], 'w'), 2, 'week diff abbreviated');\n        assert.equal(moment([2010, 0, 22]).diff([2010], 'w'), 3, 'week diff abbreviated');\n        assert.equal(moment([2010, 0, 1, 4]).diff([2010], 'h'), 4, 'hour diff abbreviated');\n        assert.equal(moment([2010, 0, 1, 0, 5]).diff([2010], 'm'), 5, 'minute diff abbreviated');\n        assert.equal(moment([2010, 0, 1, 0, 0, 6]).diff([2010], 's'), 6, 'second diff abbreviated');\n    });\n\n    test('diff month', function (assert) {\n        assert.equal(moment([2011, 0, 31]).diff([2011, 2, 1], 'months'), -1, 'month diff');\n    });\n\n    test('diff across DST', function (assert) {\n        var dst = dstForYear(2012), a, b, daysInMonth;\n        if (!dst) {\n            assert.equal(42, 42, 'at least one assertion');\n            return;\n        }\n\n        a = dst.moment;\n        b = a.clone().utc().add(12, 'hours').local();\n        daysInMonth = (a.daysInMonth() + b.daysInMonth()) / 2;\n        assert.equal(b.diff(a, 'milliseconds', true), 12 * 60 * 60 * 1000,\n                'ms diff across DST');\n        assert.equal(b.diff(a, 'seconds', true), 12 * 60 * 60,\n                'second diff across DST');\n        assert.equal(b.diff(a, 'minutes', true), 12 * 60,\n                'minute diff across DST');\n        assert.equal(b.diff(a, 'hours', true), 12,\n                'hour diff across DST');\n        assert.equal(b.diff(a, 'days', true), (12 - dst.diff) / 24,\n                'day diff across DST');\n        equal(assert, b.diff(a, 'weeks', true),  (12 - dst.diff) / 24 / 7,\n                'week diff across DST');\n        assert.ok(0.95 / (2 * 31) < b.diff(a, 'months', true),\n                'month diff across DST, lower bound');\n        assert.ok(b.diff(a, 'month', true) < 1.05 / (2 * 28),\n                'month diff across DST, upper bound');\n        assert.ok(0.95 / (2 * 31 * 12) < b.diff(a, 'years', true),\n                'year diff across DST, lower bound');\n        assert.ok(b.diff(a, 'year', true) < 1.05 / (2 * 28 * 12),\n                'year diff across DST, upper bound');\n\n        a = dst.moment;\n        b = a.clone().utc().add(12 + dst.diff, 'hours').local();\n        daysInMonth = (a.daysInMonth() + b.daysInMonth()) / 2;\n\n        assert.equal(b.diff(a, 'milliseconds', true),\n                (12 + dst.diff) * 60 * 60 * 1000,\n                'ms diff across DST');\n        assert.equal(b.diff(a, 'seconds', true),  (12 + dst.diff) * 60 * 60,\n                'second diff across DST');\n        assert.equal(b.diff(a, 'minutes', true),  (12 + dst.diff) * 60,\n                'minute diff across DST');\n        assert.equal(b.diff(a, 'hours', true),  (12 + dst.diff),\n                'hour diff across DST');\n        assert.equal(b.diff(a, 'days', true),  12 / 24, 'day diff across DST');\n        equal(assert, b.diff(a, 'weeks', true),  12 / 24 / 7,\n                'week diff across DST');\n        assert.ok(0.95 / (2 * 31) < b.diff(a, 'months', true),\n                'month diff across DST, lower bound');\n        assert.ok(b.diff(a, 'month', true) < 1.05 / (2 * 28),\n                'month diff across DST, upper bound');\n        assert.ok(0.95 / (2 * 31 * 12) < b.diff(a, 'years', true),\n                'year diff across DST, lower bound');\n        assert.ok(b.diff(a, 'year', true) < 1.05 / (2 * 28 * 12),\n                'year diff across DST, upper bound');\n    });\n\n    test('diff overflow', function (assert) {\n        assert.equal(moment([2011]).diff([2010], 'months'), 12, 'month diff');\n        assert.equal(moment([2010, 0, 2]).diff([2010], 'hours'), 24, 'hour diff');\n        assert.equal(moment([2010, 0, 1, 2]).diff([2010], 'minutes'), 120, 'minute diff');\n        assert.equal(moment([2010, 0, 1, 0, 4]).diff([2010], 'seconds'), 240, 'second diff');\n    });\n\n    test('diff between utc and local', function (assert) {\n        if (moment([2012]).utcOffset() === moment([2011]).utcOffset()) {\n            // Russia's utc offset on 1st of Jan 2012 vs 2011 is different\n            assert.equal(moment([2012]).utc().diff([2011], 'years'), 1, 'year diff');\n        }\n        assert.equal(moment([2010, 2, 2]).utc().diff([2010, 0, 2], 'months'), 2, 'month diff');\n        assert.equal(moment([2010, 0, 4]).utc().diff([2010], 'days'), 3, 'day diff');\n        assert.equal(moment([2010, 0, 22]).utc().diff([2010], 'weeks'), 3, 'week diff');\n        assert.equal(moment([2010, 0, 1, 4]).utc().diff([2010], 'hours'), 4, 'hour diff');\n        assert.equal(moment([2010, 0, 1, 0, 5]).utc().diff([2010], 'minutes'), 5, 'minute diff');\n        assert.equal(moment([2010, 0, 1, 0, 0, 6]).utc().diff([2010], 'seconds'), 6, 'second diff');\n    });\n\n    test('diff floored', function (assert) {\n        assert.equal(moment([2010, 0, 1, 23]).diff([2010], 'day'), 0, '23 hours = 0 days');\n        assert.equal(moment([2010, 0, 1, 23, 59]).diff([2010], 'day'), 0, '23:59 hours = 0 days');\n        assert.equal(moment([2010, 0, 1, 24]).diff([2010], 'day'), 1, '24 hours = 1 day');\n        assert.equal(moment([2010, 0, 2]).diff([2011, 0, 1], 'year'), 0, 'year rounded down');\n        assert.equal(moment([2011, 0, 1]).diff([2010, 0, 2], 'year'), 0, 'year rounded down');\n        assert.equal(moment([2010, 0, 2]).diff([2011, 0, 2], 'year'), -1, 'year rounded down');\n        assert.equal(moment([2011, 0, 2]).diff([2010, 0, 2], 'year'), 1, 'year rounded down');\n    });\n\n    test('year diffs include dates', function (assert) {\n        assert.ok(moment([2012, 1, 19]).diff(moment([2002, 1, 20]), 'years', true) < 10, 'year diff should include date of month');\n    });\n\n    test('month diffs', function (assert) {\n        // due to floating point math errors, these tests just need to be accurate within 0.00000001\n        assert.equal(moment([2012, 0, 1]).diff([2012, 1, 1], 'months', true), -1, 'Jan 1 to Feb 1 should be 1 month');\n        equal(assert, moment([2012, 0, 1]).diff([2012, 0, 1, 12], 'months', true), -0.5 / 31, 'Jan 1 to Jan 1 noon should be 0.5 / 31 months');\n        assert.equal(moment([2012, 0, 15]).diff([2012, 1, 15], 'months', true), -1, 'Jan 15 to Feb 15 should be 1 month');\n        assert.equal(moment([2012, 0, 28]).diff([2012, 1, 28], 'months', true), -1, 'Jan 28 to Feb 28 should be 1 month');\n        assert.ok(moment([2012, 0, 31]).diff([2012, 1, 29], 'months', true), -1, 'Jan 31 to Feb 29 should be 1 month');\n        assert.ok(-1 > moment([2012, 0, 31]).diff([2012, 2, 1], 'months', true), 'Jan 31 to Mar 1 should be more than 1 month');\n        assert.ok(-30 / 28 < moment([2012, 0, 31]).diff([2012, 2, 1], 'months', true), 'Jan 31 to Mar 1 should be less than 1 month and 1 day');\n        equal(assert, moment([2012, 0, 1]).diff([2012, 0, 31], 'months', true), -(30 / 31), 'Jan 1 to Jan 31 should be 30 / 31 months');\n        assert.ok(0 < moment('2014-02-01').diff(moment('2014-01-31'), 'months', true), 'jan-31 to feb-1 diff is positive');\n    });\n\n    test('exact month diffs', function (assert) {\n        // generate all pairs of months and compute month diff, with fixed day\n        // of month = 15.\n\n        var m1, m2;\n        for (m1 = 0; m1 < 12; ++m1) {\n            for (m2 = m1; m2 < 12; ++m2) {\n                assert.equal(moment([2013, m2, 15]).diff(moment([2013, m1, 15]), 'months', true), m2 - m1,\n                             'month diff from 2013-' + m1 + '-15 to 2013-' + m2 + '-15');\n            }\n        }\n    });\n\n    test('year diffs', function (assert) {\n        // due to floating point math errors, these tests just need to be accurate within 0.00000001\n        equal(assert, moment([2012, 0, 1]).diff([2013, 0, 1], 'years', true), -1, 'Jan 1 2012 to Jan 1 2013 should be 1 year');\n        equal(assert, moment([2012, 1, 28]).diff([2013, 1, 28], 'years', true), -1, 'Feb 28 2012 to Feb 28 2013 should be 1 year');\n        equal(assert, moment([2012, 2, 1]).diff([2013, 2, 1], 'years', true), -1, 'Mar 1 2012 to Mar 1 2013 should be 1 year');\n        equal(assert, moment([2012, 11, 1]).diff([2013, 11, 1], 'years', true), -1, 'Dec 1 2012 to Dec 1 2013 should be 1 year');\n        equal(assert, moment([2012, 11, 31]).diff([2013, 11, 31], 'years', true), -1, 'Dec 31 2012 to Dec 31 2013 should be 1 year');\n        equal(assert, moment([2012, 0, 1]).diff([2013, 6, 1], 'years', true), -1.5, 'Jan 1 2012 to Jul 1 2013 should be 1.5 years');\n        equal(assert, moment([2012, 0, 31]).diff([2013, 6, 31], 'years', true), -1.5, 'Jan 31 2012 to Jul 31 2013 should be 1.5 years');\n        equal(assert, moment([2012, 0, 1]).diff([2013, 0, 1, 12], 'years', true), -1 - (0.5 / 31) / 12, 'Jan 1 2012 to Jan 1 2013 noon should be 1+(0.5 / 31) / 12 years');\n        equal(assert, moment([2012, 0, 1]).diff([2013, 6, 1, 12], 'years', true), -1.5 - (0.5 / 31) / 12, 'Jan 1 2012 to Jul 1 2013 noon should be 1.5+(0.5 / 31) / 12 years');\n        equal(assert, moment([2012, 1, 29]).diff([2013, 1, 28], 'years', true), -1, 'Feb 29 2012 to Feb 28 2013 should be 1-(1 / 28.5) / 12 years');\n    });\n\n    test('negative zero', function (assert) {\n        function isNegative (n) {\n                return (1 / n) < 0;\n            }\n        assert.ok(!isNegative(moment([2012, 0, 1]).diff(moment([2012, 0, 1]), 'months')), 'month diff on same date is zero, not -0');\n        assert.ok(!isNegative(moment([2012, 0, 1]).diff(moment([2012, 0, 1]), 'years')), 'year diff on same date is zero, not -0');\n        assert.ok(!isNegative(moment([2012, 0, 1]).diff(moment([2012, 0, 1]), 'quarters')), 'quarter diff on same date is zero, not -0');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('duration');\n\n    test('object instantiation', function (assert) {\n        var d = moment.duration({\n            years: 2,\n            months: 3,\n            weeks: 2,\n            days: 1,\n            hours: 8,\n            minutes: 9,\n            seconds: 20,\n            milliseconds: 12\n        });\n\n        assert.equal(d.years(),        2,  'years');\n        assert.equal(d.months(),       3,  'months');\n        assert.equal(d.weeks(),        2,  'weeks');\n        assert.equal(d.days(),         15, 'days'); // two weeks + 1 day\n        assert.equal(d.hours(),        8,  'hours');\n        assert.equal(d.minutes(),      9,  'minutes');\n        assert.equal(d.seconds(),      20, 'seconds');\n        assert.equal(d.milliseconds(), 12, 'milliseconds');\n    });\n\n    test('object instantiation with strings', function (assert) {\n        var d = moment.duration({\n            years: '2',\n            months: '3',\n            weeks: '2',\n            days: '1',\n            hours: '8',\n            minutes: '9',\n            seconds: '20',\n            milliseconds: '12'\n        });\n\n        assert.equal(d.years(),        2,  'years');\n        assert.equal(d.months(),       3,  'months');\n        assert.equal(d.weeks(),        2,  'weeks');\n        assert.equal(d.days(),         15, 'days'); // two weeks + 1 day\n        assert.equal(d.hours(),        8,  'hours');\n        assert.equal(d.minutes(),      9,  'minutes');\n        assert.equal(d.seconds(),      20, 'seconds');\n        assert.equal(d.milliseconds(), 12, 'milliseconds');\n    });\n\n    test('milliseconds instantiation', function (assert) {\n        assert.equal(moment.duration(72).milliseconds(), 72, 'milliseconds');\n    });\n\n    test('undefined instantiation', function (assert) {\n        assert.equal(moment.duration(undefined).milliseconds(), 0, 'milliseconds');\n    });\n\n    test('null instantiation', function (assert) {\n        assert.equal(moment.duration(null).milliseconds(), 0, 'milliseconds');\n    });\n\n    test('instantiation by type', function (assert) {\n        assert.equal(moment.duration(1, 'years').years(),                 1, 'years');\n        assert.equal(moment.duration(1, 'y').years(),                     1, 'y');\n        assert.equal(moment.duration(2, 'months').months(),               2, 'months');\n        assert.equal(moment.duration(2, 'M').months(),                    2, 'M');\n        assert.equal(moment.duration(3, 'weeks').weeks(),                 3, 'weeks');\n        assert.equal(moment.duration(3, 'w').weeks(),                     3, 'weeks');\n        assert.equal(moment.duration(4, 'days').days(),                   4, 'days');\n        assert.equal(moment.duration(4, 'd').days(),                      4, 'd');\n        assert.equal(moment.duration(5, 'hours').hours(),                 5, 'hours');\n        assert.equal(moment.duration(5, 'h').hours(),                     5, 'h');\n        assert.equal(moment.duration(6, 'minutes').minutes(),             6, 'minutes');\n        assert.equal(moment.duration(6, 'm').minutes(),                   6, 'm');\n        assert.equal(moment.duration(7, 'seconds').seconds(),             7, 'seconds');\n        assert.equal(moment.duration(7, 's').seconds(),                   7, 's');\n        assert.equal(moment.duration(8, 'milliseconds').milliseconds(),   8, 'milliseconds');\n        assert.equal(moment.duration(8, 'ms').milliseconds(),             8, 'ms');\n    });\n\n    test('shortcuts', function (assert) {\n        assert.equal(moment.duration({y: 1}).years(),         1, 'years = y');\n        assert.equal(moment.duration({M: 2}).months(),        2, 'months = M');\n        assert.equal(moment.duration({w: 3}).weeks(),         3, 'weeks = w');\n        assert.equal(moment.duration({d: 4}).days(),          4, 'days = d');\n        assert.equal(moment.duration({h: 5}).hours(),         5, 'hours = h');\n        assert.equal(moment.duration({m: 6}).minutes(),       6, 'minutes = m');\n        assert.equal(moment.duration({s: 7}).seconds(),       7, 'seconds = s');\n        assert.equal(moment.duration({ms: 8}).milliseconds(), 8, 'milliseconds = ms');\n    });\n\n    test('generic getter', function (assert) {\n        assert.equal(moment.duration(1, 'years').get('years'),                1, 'years');\n        assert.equal(moment.duration(1, 'years').get('year'),                 1, 'years = year');\n        assert.equal(moment.duration(1, 'years').get('y'),                    1, 'years = y');\n        assert.equal(moment.duration(2, 'months').get('months'),              2, 'months');\n        assert.equal(moment.duration(2, 'months').get('month'),               2, 'months = month');\n        assert.equal(moment.duration(2, 'months').get('M'),                   2, 'months = M');\n        assert.equal(moment.duration(3, 'weeks').get('weeks'),                3, 'weeks');\n        assert.equal(moment.duration(3, 'weeks').get('week'),                 3, 'weeks = week');\n        assert.equal(moment.duration(3, 'weeks').get('w'),                    3, 'weeks = w');\n        assert.equal(moment.duration(4, 'days').get('days'),                  4, 'days');\n        assert.equal(moment.duration(4, 'days').get('day'),                   4, 'days = day');\n        assert.equal(moment.duration(4, 'days').get('d'),                     4, 'days = d');\n        assert.equal(moment.duration(5, 'hours').get('hours'),                5, 'hours');\n        assert.equal(moment.duration(5, 'hours').get('hour'),                 5, 'hours = hour');\n        assert.equal(moment.duration(5, 'hours').get('h'),                    5, 'hours = h');\n        assert.equal(moment.duration(6, 'minutes').get('minutes'),            6, 'minutes');\n        assert.equal(moment.duration(6, 'minutes').get('minute'),             6, 'minutes = minute');\n        assert.equal(moment.duration(6, 'minutes').get('m'),                  6, 'minutes = m');\n        assert.equal(moment.duration(7, 'seconds').get('seconds'),            7, 'seconds');\n        assert.equal(moment.duration(7, 'seconds').get('second'),             7, 'seconds = second');\n        assert.equal(moment.duration(7, 'seconds').get('s'),                  7, 'seconds = s');\n        assert.equal(moment.duration(8, 'milliseconds').get('milliseconds'),  8, 'milliseconds');\n        assert.equal(moment.duration(8, 'milliseconds').get('millisecond'),   8, 'milliseconds = millisecond');\n        assert.equal(moment.duration(8, 'milliseconds').get('ms'),            8, 'milliseconds = ms');\n    });\n\n    test('instantiation from another duration', function (assert) {\n        var simple = moment.duration(1234),\n            lengthy = moment.duration(60 * 60 * 24 * 360 * 1e3),\n            complicated = moment.duration({\n                years: 2,\n                months: 3,\n                weeks: 4,\n                days: 1,\n                hours: 8,\n                minutes: 9,\n                seconds: 20,\n                milliseconds: 12\n            }),\n            modified = moment.duration(1, 'day').add(moment.duration(1, 'day'));\n\n        assert.deepEqual(moment.duration(simple), simple, 'simple clones are equal');\n        assert.deepEqual(moment.duration(lengthy), lengthy, 'lengthy clones are equal');\n        assert.deepEqual(moment.duration(complicated), complicated, 'complicated clones are equal');\n        assert.deepEqual(moment.duration(modified), modified, 'cloning modified duration works');\n    });\n\n    test('instantiation from 24-hour time zero', function (assert) {\n        assert.equal(moment.duration('00:00').years(), 0, '0 years');\n        assert.equal(moment.duration('00:00').days(), 0, '0 days');\n        assert.equal(moment.duration('00:00').hours(), 0, '0 hours');\n        assert.equal(moment.duration('00:00').minutes(), 0, '0 minutes');\n        assert.equal(moment.duration('00:00').seconds(), 0, '0 seconds');\n        assert.equal(moment.duration('00:00').milliseconds(), 0, '0 milliseconds');\n    });\n\n    test('instantiation from 24-hour time <24 hours', function (assert) {\n        assert.equal(moment.duration('06:45').years(), 0, '0 years');\n        assert.equal(moment.duration('06:45').days(), 0, '0 days');\n        assert.equal(moment.duration('06:45').hours(), 6, '6 hours');\n        assert.equal(moment.duration('06:45').minutes(), 45, '45 minutes');\n        assert.equal(moment.duration('06:45').seconds(), 0, '0 seconds');\n        assert.equal(moment.duration('06:45').milliseconds(), 0, '0 milliseconds');\n    });\n\n    test('instantiation from 24-hour time >24 hours', function (assert) {\n        assert.equal(moment.duration('26:45').years(), 0, '0 years');\n        assert.equal(moment.duration('26:45').days(), 1, '0 days');\n        assert.equal(moment.duration('26:45').hours(), 2, '2 hours');\n        assert.equal(moment.duration('26:45').minutes(), 45, '45 minutes');\n        assert.equal(moment.duration('26:45').seconds(), 0, '0 seconds');\n        assert.equal(moment.duration('26:45').milliseconds(), 0, '0 milliseconds');\n    });\n\n    test('instatiation from serialized C# TimeSpan zero', function (assert) {\n        assert.equal(moment.duration('00:00:00').years(), 0, '0 years');\n        assert.equal(moment.duration('00:00:00').days(), 0, '0 days');\n        assert.equal(moment.duration('00:00:00').hours(), 0, '0 hours');\n        assert.equal(moment.duration('00:00:00').minutes(), 0, '0 minutes');\n        assert.equal(moment.duration('00:00:00').seconds(), 0, '0 seconds');\n        assert.equal(moment.duration('00:00:00').milliseconds(), 0, '0 milliseconds');\n    });\n\n    test('instatiation from serialized C# TimeSpan with days', function (assert) {\n        assert.equal(moment.duration('1.02:03:04.9999999').years(), 0, '0 years');\n        assert.equal(moment.duration('1.02:03:04.9999999').days(), 1, '1 day');\n        assert.equal(moment.duration('1.02:03:04.9999999').hours(), 2, '2 hours');\n        assert.equal(moment.duration('1.02:03:04.9999999').minutes(), 3, '3 minutes');\n        assert.equal(moment.duration('1.02:03:04.9999999').seconds(), 4, '4 seconds');\n        assert.equal(moment.duration('1.02:03:04.9999999').milliseconds(), 999, '999 milliseconds');\n\n        assert.equal(moment.duration('1 02:03:04.9999999').years(), 0, '0 years');\n        assert.equal(moment.duration('1 02:03:04.9999999').days(), 1, '1 day');\n        assert.equal(moment.duration('1 02:03:04.9999999').hours(), 2, '2 hours');\n        assert.equal(moment.duration('1 02:03:04.9999999').minutes(), 3, '3 minutes');\n        assert.equal(moment.duration('1 02:03:04.9999999').seconds(), 4, '4 seconds');\n        assert.equal(moment.duration('1 02:03:04.9999999').milliseconds(), 999, '999 milliseconds');\n    });\n\n    test('instatiation from serialized C# TimeSpan without days', function (assert) {\n        assert.equal(moment.duration('01:02:03.9999999').years(), 0, '0 years');\n        assert.equal(moment.duration('01:02:03.9999999').days(), 0, '0 days');\n        assert.equal(moment.duration('01:02:03.9999999').hours(), 1, '1 hour');\n        assert.equal(moment.duration('01:02:03.9999999').minutes(), 2, '2 minutes');\n        assert.equal(moment.duration('01:02:03.9999999').seconds(), 3, '3 seconds');\n        assert.equal(moment.duration('01:02:03.9999999').milliseconds(), 999, '999 milliseconds');\n\n        assert.equal(moment.duration('23:59:59.9999999').days(), 0, '0 days');\n        assert.equal(moment.duration('23:59:59.9999999').hours(), 23, '23 hours');\n\n        assert.equal(moment.duration('500:59:59.9999999').days(), 20, '500 hours overflows to 20 days');\n        assert.equal(moment.duration('500:59:59.9999999').hours(), 20, '500 hours overflows to 20 hours');\n    });\n\n    test('instatiation from serialized C# TimeSpan without days or milliseconds', function (assert) {\n        assert.equal(moment.duration('01:02:03').years(), 0, '0 years');\n        assert.equal(moment.duration('01:02:03').days(), 0, '0 days');\n        assert.equal(moment.duration('01:02:03').hours(), 1, '1 hour');\n        assert.equal(moment.duration('01:02:03').minutes(), 2, '2 minutes');\n        assert.equal(moment.duration('01:02:03').seconds(), 3, '3 seconds');\n        assert.equal(moment.duration('01:02:03').milliseconds(), 0, '0 milliseconds');\n    });\n\n    test('instatiation from serialized C# TimeSpan without milliseconds', function (assert) {\n        assert.equal(moment.duration('1.02:03:04').years(), 0, '0 years');\n        assert.equal(moment.duration('1.02:03:04').days(), 1, '1 day');\n        assert.equal(moment.duration('1.02:03:04').hours(), 2, '2 hours');\n        assert.equal(moment.duration('1.02:03:04').minutes(), 3, '3 minutes');\n        assert.equal(moment.duration('1.02:03:04').seconds(), 4, '4 seconds');\n        assert.equal(moment.duration('1.02:03:04').milliseconds(), 0, '0 milliseconds');\n    });\n\n    test('instatiation from serialized C# TimeSpan maxValue', function (assert) {\n        var d = moment.duration('10675199.02:48:05.4775807');\n\n        assert.equal(d.years(), 29227, '29227 years');\n        assert.equal(d.months(), 8, '8 months');\n        assert.equal(d.days(), 12, '12 day');  // if you have to change this value -- just do it\n\n        assert.equal(d.hours(), 2, '2 hours');\n        assert.equal(d.minutes(), 48, '48 minutes');\n        assert.equal(d.seconds(), 5, '5 seconds');\n        assert.equal(d.milliseconds(), 477, '477 milliseconds');\n    });\n\n    test('instatiation from serialized C# TimeSpan minValue', function (assert) {\n        var d = moment.duration('-10675199.02:48:05.4775808');\n\n        assert.equal(d.years(), -29227, '29653 years');\n        assert.equal(d.months(), -8, '8 day');\n        assert.equal(d.days(), -12, '12 day');  // if you have to change this value -- just do it\n\n        assert.equal(d.hours(), -2, '2 hours');\n        assert.equal(d.minutes(), -48, '48 minutes');\n        assert.equal(d.seconds(), -5, '5 seconds');\n        assert.equal(d.milliseconds(), -477, '477 milliseconds');\n    });\n\n    test('instantiation from ISO 8601 duration', function (assert) {\n        assert.equal(moment.duration('P1Y2M3DT4H5M6S').asSeconds(), moment.duration({y: 1, M: 2, d: 3, h: 4, m: 5, s: 6}).asSeconds(), 'all fields');\n        assert.equal(moment.duration('P3W3D').asSeconds(), moment.duration({w: 3, d: 3}).asSeconds(), 'week and day fields');\n        assert.equal(moment.duration('P1M').asSeconds(), moment.duration({M: 1}).asSeconds(), 'single month field');\n        assert.equal(moment.duration('PT1M').asSeconds(), moment.duration({m: 1}).asSeconds(), 'single minute field');\n        assert.equal(moment.duration('P1MT2H').asSeconds(), moment.duration({M: 1, h: 2}).asSeconds(), 'random fields missing');\n        assert.equal(moment.duration('-P60D').asSeconds(), moment.duration({d: -60}).asSeconds(), 'negative days');\n        assert.equal(moment.duration('PT0.5S').asSeconds(), moment.duration({s: 0.5}).asSeconds(), 'fractional seconds');\n        assert.equal(moment.duration('PT0,5S').asSeconds(), moment.duration({s: 0.5}).asSeconds(), 'fractional seconds (comma)');\n    });\n\n    test('serialization to ISO 8601 duration strings', function (assert) {\n        assert.equal(moment.duration({y: 1, M: 2, d: 3, h: 4, m: 5, s: 6}).toISOString(), 'P1Y2M3DT4H5M6S', 'all fields');\n        assert.equal(moment.duration({M: -1}).toISOString(), '-P1M', 'one month ago');\n        assert.equal(moment.duration({m: -1}).toISOString(), '-PT1M', 'one minute ago');\n        assert.equal(moment.duration({s: -0.5}).toISOString(), '-PT0.5S', 'one half second ago');\n        assert.equal(moment.duration({y: -0.5, M: 1}).toISOString(), '-P5M', 'a month after half a year ago');\n        assert.equal(moment.duration({}).toISOString(), 'P0D', 'zero duration');\n        assert.equal(moment.duration({M: 16, d:40, s: 86465}).toISOString(), 'P1Y4M40DT24H1M5S', 'all fields');\n    });\n\n    test('toString acts as toISOString', function (assert) {\n        assert.equal(moment.duration({y: 1, M: 2, d: 3, h: 4, m: 5, s: 6}).toString(), 'P1Y2M3DT4H5M6S', 'all fields');\n        assert.equal(moment.duration({M: -1}).toString(), '-P1M', 'one month ago');\n        assert.equal(moment.duration({m: -1}).toString(), '-PT1M', 'one minute ago');\n        assert.equal(moment.duration({s: -0.5}).toString(), '-PT0.5S', 'one half second ago');\n        assert.equal(moment.duration({y: -0.5, M: 1}).toString(), '-P5M', 'a month after half a year ago');\n        assert.equal(moment.duration({}).toString(), 'P0D', 'zero duration');\n        assert.equal(moment.duration({M: 16, d:40, s: 86465}).toString(), 'P1Y4M40DT24H1M5S', 'all fields');\n    });\n\n    test('toIsoString deprecation', function (assert) {\n        test.expectedDeprecations('toIsoString()');\n\n        assert.equal(moment.duration({}).toIsoString(), moment.duration({}).toISOString(), 'toIsoString delegates to toISOString');\n    });\n\n    test('`isodate` (python) test cases', function (assert) {\n        assert.equal(moment.duration('P18Y9M4DT11H9M8S').asSeconds(), moment.duration({y: 18, M: 9, d: 4, h: 11, m: 9, s: 8}).asSeconds(), 'python isodate 1');\n        assert.equal(moment.duration('P2W').asSeconds(), moment.duration({w: 2}).asSeconds(), 'python isodate 2');\n        assert.equal(moment.duration('P3Y6M4DT12H30M5S').asSeconds(), moment.duration({y: 3, M: 6, d: 4, h: 12, m: 30, s: 5}).asSeconds(), 'python isodate 3');\n        assert.equal(moment.duration('P23DT23H').asSeconds(), moment.duration({d: 23, h: 23}).asSeconds(), 'python isodate 4');\n        assert.equal(moment.duration('P4Y').asSeconds(), moment.duration({y: 4}).asSeconds(), 'python isodate 5');\n        assert.equal(moment.duration('P1M').asSeconds(), moment.duration({M: 1}).asSeconds(), 'python isodate 6');\n        assert.equal(moment.duration('PT1M').asSeconds(), moment.duration({m: 1}).asSeconds(), 'python isodate 7');\n        assert.equal(moment.duration('P0.5Y').asSeconds(), moment.duration({y: 0.5}).asSeconds(), 'python isodate 8');\n        assert.equal(moment.duration('PT36H').asSeconds(), moment.duration({h: 36}).asSeconds(), 'python isodate 9');\n        assert.equal(moment.duration('P1DT12H').asSeconds(), moment.duration({d: 1, h: 12}).asSeconds(), 'python isodate 10');\n        assert.equal(moment.duration('-P2W').asSeconds(), moment.duration({w: -2}).asSeconds(), 'python isodate 11');\n        assert.equal(moment.duration('-P2.2W').asSeconds(), moment.duration({w: -2.2}).asSeconds(), 'python isodate 12');\n        assert.equal(moment.duration('P1DT2H3M4S').asSeconds(), moment.duration({d: 1, h: 2, m: 3, s: 4}).asSeconds(), 'python isodate 13');\n        assert.equal(moment.duration('P1DT2H3M').asSeconds(), moment.duration({d: 1, h: 2, m: 3}).asSeconds(), 'python isodate 14');\n        assert.equal(moment.duration('P1DT2H').asSeconds(), moment.duration({d: 1, h: 2}).asSeconds(), 'python isodate 15');\n        assert.equal(moment.duration('PT2H').asSeconds(), moment.duration({h: 2}).asSeconds(), 'python isodate 16');\n        assert.equal(moment.duration('PT2.3H').asSeconds(), moment.duration({h: 2.3}).asSeconds(), 'python isodate 17');\n        assert.equal(moment.duration('PT2H3M4S').asSeconds(), moment.duration({h: 2, m: 3, s: 4}).asSeconds(), 'python isodate 18');\n        assert.equal(moment.duration('PT3M4S').asSeconds(), moment.duration({m: 3, s: 4}).asSeconds(), 'python isodate 19');\n        assert.equal(moment.duration('PT22S').asSeconds(), moment.duration({s: 22}).asSeconds(), 'python isodate 20');\n        assert.equal(moment.duration('PT22.22S').asSeconds(), moment.duration({s: 22.22}).asSeconds(), 'python isodate 21');\n        assert.equal(moment.duration('-P2Y').asSeconds(), moment.duration({y: -2}).asSeconds(), 'python isodate 22');\n        assert.equal(moment.duration('-P3Y6M4DT12H30M5S').asSeconds(), moment.duration({y: -3, M: -6, d: -4, h: -12, m: -30, s: -5}).asSeconds(), 'python isodate 23');\n        assert.equal(moment.duration('-P1DT2H3M4S').asSeconds(), moment.duration({d: -1, h: -2, m: -3, s: -4}).asSeconds(), 'python isodate 24');\n        assert.equal(moment.duration('PT-6H3M').asSeconds(), moment.duration({h: -6, m: 3}).asSeconds(), 'python isodate 25');\n        assert.equal(moment.duration('-PT-6H3M').asSeconds(), moment.duration({h: 6, m: -3}).asSeconds(), 'python isodate 26');\n        assert.equal(moment.duration('-P-3Y-6M-4DT-12H-30M-5S').asSeconds(), moment.duration({y: 3, M: 6, d: 4, h: 12, m: 30, s: 5}).asSeconds(), 'python isodate 27');\n        assert.equal(moment.duration('P-3Y-6M-4DT-12H-30M-5S').asSeconds(), moment.duration({y: -3, M: -6, d: -4, h: -12, m: -30, s: -5}).asSeconds(), 'python isodate 28');\n        assert.equal(moment.duration('-P-2W').asSeconds(), moment.duration({w: 2}).asSeconds(), 'python isodate 29');\n        assert.equal(moment.duration('P-2W').asSeconds(), moment.duration({w: -2}).asSeconds(), 'python isodate 30');\n    });\n\n    test('ISO 8601 misuse cases', function (assert) {\n        assert.equal(moment.duration('P').asSeconds(), 0, 'lonely P');\n        assert.equal(moment.duration('PT').asSeconds(), 0, 'just P and T');\n        assert.equal(moment.duration('P1H').asSeconds(), 0, 'missing T');\n        assert.equal(moment.duration('P1D1Y').asSeconds(), 0, 'out of order');\n        assert.equal(moment.duration('PT.5S').asSeconds(), 0.5, 'accept no leading zero for decimal');\n        assert.equal(moment.duration('PT1,S').asSeconds(), 1, 'accept trailing decimal separator');\n        assert.equal(moment.duration('PT1M0,,5S').asSeconds(), 60, 'extra decimal separators are ignored as 0');\n    });\n\n    test('humanize', function (assert) {\n        moment.locale('en');\n        assert.equal(moment.duration({seconds: 44}).humanize(),  'a few seconds', '44 seconds = a few seconds');\n        assert.equal(moment.duration({seconds: 45}).humanize(),  'a minute',      '45 seconds = a minute');\n        assert.equal(moment.duration({seconds: 89}).humanize(),  'a minute',      '89 seconds = a minute');\n        assert.equal(moment.duration({seconds: 90}).humanize(),  '2 minutes',     '90 seconds = 2 minutes');\n        assert.equal(moment.duration({minutes: 44}).humanize(),  '44 minutes',    '44 minutes = 44 minutes');\n        assert.equal(moment.duration({minutes: 45}).humanize(),  'an hour',       '45 minutes = an hour');\n        assert.equal(moment.duration({minutes: 89}).humanize(),  'an hour',       '89 minutes = an hour');\n        assert.equal(moment.duration({minutes: 90}).humanize(),  '2 hours',       '90 minutes = 2 hours');\n        assert.equal(moment.duration({hours: 5}).humanize(),     '5 hours',       '5 hours = 5 hours');\n        assert.equal(moment.duration({hours: 21}).humanize(),    '21 hours',      '21 hours = 21 hours');\n        assert.equal(moment.duration({hours: 22}).humanize(),    'a day',         '22 hours = a day');\n        assert.equal(moment.duration({hours: 35}).humanize(),    'a day',         '35 hours = a day');\n        assert.equal(moment.duration({hours: 36}).humanize(),    '2 days',        '36 hours = 2 days');\n        assert.equal(moment.duration({days: 1}).humanize(),      'a day',         '1 day = a day');\n        assert.equal(moment.duration({days: 5}).humanize(),      '5 days',        '5 days = 5 days');\n        assert.equal(moment.duration({weeks: 1}).humanize(),     '7 days',        '1 week = 7 days');\n        assert.equal(moment.duration({days: 25}).humanize(),     '25 days',       '25 days = 25 days');\n        assert.equal(moment.duration({days: 26}).humanize(),     'a month',       '26 days = a month');\n        assert.equal(moment.duration({days: 30}).humanize(),     'a month',       '30 days = a month');\n        assert.equal(moment.duration({days: 45}).humanize(),     'a month',       '45 days = a month');\n        assert.equal(moment.duration({days: 46}).humanize(),     '2 months',      '46 days = 2 months');\n        assert.equal(moment.duration({days: 74}).humanize(),     '2 months',      '74 days = 2 months');\n        assert.equal(moment.duration({days: 77}).humanize(),     '3 months',      '77 days = 3 months');\n        assert.equal(moment.duration({months: 1}).humanize(),    'a month',       '1 month = a month');\n        assert.equal(moment.duration({months: 5}).humanize(),    '5 months',      '5 months = 5 months');\n        assert.equal(moment.duration({days: 344}).humanize(),    'a year',        '344 days = a year');\n        assert.equal(moment.duration({days: 345}).humanize(),    'a year',        '345 days = a year');\n        assert.equal(moment.duration({days: 547}).humanize(),    'a year',        '547 days = a year');\n        assert.equal(moment.duration({days: 548}).humanize(),    '2 years',       '548 days = 2 years');\n        assert.equal(moment.duration({years: 1}).humanize(),     'a year',        '1 year = a year');\n        assert.equal(moment.duration({years: 5}).humanize(),     '5 years',       '5 years = 5 years');\n        assert.equal(moment.duration(7200000).humanize(),        '2 hours',       '7200000 = 2 minutes');\n    });\n\n    test('humanize duration with suffix', function (assert) {\n        moment.locale('en');\n        assert.equal(moment.duration({seconds:  44}).humanize(true),  'in a few seconds', '44 seconds = a few seconds');\n        assert.equal(moment.duration({seconds: -44}).humanize(true),  'a few seconds ago', '44 seconds = a few seconds');\n    });\n\n    test('bubble value up', function (assert) {\n        assert.equal(moment.duration({milliseconds: 61001}).milliseconds(), 1, '61001 milliseconds has 1 millisecond left over');\n        assert.equal(moment.duration({milliseconds: 61001}).seconds(),      1, '61001 milliseconds has 1 second left over');\n        assert.equal(moment.duration({milliseconds: 61001}).minutes(),      1, '61001 milliseconds has 1 minute left over');\n\n        assert.equal(moment.duration({minutes: 350}).minutes(), 50, '350 minutes has 50 minutes left over');\n        assert.equal(moment.duration({minutes: 350}).hours(),   5,  '350 minutes has 5 hours left over');\n    });\n\n    test('clipping', function (assert) {\n        assert.equal(moment.duration({months: 11}).months(), 11, '11 months is 11 months');\n        assert.equal(moment.duration({months: 11}).years(),  0,  '11 months makes no year');\n        assert.equal(moment.duration({months: 12}).months(), 0,  '12 months is 0 months left over');\n        assert.equal(moment.duration({months: 12}).years(),  1,  '12 months makes 1 year');\n        assert.equal(moment.duration({months: 13}).months(), 1,  '13 months is 1 month left over');\n        assert.equal(moment.duration({months: 13}).years(),  1,  '13 months makes 1 year');\n\n        assert.equal(moment.duration({days: 30}).days(),   30, '30 days is 30 days');\n        assert.equal(moment.duration({days: 30}).months(), 0,  '30 days makes no month');\n        assert.equal(moment.duration({days: 31}).days(),   0,  '31 days is 0 days left over');\n        assert.equal(moment.duration({days: 31}).months(), 1,  '31 days is a month');\n        assert.equal(moment.duration({days: 32}).days(),   1,  '32 days is 1 day left over');\n        assert.equal(moment.duration({days: 32}).months(), 1,  '32 days is a month');\n\n        assert.equal(moment.duration({hours: 23}).hours(), 23, '23 hours is 23 hours');\n        assert.equal(moment.duration({hours: 23}).days(),  0,  '23 hours makes no day');\n        assert.equal(moment.duration({hours: 24}).hours(), 0,  '24 hours is 0 hours left over');\n        assert.equal(moment.duration({hours: 24}).days(),  1,  '24 hours makes 1 day');\n        assert.equal(moment.duration({hours: 25}).hours(), 1,  '25 hours is 1 hour left over');\n        assert.equal(moment.duration({hours: 25}).days(),  1,  '25 hours makes 1 day');\n    });\n\n    test('bubbling consistency', function (assert) {\n        var days = 0, months = 0, newDays, newMonths, totalDays, d;\n        for (totalDays = 1; totalDays <= 500; ++totalDays) {\n            d = moment.duration(totalDays, 'days');\n            newDays = d.days();\n            newMonths = d.months() + d.years() * 12;\n            assert.ok(\n                    (months === newMonths && days + 1 === newDays) ||\n                    (months + 1 === newMonths && newDays === 0),\n                    'consistent total days ' + totalDays +\n                    ' was ' + months + ' ' + days +\n                    ' now ' + newMonths + ' ' + newDays);\n            days = newDays;\n            months = newMonths;\n        }\n    });\n\n    test('effective equivalency', function (assert) {\n        assert.deepEqual(moment.duration({seconds: 1})._data,  moment.duration({milliseconds: 1000})._data, '1 second is the same as 1000 milliseconds');\n        assert.deepEqual(moment.duration({seconds: 60})._data, moment.duration({minutes: 1})._data,         '1 minute is the same as 60 seconds');\n        assert.deepEqual(moment.duration({minutes: 60})._data, moment.duration({hours: 1})._data,           '1 hour is the same as 60 minutes');\n        assert.deepEqual(moment.duration({hours: 24})._data,   moment.duration({days: 1})._data,            '1 day is the same as 24 hours');\n        assert.deepEqual(moment.duration({days: 7})._data,     moment.duration({weeks: 1})._data,           '1 week is the same as 7 days');\n        assert.deepEqual(moment.duration({days: 31})._data,    moment.duration({months: 1})._data,          '1 month is the same as 30 days');\n        assert.deepEqual(moment.duration({months: 12})._data,  moment.duration({years: 1})._data,           '1 years is the same as 12 months');\n    });\n\n    test('asGetters', function (assert) {\n        // 400 years have exactly 146097 days\n\n        // years\n        assert.equal(moment.duration(1, 'year').asYears(),            1,           '1 year as years');\n        assert.equal(moment.duration(1, 'year').asMonths(),           12,          '1 year as months');\n        assert.equal(moment.duration(400, 'year').asMonths(),         4800,        '400 years as months');\n        assert.equal(moment.duration(1, 'year').asWeeks().toFixed(3), 52.143,      '1 year as weeks');\n        assert.equal(moment.duration(1, 'year').asDays(),             365,         '1 year as days');\n        assert.equal(moment.duration(2, 'year').asDays(),             730,         '2 years as days');\n        assert.equal(moment.duration(3, 'year').asDays(),             1096,        '3 years as days');\n        assert.equal(moment.duration(4, 'year').asDays(),             1461,        '4 years as days');\n        assert.equal(moment.duration(400, 'year').asDays(),           146097,      '400 years as days');\n        assert.equal(moment.duration(1, 'year').asHours(),            8760,        '1 year as hours');\n        assert.equal(moment.duration(1, 'year').asMinutes(),          525600,      '1 year as minutes');\n        assert.equal(moment.duration(1, 'year').asSeconds(),          31536000,    '1 year as seconds');\n        assert.equal(moment.duration(1, 'year').asMilliseconds(),     31536000000, '1 year as milliseconds');\n\n        // months\n        assert.equal(moment.duration(1, 'month').asYears().toFixed(4), 0.0833,     '1 month as years');\n        assert.equal(moment.duration(1, 'month').asMonths(),           1,          '1 month as months');\n        assert.equal(moment.duration(1, 'month').asWeeks().toFixed(3), 4.286,      '1 month as weeks');\n        assert.equal(moment.duration(1, 'month').asDays(),             30,         '1 month as days');\n        assert.equal(moment.duration(2, 'month').asDays(),             61,         '2 months as days');\n        assert.equal(moment.duration(3, 'month').asDays(),             91,         '3 months as days');\n        assert.equal(moment.duration(4, 'month').asDays(),             122,        '4 months as days');\n        assert.equal(moment.duration(5, 'month').asDays(),             152,        '5 months as days');\n        assert.equal(moment.duration(6, 'month').asDays(),             183,        '6 months as days');\n        assert.equal(moment.duration(7, 'month').asDays(),             213,        '7 months as days');\n        assert.equal(moment.duration(8, 'month').asDays(),             243,        '8 months as days');\n        assert.equal(moment.duration(9, 'month').asDays(),             274,        '9 months as days');\n        assert.equal(moment.duration(10, 'month').asDays(),            304,        '10 months as days');\n        assert.equal(moment.duration(11, 'month').asDays(),            335,        '11 months as days');\n        assert.equal(moment.duration(12, 'month').asDays(),            365,        '12 months as days');\n        assert.equal(moment.duration(24, 'month').asDays(),            730,        '24 months as days');\n        assert.equal(moment.duration(36, 'month').asDays(),            1096,       '36 months as days');\n        assert.equal(moment.duration(48, 'month').asDays(),            1461,       '48 months as days');\n        assert.equal(moment.duration(4800, 'month').asDays(),          146097,     '4800 months as days');\n        assert.equal(moment.duration(1, 'month').asHours(),            720,        '1 month as hours');\n        assert.equal(moment.duration(1, 'month').asMinutes(),          43200,      '1 month as minutes');\n        assert.equal(moment.duration(1, 'month').asSeconds(),          2592000,    '1 month as seconds');\n        assert.equal(moment.duration(1, 'month').asMilliseconds(),     2592000000, '1 month as milliseconds');\n\n        // weeks\n        assert.equal(moment.duration(1, 'week').asYears().toFixed(4),  0.0192,    '1 week as years');\n        assert.equal(moment.duration(1, 'week').asMonths().toFixed(3), 0.230,     '1 week as months');\n        assert.equal(moment.duration(1, 'week').asWeeks(),             1,         '1 week as weeks');\n        assert.equal(moment.duration(1, 'week').asDays(),              7,         '1 week as days');\n        assert.equal(moment.duration(1, 'week').asHours(),             168,       '1 week as hours');\n        assert.equal(moment.duration(1, 'week').asMinutes(),           10080,     '1 week as minutes');\n        assert.equal(moment.duration(1, 'week').asSeconds(),           604800,    '1 week as seconds');\n        assert.equal(moment.duration(1, 'week').asMilliseconds(),      604800000, '1 week as milliseconds');\n\n        // days\n        assert.equal(moment.duration(1, 'day').asYears().toFixed(4),  0.0027,   '1 day as years');\n        assert.equal(moment.duration(1, 'day').asMonths().toFixed(3), 0.033,    '1 day as months');\n        assert.equal(moment.duration(1, 'day').asWeeks().toFixed(3),  0.143,    '1 day as weeks');\n        assert.equal(moment.duration(1, 'day').asDays(),              1,        '1 day as days');\n        assert.equal(moment.duration(1, 'day').asHours(),             24,       '1 day as hours');\n        assert.equal(moment.duration(1, 'day').asMinutes(),           1440,     '1 day as minutes');\n        assert.equal(moment.duration(1, 'day').asSeconds(),           86400,    '1 day as seconds');\n        assert.equal(moment.duration(1, 'day').asMilliseconds(),      86400000, '1 day as milliseconds');\n\n        // hours\n        assert.equal(moment.duration(1, 'hour').asYears().toFixed(6),  0.000114, '1 hour as years');\n        assert.equal(moment.duration(1, 'hour').asMonths().toFixed(5), 0.00137,  '1 hour as months');\n        assert.equal(moment.duration(1, 'hour').asWeeks().toFixed(5),  0.00595,  '1 hour as weeks');\n        assert.equal(moment.duration(1, 'hour').asDays().toFixed(4),   0.0417,   '1 hour as days');\n        assert.equal(moment.duration(1, 'hour').asHours(),             1,        '1 hour as hours');\n        assert.equal(moment.duration(1, 'hour').asMinutes(),           60,       '1 hour as minutes');\n        assert.equal(moment.duration(1, 'hour').asSeconds(),           3600,     '1 hour as seconds');\n        assert.equal(moment.duration(1, 'hour').asMilliseconds(),      3600000,  '1 hour as milliseconds');\n\n        // minutes\n        assert.equal(moment.duration(1, 'minute').asYears().toFixed(8),  0.00000190, '1 minute as years');\n        assert.equal(moment.duration(1, 'minute').asMonths().toFixed(7), 0.0000228,  '1 minute as months');\n        assert.equal(moment.duration(1, 'minute').asWeeks().toFixed(7),  0.0000992,  '1 minute as weeks');\n        assert.equal(moment.duration(1, 'minute').asDays().toFixed(6),   0.000694,   '1 minute as days');\n        assert.equal(moment.duration(1, 'minute').asHours().toFixed(4),  0.0167,     '1 minute as hours');\n        assert.equal(moment.duration(1, 'minute').asMinutes(),           1,          '1 minute as minutes');\n        assert.equal(moment.duration(1, 'minute').asSeconds(),           60,         '1 minute as seconds');\n        assert.equal(moment.duration(1, 'minute').asMilliseconds(),      60000,      '1 minute as milliseconds');\n\n        // seconds\n        assert.equal(moment.duration(1, 'second').asYears().toFixed(10),  0.0000000317, '1 second as years');\n        assert.equal(moment.duration(1, 'second').asMonths().toFixed(9),  0.000000380,  '1 second as months');\n        assert.equal(moment.duration(1, 'second').asWeeks().toFixed(8),   0.00000165,   '1 second as weeks');\n        assert.equal(moment.duration(1, 'second').asDays().toFixed(7),    0.0000116,    '1 second as days');\n        assert.equal(moment.duration(1, 'second').asHours().toFixed(6),   0.000278,     '1 second as hours');\n        assert.equal(moment.duration(1, 'second').asMinutes().toFixed(4), 0.0167,       '1 second as minutes');\n        assert.equal(moment.duration(1, 'second').asSeconds(),            1,            '1 second as seconds');\n        assert.equal(moment.duration(1, 'second').asMilliseconds(),       1000,         '1 second as milliseconds');\n\n        // milliseconds\n        assert.equal(moment.duration(1, 'millisecond').asYears().toFixed(13),  0.0000000000317, '1 millisecond as years');\n        assert.equal(moment.duration(1, 'millisecond').asMonths().toFixed(12), 0.000000000380,  '1 millisecond as months');\n        assert.equal(moment.duration(1, 'millisecond').asWeeks().toFixed(11),  0.00000000165,   '1 millisecond as weeks');\n        assert.equal(moment.duration(1, 'millisecond').asDays().toFixed(10),   0.0000000116,    '1 millisecond as days');\n        assert.equal(moment.duration(1, 'millisecond').asHours().toFixed(9),   0.000000278,     '1 millisecond as hours');\n        assert.equal(moment.duration(1, 'millisecond').asMinutes().toFixed(7), 0.0000167,       '1 millisecond as minutes');\n        assert.equal(moment.duration(1, 'millisecond').asSeconds(),            0.001,           '1 millisecond as seconds');\n        assert.equal(moment.duration(1, 'millisecond').asMilliseconds(),       1,               '1 millisecond as milliseconds');\n    });\n\n    test('as getters for small units', function (assert) {\n        var dS = moment.duration(1, 'milliseconds'),\n            ds = moment.duration(3, 'seconds'),\n            dm = moment.duration(13, 'minutes');\n\n        // Tests for issue #1867.\n        // Floating point errors for small duration units were introduced in version 2.8.0.\n        assert.equal(dS.as('milliseconds'), 1, 'as(\"milliseconds\")');\n        assert.equal(dS.asMilliseconds(),   1, 'asMilliseconds()');\n        assert.equal(ds.as('seconds'),      3, 'as(\"seconds\")');\n        assert.equal(ds.asSeconds(),        3, 'asSeconds()');\n        assert.equal(dm.as('minutes'),      13, 'as(\"minutes\")');\n        assert.equal(dm.asMinutes(),        13, 'asMinutes()');\n    });\n\n    test('minutes getter for floating point hours', function (assert) {\n        // Tests for issue #2978.\n        // For certain floating point hours, .minutes() getter produced incorrect values due to the rounding errors\n        assert.equal(moment.duration(2.3, 'h').minutes(), 18, 'minutes()');\n        assert.equal(moment.duration(4.1, 'h').minutes(), 6, 'minutes()');\n    });\n\n    test('isDuration', function (assert) {\n        assert.ok(moment.isDuration(moment.duration(12345678)), 'correctly says true');\n        assert.ok(!moment.isDuration(moment()), 'moment object is not a duration');\n        assert.ok(!moment.isDuration({milliseconds: 1}), 'plain object is not a duration');\n    });\n\n    test('add', function (assert) {\n        var d = moment.duration({months: 4, weeks: 3, days: 2});\n        // for some reason, d._data._months does not get updated; use d._months instead.\n        assert.equal(d.add(1, 'month')._months, 5, 'Add months');\n        assert.equal(d.add(5, 'days')._days, 28, 'Add days');\n        assert.equal(d.add(10000)._milliseconds, 10000, 'Add milliseconds');\n        assert.equal(d.add({h: 23, m: 59})._milliseconds, 23 * 60 * 60 * 1000 + 59 * 60 * 1000 + 10000, 'Add hour:minute');\n    });\n\n    test('add and bubble', function (assert) {\n        var d;\n\n        assert.equal(moment.duration(1, 'second').add(1000, 'milliseconds').seconds(), 2, 'Adding milliseconds should bubble up to seconds');\n        assert.equal(moment.duration(1, 'minute').add(60, 'second').minutes(), 2, 'Adding seconds should bubble up to minutes');\n        assert.equal(moment.duration(1, 'hour').add(60, 'minutes').hours(), 2, 'Adding minutes should bubble up to hours');\n        assert.equal(moment.duration(1, 'day').add(24, 'hours').days(), 2, 'Adding hours should bubble up to days');\n\n        d = moment.duration(-1, 'day').add(1, 'hour');\n        assert.equal(d.hours(), -23, '-1 day + 1 hour == -23 hour (component)');\n        assert.equal(d.asHours(), -23, '-1 day + 1 hour == -23 hours');\n\n        d = moment.duration(-1, 'year').add(1, 'day');\n        assert.equal(d.days(), -30, '- 1 year + 1 day == -30 days (component)');\n        assert.equal(d.months(), -11, '- 1 year + 1 day == -11 months (component)');\n        assert.equal(d.years(), 0, '- 1 year + 1 day == 0 years (component)');\n        assert.equal(d.asDays(), -364, '- 1 year + 1 day == -364 days');\n\n        d = moment.duration(-1, 'year').add(1, 'hour');\n        assert.equal(d.hours(), -23, '- 1 year + 1 hour == -23 hours (component)');\n        assert.equal(d.days(), -30, '- 1 year + 1 hour == -30 days (component)');\n        assert.equal(d.months(), -11, '- 1 year + 1 hour == -11 months (component)');\n        assert.equal(d.years(), 0, '- 1 year + 1 hour == 0 years (component)');\n    });\n\n    test('subtract and bubble', function (assert) {\n        var d;\n\n        assert.equal(moment.duration(2, 'second').subtract(1000, 'milliseconds').seconds(), 1, 'Subtracting milliseconds should bubble up to seconds');\n        assert.equal(moment.duration(2, 'minute').subtract(60, 'second').minutes(), 1, 'Subtracting seconds should bubble up to minutes');\n        assert.equal(moment.duration(2, 'hour').subtract(60, 'minutes').hours(), 1, 'Subtracting minutes should bubble up to hours');\n        assert.equal(moment.duration(2, 'day').subtract(24, 'hours').days(), 1, 'Subtracting hours should bubble up to days');\n\n        d = moment.duration(1, 'day').subtract(1, 'hour');\n        assert.equal(d.hours(), 23, '1 day - 1 hour == 23 hour (component)');\n        assert.equal(d.asHours(), 23, '1 day - 1 hour == 23 hours');\n\n        d = moment.duration(1, 'year').subtract(1, 'day');\n        assert.equal(d.days(), 30, '1 year - 1 day == 30 days (component)');\n        assert.equal(d.months(), 11, '1 year - 1 day == 11 months (component)');\n        assert.equal(d.years(), 0, '1 year - 1 day == 0 years (component)');\n        assert.equal(d.asDays(), 364, '1 year - 1 day == 364 days');\n\n        d = moment.duration(1, 'year').subtract(1, 'hour');\n        assert.equal(d.hours(), 23, '1 year - 1 hour == 23 hours (component)');\n        assert.equal(d.days(), 30, '1 year - 1 hour == 30 days (component)');\n        assert.equal(d.months(), 11, '1 year - 1 hour == 11 months (component)');\n        assert.equal(d.years(), 0, '1 year - 1 hour == 0 years (component)');\n    });\n\n    test('subtract', function (assert) {\n        var d = moment.duration({months: 2, weeks: 2, days: 0, hours: 5});\n        // for some reason, d._data._months does not get updated; use d._months instead.\n        assert.equal(d.subtract(1, 'months')._months, 1, 'Subtract months');\n        assert.equal(d.subtract(14, 'days')._days, 0, 'Subtract days');\n        assert.equal(d.subtract(10000)._milliseconds, 5 * 60 * 60 * 1000 - 10000, 'Subtract milliseconds');\n        assert.equal(d.subtract({h: 1, m: 59})._milliseconds, 3 * 60 * 60 * 1000 + 1 * 60 * 1000 - 10000, 'Subtract hour:minute');\n    });\n\n    test('JSON.stringify duration', function (assert) {\n        var d = moment.duration(1024, 'h');\n\n        assert.equal(JSON.stringify(d), '\"' + d.toISOString() + '\"', 'JSON.stringify on duration should return ISO string');\n    });\n\n    test('duration plugins', function (assert) {\n        var durationObject = moment.duration();\n        moment.duration.fn.foo = function (arg) {\n            assert.equal(this, durationObject);\n            assert.equal(arg, 5);\n        };\n        durationObject.foo(5);\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('duration from moments');\n\n    test('pure year diff', function (assert) {\n        var m1 = moment('2012-01-01T00:00:00.000Z'),\n            m2 = moment('2013-01-01T00:00:00.000Z');\n\n        assert.equal(moment.duration({from: m1, to: m2}).as('years'), 1, 'year moment difference');\n        assert.equal(moment.duration({from: m2, to: m1}).as('years'), -1, 'negative year moment difference');\n    });\n\n    test('month and day diff', function (assert) {\n        var m1 = moment('2012-01-15T00:00:00.000Z'),\n            m2 = moment('2012-02-17T00:00:00.000Z'),\n            d = moment.duration({from: m1, to: m2});\n\n        assert.equal(d.get('days'), 2);\n        assert.equal(d.get('months'), 1);\n    });\n\n    test('day diff, separate months', function (assert) {\n        var m1 = moment('2012-01-15T00:00:00.000Z'),\n            m2 = moment('2012-02-13T00:00:00.000Z'),\n            d = moment.duration({from: m1, to: m2});\n\n        assert.equal(d.as('days'), 29);\n    });\n\n    test('hour diff', function (assert) {\n        var m1 = moment('2012-01-15T17:00:00.000Z'),\n            m2 = moment('2012-01-16T03:00:00.000Z'),\n            d = moment.duration({from: m1, to: m2});\n\n        assert.equal(d.as('hours'), 10);\n    });\n\n    test('minute diff', function (assert) {\n        var m1 = moment('2012-01-15T17:45:00.000Z'),\n            m2 = moment('2012-01-16T03:15:00.000Z'),\n            d = moment.duration({from: m1, to: m2});\n\n        assert.equal(d.as('hours'), 9.5);\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('format');\n\n    test('format YY', function (assert) {\n        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 125));\n        assert.equal(b.format('YY'), '09', 'YY ---> 09');\n    });\n\n    test('format escape brackets', function (assert) {\n        moment.locale('en');\n\n        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 125));\n        assert.equal(b.format('[day]'), 'day', 'Single bracket');\n        assert.equal(b.format('[day] YY [YY]'), 'day 09 YY', 'Double bracket');\n        assert.equal(b.format('[YY'), '[09', 'Un-ended bracket');\n        assert.equal(b.format('[[YY]]'), '[YY]', 'Double nested brackets');\n        assert.equal(b.format('[[]'), '[', 'Escape open bracket');\n        assert.equal(b.format('[Last]'), 'Last', 'localized tokens');\n        assert.equal(b.format('[L] L'), 'L 02/14/2009', 'localized tokens with escaped localized tokens');\n        assert.equal(b.format('[L LL LLL LLLL aLa]'), 'L LL LLL LLLL aLa', 'localized tokens with escaped localized tokens');\n        assert.equal(b.format('[LLL] LLL'), 'LLL February 14, 2009 3:25 PM', 'localized tokens with escaped localized tokens (recursion)');\n        assert.equal(b.format('YYYY[\\n]DD[\\n]'), '2009\\n14\\n', 'Newlines');\n    });\n\n    test('handle negative years', function (assert) {\n        moment.locale('en');\n        assert.equal(moment.utc().year(-1).format('YY'), '-01', 'YY with negative year');\n        assert.equal(moment.utc().year(-1).format('YYYY'), '-0001', 'YYYY with negative year');\n        assert.equal(moment.utc().year(-12).format('YY'), '-12', 'YY with negative year');\n        assert.equal(moment.utc().year(-12).format('YYYY'), '-0012', 'YYYY with negative year');\n        assert.equal(moment.utc().year(-123).format('YY'), '-23', 'YY with negative year');\n        assert.equal(moment.utc().year(-123).format('YYYY'), '-0123', 'YYYY with negative year');\n        assert.equal(moment.utc().year(-1234).format('YY'), '-34', 'YY with negative year');\n        assert.equal(moment.utc().year(-1234).format('YYYY'), '-1234', 'YYYY with negative year');\n        assert.equal(moment.utc().year(-12345).format('YY'), '-45', 'YY with negative year');\n        assert.equal(moment.utc().year(-12345).format('YYYY'), '-12345', 'YYYY with negative year');\n    });\n\n    test('format milliseconds', function (assert) {\n        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 123));\n        assert.equal(b.format('S'), '1', 'Deciseconds');\n        assert.equal(b.format('SS'), '12', 'Centiseconds');\n        assert.equal(b.format('SSS'), '123', 'Milliseconds');\n        b.milliseconds(789);\n        assert.equal(b.format('S'), '7', 'Deciseconds');\n        assert.equal(b.format('SS'), '78', 'Centiseconds');\n        assert.equal(b.format('SSS'), '789', 'Milliseconds');\n    });\n\n    test('format timezone', function (assert) {\n        var b = moment(new Date(2010, 1, 14, 15, 25, 50, 125));\n        assert.ok(b.format('Z').match(/^[\\+\\-]\\d\\d:\\d\\d$/), b.format('Z') + ' should be something like \\'+07:30\\'');\n        assert.ok(b.format('ZZ').match(/^[\\+\\-]\\d{4}$/), b.format('ZZ') + ' should be something like \\'+0700\\'');\n    });\n\n    test('format multiple with utc offset', function (assert) {\n        var b = moment('2012-10-08 -1200', ['YYYY-MM-DD HH:mm ZZ', 'YYYY-MM-DD ZZ', 'YYYY-MM-DD']);\n        assert.equal(b.format('YYYY-MM'), '2012-10', 'Parsing multiple formats should not crash with different sized formats');\n    });\n\n    test('isDST', function (assert) {\n        var janOffset = new Date(2011, 0, 1).getTimezoneOffset(),\n            julOffset = new Date(2011, 6, 1).getTimezoneOffset(),\n            janIsDst = janOffset < julOffset,\n            julIsDst = julOffset < janOffset,\n            jan1 = moment([2011]),\n            jul1 = moment([2011, 6]);\n\n        if (janIsDst && julIsDst) {\n            assert.ok(0, 'January and July cannot both be in DST');\n            assert.ok(0, 'January and July cannot both be in DST');\n        } else if (janIsDst) {\n            assert.ok(jan1.isDST(), 'January 1 is DST');\n            assert.ok(!jul1.isDST(), 'July 1 is not DST');\n        } else if (julIsDst) {\n            assert.ok(!jan1.isDST(), 'January 1 is not DST');\n            assert.ok(jul1.isDST(), 'July 1 is DST');\n        } else {\n            assert.ok(!jan1.isDST(), 'January 1 is not DST');\n            assert.ok(!jul1.isDST(), 'July 1 is not DST');\n        }\n    });\n\n    test('unix timestamp', function (assert) {\n        var m = moment('1234567890.123', 'X');\n        assert.equal(m.format('X'), '1234567890', 'unix timestamp without milliseconds');\n        assert.equal(m.format('X.S'), '1234567890.1', 'unix timestamp with deciseconds');\n        assert.equal(m.format('X.SS'), '1234567890.12', 'unix timestamp with centiseconds');\n        assert.equal(m.format('X.SSS'), '1234567890.123', 'unix timestamp with milliseconds');\n\n        m = moment(1234567890.123, 'X');\n        assert.equal(m.format('X'), '1234567890', 'unix timestamp as integer');\n    });\n\n    test('unix offset milliseconds', function (assert) {\n        var m = moment('1234567890123', 'x');\n        assert.equal(m.format('x'), '1234567890123', 'unix offset in milliseconds');\n\n        m = moment(1234567890123, 'x');\n        assert.equal(m.format('x'), '1234567890123', 'unix offset in milliseconds as integer');\n    });\n\n    test('utcOffset sanity checks', function (assert) {\n        assert.equal(moment().utcOffset() % 15, 0,\n                'utc offset should be a multiple of 15 (was ' + moment().utcOffset() + ')');\n\n        assert.equal(moment().utcOffset(), -(new Date()).getTimezoneOffset(),\n            'utcOffset should return the opposite of getTimezoneOffset');\n    });\n\n    test('default format', function (assert) {\n        var isoRegex = /\\d{4}.\\d\\d.\\d\\dT\\d\\d.\\d\\d.\\d\\d[\\+\\-]\\d\\d:\\d\\d/;\n        assert.ok(isoRegex.exec(moment().format()), 'default format (' + moment().format() + ') should match ISO');\n    });\n\n    test('default UTC format', function (assert) {\n        var isoRegex = /\\d{4}.\\d\\d.\\d\\dT\\d\\d.\\d\\d.\\d\\dZ/;\n        assert.ok(isoRegex.exec(moment.utc().format()), 'default UTC format (' + moment.utc().format() + ') should match ISO');\n    });\n\n    test('toJSON', function (assert) {\n        var supportsJson = typeof JSON !== 'undefined' && JSON.stringify && JSON.stringify.call,\n            date = moment('2012-10-09T21:30:40.678+0100');\n\n        assert.equal(date.toJSON(), '2012-10-09T20:30:40.678Z', 'should output ISO8601 on moment.fn.toJSON');\n\n        if (supportsJson) {\n            assert.equal(JSON.stringify({\n                date : date\n            }), '{\"date\":\"2012-10-09T20:30:40.678Z\"}', 'should output ISO8601 on JSON.stringify');\n        }\n    });\n\n    test('toISOString', function (assert) {\n        var date = moment.utc('2012-10-09T20:30:40.678');\n\n        assert.equal(date.toISOString(), '2012-10-09T20:30:40.678Z', 'should output ISO8601 on moment.fn.toISOString');\n\n        // big years\n        date = moment.utc('+020123-10-09T20:30:40.678');\n        assert.equal(date.toISOString(), '+020123-10-09T20:30:40.678Z', 'ISO8601 format on big positive year');\n        // negative years\n        date = moment.utc('-000001-10-09T20:30:40.678');\n        assert.equal(date.toISOString(), '-000001-10-09T20:30:40.678Z', 'ISO8601 format on negative year');\n        // big negative years\n        date = moment.utc('-020123-10-09T20:30:40.678');\n        assert.equal(date.toISOString(), '-020123-10-09T20:30:40.678Z', 'ISO8601 format on big negative year');\n    });\n\n    test('long years', function (assert) {\n        assert.equal(moment.utc().year(2).format('YYYYYY'), '+000002', 'small year with YYYYYY');\n        assert.equal(moment.utc().year(2012).format('YYYYYY'), '+002012', 'regular year with YYYYYY');\n        assert.equal(moment.utc().year(20123).format('YYYYYY'), '+020123', 'big year with YYYYYY');\n\n        assert.equal(moment.utc().year(-1).format('YYYYYY'), '-000001', 'small negative year with YYYYYY');\n        assert.equal(moment.utc().year(-2012).format('YYYYYY'), '-002012', 'negative year with YYYYYY');\n        assert.equal(moment.utc().year(-20123).format('YYYYYY'), '-020123', 'big negative year with YYYYYY');\n    });\n\n    test('iso week formats', function (assert) {\n        // http://en.wikipedia.org/wiki/ISO_week_date\n        var cases = {\n            '2005-01-02': '2004-53',\n            '2005-12-31': '2005-52',\n            '2007-01-01': '2007-01',\n            '2007-12-30': '2007-52',\n            '2007-12-31': '2008-01',\n            '2008-01-01': '2008-01',\n            '2008-12-28': '2008-52',\n            '2008-12-29': '2009-01',\n            '2008-12-30': '2009-01',\n            '2008-12-31': '2009-01',\n            '2009-01-01': '2009-01',\n            '2009-12-31': '2009-53',\n            '2010-01-01': '2009-53',\n            '2010-01-02': '2009-53',\n            '2010-01-03': '2009-53',\n            '404-12-31': '0404-53',\n            '405-12-31': '0405-52'\n        }, i, isoWeek, formatted2, formatted1;\n\n        for (i in cases) {\n            isoWeek = cases[i].split('-').pop();\n            formatted2 = moment(i, 'YYYY-MM-DD').format('WW');\n            assert.equal(isoWeek, formatted2, i + ': WW should be ' + isoWeek + ', but ' + formatted2);\n            isoWeek = isoWeek.replace(/^0+/, '');\n            formatted1 = moment(i, 'YYYY-MM-DD').format('W');\n            assert.equal(isoWeek, formatted1, i + ': W should be ' + isoWeek + ', but ' + formatted1);\n        }\n    });\n\n    test('iso week year formats', function (assert) {\n        // http://en.wikipedia.org/wiki/ISO_week_date\n        var cases = {\n            '2005-01-02': '2004-53',\n            '2005-12-31': '2005-52',\n            '2007-01-01': '2007-01',\n            '2007-12-30': '2007-52',\n            '2007-12-31': '2008-01',\n            '2008-01-01': '2008-01',\n            '2008-12-28': '2008-52',\n            '2008-12-29': '2009-01',\n            '2008-12-30': '2009-01',\n            '2008-12-31': '2009-01',\n            '2009-01-01': '2009-01',\n            '2009-12-31': '2009-53',\n            '2010-01-01': '2009-53',\n            '2010-01-02': '2009-53',\n            '2010-01-03': '2009-53',\n            '404-12-31': '0404-53',\n            '405-12-31': '0405-52'\n        }, i, isoWeekYear, formatted5, formatted4, formatted2;\n\n        for (i in cases) {\n            isoWeekYear = cases[i].split('-')[0];\n            formatted5 = moment(i, 'YYYY-MM-DD').format('GGGGG');\n            assert.equal('0' + isoWeekYear, formatted5, i + ': GGGGG should be ' + isoWeekYear + ', but ' + formatted5);\n            formatted4 = moment(i, 'YYYY-MM-DD').format('GGGG');\n            assert.equal(isoWeekYear, formatted4, i + ': GGGG should be ' + isoWeekYear + ', but ' + formatted4);\n            formatted2 = moment(i, 'YYYY-MM-DD').format('GG');\n            assert.equal(isoWeekYear.slice(2, 4), formatted2, i + ': GG should be ' + isoWeekYear + ', but ' + formatted2);\n        }\n    });\n\n    test('week year formats', function (assert) {\n        // http://en.wikipedia.org/wiki/ISO_week_date\n        var cases = {\n            '2005-01-02': '2004-53',\n            '2005-12-31': '2005-52',\n            '2007-01-01': '2007-01',\n            '2007-12-30': '2007-52',\n            '2007-12-31': '2008-01',\n            '2008-01-01': '2008-01',\n            '2008-12-28': '2008-52',\n            '2008-12-29': '2009-01',\n            '2008-12-30': '2009-01',\n            '2008-12-31': '2009-01',\n            '2009-01-01': '2009-01',\n            '2009-12-31': '2009-53',\n            '2010-01-01': '2009-53',\n            '2010-01-02': '2009-53',\n            '2010-01-03': '2009-53',\n            '404-12-31': '0404-53',\n            '405-12-31': '0405-52'\n        }, i, isoWeekYear, formatted5, formatted4, formatted2;\n\n        moment.defineLocale('dow:1,doy:4', {week: {dow: 1, doy: 4}});\n\n        for (i in cases) {\n            isoWeekYear = cases[i].split('-')[0];\n            formatted5 = moment(i, 'YYYY-MM-DD').format('ggggg');\n            assert.equal('0' + isoWeekYear, formatted5, i + ': ggggg should be ' + isoWeekYear + ', but ' + formatted5);\n            formatted4 = moment(i, 'YYYY-MM-DD').format('gggg');\n            assert.equal(isoWeekYear, formatted4, i + ': gggg should be ' + isoWeekYear + ', but ' + formatted4);\n            formatted2 = moment(i, 'YYYY-MM-DD').format('gg');\n            assert.equal(isoWeekYear.slice(2, 4), formatted2, i + ': gg should be ' + isoWeekYear + ', but ' + formatted2);\n        }\n        moment.defineLocale('dow:1,doy:4', null);\n    });\n\n    test('iso weekday formats', function (assert) {\n        assert.equal(moment([1985, 1,  4]).format('E'), '1', 'Feb  4 1985 is Monday    -- 1st day');\n        assert.equal(moment([2029, 8, 18]).format('E'), '2', 'Sep 18 2029 is Tuesday   -- 2nd day');\n        assert.equal(moment([2013, 3, 24]).format('E'), '3', 'Apr 24 2013 is Wednesday -- 3rd day');\n        assert.equal(moment([2015, 2,  5]).format('E'), '4', 'Mar  5 2015 is Thursday  -- 4th day');\n        assert.equal(moment([1970, 0,  2]).format('E'), '5', 'Jan  2 1970 is Friday    -- 5th day');\n        assert.equal(moment([2001, 4, 12]).format('E'), '6', 'May 12 2001 is Saturday  -- 6th day');\n        assert.equal(moment([2000, 0,  2]).format('E'), '7', 'Jan  2 2000 is Sunday    -- 7th day');\n    });\n\n    test('weekday formats', function (assert) {\n        moment.defineLocale('dow: 3,doy: 5', {week: {dow: 3, doy: 5}});\n        assert.equal(moment([1985, 1,  6]).format('e'), '0', 'Feb  6 1985 is Wednesday -- 0th day');\n        assert.equal(moment([2029, 8, 20]).format('e'), '1', 'Sep 20 2029 is Thursday  -- 1st day');\n        assert.equal(moment([2013, 3, 26]).format('e'), '2', 'Apr 26 2013 is Friday    -- 2nd day');\n        assert.equal(moment([2015, 2,  7]).format('e'), '3', 'Mar  7 2015 is Saturday  -- 3nd day');\n        assert.equal(moment([1970, 0,  4]).format('e'), '4', 'Jan  4 1970 is Sunday    -- 4th day');\n        assert.equal(moment([2001, 4, 14]).format('e'), '5', 'May 14 2001 is Monday    -- 5th day');\n        assert.equal(moment([2000, 0,  4]).format('e'), '6', 'Jan  4 2000 is Tuesday   -- 6th day');\n        moment.defineLocale('dow: 3,doy: 5', null);\n    });\n\n    test('toString is just human readable format', function (assert) {\n        var b = moment(new Date(2009, 1, 5, 15, 25, 50, 125));\n        assert.equal(b.toString(), b.format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ'));\n    });\n\n    test('toJSON skips postformat', function (assert) {\n        moment.defineLocale('postformat', {\n            postformat: function (s) {\n                s.replace(/./g, 'X');\n            }\n        });\n        assert.equal(moment.utc([2000, 0, 1]).toJSON(), '2000-01-01T00:00:00.000Z', 'toJSON doesn\\'t postformat');\n        moment.defineLocale('postformat', null);\n    });\n\n    test('calendar day timezone', function (assert) {\n        moment.locale('en');\n        var zones = [60, -60, 90, -90, 360, -360, 720, -720],\n            b = moment().utc().startOf('day').subtract({m : 1}),\n            c = moment().local().startOf('day').subtract({m : 1}),\n            d = moment().local().startOf('day').subtract({d : 2}),\n            i, z, a;\n\n        for (i = 0; i < zones.length; ++i) {\n            z = zones[i];\n            a = moment().utcOffset(z).startOf('day').subtract({m: 1});\n            assert.equal(moment(a).utcOffset(z).calendar(), 'Yesterday at 11:59 PM',\n                         'Yesterday at 11:59 PM, not Today, or the wrong time, tz = ' + z);\n        }\n\n        assert.equal(moment(b).utc().calendar(), 'Yesterday at 11:59 PM', 'Yesterday at 11:59 PM, not Today, or the wrong time');\n        assert.equal(moment(c).local().calendar(), 'Yesterday at 11:59 PM', 'Yesterday at 11:59 PM, not Today, or the wrong time');\n        assert.equal(moment(c).local().calendar(d), 'Tomorrow at 11:59 PM', 'Tomorrow at 11:59 PM, not Yesterday, or the wrong time');\n    });\n\n    test('calendar with custom formats', function (assert) {\n        assert.equal(moment().calendar(null, {sameDay: '[Today]'}), 'Today', 'Today');\n        assert.equal(moment().add(1, 'days').calendar(null, {nextDay: '[Tomorrow]'}), 'Tomorrow', 'Tomorrow');\n        assert.equal(moment([1985, 1, 4]).calendar(null, {sameElse: 'YYYY-MM-DD'}), '1985-02-04', 'Else');\n    });\n\n    test('invalid', function (assert) {\n        assert.equal(moment.invalid().format(), 'Invalid date');\n        assert.equal(moment.invalid().format('YYYY-MM-DD'), 'Invalid date');\n    });\n\n    test('quarter formats', function (assert) {\n        assert.equal(moment([1985, 1,  4]).format('Q'), '1', 'Feb  4 1985 is Q1');\n        assert.equal(moment([2029, 8, 18]).format('Q'), '3', 'Sep 18 2029 is Q3');\n        assert.equal(moment([2013, 3, 24]).format('Q'), '2', 'Apr 24 2013 is Q2');\n        assert.equal(moment([2015, 2,  5]).format('Q'), '1', 'Mar  5 2015 is Q1');\n        assert.equal(moment([1970, 0,  2]).format('Q'), '1', 'Jan  2 1970 is Q1');\n        assert.equal(moment([2001, 11, 12]).format('Q'), '4', 'Dec 12 2001 is Q4');\n        assert.equal(moment([2000, 0,  2]).format('[Q]Q-YYYY'), 'Q1-2000', 'Jan  2 2000 is Q1');\n    });\n\n    test('quarter ordinal formats', function (assert) {\n        assert.equal(moment([1985, 1, 4]).format('Qo'), '1st', 'Feb 4 1985 is 1st quarter');\n        assert.equal(moment([2029, 8, 18]).format('Qo'), '3rd', 'Sep 18 2029 is 3rd quarter');\n        assert.equal(moment([2013, 3, 24]).format('Qo'), '2nd', 'Apr 24 2013 is 2nd quarter');\n        assert.equal(moment([2015, 2,  5]).format('Qo'), '1st', 'Mar  5 2015 is 1st quarter');\n        assert.equal(moment([1970, 0,  2]).format('Qo'), '1st', 'Jan  2 1970 is 1st quarter');\n        assert.equal(moment([2001, 11, 12]).format('Qo'), '4th', 'Dec 12 2001 is 4th quarter');\n        assert.equal(moment([2000, 0,  2]).format('Qo [quarter] YYYY'), '1st quarter 2000', 'Jan  2 2000 is 1st quarter');\n    });\n\n    // test('full expanded format is returned from abbreviated formats', function (assert) {\n    //     function objectKeys(obj) {\n    //         if (Object.keys) {\n    //             return Object.keys(obj);\n    //         } else {\n    //             // IE8\n    //             var res = [], i;\n    //             for (i in obj) {\n    //                 if (obj.hasOwnProperty(i)) {\n    //                     res.push(i);\n    //                 }\n    //             }\n    //             return res;\n    //         }\n    //     }\n\n    //     var locales =\n    //         'ar-sa ar-tn ar az be bg bn bo br bs ca cs cv cy da de-at de dv el ' +\n    //         'en-au en-ca en-gb en-ie en-nz eo es et eu fa fi fo fr-ca fr-ch fr fy ' +\n    //         'gd gl he hi hr hu hy-am id is it ja jv ka kk km ko lb lo lt lv me mk ml ' +\n    //         'mr ms-my ms my nb ne nl nn pl pt-br pt ro ru se si sk sl sq sr-cyrl ' +\n    //         'sr sv sw ta te th tl-ph tlh tr tzl tzm-latn tzm uk uz vi zh-cn zh-tw';\n\n    //     each(locales.split(' '), function (locale) {\n    //         var data, tokens;\n    //         data = moment().locale(locale).localeData()._longDateFormat;\n    //         tokens = objectKeys(data);\n    //         each(tokens, function (token) {\n    //             // Check each format string to make sure it does not contain any\n    //             // tokens that need to be expanded.\n    //             each(tokens, function (i) {\n    //                 // strip escaped sequences\n    //                 var format = data[i].replace(/(\\[[^\\]]*\\])/g, '');\n    //                 assert.equal(false, !!~format.indexOf(token), 'locale ' + locale + ' contains ' + token + ' in ' + i);\n    //             });\n    //         });\n    //     });\n    // });\n\n    test('milliseconds', function (assert) {\n        var m = moment('123', 'SSS');\n\n        assert.equal(m.format('S'), '1');\n        assert.equal(m.format('SS'), '12');\n        assert.equal(m.format('SSS'), '123');\n        assert.equal(m.format('SSSS'), '1230');\n        assert.equal(m.format('SSSSS'), '12300');\n        assert.equal(m.format('SSSSSS'), '123000');\n        assert.equal(m.format('SSSSSSS'), '1230000');\n        assert.equal(m.format('SSSSSSSS'), '12300000');\n        assert.equal(m.format('SSSSSSSSS'), '123000000');\n    });\n\n    test('hmm and hmmss', function (assert) {\n        assert.equal(moment('12:34:56', 'HH:mm:ss').format('hmm'), '1234');\n        assert.equal(moment('01:34:56', 'HH:mm:ss').format('hmm'), '134');\n        assert.equal(moment('13:34:56', 'HH:mm:ss').format('hmm'), '134');\n\n        assert.equal(moment('12:34:56', 'HH:mm:ss').format('hmmss'), '123456');\n        assert.equal(moment('01:34:56', 'HH:mm:ss').format('hmmss'), '13456');\n        assert.equal(moment('13:34:56', 'HH:mm:ss').format('hmmss'), '13456');\n    });\n\n    test('Hmm and Hmmss', function (assert) {\n        assert.equal(moment('12:34:56', 'HH:mm:ss').format('Hmm'), '1234');\n        assert.equal(moment('01:34:56', 'HH:mm:ss').format('Hmm'), '134');\n        assert.equal(moment('13:34:56', 'HH:mm:ss').format('Hmm'), '1334');\n\n        assert.equal(moment('12:34:56', 'HH:mm:ss').format('Hmmss'), '123456');\n        assert.equal(moment('01:34:56', 'HH:mm:ss').format('Hmmss'), '13456');\n        assert.equal(moment('08:34:56', 'HH:mm:ss').format('Hmmss'), '83456');\n        assert.equal(moment('18:34:56', 'HH:mm:ss').format('Hmmss'), '183456');\n    });\n\n    test('k and kk', function (assert) {\n        assert.equal(moment('01:23:45', 'HH:mm:ss').format('k'), '1');\n        assert.equal(moment('12:34:56', 'HH:mm:ss').format('k'), '12');\n        assert.equal(moment('01:23:45', 'HH:mm:ss').format('kk'), '01');\n        assert.equal(moment('12:34:56', 'HH:mm:ss').format('kk'), '12');\n        assert.equal(moment('00:34:56', 'HH:mm:ss').format('kk'), '24');\n        assert.equal(moment('00:00:00', 'HH:mm:ss').format('kk'), '24');\n    });\n\n    test('Y token', function (assert) {\n        assert.equal(moment('2010-01-01', 'YYYY-MM-DD', true).format('Y'), '2010', 'format 2010 with Y');\n        assert.equal(moment('-123-01-01', 'Y-MM-DD', true).format('Y'), '-123', 'format -123 with Y');\n        assert.equal(moment('12345-01-01', 'Y-MM-DD', true).format('Y'), '+12345', 'format 12345 with Y');\n        assert.equal(moment('0-01-01', 'Y-MM-DD', true).format('Y'), '0', 'format 0 with Y');\n        assert.equal(moment('1-01-01', 'Y-MM-DD', true).format('Y'), '1', 'format 1 with Y');\n        assert.equal(moment('9999-01-01', 'Y-MM-DD', true).format('Y'), '9999', 'format 9999 with Y');\n        assert.equal(moment('10000-01-01', 'Y-MM-DD', true).format('Y'), '+10000', 'format 10000 with Y');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('from_to');\n\n    test('from', function (assert) {\n        var start = moment();\n        moment.locale('en');\n        assert.equal(start.from(start.clone().add(5, 'seconds')),  'a few seconds ago', '5 seconds = a few seconds ago');\n        assert.equal(start.from(start.clone().add(1, 'minute')),  'a minute ago', '1 minute = a minute ago');\n        assert.equal(start.from(start.clone().add(5, 'minutes')),  '5 minutes ago', '5 minutes = 5 minutes ago');\n\n        assert.equal(start.from(start.clone().subtract(5, 'seconds')),  'in a few seconds', '5 seconds = in a few seconds');\n        assert.equal(start.from(start.clone().subtract(1, 'minute')),  'in a minute', '1 minute = in a minute');\n        assert.equal(start.from(start.clone().subtract(5, 'minutes')),  'in 5 minutes', '5 minutes = in 5 minutes');\n    });\n\n    test('from with absolute duration', function (assert) {\n        var start = moment();\n        moment.locale('en');\n        assert.equal(start.from(start.clone().add(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');\n        assert.equal(start.from(start.clone().add(1, 'minute'), true),  'a minute', '1 minute = a minute');\n        assert.equal(start.from(start.clone().add(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');\n\n        assert.equal(start.from(start.clone().subtract(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');\n        assert.equal(start.from(start.clone().subtract(1, 'minute'), true),  'a minute', '1 minute = a minute');\n        assert.equal(start.from(start.clone().subtract(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');\n    });\n\n    test('to', function (assert) {\n        var start = moment();\n        moment.locale('en');\n        assert.equal(start.to(start.clone().subtract(5, 'seconds')),  'a few seconds ago', '5 seconds = a few seconds ago');\n        assert.equal(start.to(start.clone().subtract(1, 'minute')),  'a minute ago', '1 minute = a minute ago');\n        assert.equal(start.to(start.clone().subtract(5, 'minutes')),  '5 minutes ago', '5 minutes = 5 minutes ago');\n\n        assert.equal(start.to(start.clone().add(5, 'seconds')),  'in a few seconds', '5 seconds = in a few seconds');\n        assert.equal(start.to(start.clone().add(1, 'minute')),  'in a minute', '1 minute = in a minute');\n        assert.equal(start.to(start.clone().add(5, 'minutes')),  'in 5 minutes', '5 minutes = in 5 minutes');\n    });\n\n    test('to with absolute duration', function (assert) {\n        var start = moment();\n        moment.locale('en');\n        assert.equal(start.to(start.clone().add(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');\n        assert.equal(start.to(start.clone().add(1, 'minute'), true),  'a minute', '1 minute = a minute');\n        assert.equal(start.to(start.clone().add(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');\n\n        assert.equal(start.to(start.clone().subtract(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');\n        assert.equal(start.to(start.clone().subtract(1, 'minute'), true),  'a minute', '1 minute = a minute');\n        assert.equal(start.to(start.clone().subtract(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('getters and setters');\n\n    test('getters', function (assert) {\n        var a = moment([2011, 9, 12, 6, 7, 8, 9]);\n        assert.equal(a.year(), 2011, 'year');\n        assert.equal(a.month(), 9, 'month');\n        assert.equal(a.date(), 12, 'date');\n        assert.equal(a.day(), 3, 'day');\n        assert.equal(a.hours(), 6, 'hour');\n        assert.equal(a.minutes(), 7, 'minute');\n        assert.equal(a.seconds(), 8, 'second');\n        assert.equal(a.milliseconds(), 9, 'milliseconds');\n    });\n\n    test('getters programmatic', function (assert) {\n        var a = moment([2011, 9, 12, 6, 7, 8, 9]);\n        assert.equal(a.get('year'), 2011, 'year');\n        assert.equal(a.get('month'), 9, 'month');\n        assert.equal(a.get('date'), 12, 'date');\n        assert.equal(a.get('day'), 3, 'day');\n        assert.equal(a.get('hour'), 6, 'hour');\n        assert.equal(a.get('minute'), 7, 'minute');\n        assert.equal(a.get('second'), 8, 'second');\n        assert.equal(a.get('milliseconds'), 9, 'milliseconds');\n\n        //actual getters tested elsewhere\n        assert.equal(a.get('weekday'), a.weekday(), 'weekday');\n        assert.equal(a.get('isoWeekday'), a.isoWeekday(), 'isoWeekday');\n        assert.equal(a.get('week'), a.week(), 'week');\n        assert.equal(a.get('isoWeek'), a.isoWeek(), 'isoWeek');\n        assert.equal(a.get('dayOfYear'), a.dayOfYear(), 'dayOfYear');\n    });\n\n    test('setters plural', function (assert) {\n        var a = moment();\n        test.expectedDeprecations('years accessor', 'months accessor', 'dates accessor');\n\n        a.years(2011);\n        a.months(9);\n        a.dates(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(9);\n        assert.equal(a.years(), 2011, 'years');\n        assert.equal(a.months(), 9, 'months');\n        assert.equal(a.dates(), 12, 'dates');\n        assert.equal(a.days(), 3, 'days');\n        assert.equal(a.hours(), 6, 'hours');\n        assert.equal(a.minutes(), 7, 'minutes');\n        assert.equal(a.seconds(), 8, 'seconds');\n        assert.equal(a.milliseconds(), 9, 'milliseconds');\n    });\n\n    test('setters singular', function (assert) {\n        var a = moment();\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hour(6);\n        a.minute(7);\n        a.second(8);\n        a.millisecond(9);\n        assert.equal(a.year(), 2011, 'year');\n        assert.equal(a.month(), 9, 'month');\n        assert.equal(a.date(), 12, 'date');\n        assert.equal(a.day(), 3, 'day');\n        assert.equal(a.hour(), 6, 'hour');\n        assert.equal(a.minute(), 7, 'minute');\n        assert.equal(a.second(), 8, 'second');\n        assert.equal(a.millisecond(), 9, 'milliseconds');\n    });\n\n    test('setters', function (assert) {\n        var a = moment();\n        a.year(2011);\n        a.month(9);\n        a.date(12);\n        a.hours(6);\n        a.minutes(7);\n        a.seconds(8);\n        a.milliseconds(9);\n        assert.equal(a.year(), 2011, 'year');\n        assert.equal(a.month(), 9, 'month');\n        assert.equal(a.date(), 12, 'date');\n        assert.equal(a.day(), 3, 'day');\n        assert.equal(a.hours(), 6, 'hour');\n        assert.equal(a.minutes(), 7, 'minute');\n        assert.equal(a.seconds(), 8, 'second');\n        assert.equal(a.milliseconds(), 9, 'milliseconds');\n\n        // Test month() behavior. See https://github.com/timrwood/moment/pull/822\n        a = moment('20130531', 'YYYYMMDD');\n        a.month(3);\n        assert.equal(a.month(), 3, 'month edge case');\n    });\n\n    test('setter programmatic', function (assert) {\n        var a = moment();\n        a.set('year', 2011);\n        a.set('month', 9);\n        a.set('date', 12);\n        a.set('hours', 6);\n        a.set('minutes', 7);\n        a.set('seconds', 8);\n        a.set('milliseconds', 9);\n        assert.equal(a.year(), 2011, 'year');\n        assert.equal(a.month(), 9, 'month');\n        assert.equal(a.date(), 12, 'date');\n        assert.equal(a.day(), 3, 'day');\n        assert.equal(a.hours(), 6, 'hour');\n        assert.equal(a.minutes(), 7, 'minute');\n        assert.equal(a.seconds(), 8, 'second');\n        assert.equal(a.milliseconds(), 9, 'milliseconds');\n\n        // Test month() behavior. See https://github.com/timrwood/moment/pull/822\n        a = moment('20130531', 'YYYYMMDD');\n        a.month(3);\n        assert.equal(a.month(), 3, 'month edge case');\n    });\n\n    test('setters programatic with weeks', function (assert) {\n        var a = moment();\n        a.set('weekYear', 2001);\n        a.set('week', 49);\n        a.set('day', 4);\n\n        assert.equal(a.weekYear(), 2001, 'weekYear');\n        assert.equal(a.week(), 49, 'week');\n        assert.equal(a.day(), 4, 'day');\n\n        a.set('weekday', 1);\n        assert.equal(a.weekday(), 1, 'weekday');\n    });\n\n    test('setters programatic with weeks ISO', function (assert) {\n        var a = moment();\n        a.set('isoWeekYear', 2001);\n        a.set('isoWeek', 49);\n        a.set('isoWeekday', 4);\n\n        assert.equal(a.isoWeekYear(), 2001, 'isoWeekYear');\n        assert.equal(a.isoWeek(), 49, 'isoWeek');\n        assert.equal(a.isoWeekday(), 4, 'isoWeekday');\n    });\n\n    test('setters strings', function (assert) {\n        var a = moment([2012]).locale('en');\n        assert.equal(a.clone().day(0).day('Wednesday').day(), 3, 'day full name');\n        assert.equal(a.clone().day(0).day('Wed').day(), 3, 'day short name');\n        assert.equal(a.clone().day(0).day('We').day(), 3, 'day minimal name');\n        assert.equal(a.clone().day(0).day('invalid').day(), 0, 'invalid day name');\n        assert.equal(a.clone().month(0).month('April').month(), 3, 'month full name');\n        assert.equal(a.clone().month(0).month('Apr').month(), 3, 'month short name');\n        assert.equal(a.clone().month(0).month('invalid').month(), 0, 'invalid month name');\n    });\n\n    test('setters - falsey values', function (assert) {\n        var a = moment();\n        // ensure minutes wasn't coincidentally 0 already\n        a.minutes(1);\n        a.minutes(0);\n        assert.equal(a.minutes(), 0, 'falsey value');\n    });\n\n    test('chaining setters', function (assert) {\n        var a = moment();\n        a.year(2011)\n         .month(9)\n         .date(12)\n         .hours(6)\n         .minutes(7)\n         .seconds(8);\n        assert.equal(a.year(), 2011, 'year');\n        assert.equal(a.month(), 9, 'month');\n        assert.equal(a.date(), 12, 'date');\n        assert.equal(a.day(), 3, 'day');\n        assert.equal(a.hours(), 6, 'hour');\n        assert.equal(a.minutes(), 7, 'minute');\n        assert.equal(a.seconds(), 8, 'second');\n    });\n\n    test('setter with multiple unit values', function (assert) {\n        var a = moment();\n        a.set({\n            year: 2011,\n            month: 9,\n            date: 12,\n            hours: 6,\n            minutes: 7,\n            seconds: 8,\n            milliseconds: 9\n        });\n        assert.equal(a.year(), 2011, 'year');\n        assert.equal(a.month(), 9, 'month');\n        assert.equal(a.date(), 12, 'date');\n        assert.equal(a.day(), 3, 'day');\n        assert.equal(a.hours(), 6, 'hour');\n        assert.equal(a.minutes(), 7, 'minute');\n        assert.equal(a.seconds(), 8, 'second');\n        assert.equal(a.milliseconds(), 9, 'milliseconds');\n    });\n\n    test('day setter', function (assert) {\n        var a = moment([2011, 0, 15]);\n        assert.equal(moment(a).day(0).date(), 9, 'set from saturday to sunday');\n        assert.equal(moment(a).day(6).date(), 15, 'set from saturday to saturday');\n        assert.equal(moment(a).day(3).date(), 12, 'set from saturday to wednesday');\n\n        a = moment([2011, 0, 9]);\n        assert.equal(moment(a).day(0).date(), 9, 'set from sunday to sunday');\n        assert.equal(moment(a).day(6).date(), 15, 'set from sunday to saturday');\n        assert.equal(moment(a).day(3).date(), 12, 'set from sunday to wednesday');\n\n        a = moment([2011, 0, 12]);\n        assert.equal(moment(a).day(0).date(), 9, 'set from wednesday to sunday');\n        assert.equal(moment(a).day(6).date(), 15, 'set from wednesday to saturday');\n        assert.equal(moment(a).day(3).date(), 12, 'set from wednesday to wednesday');\n\n        assert.equal(moment(a).day(-7).date(), 2, 'set from wednesday to last sunday');\n        assert.equal(moment(a).day(-1).date(), 8, 'set from wednesday to last saturday');\n        assert.equal(moment(a).day(-4).date(), 5, 'set from wednesday to last wednesday');\n\n        assert.equal(moment(a).day(7).date(), 16, 'set from wednesday to next sunday');\n        assert.equal(moment(a).day(13).date(), 22, 'set from wednesday to next saturday');\n        assert.equal(moment(a).day(10).date(), 19, 'set from wednesday to next wednesday');\n\n        assert.equal(moment(a).day(14).date(), 23, 'set from wednesday to second next sunday');\n        assert.equal(moment(a).day(20).date(), 29, 'set from wednesday to second next saturday');\n        assert.equal(moment(a).day(17).date(), 26, 'set from wednesday to second next wednesday');\n    });\n\n    test('string setters', function (assert) {\n        var a = moment();\n        a.year('2011');\n        a.month('9');\n        a.date('12');\n        a.hours('6');\n        a.minutes('7');\n        a.seconds('8');\n        a.milliseconds('9');\n        assert.equal(a.year(), 2011, 'year');\n        assert.equal(a.month(), 9, 'month');\n        assert.equal(a.date(), 12, 'date');\n        assert.equal(a.day(), 3, 'day');\n        assert.equal(a.hours(), 6, 'hour');\n        assert.equal(a.minutes(), 7, 'minute');\n        assert.equal(a.seconds(), 8, 'second');\n        assert.equal(a.milliseconds(), 9, 'milliseconds');\n    });\n\n    test('setters across DST +1', function (assert) {\n        var oldUpdateOffset = moment.updateOffset,\n            // Based on a real story somewhere in America/Los_Angeles\n            dstAt = moment('2014-03-09T02:00:00-08:00').parseZone(),\n            m;\n\n        moment.updateOffset = function (mom, keepTime) {\n            if (mom.isBefore(dstAt)) {\n                mom.utcOffset(-8, keepTime);\n            } else {\n                mom.utcOffset(-7, keepTime);\n            }\n        };\n\n        m = moment('2014-03-15T00:00:00-07:00').parseZone();\n        m.year(2013);\n        assert.equal(m.format(), '2013-03-15T00:00:00-08:00', 'year across +1');\n\n        m = moment('2014-03-15T00:00:00-07:00').parseZone();\n        m.month(0);\n        assert.equal(m.format(), '2014-01-15T00:00:00-08:00', 'month across +1');\n\n        m = moment('2014-03-15T00:00:00-07:00').parseZone();\n        m.date(1);\n        assert.equal(m.format(), '2014-03-01T00:00:00-08:00', 'date across +1');\n\n        m = moment('2014-03-09T03:05:00-07:00').parseZone();\n        m.hour(0);\n        assert.equal(m.format(), '2014-03-09T00:05:00-08:00', 'hour across +1');\n\n        moment.updateOffset = oldUpdateOffset;\n    });\n\n    test('setters across DST -1', function (assert) {\n        var oldUpdateOffset = moment.updateOffset,\n            // Based on a real story somewhere in America/Los_Angeles\n            dstAt = moment('2014-11-02T02:00:00-07:00').parseZone(),\n            m;\n\n        moment.updateOffset = function (mom, keepTime) {\n            if (mom.isBefore(dstAt)) {\n                mom.utcOffset(-7, keepTime);\n            } else {\n                mom.utcOffset(-8, keepTime);\n            }\n        };\n\n        m = moment('2014-11-15T00:00:00-08:00').parseZone();\n        m.year(2013);\n        assert.equal(m.format(), '2013-11-15T00:00:00-07:00', 'year across -1');\n\n        m = moment('2014-11-15T00:00:00-08:00').parseZone();\n        m.month(0);\n        assert.equal(m.format(), '2014-01-15T00:00:00-07:00', 'month across -1');\n\n        m = moment('2014-11-15T00:00:00-08:00').parseZone();\n        m.date(1);\n        assert.equal(m.format(), '2014-11-01T00:00:00-07:00', 'date across -1');\n\n        m = moment('2014-11-02T03:30:00-08:00').parseZone();\n        m.hour(0);\n        assert.equal(m.format(), '2014-11-02T00:30:00-07:00', 'hour across -1');\n\n        moment.updateOffset = oldUpdateOffset;\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('instanceof');\n\n    test('instanceof', function (assert) {\n        var mm = moment([2010, 0, 1]);\n\n        var extend = function (a, b) {\n            var i;\n            for (i in b) {\n                a[i] = b[i];\n            }\n            return a;\n        };\n\n        assert.equal(moment() instanceof moment, true, 'simple moment object');\n        assert.equal(extend({}, moment()) instanceof moment, false, 'extended moment object');\n        assert.equal(moment(null) instanceof moment, true, 'invalid moment object');\n\n        assert.equal(new Date() instanceof moment, false, 'date object is not moment object');\n        assert.equal(Object instanceof moment, false, 'Object is not moment object');\n        assert.equal('foo' instanceof moment, false, 'string is not moment object');\n        assert.equal(1 instanceof moment, false, 'number is not moment object');\n        assert.equal(NaN instanceof moment, false, 'NaN is not moment object');\n        assert.equal(null instanceof moment, false, 'null is not moment object');\n        assert.equal(undefined instanceof moment, false, 'undefined is not moment object');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('invalid');\n\n    test('invalid', function (assert) {\n        var m = moment.invalid();\n        assert.equal(m.isValid(), false);\n        assert.equal(m.parsingFlags().userInvalidated, true);\n        assert.ok(isNaN(m.valueOf()));\n    });\n\n    test('invalid with existing flag', function (assert) {\n        var m = moment.invalid({invalidMonth : 'whatchamacallit'});\n        assert.equal(m.isValid(), false);\n        assert.equal(m.parsingFlags().userInvalidated, false);\n        assert.equal(m.parsingFlags().invalidMonth, 'whatchamacallit');\n        assert.ok(isNaN(m.valueOf()));\n    });\n\n    test('invalid with custom flag', function (assert) {\n        var m = moment.invalid({tooBusyWith : 'reiculating splines'});\n        assert.equal(m.isValid(), false);\n        assert.equal(m.parsingFlags().userInvalidated, false);\n        assert.equal(m.parsingFlags().tooBusyWith, 'reiculating splines');\n        assert.ok(isNaN(m.valueOf()));\n    });\n\n    test('invalid operations', function (assert) {\n        var invalids = [\n                moment.invalid(),\n                moment('xyz', 'l'),\n                moment('2015-01-35', 'YYYY-MM-DD'),\n                moment('2015-01-25 a', 'YYYY-MM-DD', true)\n            ],\n            i,\n            invalid,\n            valid = moment();\n\n        test.expectedDeprecations('moment().min', 'moment().max');\n\n        for (i = 0; i < invalids.length; ++i) {\n            invalid = invalids[i];\n\n            assert.ok(!invalid.clone().add(5, 'hours').isValid(), 'invalid.add is invalid');\n            assert.equal(invalid.calendar(), 'Invalid date', 'invalid.calendar is \\'Invalid date\\'');\n            assert.ok(!invalid.clone().isValid(), 'invalid.clone is invalid');\n            assert.ok(isNaN(invalid.diff(valid)), 'invalid.diff(valid) is NaN');\n            assert.ok(isNaN(valid.diff(invalid)), 'valid.diff(invalid) is NaN');\n            assert.ok(isNaN(invalid.diff(invalid)), 'invalid.diff(invalid) is NaN');\n            assert.ok(!invalid.clone().endOf('month').isValid(), 'invalid.endOf is invalid');\n            assert.equal(invalid.format(), 'Invalid date', 'invalid.format is \\'Invalid date\\'');\n            assert.equal(invalid.from(), 'Invalid date');\n            assert.equal(invalid.from(valid), 'Invalid date');\n            assert.equal(valid.from(invalid), 'Invalid date');\n            assert.equal(invalid.fromNow(), 'Invalid date');\n            assert.equal(invalid.to(), 'Invalid date');\n            assert.equal(invalid.to(valid), 'Invalid date');\n            assert.equal(valid.to(invalid), 'Invalid date');\n            assert.equal(invalid.toNow(), 'Invalid date');\n            assert.ok(isNaN(invalid.get('year')), 'invalid.get is NaN');\n            // TODO invalidAt\n            assert.ok(!invalid.isAfter(valid));\n            assert.ok(!valid.isAfter(invalid));\n            assert.ok(!invalid.isAfter(invalid));\n            assert.ok(!invalid.isBefore(valid));\n            assert.ok(!valid.isBefore(invalid));\n            assert.ok(!invalid.isBefore(invalid));\n            assert.ok(!invalid.isBetween(valid, valid));\n            assert.ok(!valid.isBetween(invalid, valid));\n            assert.ok(!valid.isBetween(valid, invalid));\n            assert.ok(!invalid.isSame(invalid));\n            assert.ok(!invalid.isSame(valid));\n            assert.ok(!valid.isSame(invalid));\n            assert.ok(!invalid.isValid());\n            assert.equal(invalid.locale(), 'en');\n            assert.equal(invalid.localeData()._abbr, 'en');\n            assert.ok(!invalid.clone().max(valid).isValid());\n            assert.ok(!valid.clone().max(invalid).isValid());\n            assert.ok(!invalid.clone().max(invalid).isValid());\n            assert.ok(!invalid.clone().min(valid).isValid());\n            assert.ok(!valid.clone().min(invalid).isValid());\n            assert.ok(!invalid.clone().min(invalid).isValid());\n            assert.ok(!moment.min(invalid, valid).isValid());\n            assert.ok(!moment.min(valid, invalid).isValid());\n            assert.ok(!moment.max(invalid, valid).isValid());\n            assert.ok(!moment.max(valid, invalid).isValid());\n            assert.ok(!invalid.clone().set('year', 2005).isValid());\n            assert.ok(!invalid.clone().startOf('month').isValid());\n\n            assert.ok(!invalid.clone().subtract(5, 'days').isValid());\n            assert.deepEqual(invalid.toArray(), [NaN, NaN, NaN, NaN, NaN, NaN, NaN]);\n            assert.deepEqual(invalid.toObject(), {\n                years: NaN,\n                months: NaN,\n                date: NaN,\n                hours: NaN,\n                minutes: NaN,\n                seconds: NaN,\n                milliseconds: NaN\n            });\n            assert.ok(moment.isDate(invalid.toDate()));\n            assert.ok(isNaN(invalid.toDate().valueOf()));\n            assert.equal(invalid.toJSON(), null);\n            assert.equal(invalid.toString(), 'Invalid date');\n            assert.ok(isNaN(invalid.unix()));\n            assert.ok(isNaN(invalid.valueOf()));\n\n            assert.ok(isNaN(invalid.year()));\n            assert.ok(isNaN(invalid.weekYear()));\n            assert.ok(isNaN(invalid.isoWeekYear()));\n            assert.ok(isNaN(invalid.quarter()));\n            assert.ok(isNaN(invalid.quarters()));\n            assert.ok(isNaN(invalid.month()));\n            assert.ok(isNaN(invalid.daysInMonth()));\n            assert.ok(isNaN(invalid.week()));\n            assert.ok(isNaN(invalid.weeks()));\n            assert.ok(isNaN(invalid.isoWeek()));\n            assert.ok(isNaN(invalid.isoWeeks()));\n            assert.ok(isNaN(invalid.weeksInYear()));\n            assert.ok(isNaN(invalid.isoWeeksInYear()));\n            assert.ok(isNaN(invalid.date()));\n            assert.ok(isNaN(invalid.day()));\n            assert.ok(isNaN(invalid.days()));\n            assert.ok(isNaN(invalid.weekday()));\n            assert.ok(isNaN(invalid.isoWeekday()));\n            assert.ok(isNaN(invalid.dayOfYear()));\n            assert.ok(isNaN(invalid.hour()));\n            assert.ok(isNaN(invalid.hours()));\n            assert.ok(isNaN(invalid.minute()));\n            assert.ok(isNaN(invalid.minutes()));\n            assert.ok(isNaN(invalid.second()));\n            assert.ok(isNaN(invalid.seconds()));\n            assert.ok(isNaN(invalid.millisecond()));\n            assert.ok(isNaN(invalid.milliseconds()));\n            assert.ok(isNaN(invalid.utcOffset()));\n\n            assert.ok(!invalid.clone().year(2001).isValid());\n            assert.ok(!invalid.clone().weekYear(2001).isValid());\n            assert.ok(!invalid.clone().isoWeekYear(2001).isValid());\n            assert.ok(!invalid.clone().quarter(1).isValid());\n            assert.ok(!invalid.clone().quarters(1).isValid());\n            assert.ok(!invalid.clone().month(1).isValid());\n            assert.ok(!invalid.clone().week(1).isValid());\n            assert.ok(!invalid.clone().weeks(1).isValid());\n            assert.ok(!invalid.clone().isoWeek(1).isValid());\n            assert.ok(!invalid.clone().isoWeeks(1).isValid());\n            assert.ok(!invalid.clone().date(1).isValid());\n            assert.ok(!invalid.clone().day(1).isValid());\n            assert.ok(!invalid.clone().days(1).isValid());\n            assert.ok(!invalid.clone().weekday(1).isValid());\n            assert.ok(!invalid.clone().isoWeekday(1).isValid());\n            assert.ok(!invalid.clone().dayOfYear(1).isValid());\n            assert.ok(!invalid.clone().hour(1).isValid());\n            assert.ok(!invalid.clone().hours(1).isValid());\n            assert.ok(!invalid.clone().minute(1).isValid());\n            assert.ok(!invalid.clone().minutes(1).isValid());\n            assert.ok(!invalid.clone().second(1).isValid());\n            assert.ok(!invalid.clone().seconds(1).isValid());\n            assert.ok(!invalid.clone().millisecond(1).isValid());\n            assert.ok(!invalid.clone().milliseconds(1).isValid());\n            assert.ok(!invalid.clone().utcOffset(1).isValid());\n\n            assert.ok(!invalid.clone().utc().isValid());\n            assert.ok(!invalid.clone().local().isValid());\n            assert.ok(!invalid.clone().parseZone('05:30').isValid());\n            assert.ok(!invalid.hasAlignedHourOffset());\n            assert.ok(!invalid.isDST());\n            assert.ok(!invalid.isDSTShifted());\n            assert.ok(!invalid.isLocal());\n            assert.ok(!invalid.isUtcOffset());\n            assert.ok(!invalid.isUtc());\n            assert.ok(!invalid.isUTC());\n\n            assert.ok(!invalid.isLeapYear());\n\n            assert.equal(moment.duration({from: invalid, to: valid}).asMilliseconds(), 0);\n            assert.equal(moment.duration({from: valid, to: invalid}).asMilliseconds(), 0);\n            assert.equal(moment.duration({from: invalid, to: invalid}).asMilliseconds(), 0);\n        }\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('is after');\n\n    test('is after without units', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), false, 'year is later');\n        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), true, 'year is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), false, 'month is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), true, 'month is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), false, 'day is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), true, 'day is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), false, 'hour is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), true, 'hour is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), false, 'minute is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), true, 'minute is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), false, 'second is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), true, 'second is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'millisecond match');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), false, 'millisecond is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), true, 'millisecond is earlier');\n        assert.equal(m.isAfter(m), false, 'moments are not after themselves');\n        assert.equal(+m, +mCopy, 'isAfter second should not change moment');\n    });\n\n    test('is after year', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year match');\n        assert.equal(m.isAfter(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');\n        assert.equal(m.isAfter(moment(new Date(2013, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is later');\n        assert.equal(m.isAfter(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), false, 'exact start of year');\n        assert.equal(m.isAfter(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), false, 'exact end of year');\n        assert.equal(m.isAfter(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), false, 'start of next year');\n        assert.equal(m.isAfter(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), true, 'end of previous year');\n        assert.equal(m.isAfter(moment(new Date(1980, 11, 31, 23, 59, 59, 999)), 'year'), true, 'end of year far before');\n        assert.equal(m.isAfter(m, 'year'), false, 'same moments are not after the same year');\n        assert.equal(+m, +mCopy, 'isAfter year should not change moment');\n    });\n\n    test('is after month', function (assert) {\n        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);\n        assert.equal(m.isAfter(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), false, 'month match');\n        assert.equal(m.isAfter(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');\n        assert.equal(m.isAfter(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year is later');\n        assert.equal(m.isAfter(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'month'), true, 'year is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), false, 'month is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), true, 'month is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), false, 'exact start of month');\n        assert.equal(m.isAfter(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), false, 'exact end of month');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), false, 'start of next month');\n        assert.equal(m.isAfter(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), true, 'end of previous month');\n        assert.equal(m.isAfter(moment(new Date(2010, 12, 31, 23, 59, 59, 999)), 'month'), true, 'later month but earlier year');\n        assert.equal(m.isAfter(m, 'month'), false, 'same moments are not after the same month');\n        assert.equal(+m, +mCopy, 'isAfter month should not change moment');\n    });\n\n    test('is after day', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 7, 8, 9, 10)), 'day'), false, 'day match');\n        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');\n        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 7, 8, 9, 10)), 'day'), false, 'year is later');\n        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 7, 8, 9, 10)), 'day'), true, 'year is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 7, 8, 9, 10)), 'day'), false, 'month is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), true, 'month is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 7, 8, 9, 10)), 'day'), false, 'day is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 7, 8, 9, 10)), 'day'), true, 'day is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 0, 0, 0, 0)), 'day'), false, 'exact start of day');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 23, 59, 59, 999)), 'day'), false, 'exact end of day');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 0, 0, 0, 0)), 'day'), false, 'start of next day');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 23, 59, 59, 999)), 'day'), true, 'end of previous day');\n        assert.equal(m.isAfter(moment(new Date(2010, 3, 10, 0, 0, 0, 0)), 'day'), true, 'later day but earlier year');\n        assert.equal(m.isAfter(m, 'day'), false, 'same moments are not after the same day');\n        assert.equal(+m, +mCopy, 'isAfter day should not change moment');\n    });\n\n    test('is after hour', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour match');\n        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');\n        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'year is later');\n        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 8, 9, 10)), 'hour'), true, 'year is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 8, 9, 10)), 'hour'), false, 'month is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'month is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 8, 9, 10)), 'hour'), false, 'day is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 3, 8, 9, 10)), 'hour'), true, 'day is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 8, 9, 10)), 'hour'), false, 'hour is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 0, 0, 0)), 'hour'), false, 'exact start of hour');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 59, 59, 999)), 'hour'), false, 'exact end of hour');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 0, 0, 0)), 'hour'), false, 'start of next hour');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 2, 59, 59, 999)), 'hour'), true, 'end of previous hour');\n        assert.equal(m.isAfter(m, 'hour'), false, 'same moments are not after the same hour');\n        assert.equal(+m, +mCopy, 'isAfter hour should not change moment');\n    });\n\n    test('is after minute', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'minute match');\n        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');\n        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'year is later');\n        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 9, 10)), 'minute'), true, 'year is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 9, 10)), 'minute'), false, 'month is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), true, 'month is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 9, 10)), 'minute'), false, 'day is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 3, 4, 9, 10)), 'minute'), true, 'day is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 9, 10)), 'minute'), false, 'hour is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 2, 4, 9, 10)), 'minute'), true, 'hour is earler');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 9, 10)), 'minute'), false, 'minute is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 9, 10)), 'minute'), true, 'minute is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 0, 0)), 'minute'), false, 'exact start of minute');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 59, 999)), 'minute'), false, 'exact end of minute');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 0, 0)), 'minute'), false, 'start of next minute');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 59, 999)), 'minute'), true, 'end of previous minute');\n        assert.equal(m.isAfter(m, 'minute'), false, 'same moments are not after the same minute');\n        assert.equal(+m, +mCopy, 'isAfter minute should not change moment');\n    });\n\n    test('is after second', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'second'), false, 'second match');\n        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');\n        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'second'), false, 'year is later');\n        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'second'), true, 'year is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'second'), false, 'month is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), true, 'month is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'second'), false, 'day is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'second'), true, 'day is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'second'), false, 'hour is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'second'), true, 'hour is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'second'), false, 'minute is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'second'), true, 'minute is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'second'), false, 'second is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'second'), true, 'second is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 0)), 'second'), false, 'exact start of second');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 999)), 'second'), false, 'exact end of second');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 0)), 'second'), false, 'start of next second');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 999)), 'second'), true, 'end of previous second');\n        assert.equal(m.isAfter(m, 'second'), false, 'same moments are not after the same second');\n        assert.equal(+m, +mCopy, 'isAfter second should not change moment');\n    });\n\n    test('is after millisecond', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'millisecond match');\n        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'plural should work');\n        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is later');\n        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'year is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), true, 'month is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), false, 'day is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), true, 'day is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), false, 'hour is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), true, 'hour is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), false, 'minute is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), true, 'minute is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), false, 'second is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), true, 'second is earlier');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), false, 'millisecond is later');\n        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), true, 'millisecond is earlier');\n        assert.equal(m.isAfter(m, 'millisecond'), false, 'same moments are not after the same millisecond');\n        assert.equal(+m, +mCopy, 'isAfter millisecond should not change moment');\n    });\n\n    test('is after invalid', function (assert) {\n        var m = moment(), invalid = moment.invalid();\n        assert.equal(m.isAfter(invalid), false, 'valid moment is not after invalid moment');\n        assert.equal(invalid.isAfter(m), false, 'invalid moment is not after valid moment');\n        assert.equal(m.isAfter(invalid, 'year'), false, 'invalid moment year');\n        assert.equal(m.isAfter(invalid, 'month'), false, 'invalid moment month');\n        assert.equal(m.isAfter(invalid, 'day'), false, 'invalid moment day');\n        assert.equal(m.isAfter(invalid, 'hour'), false, 'invalid moment hour');\n        assert.equal(m.isAfter(invalid, 'minute'), false, 'invalid moment minute');\n        assert.equal(m.isAfter(invalid, 'second'), false, 'invalid moment second');\n        assert.equal(m.isAfter(invalid, 'milliseconds'), false, 'invalid moment milliseconds');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    function isArray(input) {\n        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n    }\n\n    test('isArray recognizes Array objects', function (assert) {\n        assert.ok(isArray([1,2,3]), 'array args');\n        assert.ok(isArray([]), 'empty array');\n        assert.ok(isArray(new Array(1,2,3)), 'array constructor');\n    });\n\n    test('isArray rejects non-Array objects', function (assert) {\n        assert.ok(!isArray(), 'nothing');\n        assert.ok(!isArray(undefined), 'undefined');\n        assert.ok(!isArray(null), 'null');\n        assert.ok(!isArray(123), 'number');\n        assert.ok(!isArray('[1,2,3]'), 'string');\n        assert.ok(!isArray(new Date()), 'date');\n        assert.ok(!isArray({a:1,b:2}), 'object');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('is before');\n\n    test('is after without units', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), true, 'year is later');\n        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), false, 'year is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), true, 'month is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), false, 'month is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), true, 'day is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), false, 'day is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), true, 'hour is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), false, 'hour is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), true, 'minute is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), false, 'minute is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), true, 'second is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), false, 'second is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'millisecond match');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), true, 'millisecond is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), false, 'millisecond is earlier');\n        assert.equal(m.isBefore(m), false, 'moments are not before themselves');\n        assert.equal(+m, +mCopy, 'isBefore second should not change moment');\n    });\n\n    test('is before year', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isBefore(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year match');\n        assert.equal(m.isBefore(moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');\n        assert.equal(m.isBefore(moment(new Date(2013, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is later');\n        assert.equal(m.isBefore(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), false, 'exact start of year');\n        assert.equal(m.isBefore(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), false, 'exact end of year');\n        assert.equal(m.isBefore(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), true, 'start of next year');\n        assert.equal(m.isBefore(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of previous year');\n        assert.equal(m.isBefore(moment(new Date(1980, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of year far before');\n        assert.equal(m.isBefore(m, 'year'), false, 'same moments are not before the same year');\n        assert.equal(+m, +mCopy, 'isBefore year should not change moment');\n    });\n\n    test('is before month', function (assert) {\n        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);\n        assert.equal(m.isBefore(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), false, 'month match');\n        assert.equal(m.isBefore(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');\n        assert.equal(m.isBefore(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), true, 'year is later');\n        assert.equal(m.isBefore(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), true, 'month is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), false, 'exact start of month');\n        assert.equal(m.isBefore(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), false, 'exact end of month');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), true, 'start of next month');\n        assert.equal(m.isBefore(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), false, 'end of previous month');\n        assert.equal(m.isBefore(moment(new Date(2010, 12, 31, 23, 59, 59, 999)), 'month'), false, 'later month but earlier year');\n        assert.equal(m.isBefore(m, 'month'), false, 'same moments are not before the same month');\n        assert.equal(+m, +mCopy, 'isBefore month should not change moment');\n    });\n\n    test('is before day', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 7, 8, 9, 10)), 'day'), false, 'day match');\n        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');\n        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 7, 8, 9, 10)), 'day'), true, 'year is later');\n        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 7, 8, 9, 10)), 'day'), false, 'year is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 7, 8, 9, 10)), 'day'), true, 'month is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), false, 'month is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 7, 8, 9, 10)), 'day'), true, 'day is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 7, 8, 9, 10)), 'day'), false, 'day is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 0, 0, 0, 0)), 'day'), false, 'exact start of day');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 23, 59, 59, 999)), 'day'), false, 'exact end of day');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 0, 0, 0, 0)), 'day'), true, 'start of next day');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 23, 59, 59, 999)), 'day'), false, 'end of previous day');\n        assert.equal(m.isBefore(moment(new Date(2010, 3, 10, 0, 0, 0, 0)), 'day'), false, 'later day but earlier year');\n        assert.equal(m.isBefore(m, 'day'), false, 'same moments are not before the same day');\n        assert.equal(+m, +mCopy, 'isBefore day should not change moment');\n    });\n\n    test('is before hour', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour match');\n        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');\n        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 8, 9, 10)), 'hour'), true, 'year is later');\n        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'year is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 8, 9, 10)), 'hour'), true, 'month is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), false, 'month is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 8, 9, 10)), 'hour'), true, 'day is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 3, 8, 9, 10)), 'hour'), false, 'day is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 8, 9, 10)), 'hour'), true, 'hour is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 0, 0, 0)), 'hour'), false, 'exact start of hour');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 59, 59, 999)), 'hour'), false, 'exact end of hour');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 0, 0, 0)), 'hour'), true, 'start of next hour');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 2, 59, 59, 999)), 'hour'), false, 'end of previous hour');\n        assert.equal(m.isBefore(m, 'hour'), false, 'same moments are not before the same hour');\n        assert.equal(+m, +mCopy, 'isBefore hour should not change moment');\n    });\n\n    test('is before minute', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'minute match');\n        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');\n        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 9, 10)), 'minute'), true, 'year is later');\n        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'year is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 9, 10)), 'minute'), true, 'month is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), false, 'month is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 9, 10)), 'minute'), true, 'day is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 3, 4, 9, 10)), 'minute'), false, 'day is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 9, 10)), 'minute'), true, 'hour is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 2, 4, 9, 10)), 'minute'), false, 'hour is earler');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 9, 10)), 'minute'), true, 'minute is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 9, 10)), 'minute'), false, 'minute is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 0, 0)), 'minute'), false, 'exact start of minute');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 59, 999)), 'minute'), false, 'exact end of minute');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 0, 0)), 'minute'), true, 'start of next minute');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 59, 999)), 'minute'), false, 'end of previous minute');\n        assert.equal(m.isBefore(m, 'minute'), false, 'same moments are not before the same minute');\n        assert.equal(+m, +mCopy, 'isBefore minute should not change moment');\n    });\n\n    test('is before second', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'second'), false, 'second match');\n        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');\n        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'second'), true, 'year is later');\n        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'second'), false, 'year is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'second'), true, 'month is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), false, 'month is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'second'), true, 'day is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'second'), false, 'day is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'second'), true, 'hour is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'second'), false, 'hour is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'second'), true, 'minute is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'second'), false, 'minute is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'second'), true, 'second is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'second'), false, 'second is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 0)), 'second'), false, 'exact start of second');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 999)), 'second'), false, 'exact end of second');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 0)), 'second'), true, 'start of next second');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 999)), 'second'), false, 'end of previous second');\n        assert.equal(m.isBefore(m, 'second'), false, 'same moments are not before the same second');\n        assert.equal(+m, +mCopy, 'isBefore second should not change moment');\n    });\n\n    test('is before millisecond', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'millisecond match');\n        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds'), false, 'plural should work');\n        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'year is later');\n        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), true, 'month is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), true, 'day is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), false, 'day is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), true, 'hour is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), false, 'hour is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), true, 'minute is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), false, 'minute is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), true, 'second is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), false, 'second is earlier');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), true, 'millisecond is later');\n        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), false, 'millisecond is earlier');\n        assert.equal(m.isBefore(m, 'millisecond'), false, 'same moments are not before the same millisecond');\n        assert.equal(+m, +mCopy, 'isBefore millisecond should not change moment');\n    });\n\n    test('is before invalid', function (assert) {\n        var m = moment(), invalid = moment.invalid();\n        assert.equal(m.isBefore(invalid), false, 'valid moment is not before invalid moment');\n        assert.equal(invalid.isBefore(m), false, 'invalid moment is not before valid moment');\n        assert.equal(m.isBefore(invalid, 'year'), false, 'invalid moment year');\n        assert.equal(m.isBefore(invalid, 'month'), false, 'invalid moment month');\n        assert.equal(m.isBefore(invalid, 'day'), false, 'invalid moment day');\n        assert.equal(m.isBefore(invalid, 'hour'), false, 'invalid moment hour');\n        assert.equal(m.isBefore(invalid, 'minute'), false, 'invalid moment minute');\n        assert.equal(m.isBefore(invalid, 'second'), false, 'invalid moment second');\n        assert.equal(m.isBefore(invalid, 'milliseconds'), false, 'invalid moment milliseconds');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('is between');\n\n    test('is between without units', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isBetween(\n                    moment(new Date(2009, 3, 2, 3, 4, 5, 10)),\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'year is later');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n                    moment(new Date(2013, 3, 2, 3, 4, 5, 10))), false, 'year is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n                    moment(new Date(2012, 3, 2, 3, 4, 5, 10))), true, 'year is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)),\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'month is later');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n                    moment(new Date(2011, 5, 2, 3, 4, 5, 10))), false, 'month is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 2, 2, 3, 4, 5, 10)),\n                    moment(new Date(2011, 4, 2, 3, 4, 5, 10))), true, 'month is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 1, 3, 4, 5, 10)),\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'day is later');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n                    moment(new Date(2011, 3, 4, 3, 4, 5, 10))), false, 'day is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 1, 3, 4, 5, 10)),\n                    moment(new Date(2011, 3, 3, 3, 4, 5, 10))), true, 'day is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 1, 4, 5, 10)),\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'hour is later');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n                    moment(new Date(2011, 3, 2, 5, 4, 5, 10))), false, 'hour is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 2, 4, 5, 10)),\n                    moment(new Date(2011, 3, 2, 4, 4, 5, 10))), true, 'hour is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n                    moment(new Date(2011, 3, 2, 3, 6, 5, 10))), false, 'minute is later');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 2, 5, 10)),\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'minute is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 3, 5, 10)),\n                    moment(new Date(2011, 3, 2, 3, 5, 5, 10))), true, 'minute is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n                    moment(new Date(2011, 3, 2, 3, 4, 7, 10))), false, 'second is later');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 4, 3, 10)),\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'second is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 4, 4, 10)),\n                    moment(new Date(2011, 3, 2, 3, 4, 6, 10))), true, 'second is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 12))), false, 'millisecond is later');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 8)),\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'millisecond is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 9)),\n                    moment(new Date(2011, 3, 2, 3, 4, 5, 11))), true, 'millisecond is between');\n        assert.equal(m.isBetween(m, m), false, 'moments are not between themselves');\n        assert.equal(+m, +mCopy, 'isBetween second should not change moment');\n    });\n\n    test('is between without units inclusivity', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '()'), false, 'start and end are excluded, start is equal to moment');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '()'), false, 'start and end are excluded, end is equal to moment');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '()'), true, 'start and end are excluded, is between');\n        assert.equal(m.isBetween(\n            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), null, '()'), false, 'start and end are excluded, is not between');\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '()'), false, 'start and end are excluded, should fail on same start/end date.');\n\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '(]'), false, 'start is excluded and end is included should fail on same start date');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '(]'), true, 'start is excluded and end is included should succeed on end date');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '(]'), true, 'start is excluded and end is included, is between');\n        assert.equal(m.isBetween(\n            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), null, '(]'), false, 'start is excluded and end is included, is not between');\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '(]'), false, 'start is excluded and end is included, should fail on same start/end date.');\n\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '[)'), true, 'start is included and end is excluded should succeed on same start date');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '[)'), false, 'start is included and end is excluded should fail on same end date');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '[)'), true, 'start is included and end is excluded, is between');\n        assert.equal(m.isBetween(\n            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), null, '[)'), false, 'start is included and end is excluded, is not between');\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '[)'), false, 'start is included and end is excluded, should fail on same end and start date');\n\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '[]'), true, 'start and end inclusive should succeed on same start date');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '[]'), true, 'start and end inclusive should succeed on same end date');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), null, '[]'), true, 'start and end inclusive, is between');\n        assert.equal(m.isBetween(\n            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), null, '[]'), false, 'start and end inclusive, is not between');\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), null, '[]'), true, 'start and end inclusive, should handle same end and start date');\n    });\n\n    test('is between milliseconds inclusivity', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'options, no inclusive');\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '()'), false, 'start and end are excluded, start is equal to moment');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '()'), false, 'start and end are excluded, end is equal to moment');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '()'), true, 'start and end are excluded, is between');\n        assert.equal(m.isBetween(\n            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds', '()'), false, 'start and end are excluded, is not between');\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '()'), false, 'start and end are excluded, should fail on same start/end date.');\n\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '(]'), false, 'start is excluded and end is included should fail on same start date');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '(]'), true, 'start is excluded and end is included should succeed on end date');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '(]'), true, 'start is excluded and end is included, is between');\n        assert.equal(m.isBetween(\n            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds', '(]'), false, 'start is excluded and end is included, is not between');\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '(]'), false, 'start is excluded and end is included, should fail on same start/end date.');\n\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[)'), true, 'start is included and end is excluded should succeed on same start date');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[)'), false, 'start is included and end is excluded should fail on same end date');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[)'), true, 'start is included and end is excluded, is between');\n        assert.equal(m.isBetween(\n            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[)'), false, 'start is included and end is excluded, is not between');\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[)'), false, 'start is included and end is excluded, should fail on same end and start date');\n\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[]'), true, 'start and end inclusive should succeed on same start date');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[]'), true, 'start and end inclusive should succeed on same end date');\n        assert.equal(m.isBetween(\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[]'), true, 'start and end inclusive, is between');\n        assert.equal(m.isBetween(\n            moment(new Date(2009, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[]'), false, 'start and end inclusive, is not between');\n        assert.equal(m.isBetween(\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)),\n            moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds', '[]'), true, 'start and end inclusive, should handle same end and start date');\n    });\n\n    test('is between year', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)),\n                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year match');\n        assert.equal(m.isBetween(\n                    moment(new Date(2010, 5, 6, 7, 8, 9, 10)),\n                    moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');\n        assert.equal(m.isBetween(\n                    moment(new Date(2010, 5, 6, 7, 8, 9, 10)),\n                    moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)),\n                    moment(new Date(2013, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2010, 5, 6, 7, 8, 9, 10)),\n                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is later');\n        assert.equal(m.isBetween(m, 'year'), false, 'same moments are not between the same year');\n        assert.equal(+m, +mCopy, 'isBetween year should not change moment');\n    });\n\n    test('is between month', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)),\n                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month match');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 0, 6, 7, 8, 9, 10)),\n                    moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 0, 31, 23, 59, 59, 999)),\n                    moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), true, 'month is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)),\n                    moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), false, 'month is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 11, 6, 7, 8, 9, 10)),\n                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month is later');\n        assert.equal(m.isBetween(m, 'month'), false, 'same moments are not between the same month');\n        assert.equal(+m, +mCopy, 'isBetween month should not change moment');\n    });\n\n    test('is between day', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),\n                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), false, 'day match');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 1, 7, 8, 9, 10)),\n                    moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'days'), true, 'plural should work');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 1, 7, 8, 9, 10)),\n                    moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'day'), true, 'day is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),\n                    moment(new Date(2011, 1, 4, 7, 8, 9, 10)), 'day'), false, 'day is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 1, 7, 8, 9, 10)),\n                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), false, 'day is later');\n        assert.equal(m.isBetween(m, 'day'), false, 'same moments are not between the same day');\n        assert.equal(+m, +mCopy, 'isBetween day should not change moment');\n    });\n\n    test('is between hour', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 5, 9, 10)),\n                    moment(new Date(2011, 1, 2, 3, 9, 9, 10)), 'hour'), false, 'hour match');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 1, 59, 59, 999)),\n                    moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hours'), true, 'plural should work');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 2, 59, 59, 999)),\n                    moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hour'), true, 'hour is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),\n                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'hour'), false, 'hour is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),\n                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'hour'), false, 'hour is later');\n        assert.equal(m.isBetween(m, 'hour'), false, 'same moments are not between the same hour');\n        assert.equal(+m, +mCopy, 'isBetween hour should not change moment');\n    });\n\n    test('is between minute', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 4, 9, 10)),\n                    moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minute'), false, 'minute match');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 3, 9, 10)),\n                    moment(new Date(2011, 1, 2, 3, 5, 9, 10)), 'minutes'), true, 'plural should work');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 3, 59, 999)),\n                    moment(new Date(2011, 1, 2, 3, 5, 0, 0)), 'minute'), true, 'minute is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 5, 0, 0)),\n                    moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'minute'), false, 'minute is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 2, 9, 10)),\n                    moment(new Date(2011, 1, 2, 3, 3, 59, 999)), 'minute'), false, 'minute is later');\n        assert.equal(m.isBetween(m, 'minute'), false, 'same moments are not between the same minute');\n        assert.equal(+m, +mCopy, 'isBetween minute should not change moment');\n    });\n\n    test('is between second', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)),\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'second'), false, 'second match');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 4, 4, 10)),\n                    moment(new Date(2011, 1, 2, 3, 4, 6, 10)), 'seconds'), true, 'plural should work');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 4, 4, 999)),\n                    moment(new Date(2011, 1, 2, 3, 4, 6, 0)), 'second'), true, 'second is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 4, 6, 0)),\n                    moment(new Date(2011, 1, 2, 3, 4, 7, 10)), 'second'), false, 'second is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 4, 3, 10)),\n                    moment(new Date(2011, 1, 2, 3, 4, 4, 999)), 'second'), false, 'second is later');\n        assert.equal(m.isBetween(m, 'second'), false, 'same moments are not between the same second');\n        assert.equal(+m, +mCopy, 'isBetween second should not change moment');\n    });\n\n    test('is between millisecond', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 6)),\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 6)), 'millisecond'), false, 'millisecond match');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 5)),\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 7)), 'milliseconds'), true, 'plural should work');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 5)),\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 7)), 'millisecond'), true, 'millisecond is between');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 7)),\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'millisecond'), false, 'millisecond is earlier');\n        assert.equal(m.isBetween(\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 4)),\n                    moment(new Date(2011, 1, 2, 3, 4, 5, 6)), 'millisecond'), false, 'millisecond is later');\n        assert.equal(m.isBetween(m, 'millisecond'), false, 'same moments are not between the same millisecond');\n        assert.equal(+m, +mCopy, 'isBetween millisecond should not change moment');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('is date');\n\n    test('isDate recognizes Date objects', function (assert) {\n        assert.ok(moment.isDate(new Date()), 'no args (now)');\n        assert.ok(moment.isDate(new Date([2014, 2, 15])), 'array args');\n        assert.ok(moment.isDate(new Date('2014-03-15')), 'string args');\n        assert.ok(moment.isDate(new Date('does NOT look like a date')), 'invalid date');\n    });\n\n    test('isDate rejects non-Date objects', function (assert) {\n        assert.ok(!moment.isDate(), 'nothing');\n        assert.ok(!moment.isDate(undefined), 'undefined');\n        assert.ok(!moment.isDate(null), 'string args');\n        assert.ok(!moment.isDate(42), 'number');\n        assert.ok(!moment.isDate('2014-03-15'), 'string');\n        assert.ok(!moment.isDate([2014, 2, 15]), 'array');\n        assert.ok(!moment.isDate({year: 2014, month: 2, day: 15}), 'object');\n        assert.ok(!moment.isDate({toString: function () {\n            return '[object Date]';\n        }}), 'lying object');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('is moment');\n\n    test('is moment object', function (assert) {\n        var MyObj = function () {},\n            extend = function (a, b) {\n                var i;\n                for (i in b) {\n                    a[i] = b[i];\n                }\n                return a;\n            };\n        MyObj.prototype.toDate = function () {\n            return new Date();\n        };\n\n        assert.ok(moment.isMoment(moment()), 'simple moment object');\n        assert.ok(moment.isMoment(moment(null)), 'invalid moment object');\n        assert.ok(moment.isMoment(extend({}, moment())), 'externally cloned moments are moments');\n        assert.ok(moment.isMoment(extend({}, moment.utc())), 'externally cloned utc moments are moments');\n\n        assert.ok(!moment.isMoment(new MyObj()), 'myObj is not moment object');\n        assert.ok(!moment.isMoment(moment), 'moment function is not moment object');\n        assert.ok(!moment.isMoment(new Date()), 'date object is not moment object');\n        assert.ok(!moment.isMoment(Object), 'Object is not moment object');\n        assert.ok(!moment.isMoment('foo'), 'string is not moment object');\n        assert.ok(!moment.isMoment(1), 'number is not moment object');\n        assert.ok(!moment.isMoment(NaN), 'NaN is not moment object');\n        assert.ok(!moment.isMoment(null), 'null is not moment object');\n        assert.ok(!moment.isMoment(undefined), 'undefined is not moment object');\n    });\n\n    test('is moment with hacked hasOwnProperty', function (assert) {\n        var obj = {};\n        // HACK to suppress jshint warning about bad property name\n        obj['hasOwnMoney'.replace('Money', 'Property')] = function () {\n            return true;\n        };\n\n        assert.ok(!moment.isMoment(obj), 'isMoment works even if passed object has a wrong hasOwnProperty implementation (ie8)');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('is same');\n\n    test('is same without units', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isSame(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), false, 'year is later');\n        assert.equal(m.isSame(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), false, 'year is earlier');\n        assert.equal(m.isSame(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), false, 'month is later');\n        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), false, 'month is earlier');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), false, 'day is later');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), false, 'day is earlier');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), false, 'hour is later');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), false, 'hour is earlier');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), false, 'minute is later');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), false, 'minute is earlier');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), false, 'second is later');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), false, 'second is earlier');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), true, 'millisecond match');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), false, 'millisecond is later');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), false, 'millisecond is earlier');\n        assert.equal(m.isSame(m), true, 'moments are the same as themselves');\n        assert.equal(+m, +mCopy, 'isSame second should not change moment');\n    });\n\n    test('is same year', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSame(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year match');\n        assert.equal(m.isSame(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');\n        assert.equal(m.isSame(moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), true, 'exact start of year');\n        assert.equal(m.isSame(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), true, 'exact end of year');\n        assert.equal(m.isSame(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), false, 'start of next year');\n        assert.equal(m.isSame(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of previous year');\n        assert.equal(m.isSame(m, 'year'), true, 'same moments are in the same year');\n        assert.equal(+m, +mCopy, 'isSame year should not change moment');\n    });\n\n    test('is same month', function (assert) {\n        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);\n        assert.equal(m.isSame(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), true, 'month match');\n        assert.equal(m.isSame(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');\n        assert.equal(m.isSame(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), false, 'month mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), true, 'exact start of month');\n        assert.equal(m.isSame(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), true, 'exact end of month');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), false, 'start of next month');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), false, 'end of previous month');\n        assert.equal(m.isSame(m, 'month'), true, 'same moments are in the same month');\n        assert.equal(+m, +mCopy, 'isSame month should not change moment');\n    });\n\n    test('is same day', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), true, 'day match');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');\n        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 7, 8, 9, 10)), 'day'), false, 'year mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), false, 'month mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'day'), false, 'day mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 0, 0, 0, 0)), 'day'), true, 'exact start of day');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 23, 59, 59, 999)), 'day'), true, 'exact end of day');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 0, 0, 0, 0)), 'day'), false, 'start of next day');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 1, 23, 59, 59, 999)), 'day'), false, 'end of previous day');\n        assert.equal(m.isSame(m, 'day'), true, 'same moments are in the same day');\n        assert.equal(+m, +mCopy, 'isSame day should not change moment');\n    });\n\n    test('is same hour', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'hour match');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');\n        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 3, 8, 9, 10)), 'hour'), false, 'year mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 8, 9, 10)), 'hour'), false, 'month mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 3, 8, 9, 10)), 'hour'), false, 'day mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 8, 9, 10)), 'hour'), false, 'hour mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 0, 0, 0)), 'hour'), true, 'exact start of hour');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 59, 59, 999)), 'hour'), true, 'exact end of hour');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hour'), false, 'start of next hour');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 2, 59, 59, 999)), 'hour'), false, 'end of previous hour');\n        assert.equal(m.isSame(m, 'hour'), true, 'same moments are in the same hour');\n        assert.equal(+m, +mCopy, 'isSame hour should not change moment');\n    });\n\n    test('is same minute', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minute'), true, 'minute match');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');\n        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 3, 4, 9, 10)), 'minute'), false, 'year mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), false, 'month mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 3, 4, 9, 10)), 'minute'), false, 'day mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 4, 9, 10)), 'minute'), false, 'hour mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 5, 9, 10)), 'minute'), false, 'minute mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 0, 0)), 'minute'), true, 'exact start of minute');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 59, 999)), 'minute'), true, 'exact end of minute');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 5, 0, 0)), 'minute'), false, 'start of next minute');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 3, 59, 999)), 'minute'), false, 'end of previous minute');\n        assert.equal(m.isSame(m, 'minute'), true, 'same moments are in the same minute');\n        assert.equal(+m, +mCopy, 'isSame minute should not change moment');\n    });\n\n    test('is same second', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'second'), true, 'second match');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');\n        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 3, 4, 5, 10)), 'second'), false, 'year mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), false, 'month mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 3, 4, 5, 10)), 'second'), false, 'day mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 4, 5, 10)), 'second'), false, 'hour mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 5, 5, 10)), 'second'), false, 'minute mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 6, 10)), 'second'), false, 'second mismatch');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 0)), 'second'), true, 'exact start of second');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 999)), 'second'), true, 'exact end of second');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 6, 0)), 'second'), false, 'start of next second');\n        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 4, 999)), 'second'), false, 'end of previous second');\n        assert.equal(m.isSame(m, 'second'), true, 'same moments are in the same second');\n        assert.equal(+m, +mCopy, 'isSame second should not change moment');\n    });\n\n    test('is same millisecond', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'millisecond match');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'plural should work');\n        assert.equal(m.isSame(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is later');\n        assert.equal(m.isSame(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is earlier');\n        assert.equal(m.isSame(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is later');\n        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is earlier');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), false, 'day is later');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), false, 'day is earlier');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), false, 'hour is later');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), false, 'hour is earlier');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), false, 'minute is later');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), false, 'minute is earlier');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), false, 'second is later');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), false, 'second is earlier');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), false, 'millisecond is later');\n        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), false, 'millisecond is earlier');\n        assert.equal(m.isSame(m, 'millisecond'), true, 'same moments are in the same millisecond');\n        assert.equal(+m, +mCopy, 'isSame millisecond should not change moment');\n    });\n\n    test('is same with utc offset moments', function (assert) {\n        assert.ok(moment.parseZone('2013-02-01T-05:00').isSame(moment('2013-02-01'), 'year'), 'zoned vs local moment');\n        assert.ok(moment('2013-02-01').isSame(moment('2013-02-01').utcOffset('-05:00'), 'year'), 'local vs zoned moment');\n        assert.ok(moment.parseZone('2013-02-01T-05:00').isSame(moment.parseZone('2013-02-01T-06:30'), 'year'),\n                'zoned vs (differently) zoned moment');\n    });\n\n    test('is same with invalid moments', function (assert) {\n        assert.equal(moment.invalid().isSame(moment.invalid()), false, 'invalid moments are not considered equal');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('is same or after');\n\n    test('is same or after without units', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isSameOrAfter(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), false, 'year is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), true, 'year is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), false, 'month is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), true, 'month is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), false, 'day is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), true, 'day is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), false, 'hour is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), true, 'hour is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), false, 'minute is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), true, 'minute is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), false, 'second is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), true, 'second is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), true, 'millisecond match');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), false, 'millisecond is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), true, 'millisecond is earlier');\n        assert.equal(m.isSameOrAfter(m), true, 'moments are the same as themselves');\n        assert.equal(+m, +mCopy, 'isSameOrAfter second should not change moment');\n    });\n\n    test('is same or after year', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year match');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');\n        assert.equal(m.isSameOrAfter(moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), true, 'exact start of year');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), true, 'exact end of year');\n        assert.equal(m.isSameOrAfter(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), false, 'start of next year');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), true, 'end of previous year');\n        assert.equal(m.isSameOrAfter(m, 'year'), true, 'same moments are in the same year');\n        assert.equal(+m, +mCopy, 'isSameOrAfter year should not change moment');\n    });\n\n    test('is same or after month', function (assert) {\n        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), true, 'month match');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');\n        assert.equal(m.isSameOrAfter(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'month'), true, 'year is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), false, 'month is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), true, 'month is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), true, 'exact start of month');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), true, 'exact end of month');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), false, 'start of next month');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), true, 'end of previous month');\n        assert.equal(m.isSameOrAfter(m, 'month'), true, 'same moments are in the same month');\n        assert.equal(+m, +mCopy, 'isSameOrAfter month should not change moment');\n    });\n\n    test('is same or after day', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), true, 'day match');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');\n        assert.equal(m.isSameOrAfter(moment(new Date(2012, 1, 2, 7, 8, 9, 10)), 'day'), false, 'year is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 1, 2, 7, 8, 9, 10)), 'day'), true, 'year is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), false, 'month is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 12, 2, 7, 8, 9, 10)), 'day'), true, 'month is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'day'), false, 'day is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 1, 7, 8, 9, 10)), 'day'), true, 'day is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 0, 0, 0, 0)), 'day'), true, 'exact start of day');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 23, 59, 59, 999)), 'day'), true, 'exact end of day');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 3, 0, 0, 0, 0)), 'day'), false, 'start of next day');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 1, 23, 59, 59, 999)), 'day'), true, 'end of previous day');\n        assert.equal(m.isSameOrAfter(m, 'day'), true, 'same moments are in the same day');\n        assert.equal(+m, +mCopy, 'isSameOrAfter day should not change moment');\n    });\n\n    test('is same or after hour', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'hour match');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');\n        assert.equal(m.isSameOrAfter(moment(new Date(2012, 1, 2, 3, 8, 9, 10)), 'hour'), false, 'year is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'year is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 2, 3, 8, 9, 10)), 'hour'), false, 'month is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 12, 2, 3, 8, 9, 10)), 'hour'), true, 'month is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 3, 3, 8, 9, 10)), 'hour'), false, 'day is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 1, 3, 8, 9, 10)), 'hour'), true, 'day is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 4, 8, 9, 10)), 'hour'), false, 'hour is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 2, 8, 9, 10)), 'hour'), true, 'hour is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 0, 0, 0)), 'hour'), true, 'exact start of hour');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 59, 59, 999)), 'hour'), true, 'exact end of hour');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hour'), false, 'start of next hour');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 2, 59, 59, 999)), 'hour'), true, 'end of previous hour');\n        assert.equal(m.isSameOrAfter(m, 'hour'), true, 'same moments are in the same hour');\n        assert.equal(+m, +mCopy, 'isSameOrAfter hour should not change moment');\n    });\n\n    test('is same or after minute', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minute'), true, 'minute match');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');\n        assert.equal(m.isSameOrAfter(moment(new Date(2012, 1, 2, 3, 4, 9, 10)), 'minute'), false, 'year is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 1, 2, 3, 4, 9, 10)), 'minute'), true, 'year is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), false, 'month is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 12, 2, 3, 4, 9, 10)), 'minute'), true, 'month is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 3, 3, 4, 9, 10)), 'minute'), false, 'day is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 1, 3, 4, 9, 10)), 'minute'), true, 'day is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 4, 4, 9, 10)), 'minute'), false, 'hour is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 2, 4, 9, 10)), 'minute'), true, 'hour is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 5, 9, 10)), 'minute'), false, 'minute is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 3, 9, 10)), 'minute'), true, 'minute is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 0, 0)), 'minute'), true, 'exact start of minute');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 59, 999)), 'minute'), true, 'exact end of minute');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 5, 0, 0)), 'minute'), false, 'start of next minute');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 3, 59, 999)), 'minute'), true, 'end of previous minute');\n        assert.equal(m.isSameOrAfter(m, 'minute'), true, 'same moments are in the same minute');\n        assert.equal(+m, +mCopy, 'isSameOrAfter minute should not change moment');\n    });\n\n    test('is same or after second', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'second'), true, 'second match');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');\n        assert.equal(m.isSameOrAfter(moment(new Date(2012, 1, 2, 3, 4, 5, 10)), 'second'), false, 'year is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 1, 2, 3, 4, 5, 10)), 'second'), true, 'year is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), false, 'month is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 12, 2, 3, 4, 5, 10)), 'second'), true, 'month is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 3, 3, 4, 5, 10)), 'second'), false, 'day is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 1, 3, 4, 5, 10)), 'second'), true, 'day is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 4, 4, 5, 10)), 'second'), false, 'hour is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 2, 4, 5, 10)), 'second'), true, 'hour is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 5, 5, 10)), 'second'), false, 'minute is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 3, 5, 10)), 'second'), true, 'minute is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 6, 10)), 'second'), false, 'second is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 4, 10)), 'second'), true, 'second is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 5, 0)), 'second'), true, 'exact start of second');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 5, 999)), 'second'), true, 'exact end of second');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 6, 0)), 'second'), false, 'start of next second');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 1, 2, 3, 4, 4, 999)), 'second'), true, 'end of previous second');\n        assert.equal(m.isSameOrAfter(m, 'second'), true, 'same moments are in the same second');\n        assert.equal(+m, +mCopy, 'isSameOrAfter second should not change moment');\n    });\n\n    test('is same or after millisecond', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'millisecond match');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'plural should work');\n        assert.equal(m.isSameOrAfter(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'year is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), true, 'month is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), false, 'day is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), true, 'day is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), false, 'hour is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), true, 'hour is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), false, 'minute is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), true, 'minute is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), false, 'second is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), true, 'second is earlier');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), false, 'millisecond is later');\n        assert.equal(m.isSameOrAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), true, 'millisecond is earlier');\n        assert.equal(m.isSameOrAfter(m, 'millisecond'), true, 'same moments are in the same millisecond');\n        assert.equal(+m, +mCopy, 'isSameOrAfter millisecond should not change moment');\n    });\n\n    test('is same or after with utc offset moments', function (assert) {\n        assert.ok(moment.parseZone('2013-02-01T-05:00').isSameOrAfter(moment('2013-02-01'), 'year'), 'zoned vs local moment');\n        assert.ok(moment('2013-02-01').isSameOrAfter(moment('2013-02-01').utcOffset('-05:00'), 'year'), 'local vs zoned moment');\n        assert.ok(moment.parseZone('2013-02-01T-05:00').isSameOrAfter(moment.parseZone('2013-02-01T-06:30'), 'year'),\n                'zoned vs (differently) zoned moment');\n    });\n\n    test('is same or after with invalid moments', function (assert) {\n        var m = moment(), invalid = moment.invalid();\n        assert.equal(invalid.isSameOrAfter(invalid), false, 'invalid moments are not considered equal');\n        assert.equal(m.isSameOrAfter(invalid), false, 'valid moment is not after invalid moment');\n        assert.equal(invalid.isSameOrAfter(m), false, 'invalid moment is not after valid moment');\n        assert.equal(m.isSameOrAfter(invalid, 'year'), false, 'invalid moment year');\n        assert.equal(m.isSameOrAfter(invalid, 'month'), false, 'invalid moment month');\n        assert.equal(m.isSameOrAfter(invalid, 'day'), false, 'invalid moment day');\n        assert.equal(m.isSameOrAfter(invalid, 'hour'), false, 'invalid moment hour');\n        assert.equal(m.isSameOrAfter(invalid, 'minute'), false, 'invalid moment minute');\n        assert.equal(m.isSameOrAfter(invalid, 'second'), false, 'invalid moment second');\n        assert.equal(m.isSameOrAfter(invalid, 'milliseconds'), false, 'invalid moment milliseconds');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('is same or before');\n\n    test('is same or before without units', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isSameOrBefore(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), true, 'year is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), false, 'year is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), true, 'month is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), false, 'month is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), true, 'day is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), false, 'day is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), true, 'hour is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), false, 'hour is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), true, 'minute is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), false, 'minute is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), true, 'second is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), false, 'second is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), true, 'millisecond match');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), true, 'millisecond is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), false, 'millisecond is earlier');\n        assert.equal(m.isSameOrBefore(m), true, 'moments are the same as themselves');\n        assert.equal(+m, +mCopy, 'isSameOrBefore second should not change moment');\n    });\n\n    test('is same or before year', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year match');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');\n        assert.equal(m.isSameOrBefore(moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), true, 'exact start of year');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), true, 'exact end of year');\n        assert.equal(m.isSameOrBefore(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), true, 'start of next year');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of previous year');\n        assert.equal(m.isSameOrBefore(m, 'year'), true, 'same moments are in the same year');\n        assert.equal(+m, +mCopy, 'isSameOrBefore year should not change moment');\n    });\n\n    test('is same or before month', function (assert) {\n        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), true, 'month match');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');\n        assert.equal(m.isSameOrBefore(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), true, 'year is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), true, 'month is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), true, 'exact start of month');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), true, 'exact end of month');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), true, 'start of next month');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), false, 'end of previous month');\n        assert.equal(m.isSameOrBefore(m, 'month'), true, 'same moments are in the same month');\n        assert.equal(+m, +mCopy, 'isSameOrBefore month should not change moment');\n    });\n\n    test('is same or before day', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), true, 'day match');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');\n        assert.equal(m.isSameOrBefore(moment(new Date(2012, 1, 2, 7, 8, 9, 10)), 'day'), true, 'year is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 1, 2, 7, 8, 9, 10)), 'day'), false, 'year is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), true, 'month is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 12, 2, 7, 8, 9, 10)), 'day'), false, 'month is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'day'), true, 'day is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 1, 7, 8, 9, 10)), 'day'), false, 'day is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 0, 0, 0, 0)), 'day'), true, 'exact start of day');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 23, 59, 59, 999)), 'day'), true, 'exact end of day');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 3, 0, 0, 0, 0)), 'day'), true, 'start of next day');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 1, 23, 59, 59, 999)), 'day'), false, 'end of previous day');\n        assert.equal(m.isSameOrBefore(m, 'day'), true, 'same moments are in the same day');\n        assert.equal(+m, +mCopy, 'isSameOrBefore day should not change moment');\n    });\n\n    test('is same or before hour', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'hour match');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');\n        assert.equal(m.isSameOrBefore(moment(new Date(2012, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'year is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 1, 2, 3, 8, 9, 10)), 'hour'), false, 'year is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 2, 2, 3, 8, 9, 10)), 'hour'), true, 'month is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 12, 2, 3, 8, 9, 10)), 'hour'), false, 'month is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 3, 3, 8, 9, 10)), 'hour'), true, 'day is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 1, 3, 8, 9, 10)), 'hour'), false, 'day is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 4, 8, 9, 10)), 'hour'), true, 'hour is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 2, 8, 9, 10)), 'hour'), false, 'hour is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 0, 0, 0)), 'hour'), true, 'exact start of hour');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 59, 59, 999)), 'hour'), true, 'exact end of hour');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hour'), true, 'start of next hour');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 2, 59, 59, 999)), 'hour'), false, 'end of previous hour');\n        assert.equal(m.isSameOrBefore(m, 'hour'), true, 'same moments are in the same hour');\n        assert.equal(+m, +mCopy, 'isSameOrBefore hour should not change moment');\n    });\n\n    test('is same or before minute', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minute'), true, 'minute match');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');\n        assert.equal(m.isSameOrBefore(moment(new Date(2012, 1, 2, 3, 4, 9, 10)), 'minute'), true, 'year is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 1, 2, 3, 4, 9, 10)), 'minute'), false, 'year is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), true, 'month is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 12, 2, 3, 4, 9, 10)), 'minute'), false, 'month is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 3, 3, 4, 9, 10)), 'minute'), true, 'day is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 1, 3, 4, 9, 10)), 'minute'), false, 'day is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 4, 4, 9, 10)), 'minute'), true, 'hour is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 2, 4, 9, 10)), 'minute'), false, 'hour is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 5, 9, 10)), 'minute'), true, 'minute is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 3, 9, 10)), 'minute'), false, 'minute is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 4, 0, 0)), 'minute'), true, 'exact start of minute');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 4, 59, 999)), 'minute'), true, 'exact end of minute');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 5, 0, 0)), 'minute'), true, 'start of next minute');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 3, 59, 999)), 'minute'), false, 'end of previous minute');\n        assert.equal(m.isSameOrBefore(m, 'minute'), true, 'same moments are in the same minute');\n        assert.equal(+m, +mCopy, 'isSameOrBefore minute should not change moment');\n    });\n\n    test('is same or before second', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'second'), true, 'second match');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');\n        assert.equal(m.isSameOrBefore(moment(new Date(2012, 1, 2, 3, 4, 5, 10)), 'second'), true, 'year is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 1, 2, 3, 4, 5, 10)), 'second'), false, 'year is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), true, 'month is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 12, 2, 3, 4, 5, 10)), 'second'), false, 'month is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 3, 3, 4, 5, 10)), 'second'), true, 'day is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 1, 3, 4, 5, 10)), 'second'), false, 'day is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 4, 4, 5, 10)), 'second'), true, 'hour is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 2, 4, 5, 10)), 'second'), false, 'hour is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 5, 5, 10)), 'second'), true, 'minute is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 3, 5, 10)), 'second'), false, 'minute is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 4, 6, 10)), 'second'), true, 'second is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 4, 4, 10)), 'second'), false, 'second is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 4, 5, 0)), 'second'), true, 'exact start of second');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 4, 5, 999)), 'second'), true, 'exact end of second');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 4, 6, 0)), 'second'), true, 'start of next second');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 1, 2, 3, 4, 4, 999)), 'second'), false, 'end of previous second');\n        assert.equal(m.isSameOrBefore(m, 'second'), true, 'same moments are in the same second');\n        assert.equal(+m, +mCopy, 'isSameOrBefore second should not change moment');\n    });\n\n    test('is same or before millisecond', function (assert) {\n        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'millisecond match');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'plural should work');\n        assert.equal(m.isSameOrBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'year is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), true, 'month is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), true, 'day is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), false, 'day is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), true, 'hour is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), false, 'hour is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), true, 'minute is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), false, 'minute is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), true, 'second is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), false, 'second is earlier');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), true, 'millisecond is later');\n        assert.equal(m.isSameOrBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), false, 'millisecond is earlier');\n        assert.equal(m.isSameOrBefore(m, 'millisecond'), true, 'same moments are in the same millisecond');\n        assert.equal(+m, +mCopy, 'isSameOrBefore millisecond should not change moment');\n    });\n\n    test('is same with utc offset moments', function (assert) {\n        assert.ok(moment.parseZone('2013-02-01T-05:00').isSameOrBefore(moment('2013-02-01'), 'year'), 'zoned vs local moment');\n        assert.ok(moment('2013-02-01').isSameOrBefore(moment('2013-02-01').utcOffset('-05:00'), 'year'), 'local vs zoned moment');\n        assert.ok(moment.parseZone('2013-02-01T-05:00').isSameOrBefore(moment.parseZone('2013-02-01T-06:30'), 'year'),\n                'zoned vs (differently) zoned moment');\n    });\n\n    test('is same with invalid moments', function (assert) {\n        var m = moment(), invalid = moment.invalid();\n        assert.equal(invalid.isSameOrBefore(invalid), false, 'invalid moments are not considered equal');\n        assert.equal(m.isSameOrBefore(invalid), false, 'valid moment is not before invalid moment');\n        assert.equal(invalid.isSameOrBefore(m), false, 'invalid moment is not before valid moment');\n        assert.equal(m.isSameOrBefore(invalid, 'year'), false, 'invalid moment year');\n        assert.equal(m.isSameOrBefore(invalid, 'month'), false, 'invalid moment month');\n        assert.equal(m.isSameOrBefore(invalid, 'day'), false, 'invalid moment day');\n        assert.equal(m.isSameOrBefore(invalid, 'hour'), false, 'invalid moment hour');\n        assert.equal(m.isSameOrBefore(invalid, 'minute'), false, 'invalid moment minute');\n        assert.equal(m.isSameOrBefore(invalid, 'second'), false, 'invalid moment second');\n        assert.equal(m.isSameOrBefore(invalid, 'milliseconds'), false, 'invalid moment milliseconds');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('is valid');\n\n    test('array bad month', function (assert) {\n        assert.equal(moment([2010, -1]).isValid(), false, 'month -1 invalid');\n        assert.equal(moment([2100, 12]).isValid(), false, 'month 12 invalid');\n    });\n\n    test('array good month', function (assert) {\n        for (var i = 0; i < 12; i++) {\n            assert.equal(moment([2010, i]).isValid(), true, 'month ' + i);\n            assert.equal(moment.utc([2010, i]).isValid(), true, 'month ' + i);\n        }\n    });\n\n    test('array bad date', function (assert) {\n        var tests = [\n            moment([2010, 0, 0]),\n            moment([2100, 0, 32]),\n            moment.utc([2010, 0, 0]),\n            moment.utc([2100, 0, 32])\n        ],\n        i, m;\n\n        for (i in tests) {\n            m = tests[i];\n            assert.equal(m.isValid(), false);\n        }\n    });\n\n    test('h/hh with hour > 12', function (assert) {\n        assert.ok(moment('06/20/2014 11:51 PM', 'MM/DD/YYYY hh:mm A', true).isValid(), '11 for hh');\n        assert.ok(moment('06/20/2014 11:51 AM', 'MM/DD/YYYY hh:mm A', true).isValid(), '11 for hh');\n        assert.ok(moment('06/20/2014 23:51 PM', 'MM/DD/YYYY hh:mm A').isValid(), 'non-strict validity 23 for hh');\n        assert.ok(moment('06/20/2014 23:51 PM', 'MM/DD/YYYY hh:mm A').parsingFlags().bigHour, 'non-strict bigHour 23 for hh');\n        assert.ok(!moment('06/20/2014 23:51 PM', 'MM/DD/YYYY hh:mm A', true).isValid(), 'validity 23 for hh');\n        assert.ok(moment('06/20/2014 23:51 PM', 'MM/DD/YYYY hh:mm A', true).parsingFlags().bigHour, 'bigHour 23 for hh');\n    });\n\n    test('array bad date leap year', function (assert) {\n        assert.equal(moment([2010, 1, 29]).isValid(), false, '2010 feb 29');\n        assert.equal(moment([2100, 1, 29]).isValid(), false, '2100 feb 29');\n        assert.equal(moment([2008, 1, 30]).isValid(), false, '2008 feb 30');\n        assert.equal(moment([2000, 1, 30]).isValid(), false, '2000 feb 30');\n\n        assert.equal(moment.utc([2010, 1, 29]).isValid(), false, 'utc 2010 feb 29');\n        assert.equal(moment.utc([2100, 1, 29]).isValid(), false, 'utc 2100 feb 29');\n        assert.equal(moment.utc([2008, 1, 30]).isValid(), false, 'utc 2008 feb 30');\n        assert.equal(moment.utc([2000, 1, 30]).isValid(), false, 'utc 2000 feb 30');\n    });\n\n    test('string + formats bad date', function (assert) {\n        assert.equal(moment('2020-00-00', []).isValid(), false, 'invalid on empty array');\n        assert.equal(moment('2020-00-00', ['YYYY-MM-DD', 'DD-MM-YYYY']).isValid(), false, 'invalid on all in array');\n        assert.equal(moment('2020-00-00', ['DD-MM-YYYY', 'YYYY-MM-DD']).isValid(), false, 'invalid on all in array');\n        assert.equal(moment('2020-01-01', ['YYYY-MM-DD', 'DD-MM-YYYY']).isValid(), true, 'valid on first');\n        assert.equal(moment('2020-01-01', ['DD-MM-YYYY', 'YYYY-MM-DD']).isValid(), true, 'valid on last');\n        assert.equal(moment('2020-01-01', ['YYYY-MM-DD', 'YYYY-DD-MM']).isValid(), true, 'valid on both');\n        assert.equal(moment('2020-13-01', ['YYYY-MM-DD', 'YYYY-DD-MM']).isValid(), true, 'valid on last');\n\n        assert.equal(moment('12-13-2012', ['DD-MM-YYYY', 'YYYY-MM-DD']).isValid(), false, 'month rollover');\n        assert.equal(moment('12-13-2012', ['DD-MM-YYYY', 'DD-MM-YYYY']).isValid(), false, 'month rollover');\n        assert.equal(moment('38-12-2012', ['DD-MM-YYYY']).isValid(), false, 'day rollover');\n    });\n\n    test('string nonsensical with format', function (assert) {\n        assert.equal(moment('fail', 'MM-DD-YYYY').isValid(), false, 'string \\'fail\\' with format \\'MM-DD-YYYY\\'');\n        assert.equal(moment('xx-xx-2001', 'DD-MM-YYY').isValid(), true, 'string \\'xx-xx-2001\\' with format \\'MM-DD-YYYY\\'');\n    });\n\n    test('string with bad month name', function (assert) {\n        assert.equal(moment('01-Nam-2012', 'DD-MMM-YYYY').isValid(), false, '\\'Nam\\' is an invalid month');\n        assert.equal(moment('01-Aug-2012', 'DD-MMM-YYYY').isValid(), true, '\\'Aug\\' is a valid month');\n    });\n\n    test('string with spaceless format', function (assert) {\n        assert.equal(moment('10Sep2001', 'DDMMMYYYY').isValid(), true, 'Parsing 10Sep2001 should result in a valid date');\n    });\n\n    test('invalid string iso 8601', function (assert) {\n        var tests = [\n            '2010-00-00',\n            '2010-01-00',\n            '2010-01-40',\n            '2010-01-01T24:01',  // 24:00:00 is actually valid\n            '2010-01-01T23:60',\n            '2010-01-01T23:59:60'\n        ], i;\n\n        for (i = 0; i < tests.length; i++) {\n            assert.equal(moment(tests[i], moment.ISO_8601).isValid(), false, tests[i] + ' should be invalid');\n            assert.equal(moment.utc(tests[i], moment.ISO_8601).isValid(), false, tests[i] + ' should be invalid');\n        }\n    });\n\n    test('invalid string iso 8601 + timezone', function (assert) {\n        var tests = [\n            '2010-00-00T+00:00',\n            '2010-01-00T+00:00',\n            '2010-01-40T+00:00',\n            '2010-01-40T24:01+00:00',\n            '2010-01-40T23:60+00:00',\n            '2010-01-40T23:59:60+00:00',\n            '2010-01-40T23:59:59.9999+00:00',\n            '2010-01-40T23:59:59,9999+00:00'\n        ], i;\n\n        for (i = 0; i < tests.length; i++) {\n            assert.equal(moment(tests[i], moment.ISO_8601).isValid(), false, tests[i] + ' should be invalid');\n            assert.equal(moment.utc(tests[i], moment.ISO_8601).isValid(), false, tests[i] + ' should be invalid');\n        }\n    });\n\n    test('valid string iso 8601 - not strict', function (assert) {\n        var tests = [\n            '2010-01-30 00:00:00,000Z',\n            '20100101',\n            '20100130',\n            '20100130T23+00:00',\n            '20100130T2359+0000',\n            '20100130T235959+0000',\n            '20100130T235959,999+0000',\n            '20100130T235959,999-0700',\n            '20100130T000000,000+0700',\n            '20100130 000000,000Z'\n        ];\n\n        for (var i = 0; i < tests.length; i++) {\n            assert.equal(moment(tests[i]).isValid(), true, tests[i] + ' should be valid in normal');\n            assert.equal(moment.utc(tests[i]).isValid(), true, tests[i] + ' should be valid in normal');\n        }\n    });\n\n    test('valid string iso 8601 + timezone', function (assert) {\n        var tests = [\n            '2010-01-01',\n            '2010-01-30',\n            '2010-01-30T23+00:00',\n            '2010-01-30T23:59+00:00',\n            '2010-01-30T23:59:59+00:00',\n            '2010-01-30T23:59:59.999+00:00',\n            '2010-01-30T23:59:59.999-07:00',\n            '2010-01-30T00:00:00.000+07:00',\n            '2010-01-30T23:59:59.999-07',\n            '2010-01-30T00:00:00.000+07',\n            '2010-01-30 00:00:00.000Z'\n        ], i;\n\n        for (i = 0; i < tests.length; i++) {\n            assert.equal(moment(tests[i]).isValid(), true, tests[i] + ' should be valid in normal');\n            assert.equal(moment.utc(tests[i]).isValid(), true, tests[i] + ' should be valid in normal');\n            assert.equal(moment(tests[i], moment.ISO_8601, true).isValid(), true, tests[i] + ' should be valid in strict');\n            assert.equal(moment.utc(tests[i], moment.ISO_8601, true).isValid(), true, tests[i] + ' should be valid in strict');\n        }\n    });\n\n    test('invalidAt', function (assert) {\n        assert.equal(moment([2000, 12]).invalidAt(), 1, 'month 12 is invalid: 0-11');\n        assert.equal(moment([2000, 1, 30]).invalidAt(), 2, '30 is not a valid february day');\n        assert.equal(moment([2000, 1, 29, 25]).invalidAt(), 3, '25 is invalid hour');\n        assert.equal(moment([2000, 1, 29, 24,  1]).invalidAt(), 3, '24:01 is invalid hour');\n        assert.equal(moment([2000, 1, 29, 23, 60]).invalidAt(), 4, '60 is invalid minute');\n        assert.equal(moment([2000, 1, 29, 23, 59, 60]).invalidAt(), 5, '60 is invalid second');\n        assert.equal(moment([2000, 1, 29, 23, 59, 59, 1000]).invalidAt(), 6, '1000 is invalid millisecond');\n        assert.equal(moment([2000, 1, 29, 23, 59, 59, 999]).invalidAt(), -1, '-1 if everything is fine');\n    });\n\n    test('valid Unix timestamp', function (assert) {\n        assert.equal(moment(1371065286, 'X').isValid(), true, 'number integer');\n        assert.equal(moment(1379066897.0, 'X').isValid(), true, 'number whole 1dp');\n        assert.equal(moment(1379066897.7, 'X').isValid(), true, 'number 1dp');\n        assert.equal(moment(1379066897.00, 'X').isValid(), true, 'number whole 2dp');\n        assert.equal(moment(1379066897.07, 'X').isValid(), true, 'number 2dp');\n        assert.equal(moment(1379066897.17, 'X').isValid(), true, 'number 2dp');\n        assert.equal(moment(1379066897.000, 'X').isValid(), true, 'number whole 3dp');\n        assert.equal(moment(1379066897.007, 'X').isValid(), true, 'number 3dp');\n        assert.equal(moment(1379066897.017, 'X').isValid(), true, 'number 3dp');\n        assert.equal(moment(1379066897.157, 'X').isValid(), true, 'number 3dp');\n        assert.equal(moment('1371065286', 'X').isValid(), true, 'string integer');\n        assert.equal(moment('1379066897.', 'X').isValid(), true, 'string trailing .');\n        assert.equal(moment('1379066897.0', 'X').isValid(), true, 'string whole 1dp');\n        assert.equal(moment('1379066897.7', 'X').isValid(), true, 'string 1dp');\n        assert.equal(moment('1379066897.00', 'X').isValid(), true, 'string whole 2dp');\n        assert.equal(moment('1379066897.07', 'X').isValid(), true, 'string 2dp');\n        assert.equal(moment('1379066897.17', 'X').isValid(), true, 'string 2dp');\n        assert.equal(moment('1379066897.000', 'X').isValid(), true, 'string whole 3dp');\n        assert.equal(moment('1379066897.007', 'X').isValid(), true, 'string 3dp');\n        assert.equal(moment('1379066897.017', 'X').isValid(), true, 'string 3dp');\n        assert.equal(moment('1379066897.157', 'X').isValid(), true, 'string 3dp');\n    });\n\n    test('invalid Unix timestamp', function (assert) {\n        assert.equal(moment(undefined, 'X').isValid(), false, 'undefined');\n        assert.equal(moment('undefined', 'X').isValid(), false, 'string undefined');\n        try {\n            assert.equal(moment(null, 'X').isValid(), false, 'null');\n        } catch (e) {\n            assert.ok(true, 'null');\n        }\n\n        assert.equal(moment('null', 'X').isValid(), false, 'string null');\n        assert.equal(moment([], 'X').isValid(), false, 'array');\n        assert.equal(moment('{}', 'X').isValid(), false, 'object');\n        try {\n            assert.equal(moment('', 'X').isValid(), false, 'string empty');\n        } catch (e) {\n            assert.ok(true, 'string empty');\n        }\n\n        assert.equal(moment(' ', 'X').isValid(), false, 'string space');\n    });\n\n    test('valid Unix offset milliseconds', function (assert) {\n        assert.equal(moment(1234567890123, 'x').isValid(), true, 'number integer');\n        assert.equal(moment('1234567890123', 'x').isValid(), true, 'string integer');\n    });\n\n    test('invalid Unix offset milliseconds', function (assert) {\n        assert.equal(moment(undefined, 'x').isValid(), false, 'undefined');\n        assert.equal(moment('undefined', 'x').isValid(), false, 'string undefined');\n        try {\n            assert.equal(moment(null, 'x').isValid(), false, 'null');\n        } catch (e) {\n            assert.ok(true, 'null');\n        }\n\n        assert.equal(moment('null', 'x').isValid(), false, 'string null');\n        assert.equal(moment([], 'x').isValid(), false, 'array');\n        assert.equal(moment('{}', 'x').isValid(), false, 'object');\n        try {\n            assert.equal(moment('', 'x').isValid(), false, 'string empty');\n        } catch (e) {\n            assert.ok(true, 'string empty');\n        }\n\n        assert.equal(moment(' ', 'x').isValid(), false, 'string space');\n    });\n\n    test('empty', function (assert) {\n        assert.equal(moment(null).isValid(), false, 'null');\n        assert.equal(moment('').isValid(), false, 'empty string');\n        assert.equal(moment(null, 'YYYY').isValid(), false, 'format + null');\n        assert.equal(moment('', 'YYYY').isValid(), false, 'format + empty string');\n        assert.equal(moment(' ', 'YYYY').isValid(), false, 'format + empty when trimmed');\n    });\n\n    test('days of the year', function (assert) {\n        assert.equal(moment('2010 300', 'YYYY DDDD').isValid(), true, 'day 300 of year valid');\n        assert.equal(moment('2010 365', 'YYYY DDDD').isValid(), true, 'day 365 of year valid');\n        assert.equal(moment('2010 366', 'YYYY DDDD').isValid(), false, 'day 366 of year invalid');\n        assert.equal(moment('2012 365', 'YYYY DDDD').isValid(), true, 'day 365 of leap year valid');\n        assert.equal(moment('2012 366', 'YYYY DDDD').isValid(), true, 'day 366 of leap year valid');\n        assert.equal(moment('2012 367', 'YYYY DDDD').isValid(), false, 'day 367 of leap year invalid');\n    });\n\n    test('24:00:00.000 is valid', function (assert) {\n        assert.equal(moment('2014-01-01 24', 'YYYY-MM-DD HH').isValid(), true, '24 is valid');\n        assert.equal(moment('2014-01-01 24:00', 'YYYY-MM-DD HH:mm').isValid(), true, '24:00 is valid');\n        assert.equal(moment('2014-01-01 24:01', 'YYYY-MM-DD HH:mm').isValid(), false, '24:01 is not valid');\n    });\n\n    test('oddball permissiveness', function (assert) {\n        //https://github.com/moment/moment/issues/1128\n        assert.ok(moment('2010-10-3199', ['MM/DD/YYYY', 'MM-DD-YYYY', 'YYYY-MM-DD']).isValid());\n\n        //https://github.com/moment/moment/issues/1122\n        assert.ok(moment('3:25', ['h:mma', 'hh:mma', 'H:mm', 'HH:mm']).isValid());\n    });\n\n    test('0 hour is invalid in strict', function (assert) {\n        assert.equal(moment('00:01', 'hh:mm', true).isValid(), false, '00 hour is invalid in strict');\n        assert.equal(moment('00:01', 'hh:mm').isValid(), true, '00 hour is valid in normal');\n        assert.equal(moment('0:01', 'h:mm', true).isValid(), false, '0 hour is invalid in strict');\n        assert.equal(moment('0:01', 'h:mm').isValid(), true, '0 hour is valid in normal');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('leap year');\n\n    test('leap year', function (assert) {\n        assert.equal(moment([2010, 0, 1]).isLeapYear(), false, '2010');\n        assert.equal(moment([2100, 0, 1]).isLeapYear(), false, '2100');\n        assert.equal(moment([2008, 0, 1]).isLeapYear(), true, '2008');\n        assert.equal(moment([2000, 0, 1]).isLeapYear(), true, '2000');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('listers');\n\n    test('default', function (assert) {\n        assert.deepEqual(moment.months(), ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']);\n        assert.deepEqual(moment.monthsShort(), ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']);\n        assert.deepEqual(moment.weekdays(), ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']);\n        assert.deepEqual(moment.weekdaysShort(), ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']);\n        assert.deepEqual(moment.weekdaysMin(), ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']);\n    });\n\n    test('index', function (assert) {\n        assert.equal(moment.months(0), 'January');\n        assert.equal(moment.months(2), 'March');\n        assert.equal(moment.monthsShort(0), 'Jan');\n        assert.equal(moment.monthsShort(2), 'Mar');\n        assert.equal(moment.weekdays(0), 'Sunday');\n        assert.equal(moment.weekdays(2), 'Tuesday');\n        assert.equal(moment.weekdaysShort(0), 'Sun');\n        assert.equal(moment.weekdaysShort(2), 'Tue');\n        assert.equal(moment.weekdaysMin(0), 'Su');\n        assert.equal(moment.weekdaysMin(2), 'Tu');\n    });\n\n    test('localized', function (assert) {\n        var months = 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_'),\n            monthsShort = 'on_tw_th_fo_fi_si_se_ei_ni_te_el_tw'.split('_'),\n            weekdays = 'one_two_three_four_five_six_seven'.split('_'),\n            weekdaysShort = 'on_tw_th_fo_fi_si_se'.split('_'),\n            weekdaysMin = '1_2_3_4_5_6_7'.split('_'),\n            weekdaysLocale = 'four_five_six_seven_one_two_three'.split('_'),\n            weekdaysShortLocale = 'fo_fi_si_se_on_tw_th'.split('_'),\n            weekdaysMinLocale = '4_5_6_7_1_2_3'.split('_'),\n            week = {\n                dow : 3,\n                doy : 6\n            };\n\n        moment.locale('numerologists', {\n            months : months,\n            monthsShort : monthsShort,\n            weekdays : weekdays,\n            weekdaysShort: weekdaysShort,\n            weekdaysMin: weekdaysMin,\n            week : week\n        });\n\n        assert.deepEqual(moment.months(), months);\n        assert.deepEqual(moment.monthsShort(), monthsShort);\n        assert.deepEqual(moment.weekdays(), weekdays);\n        assert.deepEqual(moment.weekdaysShort(), weekdaysShort);\n        assert.deepEqual(moment.weekdaysMin(), weekdaysMin);\n\n        assert.equal(moment.months(0), 'one');\n        assert.equal(moment.monthsShort(0), 'on');\n        assert.equal(moment.weekdays(0), 'one');\n        assert.equal(moment.weekdaysShort(0), 'on');\n        assert.equal(moment.weekdaysMin(0), '1');\n\n        assert.equal(moment.months(2), 'three');\n        assert.equal(moment.monthsShort(2), 'th');\n        assert.equal(moment.weekdays(2), 'three');\n        assert.equal(moment.weekdaysShort(2), 'th');\n        assert.equal(moment.weekdaysMin(2), '3');\n\n        assert.deepEqual(moment.weekdays(true), weekdaysLocale);\n        assert.deepEqual(moment.weekdaysShort(true), weekdaysShortLocale);\n        assert.deepEqual(moment.weekdaysMin(true), weekdaysMinLocale);\n\n        assert.equal(moment.weekdays(true, 0), 'four');\n        assert.equal(moment.weekdaysShort(true, 0), 'fo');\n        assert.equal(moment.weekdaysMin(true, 0), '4');\n\n        assert.equal(moment.weekdays(false, 2), 'three');\n        assert.equal(moment.weekdaysShort(false, 2), 'th');\n        assert.equal(moment.weekdaysMin(false, 2), '3');\n    });\n\n    test('with functions', function (assert) {\n        var monthsShort = 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_'),\n            monthsShortWeird = 'onesy_twosy_threesy_foursy_fivesy_sixsy_sevensy_eightsy_ninesy_tensy_elevensy_twelvesy'.split('_');\n\n        moment.locale('difficult', {\n\n            monthsShort: function (m, format) {\n                var arr = format.match(/-MMM-/) ? monthsShortWeird : monthsShort;\n                return arr[m.month()];\n            }\n        });\n\n        assert.deepEqual(moment.monthsShort(), monthsShort);\n        assert.deepEqual(moment.monthsShort('MMM'), monthsShort);\n        assert.deepEqual(moment.monthsShort('-MMM-'), monthsShortWeird);\n\n        assert.deepEqual(moment.monthsShort('MMM', 2), 'three');\n        assert.deepEqual(moment.monthsShort('-MMM-', 2), 'threesy');\n        assert.deepEqual(moment.monthsShort(2), 'three');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    var indexOf;\n\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function (o) {\n            // I know\n            var i;\n            for (i = 0; i < this.length; ++i) {\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n\n    module('locale', {\n        setup : function () {\n            // TODO: Remove once locales are switched to ES6\n            each([{\n                name: 'en-gb',\n                data: {}\n            }, {\n                name: 'en-ca',\n                data: {}\n            }, {\n                name: 'es',\n                data: {\n                    relativeTime: {past: 'hace %s', s: 'unos segundos', d: 'un d\u00c3\u00ada'},\n                    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_')\n                }\n            }, {\n                name: 'fr',\n                data: {}\n            }, {\n                name: 'fr-ca',\n                data: {}\n            }, {\n                name: 'it',\n                data: {}\n            }, {\n                name: 'zh-cn',\n                data: {\n                    months: '\u00e4\u00b8\u0080\u00e6\u009c\u0088_\u00e4\u00ba\u008c\u00e6\u009c\u0088_\u00e4\u00b8\u0089\u00e6\u009c\u0088_\u00e5\u009b\u009b\u00e6\u009c\u0088_\u00e4\u00ba\u0094\u00e6\u009c\u0088_\u00e5\u0085\u00ad\u00e6\u009c\u0088_\u00e4\u00b8\u0083\u00e6\u009c\u0088_\u00e5\u0085\u00ab\u00e6\u009c\u0088_\u00e4\u00b9\u009d\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e4\u00b8\u0080\u00e6\u009c\u0088_\u00e5\u008d\u0081\u00e4\u00ba\u008c\u00e6\u009c\u0088'.split('_')\n                }\n            }], function (locale) {\n                if (moment.locale(locale.name) !== locale.name) {\n                    moment.defineLocale(locale.name, locale.data);\n                }\n            });\n            moment.locale('en');\n        }\n    });\n\n    test('library getters and setters', function (assert) {\n        var r = moment.locale('en');\n\n        assert.equal(r, 'en', 'locale should return en by default');\n        assert.equal(moment.locale(), 'en', 'locale should return en by default');\n\n        moment.locale('fr');\n        assert.equal(moment.locale(), 'fr', 'locale should return the changed locale');\n\n        moment.locale('en-gb');\n        assert.equal(moment.locale(), 'en-gb', 'locale should return the changed locale');\n\n        moment.locale('en');\n        assert.equal(moment.locale(), 'en', 'locale should reset');\n\n        moment.locale('does-not-exist');\n        assert.equal(moment.locale(), 'en', 'locale should reset');\n\n        moment.locale('EN');\n        assert.equal(moment.locale(), 'en', 'Normalize locale key case');\n\n        moment.locale('EN_gb');\n        assert.equal(moment.locale(), 'en-gb', 'Normalize locale key underscore');\n    });\n\n    test('library setter array of locales', function (assert) {\n        assert.equal(moment.locale(['non-existent', 'fr', 'also-non-existent']), 'fr', 'passing an array uses the first valid locale');\n        assert.equal(moment.locale(['es', 'fr', 'also-non-existent']), 'es', 'passing an array uses the first valid locale');\n    });\n\n    test('library setter locale substrings', function (assert) {\n        assert.equal(moment.locale('fr-crap'), 'fr', 'use substrings');\n        assert.equal(moment.locale('fr-does-not-exist'), 'fr', 'uses deep substrings');\n        assert.equal(moment.locale('fr-CA-does-not-exist'), 'fr-ca', 'uses deepest substring');\n    });\n\n    test('library getter locale array and substrings', function (assert) {\n        assert.equal(moment.locale(['en-CH', 'fr']), 'en', 'prefer root locale to shallower ones');\n        assert.equal(moment.locale(['en-gb-leeds', 'en-CA']), 'en-gb', 'prefer root locale to shallower ones');\n        assert.equal(moment.locale(['en-fake', 'en-CA']), 'en-ca', 'prefer alternatives with shared roots');\n        assert.equal(moment.locale(['en-fake', 'en-fake2', 'en-ca']), 'en-ca', 'prefer alternatives with shared roots');\n        assert.equal(moment.locale(['fake-CA', 'fake-MX', 'fr']), 'fr', 'always find something if possible');\n        assert.equal(moment.locale(['fake-CA', 'fake-MX', 'fr']), 'fr', 'always find something if possible');\n        assert.equal(moment.locale(['fake-CA', 'fake-MX', 'fr-fake-fake-fake']), 'fr', 'always find something if possible');\n        assert.equal(moment.locale(['en', 'en-CA']), 'en', 'prefer earlier if it works');\n    });\n\n    test('library ensure inheritance', function (assert) {\n        moment.locale('made-up', {\n            // I put them out of order\n            months : 'February_March_April_May_June_July_August_September_October_November_December_January'.split('_')\n            // the rest of the properties should be inherited.\n        });\n\n        assert.equal(moment([2012, 5, 6]).format('MMMM'), 'July', 'Override some of the configs');\n        assert.equal(moment([2012, 5, 6]).format('MMM'), 'Jun', 'But not all of them');\n    });\n\n    test('library ensure inheritance LT L LL LLL LLLL', function (assert) {\n        var locale = 'test-inherit-lt';\n\n        moment.defineLocale(locale, {\n            longDateFormat : {\n                LT : '-[LT]-',\n                L : '-[L]-',\n                LL : '-[LL]-',\n                LLL : '-[LLL]-',\n                LLLL : '-[LLLL]-'\n            },\n            calendar : {\n                sameDay : '[sameDay] LT',\n                nextDay : '[nextDay] L',\n                nextWeek : '[nextWeek] LL',\n                lastDay : '[lastDay] LLL',\n                lastWeek : '[lastWeek] LLLL',\n                sameElse : 'L'\n            }\n        });\n\n        moment.locale('es');\n\n        assert.equal(moment().locale(locale).calendar(), 'sameDay -LT-', 'Should use instance locale in LT formatting');\n        assert.equal(moment().add(1, 'days').locale(locale).calendar(), 'nextDay -L-', 'Should use instance locale in L formatting');\n        assert.equal(moment().add(-1, 'days').locale(locale).calendar(), 'lastDay -LLL-', 'Should use instance locale in LL formatting');\n        assert.equal(moment().add(4, 'days').locale(locale).calendar(), 'nextWeek -LL-', 'Should use instance locale in LLL formatting');\n        assert.equal(moment().add(-4, 'days').locale(locale).calendar(), 'lastWeek -LLLL-', 'Should use instance locale in LLLL formatting');\n    });\n\n    test('library localeData', function (assert) {\n        moment.locale('en');\n\n        var jan = moment([2000, 0]);\n\n        assert.equal(moment.localeData().months(jan), 'January', 'no arguments returns global');\n        assert.equal(moment.localeData('zh-cn').months(jan), '\u00e4\u00b8\u0080\u00e6\u009c\u0088', 'a string returns the locale based on key');\n        assert.equal(moment.localeData(moment().locale('es')).months(jan), 'enero', 'if you pass in a moment it uses the moment\\'s locale');\n    });\n\n    test('library deprecations', function (assert) {\n        test.expectedDeprecations('moment.lang');\n        moment.lang('dude', {months: ['Movember']});\n        assert.equal(moment.locale(), 'dude', 'setting the lang sets the locale');\n        assert.equal(moment.lang(), moment.locale());\n        assert.equal(moment.langData(), moment.localeData(), 'langData is localeData');\n        moment.defineLocale('dude', null);\n    });\n\n    test('defineLocale', function (assert) {\n        moment.locale('en');\n        moment.defineLocale('dude', {months: ['Movember']});\n        assert.equal(moment().locale(), 'dude', 'defineLocale also sets it');\n        assert.equal(moment().locale('dude').locale(), 'dude', 'defineLocale defines a locale');\n        moment.defineLocale('dude', null);\n    });\n\n    test('locales', function (assert) {\n        moment.defineLocale('dude', {months: ['Movember']});\n        assert.equal(true, !!~indexOf.call(moment.locales(), 'dude'), 'locales returns an array of defined locales');\n        assert.equal(true, !!~indexOf.call(moment.locales(), 'en'), 'locales should always include english');\n        moment.defineLocale('dude', null);\n    });\n\n    test('library convenience', function (assert) {\n        moment.locale('something', {week: {dow: 3}});\n        moment.locale('something');\n        assert.equal(moment.locale(), 'something', 'locale can be used to create the locale too');\n        moment.defineLocale('something', null);\n    });\n\n    test('firstDayOfWeek firstDayOfYear locale getters', function (assert) {\n        moment.locale('something', {week: {dow: 3, doy: 4}});\n        moment.locale('something');\n        assert.equal(moment.localeData().firstDayOfWeek(), 3, 'firstDayOfWeek');\n        assert.equal(moment.localeData().firstDayOfYear(), 4, 'firstDayOfYear');\n        moment.defineLocale('something', null);\n    });\n\n    test('instance locale method', function (assert) {\n        moment.locale('en');\n\n        assert.equal(moment([2012, 5, 6]).format('MMMM'), 'June', 'Normally default to global');\n        assert.equal(moment([2012, 5, 6]).locale('es').format('MMMM'), 'junio', 'Use the instance specific locale');\n        assert.equal(moment([2012, 5, 6]).format('MMMM'), 'June', 'Using an instance specific locale does not affect other moments');\n    });\n\n    test('instance locale method with array', function (assert) {\n        var m = moment().locale(['non-existent', 'fr', 'also-non-existent']);\n        assert.equal(m.locale(), 'fr', 'passing an array uses the first valid locale');\n        m = moment().locale(['es', 'fr', 'also-non-existent']);\n        assert.equal(m.locale(), 'es', 'passing an array uses the first valid locale');\n    });\n\n    test('instance getter locale substrings', function (assert) {\n        var m = moment();\n\n        m.locale('fr-crap');\n        assert.equal(m.locale(), 'fr', 'use substrings');\n\n        m.locale('fr-does-not-exist');\n        assert.equal(m.locale(), 'fr', 'uses deep substrings');\n    });\n\n    test('instance locale persists with manipulation', function (assert) {\n        moment.locale('en');\n\n        assert.equal(moment([2012, 5, 6]).locale('es').add({days: 1}).format('MMMM'), 'junio', 'With addition');\n        assert.equal(moment([2012, 5, 6]).locale('es').day(0).format('MMMM'), 'junio', 'With day getter');\n        assert.equal(moment([2012, 5, 6]).locale('es').endOf('day').format('MMMM'), 'junio', 'With endOf');\n    });\n\n    test('instance locale persists with cloning', function (assert) {\n        moment.locale('en');\n\n        var a = moment([2012, 5, 6]).locale('es'),\n            b = a.clone(),\n            c = moment(a);\n\n        assert.equal(b.format('MMMM'), 'junio', 'using moment.fn.clone()');\n        assert.equal(b.format('MMMM'), 'junio', 'using moment()');\n    });\n\n    test('duration locale method', function (assert) {\n        moment.locale('en');\n\n        assert.equal(moment.duration({seconds:  44}).humanize(), 'a few seconds', 'Normally default to global');\n        assert.equal(moment.duration({seconds:  44}).locale('es').humanize(), 'unos segundos', 'Use the instance specific locale');\n        assert.equal(moment.duration({seconds:  44}).humanize(), 'a few seconds', 'Using an instance specific locale does not affect other durations');\n    });\n\n    test('duration locale persists with cloning', function (assert) {\n        moment.locale('en');\n\n        var a = moment.duration({seconds:  44}).locale('es'),\n            b = moment.duration(a);\n\n        assert.equal(b.humanize(), 'unos segundos', 'using moment.duration()');\n    });\n\n    test('changing the global locale doesn\\'t affect existing duration instances', function (assert) {\n        var mom = moment.duration();\n        moment.locale('fr');\n        assert.equal('en', mom.locale());\n    });\n\n    test('duration deprecations', function (assert) {\n        test.expectedDeprecations('moment().lang()');\n        assert.equal(moment.duration().lang(), moment.duration().localeData(), 'duration.lang is the same as duration.localeData');\n    });\n\n    test('from and fromNow with invalid date', function (assert) {\n        assert.equal(moment(NaN).from(), 'Invalid date', 'moment.from with invalid moment');\n        assert.equal(moment(NaN).fromNow(), 'Invalid date', 'moment.fromNow with invalid moment');\n    });\n\n    test('from relative time future', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({s: 44})),  'in a few seconds', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({s: 45})),  'in a minute',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({s: 89})),  'in a minute',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({s: 90})),  'in 2 minutes',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({m: 44})),  'in 44 minutes',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({m: 45})),  'in an hour',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({m: 89})),  'in an hour',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({m: 90})),  'in 2 hours',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 5})),   'in 5 hours',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 21})),  'in 21 hours',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 22})),  'in a day',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 35})),  'in a day',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 36})),  'in 2 days',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 1})),   'in a day',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 5})),   'in 5 days',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 25})),  'in 25 days',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 26})),  'in a month',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 30})),  'in a month',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 45})),  'in a month',       '45 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 47})),  'in 2 months',      '47 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 74})),  'in 2 months',      '74 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 78})),  'in 3 months',      '78 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({M: 1})),   'in a month',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({M: 5})),   'in 5 months',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 315})), 'in 10 months',     '315 days = 10 months');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 344})), 'in a year',        '344 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 345})), 'in a year',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 548})), 'in 2 years',       '548 days = in 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({y: 1})),   'in a year',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).subtract({y: 5})),   'in 5 years',       '5 years = 5 years');\n    });\n\n    test('from relative time past', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44})),  'a few seconds ago', '44 seconds = a few seconds');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45})),  'a minute ago',      '45 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89})),  'a minute ago',      '89 seconds = a minute');\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90})),  '2 minutes ago',     '90 seconds = 2 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44})),  '44 minutes ago',    '44 minutes = 44 minutes');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45})),  'an hour ago',       '45 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89})),  'an hour ago',       '89 minutes = an hour');\n        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90})),  '2 hours ago',       '90 minutes = 2 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5})),   '5 hours ago',       '5 hours = 5 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21})),  '21 hours ago',      '21 hours = 21 hours');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22})),  'a day ago',         '22 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35})),  'a day ago',         '35 hours = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36})),  '2 days ago',        '36 hours = 2 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1})),   'a day ago',         '1 day = a day');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5})),   '5 days ago',        '5 days = 5 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25})),  '25 days ago',       '25 days = 25 days');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26})),  'a month ago',       '26 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30})),  'a month ago',       '30 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43})),  'a month ago',       '43 days = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46})),  '2 months ago',      '46 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74})),  '2 months ago',      '75 days = 2 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76})),  '3 months ago',      '76 days = 3 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1})),   'a month ago',       '1 month = a month');\n        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5})),   '5 months ago',      '5 months = 5 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 315})), '10 months ago',     '315 days = 10 months');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 344})), 'a year ago',        '344 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345})), 'a year ago',        '345 days = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548})), '2 years ago',       '548 days = 2 years');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1})),   'a year ago',        '1 year = a year');\n        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5})),   '5 years ago',       '5 years = 5 years');\n    });\n\n    test('instance locale used with from', function (assert) {\n        moment.locale('en');\n\n        var a = moment([2012, 5, 6]).locale('es'),\n            b = moment([2012, 5, 7]);\n\n        assert.equal(a.from(b), 'hace un d\u00c3\u00ada', 'preserve locale of first moment');\n        assert.equal(b.from(a), 'in a day', 'do not preserve locale of second moment');\n    });\n\n    test('instance localeData', function (assert) {\n        moment.defineLocale('dude', {week: {dow: 3}});\n        assert.equal(moment().locale('dude').localeData()._week.dow, 3);\n        moment.defineLocale('dude', null);\n    });\n\n    test('month name callback function', function (assert) {\n        function fakeReplace(m, format) {\n            if (/test/.test(format)) {\n                return 'test';\n            }\n            if (m.date() === 1) {\n                return 'date';\n            }\n            return 'default';\n        }\n\n        moment.locale('made-up-2', {\n            months : fakeReplace,\n            monthsShort : fakeReplace,\n            weekdays : fakeReplace,\n            weekdaysShort : fakeReplace,\n            weekdaysMin : fakeReplace\n        });\n\n        assert.equal(moment().format('[test] dd ddd dddd MMM MMMM'), 'test test test test test test', 'format month name function should be able to access the format string');\n        assert.equal(moment([2011, 0, 1]).format('dd ddd dddd MMM MMMM'), 'date date date date date', 'format month name function should be able to access the moment object');\n        assert.equal(moment([2011, 0, 2]).format('dd ddd dddd MMM MMMM'), 'default default default default default', 'format month name function should be able to access the moment object');\n    });\n\n    test('changing parts of a locale config', function (assert) {\n        test.expectedDeprecations('defineLocaleOverride');\n\n        moment.locale('partial-lang', {\n            months : 'a b c d e f g h i j k l'.split(' ')\n        });\n\n        assert.equal(moment([2011, 0, 1]).format('MMMM'), 'a', 'should be able to set locale values when creating the localeuage');\n\n        moment.locale('partial-lang', {\n            monthsShort : 'A B C D E F G H I J K L'.split(' ')\n        });\n\n        assert.equal(moment([2011, 0, 1]).format('MMMM MMM'), 'a A', 'should be able to set locale values after creating the localeuage');\n\n        moment.defineLocale('partial-lang', null);\n    });\n\n    test('start/endOf week feature for first-day-is-monday locales', function (assert) {\n        moment.locale('monday-lang', {\n            week : {\n                dow : 1 // Monday is the first day of the week\n            }\n        });\n\n        moment.locale('monday-lang');\n        assert.equal(moment([2013, 0, 1]).startOf('week').day(), 1, 'for locale monday-lang first day of the week should be monday');\n        assert.equal(moment([2013, 0, 1]).endOf('week').day(), 0, 'for locale monday-lang last day of the week should be sunday');\n        moment.defineLocale('monday-lang', null);\n    });\n\n    test('meridiem parsing', function (assert) {\n        moment.locale('meridiem-parsing', {\n            meridiemParse : /[bd]/i,\n            isPM : function (input) {\n                return input === 'b';\n            }\n        });\n\n        moment.locale('meridiem-parsing');\n        assert.equal(moment('2012-01-01 3b', 'YYYY-MM-DD ha').hour(), 15, 'Custom parsing of meridiem should work');\n        assert.equal(moment('2012-01-01 3d', 'YYYY-MM-DD ha').hour(), 3, 'Custom parsing of meridiem should work');\n        moment.defineLocale('meridiem-parsing', null);\n    });\n\n    test('invalid date formatting', function (assert) {\n        moment.locale('has-invalid', {\n            invalidDate: 'KHAAAAAAAAAAAN!'\n        });\n\n        assert.equal(moment.invalid().format(), 'KHAAAAAAAAAAAN!');\n        assert.equal(moment.invalid().format('YYYY-MM-DD'), 'KHAAAAAAAAAAAN!');\n        moment.defineLocale('has-invalid', null);\n    });\n\n    test('return locale name', function (assert) {\n        var registered = moment.locale('return-this', {});\n\n        assert.equal(registered, 'return-this', 'returns the locale configured');\n        moment.locale('return-this', null);\n    });\n\n    test('changing the global locale doesn\\'t affect existing instances', function (assert) {\n        var mom = moment();\n        moment.locale('fr');\n        assert.equal('en', mom.locale());\n    });\n\n    test('setting a language on instance returns the original moment for chaining', function (assert) {\n        test.expectedDeprecations('moment().lang()');\n        var mom = moment();\n\n        assert.equal(mom.lang('fr'), mom, 'setting the language (lang) returns the original moment for chaining');\n        assert.equal(mom.locale('it'), mom, 'setting the language (locale) returns the original moment for chaining');\n    });\n\n    test('lang(key) changes the language of the instance', function (assert) {\n        test.expectedDeprecations('moment().lang()');\n        var m = moment().month(0);\n        m.lang('fr');\n        assert.equal(m.locale(), 'fr', 'm.lang(key) changes instance locale');\n    });\n\n    test('moment#locale(false) resets to global locale', function (assert) {\n        var m = moment();\n\n        moment.locale('fr');\n        m.locale('it');\n\n        assert.equal(moment.locale(), 'fr', 'global locale is it');\n        assert.equal(m.locale(), 'it', 'instance locale is it');\n        m.locale(false);\n        assert.equal(m.locale(), 'fr', 'instance locale reset to global locale');\n    });\n\n    test('moment().locale with missing key doesn\\'t change locale', function (assert) {\n        assert.equal(moment().locale('boo').localeData(), moment.localeData(),\n                'preserve global locale in case of bad locale id');\n    });\n\n    test('moment().lang with missing key doesn\\'t change locale', function (assert) {\n        test.expectedDeprecations('moment().lang()');\n        assert.equal(moment().lang('boo').localeData(), moment.localeData(),\n                'preserve global locale in case of bad locale id');\n    });\n\n\n    // TODO: Enable this after fixing pl months parse hack hack\n    // test('monthsParseExact', function (assert) {\n    //     var locale = 'test-months-parse-exact';\n\n    //     moment.defineLocale(locale, {\n    //         monthsParseExact: true,\n    //         months: 'A_AA_AAA_B_B B_BB  B_C_C-C_C,C2C_D_D+D_D`D*D'.split('_'),\n    //         monthsShort: 'E_EE_EEE_F_FF_FFF_G_GG_GGG_H_HH_HHH'.split('_')\n    //     });\n\n    //     assert.equal(moment('A', 'MMMM', true).month(), 0, 'parse long month 0 with MMMM');\n    //     assert.equal(moment('AA', 'MMMM', true).month(), 1, 'parse long month 1 with MMMM');\n    //     assert.equal(moment('AAA', 'MMMM', true).month(), 2, 'parse long month 2 with MMMM');\n    //     assert.equal(moment('B B', 'MMMM', true).month(), 4, 'parse long month 4 with MMMM');\n    //     assert.equal(moment('BB  B', 'MMMM', true).month(), 5, 'parse long month 5 with MMMM');\n    //     assert.equal(moment('C-C', 'MMMM', true).month(), 7, 'parse long month 7 with MMMM');\n    //     assert.equal(moment('C,C2C', 'MMMM', true).month(), 8, 'parse long month 8 with MMMM');\n    //     assert.equal(moment('D+D', 'MMMM', true).month(), 10, 'parse long month 10 with MMMM');\n    //     assert.equal(moment('D`D*D', 'MMMM', true).month(), 11, 'parse long month 11 with MMMM');\n\n    //     assert.equal(moment('E', 'MMM', true).month(), 0, 'parse long month 0 with MMM');\n    //     assert.equal(moment('EE', 'MMM', true).month(), 1, 'parse long month 1 with MMM');\n    //     assert.equal(moment('EEE', 'MMM', true).month(), 2, 'parse long month 2 with MMM');\n\n    //     assert.equal(moment('A', 'MMM').month(), 0, 'non-strict parse long month 0 with MMM');\n    //     assert.equal(moment('AA', 'MMM').month(), 1, 'non-strict parse long month 1 with MMM');\n    //     assert.equal(moment('AAA', 'MMM').month(), 2, 'non-strict parse long month 2 with MMM');\n    //     assert.equal(moment('E', 'MMMM').month(), 0, 'non-strict parse short month 0 with MMMM');\n    //     assert.equal(moment('EE', 'MMMM').month(), 1, 'non-strict parse short month 1 with MMMM');\n    //     assert.equal(moment('EEE', 'MMMM').month(), 2, 'non-strict parse short month 2 with MMMM');\n    // });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('locale inheritance');\n\n    test('calendar', function (assert) {\n        moment.defineLocale('base-cal', {\n            calendar : {\n                sameDay: '[Today at] HH:mm',\n                nextDay: '[Tomorrow at] HH:mm',\n                nextWeek: '[Next week at] HH:mm',\n                lastDay: '[Yesterday at] HH:mm',\n                lastWeek: '[Last week at] HH:mm',\n                sameElse: '[whatever]'\n            }\n        });\n        moment.defineLocale('child-cal', {\n            parentLocale: 'base-cal',\n            calendar: {\n                sameDay: '[Today] HH:mm',\n                nextDay: '[Tomorrow] HH:mm',\n                nextWeek: '[Next week] HH:mm'\n            }\n        });\n\n        moment.locale('child-cal');\n        var anchor = moment.utc('2015-05-05T12:00:00', moment.ISO_8601);\n        assert.equal(anchor.clone().add(3, 'hours').calendar(anchor), 'Today 15:00', 'today uses child version');\n        assert.equal(anchor.clone().add(1, 'day').calendar(anchor), 'Tomorrow 12:00', 'tomorrow uses child version');\n        assert.equal(anchor.clone().add(3, 'days').calendar(anchor), 'Next week 12:00', 'next week uses child version');\n\n        assert.equal(anchor.clone().subtract(1, 'day').calendar(anchor), 'Yesterday at 12:00', 'yesterday uses parent version');\n        assert.equal(anchor.clone().subtract(3, 'days').calendar(anchor), 'Last week at 12:00', 'last week uses parent version');\n        assert.equal(anchor.clone().subtract(7, 'days').calendar(anchor), 'whatever', 'sameElse uses parent version -');\n        assert.equal(anchor.clone().add(7, 'days').calendar(anchor), 'whatever', 'sameElse uses parent version +');\n    });\n\n    test('missing', function (assert) {\n        moment.defineLocale('base-cal-2', {\n            calendar: {\n                sameDay: '[Today at] HH:mm',\n                nextDay: '[Tomorrow at] HH:mm',\n                nextWeek: '[Next week at] HH:mm',\n                lastDay: '[Yesterday at] HH:mm',\n                lastWeek: '[Last week at] HH:mm',\n                sameElse: '[whatever]'\n            }\n        });\n        moment.defineLocale('child-cal-2', {\n            parentLocale: 'base-cal-2'\n        });\n        moment.locale('child-cal-2');\n        var anchor = moment.utc('2015-05-05T12:00:00', moment.ISO_8601);\n        assert.equal(anchor.clone().add(3, 'hours').calendar(anchor), 'Today at 15:00', 'today uses parent version');\n        assert.equal(anchor.clone().add(1, 'day').calendar(anchor), 'Tomorrow at 12:00', 'tomorrow uses parent version');\n        assert.equal(anchor.clone().add(3, 'days').calendar(anchor), 'Next week at 12:00', 'next week uses parent version');\n        assert.equal(anchor.clone().subtract(1, 'day').calendar(anchor), 'Yesterday at 12:00', 'yesterday uses parent version');\n        assert.equal(anchor.clone().subtract(3, 'days').calendar(anchor), 'Last week at 12:00', 'last week uses parent version');\n        assert.equal(anchor.clone().subtract(7, 'days').calendar(anchor), 'whatever', 'sameElse uses parent version -');\n        assert.equal(anchor.clone().add(7, 'days').calendar(anchor), 'whatever', 'sameElse uses parent version +');\n    });\n\n    // Test function vs obj both directions\n\n    test('long date format', function (assert) {\n        moment.defineLocale('base-ldf', {\n            longDateFormat : {\n                LTS  : 'h:mm:ss A',\n                LT   : 'h:mm A',\n                L    : 'MM/DD/YYYY',\n                LL   : 'MMMM D, YYYY',\n                LLL  : 'MMMM D, YYYY h:mm A',\n                LLLL : 'dddd, MMMM D, YYYY h:mm A'\n            }\n        });\n        moment.defineLocale('child-ldf', {\n            parentLocale: 'base-ldf',\n            longDateFormat: {\n                LLL  : '[child] MMMM D, YYYY h:mm A',\n                LLLL : '[child] dddd, MMMM D, YYYY h:mm A'\n            }\n        });\n\n        moment.locale('child-ldf');\n        var anchor = moment.utc('2015-09-06T12:34:56', moment.ISO_8601);\n        assert.equal(anchor.format('LTS'), '12:34:56 PM', 'LTS uses base');\n        assert.equal(anchor.format('LT'), '12:34 PM', 'LT uses base');\n        assert.equal(anchor.format('L'), '09/06/2015', 'L uses base');\n        assert.equal(anchor.format('l'), '9/6/2015', 'l uses base');\n        assert.equal(anchor.format('LL'), 'September 6, 2015', 'LL uses base');\n        assert.equal(anchor.format('ll'), 'Sep 6, 2015', 'll uses base');\n        assert.equal(anchor.format('LLL'), 'child September 6, 2015 12:34 PM', 'LLL uses child');\n        assert.equal(anchor.format('lll'), 'child Sep 6, 2015 12:34 PM', 'lll uses child');\n        assert.equal(anchor.format('LLLL'), 'child Sunday, September 6, 2015 12:34 PM', 'LLLL uses child');\n        assert.equal(anchor.format('llll'), 'child Sun, Sep 6, 2015 12:34 PM', 'llll uses child');\n    });\n\n    test('ordinal', function (assert) {\n        moment.defineLocale('base-ordinal-1', {\n            ordinal : '%dx'\n        });\n        moment.defineLocale('child-ordinal-1', {\n            parentLocale: 'base-ordinal-1',\n            ordinal : '%dy'\n        });\n\n        assert.equal(moment.utc('2015-02-03', moment.ISO_8601).format('Do'), '3y', 'ordinal uses child string');\n\n        moment.defineLocale('base-ordinal-2', {\n            ordinal : '%dx'\n        });\n        moment.defineLocale('child-ordinal-2', {\n            parentLocale: 'base-ordinal-2',\n            ordinal : function (num) {\n                return num + 'y';\n            }\n        });\n\n        assert.equal(moment.utc('2015-02-03', moment.ISO_8601).format('Do'), '3y', 'ordinal uses child function');\n\n        moment.defineLocale('base-ordinal-3', {\n            ordinal : function (num) {\n                return num + 'x';\n            }\n        });\n        moment.defineLocale('child-ordinal-3', {\n            parentLocale: 'base-ordinal-3',\n            ordinal : '%dy'\n        });\n\n        assert.equal(moment.utc('2015-02-03', moment.ISO_8601).format('Do'), '3y', 'ordinal uses child string (overwrite parent function)');\n    });\n\n    test('ordinal parse', function (assert) {\n        moment.defineLocale('base-ordinal-parse-1', {\n            ordinalParse : /\\d{1,2}x/\n        });\n        moment.defineLocale('child-ordinal-parse-1', {\n            parentLocale: 'base-ordinal-parse-1',\n            ordinalParse : /\\d{1,2}y/\n        });\n\n        assert.ok(moment.utc('2015-01-1y', 'YYYY-MM-Do', true).isValid(), 'ordinal parse uses child');\n\n        moment.defineLocale('base-ordinal-parse-2', {\n            ordinalParse : /\\d{1,2}x/\n        });\n        moment.defineLocale('child-ordinal-parse-2', {\n            parentLocale: 'base-ordinal-parse-2',\n            ordinalParse : null\n        });\n\n        assert.ok(moment.utc('2015-01-1', 'YYYY-MM-Do', true).isValid(), 'ordinal parse uses child (default)');\n    });\n\n    test('months', function (assert) {\n        moment.defineLocale('base-months', {\n            months : 'One_Two_Three_Four_Five_Six_Seven_Eight_Nine_Ten_Eleven_Twelve'.split('_')\n        });\n        moment.defineLocale('child-months', {\n            parentLocale: 'base-months',\n            months : 'First_Second_Third_Fourth_Fifth_Sixth_Seventh_Eighth_Ninth_Tenth_Eleventh_Twelveth '.split('_')\n        });\n        assert.ok(moment.utc('2015-01-01', 'YYYY-MM-DD').format('MMMM'), 'First', 'months uses child');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('locale update');\n\n    test('calendar', function (assert) {\n        moment.defineLocale('cal', null);\n        moment.defineLocale('cal', {\n            calendar : {\n                sameDay: '[Today at] HH:mm',\n                nextDay: '[Tomorrow at] HH:mm',\n                nextWeek: '[Next week at] HH:mm',\n                lastDay: '[Yesterday at] HH:mm',\n                lastWeek: '[Last week at] HH:mm',\n                sameElse: '[whatever]'\n            }\n        });\n        moment.updateLocale('cal', {\n            calendar: {\n                sameDay: '[Today] HH:mm',\n                nextDay: '[Tomorrow] HH:mm',\n                nextWeek: '[Next week] HH:mm'\n            }\n        });\n\n        moment.locale('cal');\n        var anchor = moment.utc('2015-05-05T12:00:00', moment.ISO_8601);\n        assert.equal(anchor.clone().add(3, 'hours').calendar(anchor), 'Today 15:00', 'today uses child version');\n        assert.equal(anchor.clone().add(1, 'day').calendar(anchor), 'Tomorrow 12:00', 'tomorrow uses child version');\n        assert.equal(anchor.clone().add(3, 'days').calendar(anchor), 'Next week 12:00', 'next week uses child version');\n\n        assert.equal(anchor.clone().subtract(1, 'day').calendar(anchor), 'Yesterday at 12:00', 'yesterday uses parent version');\n        assert.equal(anchor.clone().subtract(3, 'days').calendar(anchor), 'Last week at 12:00', 'last week uses parent version');\n        assert.equal(anchor.clone().subtract(7, 'days').calendar(anchor), 'whatever', 'sameElse uses parent version -');\n        assert.equal(anchor.clone().add(7, 'days').calendar(anchor), 'whatever', 'sameElse uses parent version +');\n    });\n\n    test('missing', function (assert) {\n        moment.defineLocale('cal-2', null);\n        moment.defineLocale('cal-2', {\n            calendar: {\n                sameDay: '[Today at] HH:mm',\n                nextDay: '[Tomorrow at] HH:mm',\n                nextWeek: '[Next week at] HH:mm',\n                lastDay: '[Yesterday at] HH:mm',\n                lastWeek: '[Last week at] HH:mm',\n                sameElse: '[whatever]'\n            }\n        });\n        moment.updateLocale('cal-2', {\n        });\n        moment.locale('cal-2');\n        var anchor = moment.utc('2015-05-05T12:00:00', moment.ISO_8601);\n        assert.equal(anchor.clone().add(3, 'hours').calendar(anchor), 'Today at 15:00', 'today uses parent version');\n        assert.equal(anchor.clone().add(1, 'day').calendar(anchor), 'Tomorrow at 12:00', 'tomorrow uses parent version');\n        assert.equal(anchor.clone().add(3, 'days').calendar(anchor), 'Next week at 12:00', 'next week uses parent version');\n        assert.equal(anchor.clone().subtract(1, 'day').calendar(anchor), 'Yesterday at 12:00', 'yesterday uses parent version');\n        assert.equal(anchor.clone().subtract(3, 'days').calendar(anchor), 'Last week at 12:00', 'last week uses parent version');\n        assert.equal(anchor.clone().subtract(7, 'days').calendar(anchor), 'whatever', 'sameElse uses parent version -');\n        assert.equal(anchor.clone().add(7, 'days').calendar(anchor), 'whatever', 'sameElse uses parent version +');\n    });\n\n    // Test function vs obj both directions\n\n    test('long date format', function (assert) {\n        moment.defineLocale('ldf', null);\n        moment.defineLocale('ldf', {\n            longDateFormat : {\n                LTS  : 'h:mm:ss A',\n                LT   : 'h:mm A',\n                L    : 'MM/DD/YYYY',\n                LL   : 'MMMM D, YYYY',\n                LLL  : 'MMMM D, YYYY h:mm A',\n                LLLL : 'dddd, MMMM D, YYYY h:mm A'\n            }\n        });\n        moment.updateLocale('ldf', {\n            longDateFormat: {\n                LLL  : '[child] MMMM D, YYYY h:mm A',\n                LLLL : '[child] dddd, MMMM D, YYYY h:mm A'\n            }\n        });\n\n        moment.locale('ldf');\n        var anchor = moment.utc('2015-09-06T12:34:56', moment.ISO_8601);\n        assert.equal(anchor.format('LTS'), '12:34:56 PM', 'LTS uses base');\n        assert.equal(anchor.format('LT'), '12:34 PM', 'LT uses base');\n        assert.equal(anchor.format('L'), '09/06/2015', 'L uses base');\n        assert.equal(anchor.format('l'), '9/6/2015', 'l uses base');\n        assert.equal(anchor.format('LL'), 'September 6, 2015', 'LL uses base');\n        assert.equal(anchor.format('ll'), 'Sep 6, 2015', 'll uses base');\n        assert.equal(anchor.format('LLL'), 'child September 6, 2015 12:34 PM', 'LLL uses child');\n        assert.equal(anchor.format('lll'), 'child Sep 6, 2015 12:34 PM', 'lll uses child');\n        assert.equal(anchor.format('LLLL'), 'child Sunday, September 6, 2015 12:34 PM', 'LLLL uses child');\n        assert.equal(anchor.format('llll'), 'child Sun, Sep 6, 2015 12:34 PM', 'llll uses child');\n    });\n\n    test('ordinal', function (assert) {\n        moment.defineLocale('ordinal-1', null);\n        moment.defineLocale('ordinal-1', {\n            ordinal : '%dx'\n        });\n        moment.updateLocale('ordinal-1', {\n            ordinal : '%dy'\n        });\n\n        assert.equal(moment.utc('2015-02-03', moment.ISO_8601).format('Do'), '3y', 'ordinal uses child string');\n\n        moment.defineLocale('ordinal-2', null);\n        moment.defineLocale('ordinal-2', {\n            ordinal : '%dx'\n        });\n        moment.updateLocale('ordinal-2', {\n            ordinal : function (num) {\n                return num + 'y';\n            }\n        });\n\n        assert.equal(moment.utc('2015-02-03', moment.ISO_8601).format('Do'), '3y', 'ordinal uses child function');\n\n        moment.defineLocale('ordinal-3', null);\n        moment.defineLocale('ordinal-3', {\n            ordinal : function (num) {\n                return num + 'x';\n            }\n        });\n        moment.updateLocale('ordinal-3', {\n            ordinal : '%dy'\n        });\n\n        assert.equal(moment.utc('2015-02-03', moment.ISO_8601).format('Do'), '3y', 'ordinal uses child string (overwrite parent function)');\n    });\n\n    test('ordinal parse', function (assert) {\n        moment.defineLocale('ordinal-parse-1', null);\n        moment.defineLocale('ordinal-parse-1', {\n            ordinalParse : /\\d{1,2}x/\n        });\n        moment.updateLocale('ordinal-parse-1', {\n            ordinalParse : /\\d{1,2}y/\n        });\n\n        assert.ok(moment.utc('2015-01-1y', 'YYYY-MM-Do', true).isValid(), 'ordinal parse uses child');\n\n        moment.defineLocale('ordinal-parse-2', null);\n        moment.defineLocale('ordinal-parse-2', {\n            ordinalParse : /\\d{1,2}x/\n        });\n        moment.updateLocale('ordinal-parse-2', {\n            ordinalParse : null\n        });\n\n        assert.ok(moment.utc('2015-01-1', 'YYYY-MM-Do', true).isValid(), 'ordinal parse uses child (default)');\n    });\n\n    test('months', function (assert) {\n        moment.defineLocale('months', null);\n        moment.defineLocale('months', {\n            months : 'One_Two_Three_Four_Five_Six_Seven_Eight_Nine_Ten_Eleven_Twelve'.split('_')\n        });\n        moment.updateLocale('months', {\n            parentLocale: 'base-months',\n            months : 'First_Second_Third_Fourth_Fifth_Sixth_Seventh_Eighth_Ninth_Tenth_Eleventh_Twelveth '.split('_')\n        });\n        assert.ok(moment.utc('2015-01-01', 'YYYY-MM-DD').format('MMMM'), 'First', 'months uses child');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('min max');\n\n    test('min', function (assert) {\n        var now = moment(),\n            future = now.clone().add(1, 'month'),\n            past = now.clone().subtract(1, 'month'),\n            invalid = moment.invalid();\n\n        assert.equal(moment.min(now, future, past), past, 'min(now, future, past)');\n        assert.equal(moment.min(future, now, past), past, 'min(future, now, past)');\n        assert.equal(moment.min(future, past, now), past, 'min(future, past, now)');\n        assert.equal(moment.min(past, future, now), past, 'min(past, future, now)');\n        assert.equal(moment.min(now, past), past, 'min(now, past)');\n        assert.equal(moment.min(past, now), past, 'min(past, now)');\n        assert.equal(moment.min(now), now, 'min(now, past)');\n\n        assert.equal(moment.min([now, future, past]), past, 'min([now, future, past])');\n        assert.equal(moment.min([now, past]), past, 'min(now, past)');\n        assert.equal(moment.min([now]), now, 'min(now)');\n\n        assert.equal(moment.min([now, invalid]), invalid, 'min(now, invalid)');\n        assert.equal(moment.min([invalid, now]), invalid, 'min(invalid, now)');\n    });\n\n    test('max', function (assert) {\n        var now = moment(),\n            future = now.clone().add(1, 'month'),\n            past = now.clone().subtract(1, 'month'),\n            invalid = moment.invalid();\n\n        assert.equal(moment.max(now, future, past), future, 'max(now, future, past)');\n        assert.equal(moment.max(future, now, past), future, 'max(future, now, past)');\n        assert.equal(moment.max(future, past, now), future, 'max(future, past, now)');\n        assert.equal(moment.max(past, future, now), future, 'max(past, future, now)');\n        assert.equal(moment.max(now, past), now, 'max(now, past)');\n        assert.equal(moment.max(past, now), now, 'max(past, now)');\n        assert.equal(moment.max(now), now, 'max(now, past)');\n\n        assert.equal(moment.max([now, future, past]), future, 'max([now, future, past])');\n        assert.equal(moment.max([now, past]), now, 'max(now, past)');\n        assert.equal(moment.max([now]), now, 'max(now)');\n\n        assert.equal(moment.max([now, invalid]), invalid, 'max(now, invalid)');\n        assert.equal(moment.max([invalid, now]), invalid, 'max(invalid, now)');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('mutable');\n\n    test('manipulation methods', function (assert) {\n        var m = moment();\n\n        assert.equal(m, m.year(2011), 'year() should be mutable');\n        assert.equal(m, m.month(1), 'month() should be mutable');\n        assert.equal(m, m.hours(7), 'hours() should be mutable');\n        assert.equal(m, m.minutes(33), 'minutes() should be mutable');\n        assert.equal(m, m.seconds(44), 'seconds() should be mutable');\n        assert.equal(m, m.milliseconds(55), 'milliseconds() should be mutable');\n        assert.equal(m, m.day(2), 'day() should be mutable');\n        assert.equal(m, m.startOf('week'), 'startOf() should be mutable');\n        assert.equal(m, m.add(1, 'days'), 'add() should be mutable');\n        assert.equal(m, m.subtract(2, 'years'), 'subtract() should be mutable');\n        assert.equal(m, m.local(), 'local() should be mutable');\n        assert.equal(m, m.utc(), 'utc() should be mutable');\n    });\n\n    test('non mutable methods', function (assert) {\n        var m = moment();\n        assert.notEqual(m, m.clone(), 'clone() should not be mutable');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('normalize units');\n\n    test('normalize units', function (assert) {\n        var fullKeys = ['year', 'quarter', 'month', 'isoWeek', 'week', 'day', 'hour', 'minute', 'second', 'millisecond', 'date', 'dayOfYear', 'weekday', 'isoWeekday', 'weekYear', 'isoWeekYear'],\n            aliases = ['y', 'Q', 'M', 'W', 'w', 'd', 'h', 'm', 's', 'ms', 'D', 'DDD', 'e', 'E', 'gg', 'GG'],\n            length = fullKeys.length,\n            fullKey,\n            fullKeyCaps,\n            fullKeyPlural,\n            fullKeyCapsPlural,\n            fullKeyLower,\n            alias,\n            index;\n\n        for (index = 0; index < length; index += 1) {\n            fullKey = fullKeys[index];\n            fullKeyCaps = fullKey.toUpperCase();\n            fullKeyLower = fullKey.toLowerCase();\n            fullKeyPlural = fullKey + 's';\n            fullKeyCapsPlural = fullKeyCaps + 's';\n            alias = aliases[index];\n            assert.equal(moment.normalizeUnits(fullKey), fullKey, 'Testing full key ' + fullKey);\n            assert.equal(moment.normalizeUnits(fullKeyCaps), fullKey, 'Testing full key capitalised ' + fullKey);\n            assert.equal(moment.normalizeUnits(fullKeyPlural), fullKey, 'Testing full key plural ' + fullKey);\n            assert.equal(moment.normalizeUnits(fullKeyCapsPlural), fullKey, 'Testing full key capitalised and plural ' + fullKey);\n            assert.equal(moment.normalizeUnits(alias), fullKey, 'Testing alias ' + fullKey);\n        }\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('now');\n\n    test('now', function (assert) {\n        var startOfTest = new Date().valueOf(),\n            momentNowTime = moment.now(),\n            afterMomentCreationTime = new Date().valueOf();\n\n        assert.ok(startOfTest <= momentNowTime, 'moment now() time should be now, not in the past');\n        assert.ok(momentNowTime <= afterMomentCreationTime, 'moment now() time should be now, not in the future');\n    });\n\n    test('now - Date mocked', function (assert) {\n        // We need to test mocking the global Date object, so disable 'Read Only' jshint check\n        /* jshint -W020 */\n        var RealDate = Date,\n            customTimeMs = moment('2015-01-01T01:30:00.000Z').valueOf();\n\n        function MockDate() {\n            return new RealDate(customTimeMs);\n        }\n\n        MockDate.now = function () {\n            return new MockDate().valueOf();\n        };\n\n        MockDate.prototype = RealDate.prototype;\n\n        Date = MockDate;\n\n        try {\n            assert.equal(moment().valueOf(), customTimeMs, 'moment now() time should use the global Date object');\n        } finally {\n            Date = RealDate;\n        }\n    });\n\n    test('now - custom value', function (assert) {\n        var customTimeStr = '2015-01-01T01:30:00.000Z',\n            customTime = moment(customTimeStr, moment.ISO_8601).valueOf(),\n            oldFn = moment.now;\n\n        moment.now = function () {\n            return customTime;\n        };\n\n        try {\n            assert.ok(moment().toISOString() === customTimeStr, 'moment() constructor should use the function defined by moment.now, but it did not');\n            assert.ok(moment.utc().toISOString() === customTimeStr, 'moment() constructor should use the function defined by moment.now, but it did not');\n            assert.ok(moment.utc([]).toISOString() === '2015-01-01T00:00:00.000Z', 'moment() constructor should fall back to the date defined by moment.now when an empty array is given, but it did not');\n        } finally {\n            moment.now = oldFn;\n        }\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('parsing flags');\n\n    function flags () {\n        return moment.apply(null, arguments).parsingFlags();\n    }\n\n    test('overflow with array', function (assert) {\n        //months\n        assert.equal(flags([2010, 0]).overflow, -1, 'month 0 valid');\n        assert.equal(flags([2010, 1]).overflow, -1, 'month 1 valid');\n        assert.equal(flags([2010, -1]).overflow, 1, 'month -1 invalid');\n        assert.equal(flags([2100, 12]).overflow, 1, 'month 12 invalid');\n\n        //days\n        assert.equal(flags([2010, 1, 16]).overflow, -1, 'date valid');\n        assert.equal(flags([2010, 1, -1]).overflow, 2, 'date -1 invalid');\n        assert.equal(flags([2010, 1, 0]).overflow, 2, 'date 0 invalid');\n        assert.equal(flags([2010, 1, 32]).overflow, 2, 'date 32 invalid');\n        assert.equal(flags([2012, 1, 29]).overflow, -1, 'date leap year valid');\n        assert.equal(flags([2010, 1, 29]).overflow, 2, 'date leap year invalid');\n\n        //hours\n        assert.equal(flags([2010, 1, 1, 8]).overflow, -1, 'hour valid');\n        assert.equal(flags([2010, 1, 1, 0]).overflow, -1, 'hour 0 valid');\n        assert.equal(flags([2010, 1, 1, -1]).overflow, 3, 'hour -1 invalid');\n        assert.equal(flags([2010, 1, 1, 25]).overflow, 3, 'hour 25 invalid');\n        assert.equal(flags([2010, 1, 1, 24, 1]).overflow, 3, 'hour 24:01 invalid');\n\n        //minutes\n        assert.equal(flags([2010, 1, 1, 8, 15]).overflow, -1, 'minute valid');\n        assert.equal(flags([2010, 1, 1, 8, 0]).overflow, -1, 'minute 0 valid');\n        assert.equal(flags([2010, 1, 1, 8, -1]).overflow, 4, 'minute -1 invalid');\n        assert.equal(flags([2010, 1, 1, 8, 60]).overflow, 4, 'minute 60 invalid');\n\n        //seconds\n        assert.equal(flags([2010, 1, 1, 8, 15, 12]).overflow, -1, 'second valid');\n        assert.equal(flags([2010, 1, 1, 8, 15, 0]).overflow, -1, 'second 0 valid');\n        assert.equal(flags([2010, 1, 1, 8, 15, -1]).overflow, 5, 'second -1 invalid');\n        assert.equal(flags([2010, 1, 1, 8, 15, 60]).overflow, 5, 'second 60 invalid');\n\n        //milliseconds\n        assert.equal(flags([2010, 1, 1, 8, 15, 12, 345]).overflow, -1, 'millisecond valid');\n        assert.equal(flags([2010, 1, 1, 8, 15, 12, 0]).overflow, -1, 'millisecond 0 valid');\n        assert.equal(flags([2010, 1, 1, 8, 15, 12, -1]).overflow, 6, 'millisecond -1 invalid');\n        assert.equal(flags([2010, 1, 1, 8, 15, 12, 1000]).overflow, 6, 'millisecond 1000 invalid');\n\n        // 24 hrs\n        assert.equal(flags([2010, 1, 1, 24, 0, 0, 0]).overflow, -1, '24:00:00.000 is fine');\n        assert.equal(flags([2010, 1, 1, 24, 1, 0, 0]).overflow, 3, '24:01:00.000 is wrong hour');\n        assert.equal(flags([2010, 1, 1, 24, 0, 1, 0]).overflow, 3, '24:00:01.000 is wrong hour');\n        assert.equal(flags([2010, 1, 1, 24, 0, 0, 1]).overflow, 3, '24:00:00.001 is wrong hour');\n    });\n\n    test('overflow without format', function (assert) {\n        //months\n        assert.equal(flags('2001-01', 'YYYY-MM').overflow, -1, 'month 1 valid');\n        assert.equal(flags('2001-12', 'YYYY-MM').overflow, -1, 'month 12 valid');\n        assert.equal(flags('2001-13', 'YYYY-MM').overflow, 1, 'month 13 invalid');\n\n        //days\n        assert.equal(flags('2010-01-16', 'YYYY-MM-DD').overflow, -1, 'date 16 valid');\n        assert.equal(flags('2010-01-0',  'YYYY-MM-DD').overflow, 2, 'date 0 invalid');\n        assert.equal(flags('2010-01-32', 'YYYY-MM-DD').overflow, 2, 'date 32 invalid');\n        assert.equal(flags('2012-02-29', 'YYYY-MM-DD').overflow, -1, 'date leap year valid');\n        assert.equal(flags('2010-02-29', 'YYYY-MM-DD').overflow, 2, 'date leap year invalid');\n\n        //days of the year\n        assert.equal(flags('2010 300', 'YYYY DDDD').overflow, -1, 'day 300 of year valid');\n        assert.equal(flags('2010 365', 'YYYY DDDD').overflow, -1, 'day 365 of year valid');\n        assert.equal(flags('2010 366', 'YYYY DDDD').overflow, 2, 'day 366 of year invalid');\n        assert.equal(flags('2012 366', 'YYYY DDDD').overflow, -1, 'day 366 of leap year valid');\n        assert.equal(flags('2012 367', 'YYYY DDDD').overflow, 2, 'day 367 of leap year invalid');\n\n        //hours\n        assert.equal(flags('08', 'HH').overflow, -1, 'hour valid');\n        assert.equal(flags('00', 'HH').overflow, -1, 'hour 0 valid');\n        assert.equal(flags('25', 'HH').overflow, 3, 'hour 25 invalid');\n        assert.equal(flags('24:01', 'HH:mm').overflow, 3, 'hour 24:01 invalid');\n\n        //minutes\n        assert.equal(flags('08:15', 'HH:mm').overflow, -1, 'minute valid');\n        assert.equal(flags('08:00', 'HH:mm').overflow, -1, 'minute 0 valid');\n        assert.equal(flags('08:60', 'HH:mm').overflow, 4, 'minute 60 invalid');\n\n        //seconds\n        assert.equal(flags('08:15:12', 'HH:mm:ss').overflow, -1, 'second valid');\n        assert.equal(flags('08:15:00', 'HH:mm:ss').overflow, -1, 'second 0 valid');\n        assert.equal(flags('08:15:60', 'HH:mm:ss').overflow, 5, 'second 60 invalid');\n\n        //milliseconds\n        assert.equal(flags('08:15:12:345', 'HH:mm:ss:SSSS').overflow, -1, 'millisecond valid');\n        assert.equal(flags('08:15:12:000', 'HH:mm:ss:SSSS').overflow, -1, 'millisecond 0 valid');\n\n        //this is OK because we don't match the last digit, so it's 100 ms\n        assert.equal(flags('08:15:12:1000', 'HH:mm:ss:SSSS').overflow, -1, 'millisecond 1000 actually valid');\n    });\n\n    test('extra tokens', function (assert) {\n        assert.deepEqual(flags('1982-05-25', 'YYYY-MM-DD').unusedTokens, [], 'nothing extra');\n        assert.deepEqual(flags('1982-05', 'YYYY-MM-DD').unusedTokens, ['DD'], 'extra formatting token');\n        assert.deepEqual(flags('1982', 'YYYY-MM-DD').unusedTokens, ['MM', 'DD'], 'multiple extra formatting tokens');\n        assert.deepEqual(flags('1982-05', 'YYYY-MM-').unusedTokens, [], 'extra non-formatting token');\n        assert.deepEqual(flags('1982-05-', 'YYYY-MM-DD').unusedTokens, ['DD'], 'non-extra non-formatting token');\n        assert.deepEqual(flags('1982 05 1982', 'YYYY-MM-DD').unusedTokens, [], 'different non-formatting token');\n    });\n\n    test('extra tokens strict', function (assert) {\n        assert.deepEqual(flags('1982-05-25', 'YYYY-MM-DD', true).unusedTokens, [], 'nothing extra');\n        assert.deepEqual(flags('1982-05', 'YYYY-MM-DD', true).unusedTokens, ['-', 'DD'], 'extra formatting token');\n        assert.deepEqual(flags('1982', 'YYYY-MM-DD', true).unusedTokens, ['-', 'MM', '-', 'DD'], 'multiple extra formatting tokens');\n        assert.deepEqual(flags('1982-05', 'YYYY-MM-', true).unusedTokens, ['-'], 'extra non-formatting token');\n        assert.deepEqual(flags('1982-05-', 'YYYY-MM-DD', true).unusedTokens, ['DD'], 'non-extra non-formatting token');\n        assert.deepEqual(flags('1982 05 1982', 'YYYY-MM-DD', true).unusedTokens, ['-', '-'], 'different non-formatting token');\n    });\n\n    test('unused input', function (assert) {\n        assert.deepEqual(flags('1982-05-25', 'YYYY-MM-DD').unusedInput, [], 'normal input');\n        assert.deepEqual(flags('1982-05-25 this is more stuff', 'YYYY-MM-DD').unusedInput, [' this is more stuff'], 'trailing nonsense');\n        assert.deepEqual(flags('1982-05-25 09:30', 'YYYY-MM-DD').unusedInput, [' 09:30'], ['trailing legit-looking input']);\n        assert.deepEqual(flags('1982-05-25 some junk', 'YYYY-MM-DD [some junk]').unusedInput, [], 'junk that actually gets matched');\n        assert.deepEqual(flags('stuff at beginning 1982-05-25', 'YYYY-MM-DD').unusedInput, ['stuff at beginning '], 'leading junk');\n        assert.deepEqual(flags('junk 1982 more junk 05 yet more junk25', 'YYYY-MM-DD').unusedInput, ['junk ', ' more junk ', ' yet more junk'], 'interstitial junk');\n    });\n\n    test('unused input strict', function (assert) {\n        assert.deepEqual(flags('1982-05-25', 'YYYY-MM-DD', true).unusedInput, [], 'normal input');\n        assert.deepEqual(flags('1982-05-25 this is more stuff', 'YYYY-MM-DD', true).unusedInput, [' this is more stuff'], 'trailing nonsense');\n        assert.deepEqual(flags('1982-05-25 09:30', 'YYYY-MM-DD', true).unusedInput, [' 09:30'], ['trailing legit-looking input']);\n        assert.deepEqual(flags('1982-05-25 some junk', 'YYYY-MM-DD [some junk]', true).unusedInput, [], 'junk that actually gets matched');\n        assert.deepEqual(flags('stuff at beginning 1982-05-25', 'YYYY-MM-DD', true).unusedInput, ['stuff at beginning '], 'leading junk');\n        assert.deepEqual(flags('junk 1982 more junk 05 yet more junk25', 'YYYY-MM-DD', true).unusedInput, ['junk ', ' more junk ', ' yet more junk'], 'interstitial junk');\n    });\n\n    test('chars left over', function (assert) {\n        assert.equal(flags('1982-05-25', 'YYYY-MM-DD').charsLeftOver, 0, 'normal input');\n        assert.equal(flags('1982-05-25 this is more stuff', 'YYYY-MM-DD').charsLeftOver, ' this is more stuff'.length, 'trailing nonsense');\n        assert.equal(flags('1982-05-25 09:30', 'YYYY-MM-DD').charsLeftOver, ' 09:30'.length, 'trailing legit-looking input');\n        assert.equal(flags('stuff at beginning 1982-05-25', 'YYYY-MM-DD').charsLeftOver, 'stuff at beginning '.length, 'leading junk');\n        assert.equal(flags('1982 junk 05 more junk25', 'YYYY-MM-DD').charsLeftOver, [' junk ', ' more junk'].join('').length, 'interstitial junk');\n        assert.equal(flags('stuff at beginning 1982 junk 05 more junk25', 'YYYY-MM-DD').charsLeftOver, ['stuff at beginning ', ' junk ', ' more junk'].join('').length, 'leading and interstitial junk');\n    });\n\n    test('empty', function (assert) {\n        assert.equal(flags('1982-05-25', 'YYYY-MM-DD').empty, false, 'normal input');\n        assert.equal(flags('nothing here', 'YYYY-MM-DD').empty, true, 'pure garbage');\n        assert.equal(flags('junk but has the number 2000 in it', 'YYYY-MM-DD').empty, false, 'only mostly garbage');\n        assert.equal(flags('', 'YYYY-MM-DD').empty, true, 'empty string');\n        assert.equal(flags('', 'YYYY-MM-DD').empty, true, 'blank string');\n    });\n\n    test('null', function (assert) {\n        assert.equal(flags('1982-05-25', 'YYYY-MM-DD').nullInput, false, 'normal input');\n        assert.equal(flags(null).nullInput, true, 'just null');\n        assert.equal(flags(null, 'YYYY-MM-DD').nullInput, true, 'null with format');\n    });\n\n    test('invalid month', function (assert) {\n        assert.equal(flags('1982 May', 'YYYY MMMM').invalidMonth, null, 'normal input');\n        assert.equal(flags('1982 Laser', 'YYYY MMMM').invalidMonth, 'Laser', 'bad month name');\n    });\n\n    test('empty format array', function (assert) {\n        assert.equal(flags('1982 May', ['YYYY MMM']).invalidFormat, false, 'empty format array');\n        assert.equal(flags('1982 May', []).invalidFormat, true, 'empty format array');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    var symbolMap = {\n            '1': '!',\n            '2': '@',\n            '3': '#',\n            '4': '$',\n            '5': '%',\n            '6': '^',\n            '7': '&',\n            '8': '*',\n            '9': '(',\n            '0': ')'\n        },\n        numberMap = {\n            '!': '1',\n            '@': '2',\n            '#': '3',\n            '$': '4',\n            '%': '5',\n            '^': '6',\n            '&': '7',\n            '*': '8',\n            '(': '9',\n            ')': '0'\n        };\n\n    module('preparse and postformat', {\n        setup: function () {\n            moment.locale('symbol', {\n                preparse: function (string) {\n                    return string.replace(/[!@#$%\\^&*()]/g, function (match) {\n                        return numberMap[match];\n                    });\n                },\n\n                postformat: function (string) {\n                    return string.replace(/\\d/g, function (match) {\n                        return symbolMap[match];\n                    });\n                }\n            });\n        },\n        teardown: function () {\n            moment.defineLocale('symbol', null);\n        }\n    });\n\n    test('transform', function (assert) {\n        assert.equal(moment.utc('@)!@-)*-@&', 'YYYY-MM-DD').unix(), 1346025600, 'preparse string + format');\n        assert.equal(moment.utc('@)!@-)*-@&').unix(), 1346025600, 'preparse ISO8601 string');\n        assert.equal(moment.unix(1346025600).utc().format('YYYY-MM-DD'), '@)!@-)*-@&', 'postformat');\n    });\n\n    test('transform from', function (assert) {\n        var start = moment([2007, 1, 28]);\n\n        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '@ minutes', 'postformat should work on moment.fn.from');\n        assert.equal(moment().add(6, 'd').fromNow(true), '^ days', 'postformat should work on moment.fn.fromNow');\n        assert.equal(moment.duration(10, 'h').humanize(), '!) hours', 'postformat should work on moment.duration.fn.humanize');\n    });\n\n    test('calendar day', function (assert) {\n        var a = moment().hours(12).minutes(0).seconds(0);\n\n        assert.equal(moment(a).calendar(),                   'Today at !@:)) PM',     'today at the same time');\n        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at !@:@% PM',     'Now plus 25 min');\n        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at !:)) PM',      'Now plus 1 hour');\n        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at !@:)) PM',  'tomorrow at the same time');\n        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at !!:)) AM',     'Now minus 1 hour');\n        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at !@:)) PM', 'yesterday at the same time');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('quarter');\n\n    test('library quarter getter', function (assert) {\n        assert.equal(moment([1985,  1,  4]).quarter(), 1, 'Feb  4 1985 is Q1');\n        assert.equal(moment([2029,  8, 18]).quarter(), 3, 'Sep 18 2029 is Q3');\n        assert.equal(moment([2013,  3, 24]).quarter(), 2, 'Apr 24 2013 is Q2');\n        assert.equal(moment([2015,  2,  5]).quarter(), 1, 'Mar  5 2015 is Q1');\n        assert.equal(moment([1970,  0,  2]).quarter(), 1, 'Jan  2 1970 is Q1');\n        assert.equal(moment([2001, 11, 12]).quarter(), 4, 'Dec 12 2001 is Q4');\n        assert.equal(moment([2000,  0,  2]).quarter(), 1, 'Jan  2 2000 is Q1');\n    });\n\n    test('quarter setter singular', function (assert) {\n        var m = moment([2014, 4, 11]);\n        assert.equal(m.quarter(2).month(), 4, 'set same quarter');\n        assert.equal(m.quarter(3).month(), 7, 'set 3rd quarter');\n        assert.equal(m.quarter(1).month(), 1, 'set 1st quarter');\n        assert.equal(m.quarter(4).month(), 10, 'set 4th quarter');\n    });\n\n    test('quarter setter plural', function (assert) {\n        var m = moment([2014, 4, 11]);\n        assert.equal(m.quarters(2).month(), 4, 'set same quarter');\n        assert.equal(m.quarters(3).month(), 7, 'set 3rd quarter');\n        assert.equal(m.quarters(1).month(), 1, 'set 1st quarter');\n        assert.equal(m.quarters(4).month(), 10, 'set 4th quarter');\n    });\n\n    test('quarter setter programmatic', function (assert) {\n        var m = moment([2014, 4, 11]);\n        assert.equal(m.set('quarter', 2).month(), 4, 'set same quarter');\n        assert.equal(m.set('quarter', 3).month(), 7, 'set 3rd quarter');\n        assert.equal(m.set('quarter', 1).month(), 1, 'set 1st quarter');\n        assert.equal(m.set('quarter', 4).month(), 10, 'set 4th quarter');\n    });\n\n    test('quarter setter programmatic plural', function (assert) {\n        var m = moment([2014, 4, 11]);\n        assert.equal(m.set('quarters', 2).month(), 4, 'set same quarter');\n        assert.equal(m.set('quarters', 3).month(), 7, 'set 3rd quarter');\n        assert.equal(m.set('quarters', 1).month(), 1, 'set 1st quarter');\n        assert.equal(m.set('quarters', 4).month(), 10, 'set 4th quarter');\n    });\n\n    test('quarter setter programmatic abbr', function (assert) {\n        var m = moment([2014, 4, 11]);\n        assert.equal(m.set('Q', 2).month(), 4, 'set same quarter');\n        assert.equal(m.set('Q', 3).month(), 7, 'set 3rd quarter');\n        assert.equal(m.set('Q', 1).month(), 1, 'set 1st quarter');\n        assert.equal(m.set('Q', 4).month(), 10, 'set 4th quarter');\n    });\n\n    test('quarter setter only month changes', function (assert) {\n        var m = moment([2014, 4, 11, 1, 2, 3, 4]).quarter(4);\n        assert.equal(m.year(), 2014, 'keep year');\n        assert.equal(m.month(), 10, 'set month');\n        assert.equal(m.date(), 11, 'keep date');\n        assert.equal(m.hour(), 1, 'keep hour');\n        assert.equal(m.minute(), 2, 'keep minutes');\n        assert.equal(m.second(), 3, 'keep seconds');\n        assert.equal(m.millisecond(), 4, 'keep milliseconds');\n    });\n\n    test('quarter setter bubble to next year', function (assert) {\n        var m = moment([2014, 4, 11, 1, 2, 3, 4]).quarter(7);\n        assert.equal(m.year(), 2015, 'year bubbled');\n        assert.equal(m.month(), 7, 'set month');\n        assert.equal(m.date(), 11, 'keep date');\n        assert.equal(m.hour(), 1, 'keep hour');\n        assert.equal(m.minute(), 2, 'keep minutes');\n        assert.equal(m.second(), 3, 'keep seconds');\n        assert.equal(m.millisecond(), 4, 'keep milliseconds');\n    });\n\n    test('quarter diff', function (assert) {\n        assert.equal(moment('2014-01-01').diff(moment('2014-04-01'), 'quarter'),\n                -1, 'diff -1 quarter');\n        assert.equal(moment('2014-04-01').diff(moment('2014-01-01'), 'quarter'),\n                1, 'diff 1 quarter');\n        assert.equal(moment('2014-05-01').diff(moment('2014-01-01'), 'quarter'),\n                1, 'diff 1 quarter');\n        assert.ok(Math.abs((4 / 3) - moment('2014-05-01').diff(\n                        moment('2014-01-01'), 'quarter', true)) < 0.00001,\n                'diff 1 1/3 quarter');\n        assert.equal(moment('2015-01-01').diff(moment('2014-01-01'), 'quarter'),\n                4, 'diff 4 quarters');\n    });\n\n    test('quarter setter bubble to previous year', function (assert) {\n        var m = moment([2014, 4, 11, 1, 2, 3, 4]).quarter(-3);\n        assert.equal(m.year(), 2013, 'year bubbled');\n        assert.equal(m.month(), 1, 'set month');\n        assert.equal(m.date(), 11, 'keep date');\n        assert.equal(m.hour(), 1, 'keep hour');\n        assert.equal(m.minute(), 2, 'keep minutes');\n        assert.equal(m.second(), 3, 'keep seconds');\n        assert.equal(m.millisecond(), 4, 'keep milliseconds');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('relative time');\n\n    test('default thresholds fromNow', function (assert) {\n        var a = moment();\n\n        // Seconds to minutes threshold\n        a.subtract(44, 'seconds');\n        assert.equal(a.fromNow(), 'a few seconds ago', 'Below default seconds to minutes threshold');\n        a.subtract(1, 'seconds');\n        assert.equal(a.fromNow(), 'a minute ago', 'Above default seconds to minutes threshold');\n\n        // Minutes to hours threshold\n        a = moment();\n        a.subtract(44, 'minutes');\n        assert.equal(a.fromNow(), '44 minutes ago', 'Below default minute to hour threshold');\n        a.subtract(1, 'minutes');\n        assert.equal(a.fromNow(), 'an hour ago', 'Above default minute to hour threshold');\n\n        // Hours to days threshold\n        a = moment();\n        a.subtract(21, 'hours');\n        assert.equal(a.fromNow(), '21 hours ago', 'Below default hours to day threshold');\n        a.subtract(1, 'hours');\n        assert.equal(a.fromNow(), 'a day ago', 'Above default hours to day threshold');\n\n        // Days to month threshold\n        a = moment();\n        a.subtract(25, 'days');\n        assert.equal(a.fromNow(), '25 days ago', 'Below default days to month (singular) threshold');\n        a.subtract(1, 'days');\n        assert.equal(a.fromNow(), 'a month ago', 'Above default days to month (singular) threshold');\n\n        // months to year threshold\n        a = moment();\n        a.subtract(10, 'months');\n        assert.equal(a.fromNow(), '10 months ago', 'Below default days to years threshold');\n        a.subtract(1, 'month');\n        assert.equal(a.fromNow(), 'a year ago', 'Above default days to years threshold');\n    });\n\n    test('default thresholds toNow', function (assert) {\n        var a = moment();\n\n        // Seconds to minutes threshold\n        a.subtract(44, 'seconds');\n        assert.equal(a.toNow(), 'in a few seconds', 'Below default seconds to minutes threshold');\n        a.subtract(1, 'seconds');\n        assert.equal(a.toNow(), 'in a minute', 'Above default seconds to minutes threshold');\n\n        // Minutes to hours threshold\n        a = moment();\n        a.subtract(44, 'minutes');\n        assert.equal(a.toNow(), 'in 44 minutes', 'Below default minute to hour threshold');\n        a.subtract(1, 'minutes');\n        assert.equal(a.toNow(), 'in an hour', 'Above default minute to hour threshold');\n\n        // Hours to days threshold\n        a = moment();\n        a.subtract(21, 'hours');\n        assert.equal(a.toNow(), 'in 21 hours', 'Below default hours to day threshold');\n        a.subtract(1, 'hours');\n        assert.equal(a.toNow(), 'in a day', 'Above default hours to day threshold');\n\n        // Days to month threshold\n        a = moment();\n        a.subtract(25, 'days');\n        assert.equal(a.toNow(), 'in 25 days', 'Below default days to month (singular) threshold');\n        a.subtract(1, 'days');\n        assert.equal(a.toNow(), 'in a month', 'Above default days to month (singular) threshold');\n\n        // months to year threshold\n        a = moment();\n        a.subtract(10, 'months');\n        assert.equal(a.toNow(), 'in 10 months', 'Below default days to years threshold');\n        a.subtract(1, 'month');\n        assert.equal(a.toNow(), 'in a year', 'Above default days to years threshold');\n    });\n\n    test('custom thresholds', function (assert) {\n        var a;\n\n        // Seconds to minute threshold, under 30\n        moment.relativeTimeThreshold('s', 25);\n\n        a = moment();\n        a.subtract(24, 'seconds');\n        assert.equal(a.fromNow(), 'a few seconds ago', 'Below custom seconds to minute threshold, s < 30');\n        a.subtract(1, 'seconds');\n        assert.equal(a.fromNow(), 'a minute ago', 'Above custom seconds to minute threshold, s < 30');\n\n        // Seconds to minutes threshold\n        moment.relativeTimeThreshold('s', 55);\n\n        a = moment();\n        a.subtract(54, 'seconds');\n        assert.equal(a.fromNow(), 'a few seconds ago', 'Below custom seconds to minutes threshold');\n        a.subtract(1, 'seconds');\n        assert.equal(a.fromNow(), 'a minute ago', 'Above custom seconds to minutes threshold');\n\n        moment.relativeTimeThreshold('s', 45);\n\n        // Minutes to hours threshold\n        moment.relativeTimeThreshold('m', 55);\n        a = moment();\n        a.subtract(54, 'minutes');\n        assert.equal(a.fromNow(), '54 minutes ago', 'Below custom minutes to hours threshold');\n        a.subtract(1, 'minutes');\n        assert.equal(a.fromNow(), 'an hour ago', 'Above custom minutes to hours threshold');\n        moment.relativeTimeThreshold('m', 45);\n\n        // Hours to days threshold\n        moment.relativeTimeThreshold('h', 24);\n        a = moment();\n        a.subtract(23, 'hours');\n        assert.equal(a.fromNow(), '23 hours ago', 'Below custom hours to days threshold');\n        a.subtract(1, 'hours');\n        assert.equal(a.fromNow(), 'a day ago', 'Above custom hours to days threshold');\n        moment.relativeTimeThreshold('h', 22);\n\n        // Days to month threshold\n        moment.relativeTimeThreshold('d', 28);\n        a = moment();\n        a.subtract(27, 'days');\n        assert.equal(a.fromNow(), '27 days ago', 'Below custom days to month (singular) threshold');\n        a.subtract(1, 'days');\n        assert.equal(a.fromNow(), 'a month ago', 'Above custom days to month (singular) threshold');\n        moment.relativeTimeThreshold('d', 26);\n\n        // months to years threshold\n        moment.relativeTimeThreshold('M', 9);\n        a = moment();\n        a.subtract(8, 'months');\n        assert.equal(a.fromNow(), '8 months ago', 'Below custom days to years threshold');\n        a.subtract(1, 'months');\n        assert.equal(a.fromNow(), 'a year ago', 'Above custom days to years threshold');\n        moment.relativeTimeThreshold('M', 11);\n    });\n\n    test('retrive threshold settings', function (assert) {\n        moment.relativeTimeThreshold('m', 45);\n        var minuteThreshold = moment.relativeTimeThreshold('m');\n\n        assert.equal(minuteThreshold, 45, 'Can retrieve minute setting');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('start and end of units');\n\n    test('start of year', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('year'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('years'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('y');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 0, 'strip out the month');\n        assert.equal(m.date(), 1, 'strip out the day');\n        assert.equal(m.hours(), 0, 'strip out the hours');\n        assert.equal(m.minutes(), 0, 'strip out the minutes');\n        assert.equal(m.seconds(), 0, 'strip out the seconds');\n        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');\n    });\n\n    test('end of year', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('year'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('years'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('y');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 11, 'set the month');\n        assert.equal(m.date(), 31, 'set the day');\n        assert.equal(m.hours(), 23, 'set the hours');\n        assert.equal(m.minutes(), 59, 'set the minutes');\n        assert.equal(m.seconds(), 59, 'set the seconds');\n        assert.equal(m.milliseconds(), 999, 'set the seconds');\n    });\n\n    test('start of quarter', function (assert) {\n        var m = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).startOf('quarter'),\n            ms = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).startOf('quarters'),\n            ma = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).startOf('Q');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.quarter(), 2, 'keep the quarter');\n        assert.equal(m.month(), 3, 'strip out the month');\n        assert.equal(m.date(), 1, 'strip out the day');\n        assert.equal(m.hours(), 0, 'strip out the hours');\n        assert.equal(m.minutes(), 0, 'strip out the minutes');\n        assert.equal(m.seconds(), 0, 'strip out the seconds');\n        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');\n    });\n\n    test('end of quarter', function (assert) {\n        var m = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).endOf('quarter'),\n            ms = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).endOf('quarters'),\n            ma = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).endOf('Q');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.quarter(), 2, 'keep the quarter');\n        assert.equal(m.month(), 5, 'set the month');\n        assert.equal(m.date(), 30, 'set the day');\n        assert.equal(m.hours(), 23, 'set the hours');\n        assert.equal(m.minutes(), 59, 'set the minutes');\n        assert.equal(m.seconds(), 59, 'set the seconds');\n        assert.equal(m.milliseconds(), 999, 'set the seconds');\n    });\n\n    test('start of month', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('month'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('months'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('M');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.date(), 1, 'strip out the day');\n        assert.equal(m.hours(), 0, 'strip out the hours');\n        assert.equal(m.minutes(), 0, 'strip out the minutes');\n        assert.equal(m.seconds(), 0, 'strip out the seconds');\n        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');\n    });\n\n    test('end of month', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('month'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('months'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('M');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.date(), 28, 'set the day');\n        assert.equal(m.hours(), 23, 'set the hours');\n        assert.equal(m.minutes(), 59, 'set the minutes');\n        assert.equal(m.seconds(), 59, 'set the seconds');\n        assert.equal(m.milliseconds(), 999, 'set the seconds');\n    });\n\n    test('start of week', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('week'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('weeks'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('w');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 0, 'rolls back to January');\n        assert.equal(m.day(), 0, 'set day of week');\n        assert.equal(m.date(), 30, 'set correct date');\n        assert.equal(m.hours(), 0, 'strip out the hours');\n        assert.equal(m.minutes(), 0, 'strip out the minutes');\n        assert.equal(m.seconds(), 0, 'strip out the seconds');\n        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');\n    });\n\n    test('end of week', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('week'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('weeks'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('weeks');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.day(), 6, 'set the day of the week');\n        assert.equal(m.date(), 5, 'set the day');\n        assert.equal(m.hours(), 23, 'set the hours');\n        assert.equal(m.minutes(), 59, 'set the minutes');\n        assert.equal(m.seconds(), 59, 'set the seconds');\n        assert.equal(m.milliseconds(), 999, 'set the seconds');\n    });\n\n    test('start of iso-week', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('isoWeek'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('isoWeeks'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('W');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 0, 'rollback to January');\n        assert.equal(m.isoWeekday(), 1, 'set day of iso-week');\n        assert.equal(m.date(), 31, 'set correct date');\n        assert.equal(m.hours(), 0, 'strip out the hours');\n        assert.equal(m.minutes(), 0, 'strip out the minutes');\n        assert.equal(m.seconds(), 0, 'strip out the seconds');\n        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');\n    });\n\n    test('end of iso-week', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('isoWeek'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('isoWeeks'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('W');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.isoWeekday(), 7, 'set the day of the week');\n        assert.equal(m.date(), 6, 'set the day');\n        assert.equal(m.hours(), 23, 'set the hours');\n        assert.equal(m.minutes(), 59, 'set the minutes');\n        assert.equal(m.seconds(), 59, 'set the seconds');\n        assert.equal(m.milliseconds(), 999, 'set the seconds');\n    });\n\n    test('start of day', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('day'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('days'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('d');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.date(), 2, 'keep the day');\n        assert.equal(m.hours(), 0, 'strip out the hours');\n        assert.equal(m.minutes(), 0, 'strip out the minutes');\n        assert.equal(m.seconds(), 0, 'strip out the seconds');\n        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');\n    });\n\n    test('end of day', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('day'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('days'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('d');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.date(), 2, 'keep the day');\n        assert.equal(m.hours(), 23, 'set the hours');\n        assert.equal(m.minutes(), 59, 'set the minutes');\n        assert.equal(m.seconds(), 59, 'set the seconds');\n        assert.equal(m.milliseconds(), 999, 'set the seconds');\n    });\n\n    test('start of date', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('date'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('dates');\n\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.date(), 2, 'keep the day');\n        assert.equal(m.hours(), 0, 'strip out the hours');\n        assert.equal(m.minutes(), 0, 'strip out the minutes');\n        assert.equal(m.seconds(), 0, 'strip out the seconds');\n        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');\n    });\n\n    test('end of date', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('date'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('dates');\n\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.date(), 2, 'keep the day');\n        assert.equal(m.hours(), 23, 'set the hours');\n        assert.equal(m.minutes(), 59, 'set the minutes');\n        assert.equal(m.seconds(), 59, 'set the seconds');\n        assert.equal(m.milliseconds(), 999, 'set the seconds');\n    });\n\n\n    test('start of hour', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('hour'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('hours'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('h');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.date(), 2, 'keep the day');\n        assert.equal(m.hours(), 3, 'keep the hours');\n        assert.equal(m.minutes(), 0, 'strip out the minutes');\n        assert.equal(m.seconds(), 0, 'strip out the seconds');\n        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');\n    });\n\n    test('end of hour', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('hour'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('hours'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('h');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.date(), 2, 'keep the day');\n        assert.equal(m.hours(), 3, 'keep the hours');\n        assert.equal(m.minutes(), 59, 'set the minutes');\n        assert.equal(m.seconds(), 59, 'set the seconds');\n        assert.equal(m.milliseconds(), 999, 'set the seconds');\n    });\n\n    test('start of minute', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('minute'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('minutes'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('m');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.date(), 2, 'keep the day');\n        assert.equal(m.hours(), 3, 'keep the hours');\n        assert.equal(m.minutes(), 4, 'keep the minutes');\n        assert.equal(m.seconds(), 0, 'strip out the seconds');\n        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');\n    });\n\n    test('end of minute', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('minute'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('minutes'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('m');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.date(), 2, 'keep the day');\n        assert.equal(m.hours(), 3, 'keep the hours');\n        assert.equal(m.minutes(), 4, 'keep the minutes');\n        assert.equal(m.seconds(), 59, 'set the seconds');\n        assert.equal(m.milliseconds(), 999, 'set the seconds');\n    });\n\n    test('start of second', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('second'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('seconds'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('s');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.date(), 2, 'keep the day');\n        assert.equal(m.hours(), 3, 'keep the hours');\n        assert.equal(m.minutes(), 4, 'keep the minutes');\n        assert.equal(m.seconds(), 5, 'keep the the seconds');\n        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');\n    });\n\n    test('end of second', function (assert) {\n        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('second'),\n            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('seconds'),\n            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('s');\n        assert.equal(+m, +ms, 'Plural or singular should work');\n        assert.equal(+m, +ma, 'Full or abbreviated should work');\n        assert.equal(m.year(), 2011, 'keep the year');\n        assert.equal(m.month(), 1, 'keep the month');\n        assert.equal(m.date(), 2, 'keep the day');\n        assert.equal(m.hours(), 3, 'keep the hours');\n        assert.equal(m.minutes(), 4, 'keep the minutes');\n        assert.equal(m.seconds(), 5, 'keep the seconds');\n        assert.equal(m.milliseconds(), 999, 'set the seconds');\n    });\n\n    test('startOf across DST +1', function (assert) {\n        var oldUpdateOffset = moment.updateOffset,\n            // Based on a real story somewhere in America/Los_Angeles\n            dstAt = moment('2014-03-09T02:00:00-08:00').parseZone(),\n            m;\n\n        moment.updateOffset = function (mom, keepTime) {\n            if (mom.isBefore(dstAt)) {\n                mom.utcOffset(-8, keepTime);\n            } else {\n                mom.utcOffset(-7, keepTime);\n            }\n        };\n\n        m = moment('2014-03-15T00:00:00-07:00').parseZone();\n        m.startOf('y');\n        assert.equal(m.format(), '2014-01-01T00:00:00-08:00', 'startOf(\\'year\\') across +1');\n\n        m = moment('2014-03-15T00:00:00-07:00').parseZone();\n        m.startOf('M');\n        assert.equal(m.format(), '2014-03-01T00:00:00-08:00', 'startOf(\\'month\\') across +1');\n\n        m = moment('2014-03-09T09:00:00-07:00').parseZone();\n        m.startOf('d');\n        assert.equal(m.format(), '2014-03-09T00:00:00-08:00', 'startOf(\\'day\\') across +1');\n\n        m = moment('2014-03-09T03:05:00-07:00').parseZone();\n        m.startOf('h');\n        assert.equal(m.format(), '2014-03-09T03:00:00-07:00', 'startOf(\\'hour\\') after +1');\n\n        m = moment('2014-03-09T01:35:00-08:00').parseZone();\n        m.startOf('h');\n        assert.equal(m.format(), '2014-03-09T01:00:00-08:00', 'startOf(\\'hour\\') before +1');\n\n        // There is no such time as 2:30-7 to try startOf('hour') across that\n\n        moment.updateOffset = oldUpdateOffset;\n    });\n\n    test('startOf across DST -1', function (assert) {\n        var oldUpdateOffset = moment.updateOffset,\n            // Based on a real story somewhere in America/Los_Angeles\n            dstAt = moment('2014-11-02T02:00:00-07:00').parseZone(),\n            m;\n\n        moment.updateOffset = function (mom, keepTime) {\n            if (mom.isBefore(dstAt)) {\n                mom.utcOffset(-7, keepTime);\n            } else {\n                mom.utcOffset(-8, keepTime);\n            }\n        };\n\n        m = moment('2014-11-15T00:00:00-08:00').parseZone();\n        m.startOf('y');\n        assert.equal(m.format(), '2014-01-01T00:00:00-07:00', 'startOf(\\'year\\') across -1');\n\n        m = moment('2014-11-15T00:00:00-08:00').parseZone();\n        m.startOf('M');\n        assert.equal(m.format(), '2014-11-01T00:00:00-07:00', 'startOf(\\'month\\') across -1');\n\n        m = moment('2014-11-02T09:00:00-08:00').parseZone();\n        m.startOf('d');\n        assert.equal(m.format(), '2014-11-02T00:00:00-07:00', 'startOf(\\'day\\') across -1');\n\n        // note that utc offset is -8\n        m = moment('2014-11-02T01:30:00-08:00').parseZone();\n        m.startOf('h');\n        assert.equal(m.format(), '2014-11-02T01:00:00-08:00', 'startOf(\\'hour\\') after +1');\n\n        // note that utc offset is -7\n        m = moment('2014-11-02T01:30:00-07:00').parseZone();\n        m.startOf('h');\n        assert.equal(m.format(), '2014-11-02T01:00:00-07:00', 'startOf(\\'hour\\') before +1');\n\n        moment.updateOffset = oldUpdateOffset;\n    });\n\n    test('endOf millisecond and no-arg', function (assert) {\n        var m = moment();\n        assert.equal(+m, +m.clone().endOf(), 'endOf without argument should change time');\n        assert.equal(+m, +m.clone().endOf('ms'), 'endOf with ms argument should change time');\n        assert.equal(+m, +m.clone().endOf('millisecond'), 'endOf with millisecond argument should change time');\n        assert.equal(+m, +m.clone().endOf('milliseconds'), 'endOf with milliseconds argument should change time');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('string prototype');\n\n    test('string prototype overrides call', function (assert) {\n        var prior = String.prototype.call, b;\n        String.prototype.call = function () {\n            return null;\n        };\n\n        b = moment(new Date(2011, 7, 28, 15, 25, 50, 125));\n        assert.equal(b.format('MMMM Do YYYY, h:mm a'), 'August 28th 2011, 3:25 pm');\n\n        String.prototype.call = prior;\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('to type');\n\n    test('toObject', function (assert) {\n        var expected = {\n            years:2010,\n            months:3,\n            date:5,\n            hours:15,\n            minutes:10,\n            seconds:3,\n            milliseconds:123\n        };\n        assert.deepEqual(moment(expected).toObject(), expected, 'toObject invalid');\n    });\n\n    test('toArray', function (assert) {\n        var expected = [2014, 11, 26, 11, 46, 58, 17];\n        assert.deepEqual(moment(expected).toArray(), expected, 'toArray invalid');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('utc');\n\n    test('utc and local', function (assert) {\n        var m = moment(Date.UTC(2011, 1, 2, 3, 4, 5, 6)), offset, expected;\n        m.utc();\n        // utc\n        assert.equal(m.date(), 2, 'the day should be correct for utc');\n        assert.equal(m.day(), 3, 'the date should be correct for utc');\n        assert.equal(m.hours(), 3, 'the hours should be correct for utc');\n\n        // local\n        m.local();\n        if (m.utcOffset() < -180) {\n            assert.equal(m.date(), 1, 'the date should be correct for local');\n            assert.equal(m.day(), 2, 'the day should be correct for local');\n        } else {\n            assert.equal(m.date(), 2, 'the date should be correct for local');\n            assert.equal(m.day(), 3, 'the day should be correct for local');\n        }\n        offset = Math.floor(m.utcOffset() / 60);\n        expected = (24 + 3 + offset) % 24;\n        assert.equal(m.hours(), expected, 'the hours (' + m.hours() + ') should be correct for local');\n        assert.equal(moment().utc().utcOffset(), 0, 'timezone in utc should always be zero');\n    });\n\n    test('creating with utc and no arguments', function (assert) {\n        var startOfTest = new Date().valueOf(),\n            momentDefaultUtcTime = moment.utc().valueOf(),\n            afterMomentCreationTime = new Date().valueOf();\n\n        assert.ok(startOfTest <= momentDefaultUtcTime, 'moment UTC default time should be now, not in the past');\n        assert.ok(momentDefaultUtcTime <= afterMomentCreationTime, 'moment UTC default time should be now, not in the future');\n    });\n\n    test('creating with utc and a date parameter array', function (assert) {\n        var m = moment.utc([2011, 1, 2, 3, 4, 5, 6]);\n        assert.equal(m.date(), 2, 'the day should be correct for utc array');\n        assert.equal(m.hours(), 3, 'the hours should be correct for utc array');\n\n        m = moment.utc('2011-02-02 3:04:05', 'YYYY-MM-DD HH:mm:ss');\n        assert.equal(m.date(), 2, 'the day should be correct for utc parsing format');\n        assert.equal(m.hours(), 3, 'the hours should be correct for utc parsing format');\n\n        m = moment.utc('2011-02-02T03:04:05+00:00');\n        assert.equal(m.date(), 2, 'the day should be correct for utc parsing iso');\n        assert.equal(m.hours(), 3, 'the hours should be correct for utc parsing iso');\n    });\n\n    test('creating with utc without timezone', function (assert) {\n        var m = moment.utc('2012-01-02T08:20:00');\n        assert.equal(m.date(), 2, 'the day should be correct for utc parse without timezone');\n        assert.equal(m.hours(), 8, 'the hours should be correct for utc parse without timezone');\n\n        m = moment.utc('2012-01-02T08:20:00+09:00');\n        assert.equal(m.date(), 1, 'the day should be correct for utc parse with timezone');\n        assert.equal(m.hours(), 23, 'the hours should be correct for utc parse with timezone');\n    });\n\n    test('cloning with utc offset', function (assert) {\n        var m = moment.utc('2012-01-02T08:20:00');\n        assert.equal(moment.utc(m)._isUTC, true, 'the local offset should be converted to UTC');\n        assert.equal(moment.utc(m.clone().utc())._isUTC, true, 'the local offset should stay in UTC');\n\n        m.utcOffset(120);\n        assert.equal(moment.utc(m)._isUTC, true, 'the explicit utc offset should stay in UTC');\n        assert.equal(moment.utc(m).utcOffset(), 0, 'the explicit utc offset should have an offset of 0');\n    });\n\n    test('weekday with utc', function (assert) {\n        assert.equal(\n            moment('2013-09-15T00:00:00Z').utc().weekday(), // first minute of the day\n            moment('2013-09-15T23:59:00Z').utc().weekday(), // last minute of the day\n            'a UTC-moment\\'s .weekday() should not be affected by the local timezone'\n        );\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('utc offset');\n\n    test('setter / getter blackbox', function (assert) {\n        var m = moment([2010]);\n\n        assert.equal(m.clone().utcOffset(0).utcOffset(), 0, 'utcOffset 0');\n\n        assert.equal(m.clone().utcOffset(1).utcOffset(), 60, 'utcOffset 1 is 60');\n        assert.equal(m.clone().utcOffset(60).utcOffset(), 60, 'utcOffset 60');\n        assert.equal(m.clone().utcOffset('+01:00').utcOffset(), 60, 'utcOffset +01:00 is 60');\n        assert.equal(m.clone().utcOffset('+0100').utcOffset(), 60, 'utcOffset +0100 is 60');\n\n        assert.equal(m.clone().utcOffset(-1).utcOffset(), -60, 'utcOffset -1 is -60');\n        assert.equal(m.clone().utcOffset(-60).utcOffset(), -60, 'utcOffset -60');\n        assert.equal(m.clone().utcOffset('-01:00').utcOffset(), -60, 'utcOffset -01:00 is -60');\n        assert.equal(m.clone().utcOffset('-0100').utcOffset(), -60, 'utcOffset -0100 is -60');\n\n        assert.equal(m.clone().utcOffset(1.5).utcOffset(), 90, 'utcOffset 1.5 is 90');\n        assert.equal(m.clone().utcOffset(90).utcOffset(), 90, 'utcOffset 1.5 is 90');\n        assert.equal(m.clone().utcOffset('+01:30').utcOffset(), 90, 'utcOffset +01:30 is 90');\n        assert.equal(m.clone().utcOffset('+0130').utcOffset(), 90, 'utcOffset +0130 is 90');\n\n        assert.equal(m.clone().utcOffset(-1.5).utcOffset(), -90, 'utcOffset -1.5');\n        assert.equal(m.clone().utcOffset(-90).utcOffset(), -90, 'utcOffset -90');\n        assert.equal(m.clone().utcOffset('-01:30').utcOffset(), -90, 'utcOffset +01:30 is 90');\n        assert.equal(m.clone().utcOffset('-0130').utcOffset(), -90, 'utcOffset +0130 is 90');\n        assert.equal(m.clone().utcOffset('+00:10').utcOffset(), 10, 'utcOffset +00:10 is 10');\n        assert.equal(m.clone().utcOffset('-00:10').utcOffset(), -10, 'utcOffset +00:10 is 10');\n        assert.equal(m.clone().utcOffset('+0010').utcOffset(), 10, 'utcOffset +0010 is 10');\n        assert.equal(m.clone().utcOffset('-0010').utcOffset(), -10, 'utcOffset +0010 is 10');\n    });\n\n    test('utcOffset shorthand hours -> minutes', function (assert) {\n        var i;\n        for (i = -15; i <= 15; ++i) {\n            assert.equal(moment().utcOffset(i).utcOffset(), i * 60,\n                    '' + i + ' -> ' + i * 60);\n        }\n        assert.equal(moment().utcOffset(-16).utcOffset(), -16, '-16 -> -16');\n        assert.equal(moment().utcOffset(16).utcOffset(), 16, '16 -> 16');\n    });\n\n    test('isLocal, isUtc, isUtcOffset', function (assert) {\n        assert.ok(moment().isLocal(), 'moment() creates objects in local time');\n        assert.ok(!moment.utc().isLocal(), 'moment.utc creates objects NOT in local time');\n        assert.ok(moment.utc().local().isLocal(), 'moment.fn.local() converts to local time');\n        assert.ok(!moment().utcOffset(5).isLocal(), 'moment.fn.utcOffset(N) puts objects NOT in local time');\n        assert.ok(moment().utcOffset(5).local().isLocal(), 'moment.fn.local() converts to local time');\n\n        assert.ok(moment.utc().isUtc(), 'moment.utc() creates objects in utc time');\n        assert.ok(moment().utcOffset(0).isUtc(), 'utcOffset(0) is equivalent to utc mode');\n        assert.ok(!moment().utcOffset(1).isUtc(), 'utcOffset(1) is NOT equivalent to utc mode');\n\n        assert.ok(!moment().isUtcOffset(), 'moment() creates objects NOT in utc-offset mode');\n        assert.ok(moment.utc().isUtcOffset(), 'moment.utc() creates objects in utc-offset mode');\n        assert.ok(moment().utcOffset(3).isUtcOffset(), 'utcOffset(N != 0) creates objects in utc-offset mode');\n        assert.ok(moment().utcOffset(0).isUtcOffset(), 'utcOffset(0) creates objects in utc-offset mode');\n    });\n\n    test('isUTC', function (assert) {\n        assert.ok(moment.utc().isUTC(), 'moment.utc() creates objects in utc time');\n        assert.ok(moment().utcOffset(0).isUTC(), 'utcOffset(0) is equivalent to utc mode');\n        assert.ok(!moment().utcOffset(1).isUTC(), 'utcOffset(1) is NOT equivalent to utc mode');\n    });\n\n    test('change hours when changing the utc offset', function (assert) {\n        var m = moment.utc([2000, 0, 1, 6]);\n        assert.equal(m.hour(), 6, 'UTC 6AM should be 6AM at +0000');\n\n        // sanity check\n        m.utcOffset(0);\n        assert.equal(m.hour(), 6, 'UTC 6AM should be 6AM at +0000');\n\n        m.utcOffset(-60);\n        assert.equal(m.hour(), 5, 'UTC 6AM should be 5AM at -0100');\n\n        m.utcOffset(60);\n        assert.equal(m.hour(), 7, 'UTC 6AM should be 7AM at +0100');\n    });\n\n    test('change minutes when changing the utc offset', function (assert) {\n        var m = moment.utc([2000, 0, 1, 6, 31]);\n\n        m.utcOffset(0);\n        assert.equal(m.format('HH:mm'), '06:31', 'UTC 6:31AM should be 6:31AM at +0000');\n\n        m.utcOffset(-30);\n        assert.equal(m.format('HH:mm'), '06:01', 'UTC 6:31AM should be 6:01AM at -0030');\n\n        m.utcOffset(30);\n        assert.equal(m.format('HH:mm'), '07:01', 'UTC 6:31AM should be 7:01AM at +0030');\n\n        m.utcOffset(-1380);\n        assert.equal(m.format('HH:mm'), '07:31', 'UTC 6:31AM should be 7:31AM at +1380');\n    });\n\n    test('distance from the unix epoch', function (assert) {\n        var zoneA = moment(),\n            zoneB = moment(zoneA),\n            zoneC = moment(zoneA),\n            zoneD = moment(zoneA),\n            zoneE = moment(zoneA);\n\n        zoneB.utc();\n        assert.equal(+zoneA, +zoneB, 'moment should equal moment.utc');\n\n        zoneC.utcOffset(60);\n        assert.equal(+zoneA, +zoneC, 'moment should equal moment.utcOffset(60)');\n\n        zoneD.utcOffset(-480);\n        assert.equal(+zoneA, +zoneD,\n                'moment should equal moment.utcOffset(-480)');\n\n        zoneE.utcOffset(-1000);\n        assert.equal(+zoneA, +zoneE,\n                'moment should equal moment.utcOffset(-1000)');\n    });\n\n    test('update offset after changing any values', function (assert) {\n        var oldOffset = moment.updateOffset,\n            m = moment.utc([2000, 6, 1]);\n\n        moment.updateOffset = function (mom, keepTime) {\n            if (mom.__doChange) {\n                if (+mom > 962409600000) {\n                    mom.utcOffset(-120, keepTime);\n                } else {\n                    mom.utcOffset(-60, keepTime);\n                }\n            }\n        };\n\n        assert.equal(m.format('ZZ'), '+0000', 'should be at +0000');\n        assert.equal(m.format('HH:mm'), '00:00', 'should start 12AM at +0000 timezone');\n\n        m.__doChange = true;\n        m.add(1, 'h');\n\n        assert.equal(m.format('ZZ'), '-0200', 'should be at -0200');\n        assert.equal(m.format('HH:mm'), '23:00', '1AM at +0000 should be 11PM at -0200 timezone');\n\n        m.subtract(1, 'h');\n\n        assert.equal(m.format('ZZ'), '-0100', 'should be at -0100');\n        assert.equal(m.format('HH:mm'), '23:00', '12AM at +0000 should be 11PM at -0100 timezone');\n\n        moment.updateOffset = oldOffset;\n    });\n\n    //////////////////\n    test('getters and setters', function (assert) {\n        var a = moment([2011, 5, 20]);\n\n        assert.equal(a.clone().utcOffset(-120).year(2012).year(), 2012, 'should get and set year correctly');\n        assert.equal(a.clone().utcOffset(-120).month(1).month(), 1, 'should get and set month correctly');\n        assert.equal(a.clone().utcOffset(-120).date(2).date(), 2, 'should get and set date correctly');\n        assert.equal(a.clone().utcOffset(-120).day(1).day(), 1, 'should get and set day correctly');\n        assert.equal(a.clone().utcOffset(-120).hour(1).hour(), 1, 'should get and set hour correctly');\n        assert.equal(a.clone().utcOffset(-120).minute(1).minute(), 1, 'should get and set minute correctly');\n    });\n\n    test('getters', function (assert) {\n        var a = moment.utc([2012, 0, 1, 0, 0, 0]);\n\n        assert.equal(a.clone().utcOffset(-120).year(),  2011, 'should get year correctly');\n        assert.equal(a.clone().utcOffset(-120).month(),   11, 'should get month correctly');\n        assert.equal(a.clone().utcOffset(-120).date(),    31, 'should get date correctly');\n        assert.equal(a.clone().utcOffset(-120).hour(),    22, 'should get hour correctly');\n        assert.equal(a.clone().utcOffset(-120).minute(),   0, 'should get minute correctly');\n\n        assert.equal(a.clone().utcOffset(120).year(),  2012, 'should get year correctly');\n        assert.equal(a.clone().utcOffset(120).month(),    0, 'should get month correctly');\n        assert.equal(a.clone().utcOffset(120).date(),     1, 'should get date correctly');\n        assert.equal(a.clone().utcOffset(120).hour(),     2, 'should get hour correctly');\n        assert.equal(a.clone().utcOffset(120).minute(),   0, 'should get minute correctly');\n\n        assert.equal(a.clone().utcOffset(90).year(),  2012, 'should get year correctly');\n        assert.equal(a.clone().utcOffset(90).month(),    0, 'should get month correctly');\n        assert.equal(a.clone().utcOffset(90).date(),     1, 'should get date correctly');\n        assert.equal(a.clone().utcOffset(90).hour(),     1, 'should get hour correctly');\n        assert.equal(a.clone().utcOffset(90).minute(),  30, 'should get minute correctly');\n    });\n\n    test('from', function (assert) {\n        var zoneA = moment(),\n            zoneB = moment(zoneA).utcOffset(-720),\n            zoneC = moment(zoneA).utcOffset(-360),\n            zoneD = moment(zoneA).utcOffset(690),\n            other = moment(zoneA).add(35, 'm');\n\n        assert.equal(zoneA.from(other), zoneB.from(other), 'moment#from should be the same in all zones');\n        assert.equal(zoneA.from(other), zoneC.from(other), 'moment#from should be the same in all zones');\n        assert.equal(zoneA.from(other), zoneD.from(other), 'moment#from should be the same in all zones');\n    });\n\n    test('diff', function (assert) {\n        var zoneA = moment(),\n            zoneB = moment(zoneA).utcOffset(-720),\n            zoneC = moment(zoneA).utcOffset(-360),\n            zoneD = moment(zoneA).utcOffset(690),\n            other = moment(zoneA).add(35, 'm');\n\n        assert.equal(zoneA.diff(other), zoneB.diff(other), 'moment#diff should be the same in all zones');\n        assert.equal(zoneA.diff(other), zoneC.diff(other), 'moment#diff should be the same in all zones');\n        assert.equal(zoneA.diff(other), zoneD.diff(other), 'moment#diff should be the same in all zones');\n\n        assert.equal(zoneA.diff(other, 'minute', true), zoneB.diff(other, 'minute', true), 'moment#diff should be the same in all zones');\n        assert.equal(zoneA.diff(other, 'minute', true), zoneC.diff(other, 'minute', true), 'moment#diff should be the same in all zones');\n        assert.equal(zoneA.diff(other, 'minute', true), zoneD.diff(other, 'minute', true), 'moment#diff should be the same in all zones');\n\n        assert.equal(zoneA.diff(other, 'hour', true), zoneB.diff(other, 'hour', true), 'moment#diff should be the same in all zones');\n        assert.equal(zoneA.diff(other, 'hour', true), zoneC.diff(other, 'hour', true), 'moment#diff should be the same in all zones');\n        assert.equal(zoneA.diff(other, 'hour', true), zoneD.diff(other, 'hour', true), 'moment#diff should be the same in all zones');\n    });\n\n    test('unix offset and timestamp', function (assert) {\n        var zoneA = moment(),\n            zoneB = moment(zoneA).utcOffset(-720),\n            zoneC = moment(zoneA).utcOffset(-360),\n            zoneD = moment(zoneA).utcOffset(690);\n\n        assert.equal(zoneA.unix(), zoneB.unix(), 'moment#unix should be the same in all zones');\n        assert.equal(zoneA.unix(), zoneC.unix(), 'moment#unix should be the same in all zones');\n        assert.equal(zoneA.unix(), zoneD.unix(), 'moment#unix should be the same in all zones');\n\n        assert.equal(+zoneA, +zoneB, 'moment#valueOf should be the same in all zones');\n        assert.equal(+zoneA, +zoneC, 'moment#valueOf should be the same in all zones');\n        assert.equal(+zoneA, +zoneD, 'moment#valueOf should be the same in all zones');\n    });\n\n    test('cloning', function (assert) {\n        assert.equal(moment().utcOffset(-120).clone().utcOffset(), -120,\n                'explicit cloning should retain the offset');\n        assert.equal(moment().utcOffset(120).clone().utcOffset(), 120,\n                'explicit cloning should retain the offset');\n        assert.equal(moment(moment().utcOffset(-120)).utcOffset(), -120,\n                'implicit cloning should retain the offset');\n        assert.equal(moment(moment().utcOffset(120)).utcOffset(), 120,\n                'implicit cloning should retain the offset');\n    });\n\n    test('start of / end of', function (assert) {\n        var a = moment.utc([2010, 1, 2, 0, 0, 0]).utcOffset(-450);\n\n        assert.equal(a.clone().startOf('day').hour(), 0,\n                'start of day should work on moments with utc offset');\n        assert.equal(a.clone().startOf('day').minute(), 0,\n                'start of day should work on moments with utc offset');\n        assert.equal(a.clone().startOf('hour').minute(), 0,\n                'start of hour should work on moments with utc offset');\n\n        assert.equal(a.clone().endOf('day').hour(), 23,\n                'end of day should work on moments with utc offset');\n        assert.equal(a.clone().endOf('day').minute(), 59,\n                'end of day should work on moments with utc offset');\n        assert.equal(a.clone().endOf('hour').minute(), 59,\n                'end of hour should work on moments with utc offset');\n    });\n\n    test('reset offset with moment#utc', function (assert) {\n        var a = moment.utc([2012]).utcOffset(-480);\n\n        assert.equal(a.clone().hour(),      16, 'different utc offset should have different hour');\n        assert.equal(a.clone().utc().hour(), 0, 'calling moment#utc should reset the offset');\n    });\n\n    test('reset offset with moment#local', function (assert) {\n        var a = moment([2012]).utcOffset(-480);\n\n        assert.equal(a.clone().local().hour(), 0, 'calling moment#local should reset the offset');\n    });\n\n    test('toDate', function (assert) {\n        var zoneA = new Date(),\n            zoneB = moment(zoneA).utcOffset(-720).toDate(),\n            zoneC = moment(zoneA).utcOffset(-360).toDate(),\n            zoneD = moment(zoneA).utcOffset(690).toDate();\n\n        assert.equal(+zoneA, +zoneB, 'moment#toDate should output a date with the right unix timestamp');\n        assert.equal(+zoneA, +zoneC, 'moment#toDate should output a date with the right unix timestamp');\n        assert.equal(+zoneA, +zoneD, 'moment#toDate should output a date with the right unix timestamp');\n    });\n\n    test('same / before / after', function (assert) {\n        var zoneA = moment().utc(),\n            zoneB = moment(zoneA).utcOffset(-120),\n            zoneC = moment(zoneA).utcOffset(120);\n\n        assert.ok(zoneA.isSame(zoneB), 'two moments with different offsets should be the same');\n        assert.ok(zoneA.isSame(zoneC), 'two moments with different offsets should be the same');\n\n        assert.ok(zoneA.isSame(zoneB, 'hour'), 'two moments with different offsets should be the same hour');\n        assert.ok(zoneA.isSame(zoneC, 'hour'), 'two moments with different offsets should be the same hour');\n\n        zoneA.add(1, 'hour');\n\n        assert.ok(zoneA.isAfter(zoneB), 'isAfter should work with two moments with different offsets');\n        assert.ok(zoneA.isAfter(zoneC), 'isAfter should work with two moments with different offsets');\n\n        assert.ok(zoneA.isAfter(zoneB, 'hour'), 'isAfter:hour should work with two moments with different offsets');\n        assert.ok(zoneA.isAfter(zoneC, 'hour'), 'isAfter:hour should work with two moments with different offsets');\n\n        zoneA.subtract(2, 'hour');\n\n        assert.ok(zoneA.isBefore(zoneB), 'isBefore should work with two moments with different offsets');\n        assert.ok(zoneA.isBefore(zoneC), 'isBefore should work with two moments with different offsets');\n\n        assert.ok(zoneA.isBefore(zoneB, 'hour'), 'isBefore:hour should work with two moments with different offsets');\n        assert.ok(zoneA.isBefore(zoneC, 'hour'), 'isBefore:hour should work with two moments with different offsets');\n    });\n\n    test('add / subtract over dst', function (assert) {\n        var oldOffset = moment.updateOffset,\n            m = moment.utc([2000, 2, 31, 3]);\n\n        moment.updateOffset = function (mom, keepTime) {\n            if (mom.clone().utc().month() > 2) {\n                mom.utcOffset(60, keepTime);\n            } else {\n                mom.utcOffset(0, keepTime);\n            }\n        };\n\n        assert.equal(m.hour(), 3, 'should start at 00:00');\n\n        m.add(24, 'hour');\n\n        assert.equal(m.hour(), 4, 'adding 24 hours should disregard dst');\n\n        m.subtract(24, 'hour');\n\n        assert.equal(m.hour(), 3, 'subtracting 24 hours should disregard dst');\n\n        m.add(1, 'day');\n\n        assert.equal(m.hour(), 3, 'adding 1 day should have the same hour');\n\n        m.subtract(1, 'day');\n\n        assert.equal(m.hour(), 3, 'subtracting 1 day should have the same hour');\n\n        m.add(1, 'month');\n\n        assert.equal(m.hour(), 3, 'adding 1 month should have the same hour');\n\n        m.subtract(1, 'month');\n\n        assert.equal(m.hour(), 3, 'subtracting 1 month should have the same hour');\n\n        moment.updateOffset = oldOffset;\n    });\n\n    test('isDST', function (assert) {\n        var oldOffset = moment.updateOffset;\n\n        moment.updateOffset = function (mom, keepTime) {\n            if (mom.month() > 2 && mom.month() < 9) {\n                mom.utcOffset(60, keepTime);\n            } else {\n                mom.utcOffset(0, keepTime);\n            }\n        };\n\n        assert.ok(!moment().month(0).isDST(),  'Jan should not be summer dst');\n        assert.ok(moment().month(6).isDST(),   'Jul should be summer dst');\n        assert.ok(!moment().month(11).isDST(), 'Dec should not be summer dst');\n\n        moment.updateOffset = function (mom) {\n            if (mom.month() > 2 && mom.month() < 9) {\n                mom.utcOffset(0);\n            } else {\n                mom.utcOffset(60);\n            }\n        };\n\n        assert.ok(moment().month(0).isDST(),  'Jan should be winter dst');\n        assert.ok(!moment().month(6).isDST(), 'Jul should not be winter dst');\n        assert.ok(moment().month(11).isDST(), 'Dec should be winter dst');\n\n        moment.updateOffset = oldOffset;\n    });\n\n    test('zone names', function (assert) {\n        assert.equal(moment().zoneAbbr(),   '', 'Local zone abbr should be empty');\n        assert.equal(moment().format('z'),  '', 'Local zone formatted abbr should be empty');\n        assert.equal(moment().zoneName(),   '', 'Local zone name should be empty');\n        assert.equal(moment().format('zz'), '', 'Local zone formatted name should be empty');\n\n        assert.equal(moment.utc().zoneAbbr(),   'UTC', 'UTC zone abbr should be UTC');\n        assert.equal(moment.utc().format('z'),  'UTC', 'UTC zone formatted abbr should be UTC');\n        assert.equal(moment.utc().zoneName(),   'Coordinated Universal Time', 'UTC zone abbr should be Coordinated Universal Time');\n        assert.equal(moment.utc().format('zz'), 'Coordinated Universal Time', 'UTC zone formatted abbr should be Coordinated Universal Time');\n    });\n\n    test('hours alignment with UTC', function (assert) {\n        assert.equal(moment().utcOffset(-120).hasAlignedHourOffset(), true);\n        assert.equal(moment().utcOffset(180).hasAlignedHourOffset(), true);\n        assert.equal(moment().utcOffset(-90).hasAlignedHourOffset(), false);\n        assert.equal(moment().utcOffset(90).hasAlignedHourOffset(), false);\n    });\n\n    test('hours alignment with other zone', function (assert) {\n        var m = moment().utcOffset(-120);\n\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-180)), true);\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(180)), true);\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-90)), false);\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(90)), false);\n\n        m = moment().utcOffset(-90);\n\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-180)), false);\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(180)), false);\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-30)), true);\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(30)), true);\n\n        m = moment().utcOffset(60);\n\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-180)), true);\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(180)), true);\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-90)), false);\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(90)), false);\n\n        m = moment().utcOffset(-25);\n\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(35)), true);\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-85)), true);\n\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-35)), false);\n        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(85)), false);\n    });\n\n    test('parse zone', function (assert) {\n        var m = moment('2013-01-01T00:00:00-13:00').parseZone();\n        assert.equal(m.utcOffset(), -13 * 60);\n        assert.equal(m.hours(), 0);\n    });\n\n    test('parse zone static', function (assert) {\n        var m = moment.parseZone('2013-01-01T00:00:00-13:00');\n        assert.equal(m.utcOffset(), -13 * 60);\n        assert.equal(m.hours(), 0);\n    });\n\n    test('parse zone with more arguments', function (assert) {\n        var m;\n        m = moment.parseZone('2013 01 01 05 -13:00', 'YYYY MM DD HH ZZ');\n        assert.equal(m.format(), '2013-01-01T05:00:00-13:00', 'accept input and format');\n        m = moment.parseZone('2013-01-01-13:00', 'YYYY MM DD ZZ', true);\n        assert.equal(m.isValid(), false, 'accept input, format and strict flag');\n        m = moment.parseZone('2013-01-01-13:00', ['DD MM YYYY ZZ', 'YYYY MM DD ZZ']);\n        assert.equal(m.format(), '2013-01-01T00:00:00-13:00', 'accept input and array of formats');\n    });\n\n    test('parse zone with a timezone from the format string', function (assert) {\n        var m = moment('11-12-2013 -0400 +1100', 'DD-MM-YYYY ZZ #####').parseZone();\n\n        assert.equal(m.utcOffset(), -4 * 60);\n    });\n\n    test('parse zone without a timezone included in the format string', function (assert) {\n        var m = moment('11-12-2013 -0400 +1100', 'DD-MM-YYYY').parseZone();\n\n        assert.equal(m.utcOffset(), 11 * 60);\n    });\n\n    test('timezone format', function (assert) {\n        assert.equal(moment().utcOffset(60).format('ZZ'), '+0100', '-60 -> +0100');\n        assert.equal(moment().utcOffset(90).format('ZZ'), '+0130', '-90 -> +0130');\n        assert.equal(moment().utcOffset(120).format('ZZ'), '+0200', '-120 -> +0200');\n\n        assert.equal(moment().utcOffset(-60).format('ZZ'), '-0100', '+60 -> -0100');\n        assert.equal(moment().utcOffset(-90).format('ZZ'), '-0130', '+90 -> -0130');\n        assert.equal(moment().utcOffset(-120).format('ZZ'), '-0200', '+120 -> -0200');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('week year');\n\n    test('iso week year', function (assert) {\n        // Some examples taken from http://en.wikipedia.org/wiki/ISO_week\n        assert.equal(moment([2005, 0, 1]).isoWeekYear(), 2004);\n        assert.equal(moment([2005, 0, 2]).isoWeekYear(), 2004);\n        assert.equal(moment([2005, 0, 3]).isoWeekYear(), 2005);\n        assert.equal(moment([2005, 11, 31]).isoWeekYear(), 2005);\n        assert.equal(moment([2006, 0, 1]).isoWeekYear(), 2005);\n        assert.equal(moment([2006, 0, 2]).isoWeekYear(), 2006);\n        assert.equal(moment([2007, 0, 1]).isoWeekYear(), 2007);\n        assert.equal(moment([2007, 11, 30]).isoWeekYear(), 2007);\n        assert.equal(moment([2007, 11, 31]).isoWeekYear(), 2008);\n        assert.equal(moment([2008, 0, 1]).isoWeekYear(), 2008);\n        assert.equal(moment([2008, 11, 28]).isoWeekYear(), 2008);\n        assert.equal(moment([2008, 11, 29]).isoWeekYear(), 2009);\n        assert.equal(moment([2008, 11, 30]).isoWeekYear(), 2009);\n        assert.equal(moment([2008, 11, 31]).isoWeekYear(), 2009);\n        assert.equal(moment([2009, 0, 1]).isoWeekYear(), 2009);\n        assert.equal(moment([2010, 0, 1]).isoWeekYear(), 2009);\n        assert.equal(moment([2010, 0, 2]).isoWeekYear(), 2009);\n        assert.equal(moment([2010, 0, 3]).isoWeekYear(), 2009);\n        assert.equal(moment([2010, 0, 4]).isoWeekYear(), 2010);\n    });\n\n    test('week year', function (assert) {\n        // Some examples taken from http://en.wikipedia.org/wiki/ISO_week\n        moment.locale('dow: 1,doy: 4', {week: {dow: 1, doy: 4}}); // like iso\n        assert.equal(moment([2005, 0, 1]).weekYear(), 2004);\n        assert.equal(moment([2005, 0, 2]).weekYear(), 2004);\n        assert.equal(moment([2005, 0, 3]).weekYear(), 2005);\n        assert.equal(moment([2005, 11, 31]).weekYear(), 2005);\n        assert.equal(moment([2006, 0, 1]).weekYear(), 2005);\n        assert.equal(moment([2006, 0, 2]).weekYear(), 2006);\n        assert.equal(moment([2007, 0, 1]).weekYear(), 2007);\n        assert.equal(moment([2007, 11, 30]).weekYear(), 2007);\n        assert.equal(moment([2007, 11, 31]).weekYear(), 2008);\n        assert.equal(moment([2008, 0, 1]).weekYear(), 2008);\n        assert.equal(moment([2008, 11, 28]).weekYear(), 2008);\n        assert.equal(moment([2008, 11, 29]).weekYear(), 2009);\n        assert.equal(moment([2008, 11, 30]).weekYear(), 2009);\n        assert.equal(moment([2008, 11, 31]).weekYear(), 2009);\n        assert.equal(moment([2009, 0, 1]).weekYear(), 2009);\n        assert.equal(moment([2010, 0, 1]).weekYear(), 2009);\n        assert.equal(moment([2010, 0, 2]).weekYear(), 2009);\n        assert.equal(moment([2010, 0, 3]).weekYear(), 2009);\n        assert.equal(moment([2010, 0, 4]).weekYear(), 2010);\n\n        moment.locale('dow: 1,doy: 7', {week: {dow: 1, doy: 7}});\n        assert.equal(moment([2004, 11, 26]).weekYear(), 2004);\n        assert.equal(moment([2004, 11, 27]).weekYear(), 2005);\n        assert.equal(moment([2005, 11, 25]).weekYear(), 2005);\n        assert.equal(moment([2005, 11, 26]).weekYear(), 2006);\n        assert.equal(moment([2006, 11, 31]).weekYear(), 2006);\n        assert.equal(moment([2007,  0,  1]).weekYear(), 2007);\n        assert.equal(moment([2007, 11, 30]).weekYear(), 2007);\n        assert.equal(moment([2007, 11, 31]).weekYear(), 2008);\n        assert.equal(moment([2008, 11, 28]).weekYear(), 2008);\n        assert.equal(moment([2008, 11, 29]).weekYear(), 2009);\n        assert.equal(moment([2009, 11, 27]).weekYear(), 2009);\n        assert.equal(moment([2009, 11, 28]).weekYear(), 2010);\n    });\n\n    // Verifies that the week number, week day computation is correct for all dow, doy combinations\n    test('week year roundtrip', function (assert) {\n        var dow, doy, wd, m, localeName;\n        for (dow = 0; dow < 7; ++dow) {\n            for (doy = dow; doy < dow + 7; ++doy) {\n                for (wd = 0; wd < 7; ++wd) {\n                    localeName = 'dow: ' + dow + ', doy: ' + doy;\n                    moment.locale(localeName, {week: {dow: dow, doy: doy}});\n                    // We use the 10th week as the 1st one can spill to the previous year\n                    m = moment('2015 10 ' + wd, 'gggg w d', true);\n                    assert.equal(m.format('gggg w d'), '2015 10 ' + wd, 'dow: ' + dow + ' doy: ' + doy + ' wd: ' + wd);\n                    m = moment('2015 10 ' + wd, 'gggg w e', true);\n                    assert.equal(m.format('gggg w e'), '2015 10 ' + wd, 'dow: ' + dow + ' doy: ' + doy + ' wd: ' + wd);\n                    moment.defineLocale(localeName, null);\n                }\n            }\n        }\n    });\n\n    test('week numbers 2012/2013', function (assert) {\n        moment.locale('dow: 6, doy: 12', {week: {dow: 6, doy: 12}});\n        assert.equal(52, moment('2012-12-28', 'YYYY-MM-DD').week(), '2012-12-28 is week 52'); // 51 -- should be 52?\n        assert.equal(1, moment('2012-12-29', 'YYYY-MM-DD').week(), '2012-12-29 is week 1'); // 52 -- should be 1\n        assert.equal(1, moment('2013-01-01', 'YYYY-MM-DD').week(), '2013-01-01 is week 1'); // 52 -- should be 1\n        assert.equal(2, moment('2013-01-08', 'YYYY-MM-DD').week(), '2013-01-08 is week 2'); // 53 -- should be 2\n        assert.equal(2, moment('2013-01-11', 'YYYY-MM-DD').week(), '2013-01-11 is week 2'); // 53 -- should be 2\n        assert.equal(3, moment('2013-01-12', 'YYYY-MM-DD').week(), '2013-01-12 is week 3'); // 1 -- should be 3\n        assert.equal(52, moment('2012-01-01', 'YYYY-MM-DD').weeksInYear(), 'weeks in 2012 are 52'); // 52\n        moment.defineLocale('dow: 6, doy: 12', null);\n    });\n\n    test('weeks numbers dow:1 doy:4', function (assert) {\n        moment.locale('dow: 1, doy: 4', {week: {dow: 1, doy: 4}});\n        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');\n        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');\n        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');\n        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');\n        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');\n        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');\n        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');\n        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');\n        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');\n        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');\n        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');\n        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');\n        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');\n        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');\n        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');\n        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');\n        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');\n        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');\n        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');\n        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');\n        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');\n        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');\n        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');\n        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');\n        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');\n        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');\n        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');\n        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');\n        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');\n        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');\n        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');\n        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');\n        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');\n        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');\n        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');\n        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');\n        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');\n        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');\n        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');\n        moment.defineLocale('dow: 1, doy: 4', null);\n    });\n\n    test('weeks numbers dow:6 doy:12', function (assert) {\n        moment.locale('dow: 6, doy: 12', {week: {dow: 6, doy: 12}});\n        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');\n        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');\n        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');\n        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');\n        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');\n        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');\n        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');\n        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');\n        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');\n        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');\n        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');\n        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');\n        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');\n        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');\n        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');\n        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');\n        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');\n        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');\n        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');\n        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');\n        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');\n        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');\n        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');\n        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');\n        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');\n        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');\n        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');\n        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');\n        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');\n        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');\n        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');\n        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');\n        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');\n        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');\n        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');\n        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');\n        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');\n        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');\n        moment.defineLocale('dow: 6, doy: 12', null);\n    });\n\n    test('weeks numbers dow:1 doy:7', function (assert) {\n        moment.locale('dow: 1, doy: 7', {week: {dow: 1, doy: 7}});\n        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');\n        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');\n        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');\n        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');\n        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');\n        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');\n        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');\n        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');\n        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');\n        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');\n        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');\n        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');\n        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');\n        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');\n        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');\n        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');\n        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');\n        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');\n        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');\n        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');\n        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');\n        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');\n        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');\n        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');\n        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');\n        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');\n        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');\n        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');\n        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');\n        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');\n        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');\n        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');\n        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');\n        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');\n        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');\n        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');\n        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');\n        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');\n        moment.defineLocale('dow: 1, doy: 7', null);\n    });\n\n    test('weeks numbers dow:0 doy:6', function (assert) {\n        moment.locale('dow: 0, doy: 6', {week: {dow: 0, doy: 6}});\n        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');\n        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');\n        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');\n        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');\n        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');\n        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');\n        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');\n        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');\n        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');\n        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');\n        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');\n        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');\n        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');\n        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');\n        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');\n        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');\n        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');\n        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');\n        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');\n        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');\n        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');\n        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');\n        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');\n        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');\n        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');\n        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');\n        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');\n        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');\n        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');\n        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');\n        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');\n        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');\n        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');\n        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');\n        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');\n        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');\n        moment.defineLocale('dow: 0, doy: 6', null);\n    });\n\n    test('week year overflows', function (assert) {\n        assert.equal('2005-01-01', moment.utc('2004-W53-6', moment.ISO_8601, true).format('YYYY-MM-DD'), '2004-W53-6 is 1st Jan 2005');\n        assert.equal('2007-12-31', moment.utc('2008-W01-1', moment.ISO_8601, true).format('YYYY-MM-DD'), '2008-W01-1 is 31st Dec 2007');\n    });\n\n    test('weeks overflow', function (assert) {\n        assert.equal(7, moment.utc('2004-W54-1', moment.ISO_8601, true).parsingFlags().overflow, '2004 has only 53 weeks');\n        assert.equal(7, moment.utc('2004-W00-1', moment.ISO_8601, true).parsingFlags().overflow, 'there is no 0th week');\n    });\n\n    test('weekday overflow', function (assert) {\n        assert.equal(8, moment.utc('2004-W30-0', moment.ISO_8601, true).parsingFlags().overflow, 'there is no 0 iso weekday');\n        assert.equal(8, moment.utc('2004-W30-8', moment.ISO_8601, true).parsingFlags().overflow, 'there is no 8 iso weekday');\n        assert.equal(8, moment.utc('2004-w30-7', 'gggg-[w]ww-e', true).parsingFlags().overflow, 'there is no 7 \\'e\\' weekday');\n        assert.equal(8, moment.utc('2004-w30-7', 'gggg-[w]ww-d', true).parsingFlags().overflow, 'there is no 7 \\'d\\' weekday');\n    });\n\n    test('week year setter works', function (assert) {\n        for (var year = 2000; year <= 2020; year += 1) {\n            assert.equal(moment.utc('2012-12-31T00:00:00.000Z').isoWeekYear(year).isoWeekYear(), year, 'setting iso-week-year to ' + year);\n            assert.equal(moment.utc('2012-12-31T00:00:00.000Z').weekYear(year).weekYear(), year, 'setting week-year to ' + year);\n        }\n\n        assert.equal(moment.utc('2004-W53-1', moment.ISO_8601, true).isoWeekYear(2013).format('GGGG-[W]WW-E'), '2013-W52-1', '2004-W53-1 to 2013');\n        assert.equal(moment.utc('2004-W53-1', moment.ISO_8601, true).isoWeekYear(2020).format('GGGG-[W]WW-E'), '2020-W53-1', '2004-W53-1 to 2020');\n        assert.equal(moment.utc('2005-W52-1', moment.ISO_8601, true).isoWeekYear(2004).format('GGGG-[W]WW-E'), '2004-W52-1', '2005-W52-1 to 2004');\n        assert.equal(moment.utc('2013-W30-4', moment.ISO_8601, true).isoWeekYear(2015).format('GGGG-[W]WW-E'), '2015-W30-4', '2013-W30-4 to 2015');\n\n        assert.equal(moment.utc('2005-w53-0', 'gggg-[w]ww-e', true).weekYear(2013).format('gggg-[w]ww-e'), '2013-w52-0', '2005-w53-0 to 2013');\n        assert.equal(moment.utc('2005-w53-0', 'gggg-[w]ww-e', true).weekYear(2016).format('gggg-[w]ww-e'), '2016-w53-0', '2005-w53-0 to 2016');\n        assert.equal(moment.utc('2004-w52-0', 'gggg-[w]ww-e', true).weekYear(2005).format('gggg-[w]ww-e'), '2005-w52-0', '2004-w52-0 to 2005');\n        assert.equal(moment.utc('2013-w30-4', 'gggg-[w]ww-e', true).weekYear(2015).format('gggg-[w]ww-e'), '2015-w30-4', '2013-w30-4 to 2015');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('week day');\n\n    test('iso weekday', function (assert) {\n        var i;\n\n        for (i = 0; i < 7; ++i) {\n            moment.locale('dow:' + i + ',doy: 6', {week: {dow: i, doy: 6}});\n            assert.equal(moment([1985, 1,  4]).isoWeekday(), 1, 'Feb  4 1985 is Monday    -- 1st day');\n            assert.equal(moment([2029, 8, 18]).isoWeekday(), 2, 'Sep 18 2029 is Tuesday   -- 2nd day');\n            assert.equal(moment([2013, 3, 24]).isoWeekday(), 3, 'Apr 24 2013 is Wednesday -- 3rd day');\n            assert.equal(moment([2015, 2,  5]).isoWeekday(), 4, 'Mar  5 2015 is Thursday  -- 4th day');\n            assert.equal(moment([1970, 0,  2]).isoWeekday(), 5, 'Jan  2 1970 is Friday    -- 5th day');\n            assert.equal(moment([2001, 4, 12]).isoWeekday(), 6, 'May 12 2001 is Saturday  -- 6th day');\n            assert.equal(moment([2000, 0,  2]).isoWeekday(), 7, 'Jan  2 2000 is Sunday    -- 7th day');\n        }\n    });\n\n    test('iso weekday setter', function (assert) {\n        var a = moment([2011, 0, 10]);\n        assert.equal(moment(a).isoWeekday(1).date(),  10, 'set from mon to mon');\n        assert.equal(moment(a).isoWeekday(4).date(),  13, 'set from mon to thu');\n        assert.equal(moment(a).isoWeekday(7).date(),  16, 'set from mon to sun');\n        assert.equal(moment(a).isoWeekday(-6).date(),  3, 'set from mon to last mon');\n        assert.equal(moment(a).isoWeekday(-3).date(),  6, 'set from mon to last thu');\n        assert.equal(moment(a).isoWeekday(0).date(),   9, 'set from mon to last sun');\n        assert.equal(moment(a).isoWeekday(8).date(),  17, 'set from mon to next mon');\n        assert.equal(moment(a).isoWeekday(11).date(), 20, 'set from mon to next thu');\n        assert.equal(moment(a).isoWeekday(14).date(), 23, 'set from mon to next sun');\n\n        a = moment([2011, 0, 13]);\n        assert.equal(moment(a).isoWeekday(1).date(), 10, 'set from thu to mon');\n        assert.equal(moment(a).isoWeekday(4).date(), 13, 'set from thu to thu');\n        assert.equal(moment(a).isoWeekday(7).date(), 16, 'set from thu to sun');\n        assert.equal(moment(a).isoWeekday(-6).date(),  3, 'set from thu to last mon');\n        assert.equal(moment(a).isoWeekday(-3).date(),  6, 'set from thu to last thu');\n        assert.equal(moment(a).isoWeekday(0).date(),   9, 'set from thu to last sun');\n        assert.equal(moment(a).isoWeekday(8).date(),  17, 'set from thu to next mon');\n        assert.equal(moment(a).isoWeekday(11).date(), 20, 'set from thu to next thu');\n        assert.equal(moment(a).isoWeekday(14).date(), 23, 'set from thu to next sun');\n\n        a = moment([2011, 0, 16]);\n        assert.equal(moment(a).isoWeekday(1).date(), 10, 'set from sun to mon');\n        assert.equal(moment(a).isoWeekday(4).date(), 13, 'set from sun to thu');\n        assert.equal(moment(a).isoWeekday(7).date(), 16, 'set from sun to sun');\n        assert.equal(moment(a).isoWeekday(-6).date(),  3, 'set from sun to last mon');\n        assert.equal(moment(a).isoWeekday(-3).date(),  6, 'set from sun to last thu');\n        assert.equal(moment(a).isoWeekday(0).date(),   9, 'set from sun to last sun');\n        assert.equal(moment(a).isoWeekday(8).date(),  17, 'set from sun to next mon');\n        assert.equal(moment(a).isoWeekday(11).date(), 20, 'set from sun to next thu');\n        assert.equal(moment(a).isoWeekday(14).date(), 23, 'set from sun to next sun');\n    });\n\n    test('weekday first day of week Sunday (dow 0)', function (assert) {\n        moment.locale('dow: 0,doy: 6', {week: {dow: 0, doy: 6}});\n        assert.equal(moment([1985, 1,  3]).weekday(), 0, 'Feb  3 1985 is Sunday    -- 0th day');\n        assert.equal(moment([2029, 8, 17]).weekday(), 1, 'Sep 17 2029 is Monday    -- 1st day');\n        assert.equal(moment([2013, 3, 23]).weekday(), 2, 'Apr 23 2013 is Tuesday   -- 2nd day');\n        assert.equal(moment([2015, 2,  4]).weekday(), 3, 'Mar  4 2015 is Wednesday -- 3nd day');\n        assert.equal(moment([1970, 0,  1]).weekday(), 4, 'Jan  1 1970 is Thursday  -- 4th day');\n        assert.equal(moment([2001, 4, 11]).weekday(), 5, 'May 11 2001 is Friday    -- 5th day');\n        assert.equal(moment([2000, 0,  1]).weekday(), 6, 'Jan  1 2000 is Saturday  -- 6th day');\n    });\n\n    test('weekday first day of week Monday (dow 1)', function (assert) {\n        moment.locale('dow: 1,doy: 6', {week: {dow: 1, doy: 6}});\n        assert.equal(moment([1985, 1,  4]).weekday(), 0, 'Feb  4 1985 is Monday    -- 0th day');\n        assert.equal(moment([2029, 8, 18]).weekday(), 1, 'Sep 18 2029 is Tuesday   -- 1st day');\n        assert.equal(moment([2013, 3, 24]).weekday(), 2, 'Apr 24 2013 is Wednesday -- 2nd day');\n        assert.equal(moment([2015, 2,  5]).weekday(), 3, 'Mar  5 2015 is Thursday  -- 3nd day');\n        assert.equal(moment([1970, 0,  2]).weekday(), 4, 'Jan  2 1970 is Friday    -- 4th day');\n        assert.equal(moment([2001, 4, 12]).weekday(), 5, 'May 12 2001 is Saturday  -- 5th day');\n        assert.equal(moment([2000, 0,  2]).weekday(), 6, 'Jan  2 2000 is Sunday    -- 6th day');\n    });\n\n    test('weekday first day of week Tuesday (dow 2)', function (assert) {\n        moment.locale('dow: 2,doy: 6', {week: {dow: 2, doy: 6}});\n        assert.equal(moment([1985, 1,  5]).weekday(), 0, 'Feb  5 1985 is Tuesday   -- 0th day');\n        assert.equal(moment([2029, 8, 19]).weekday(), 1, 'Sep 19 2029 is Wednesday -- 1st day');\n        assert.equal(moment([2013, 3, 25]).weekday(), 2, 'Apr 25 2013 is Thursday  -- 2nd day');\n        assert.equal(moment([2015, 2,  6]).weekday(), 3, 'Mar  6 2015 is Friday    -- 3nd day');\n        assert.equal(moment([1970, 0,  3]).weekday(), 4, 'Jan  3 1970 is Staturday -- 4th day');\n        assert.equal(moment([2001, 4, 13]).weekday(), 5, 'May 13 2001 is Sunday    -- 5th day');\n        assert.equal(moment([2000, 0,  3]).weekday(), 6, 'Jan  3 2000 is Monday    -- 6th day');\n    });\n\n    test('weekday first day of week Wednesday (dow 3)', function (assert) {\n        moment.locale('dow: 3,doy: 6', {week: {dow: 3, doy: 6}});\n        assert.equal(moment([1985, 1,  6]).weekday(), 0, 'Feb  6 1985 is Wednesday -- 0th day');\n        assert.equal(moment([2029, 8, 20]).weekday(), 1, 'Sep 20 2029 is Thursday  -- 1st day');\n        assert.equal(moment([2013, 3, 26]).weekday(), 2, 'Apr 26 2013 is Friday    -- 2nd day');\n        assert.equal(moment([2015, 2,  7]).weekday(), 3, 'Mar  7 2015 is Saturday  -- 3nd day');\n        assert.equal(moment([1970, 0,  4]).weekday(), 4, 'Jan  4 1970 is Sunday    -- 4th day');\n        assert.equal(moment([2001, 4, 14]).weekday(), 5, 'May 14 2001 is Monday    -- 5th day');\n        assert.equal(moment([2000, 0,  4]).weekday(), 6, 'Jan  4 2000 is Tuesday   -- 6th day');\n        moment.locale('dow:3,doy:6', null);\n    });\n\n    test('weekday first day of week Thursday (dow 4)', function (assert) {\n        moment.locale('dow: 4,doy: 6', {week: {dow: 4, doy: 6}});\n        assert.equal(moment([1985, 1,  7]).weekday(), 0, 'Feb  7 1985 is Thursday  -- 0th day');\n        assert.equal(moment([2029, 8, 21]).weekday(), 1, 'Sep 21 2029 is Friday    -- 1st day');\n        assert.equal(moment([2013, 3, 27]).weekday(), 2, 'Apr 27 2013 is Saturday  -- 2nd day');\n        assert.equal(moment([2015, 2,  8]).weekday(), 3, 'Mar  8 2015 is Sunday    -- 3nd day');\n        assert.equal(moment([1970, 0,  5]).weekday(), 4, 'Jan  5 1970 is Monday    -- 4th day');\n        assert.equal(moment([2001, 4, 15]).weekday(), 5, 'May 15 2001 is Tuesday   -- 5th day');\n        assert.equal(moment([2000, 0,  5]).weekday(), 6, 'Jan  5 2000 is Wednesday -- 6th day');\n    });\n\n    test('weekday first day of week Friday (dow 5)', function (assert) {\n        moment.locale('dow: 5,doy: 6', {week: {dow: 5, doy: 6}});\n        assert.equal(moment([1985, 1,  8]).weekday(), 0, 'Feb  8 1985 is Friday    -- 0th day');\n        assert.equal(moment([2029, 8, 22]).weekday(), 1, 'Sep 22 2029 is Staturday -- 1st day');\n        assert.equal(moment([2013, 3, 28]).weekday(), 2, 'Apr 28 2013 is Sunday    -- 2nd day');\n        assert.equal(moment([2015, 2,  9]).weekday(), 3, 'Mar  9 2015 is Monday    -- 3nd day');\n        assert.equal(moment([1970, 0,  6]).weekday(), 4, 'Jan  6 1970 is Tuesday   -- 4th day');\n        assert.equal(moment([2001, 4, 16]).weekday(), 5, 'May 16 2001 is Wednesday -- 5th day');\n        assert.equal(moment([2000, 0,  6]).weekday(), 6, 'Jan  6 2000 is Thursday  -- 6th day');\n    });\n\n    test('weekday first day of week Saturday (dow 6)', function (assert) {\n        moment.locale('dow: 6,doy: 6', {week: {dow: 6, doy: 6}});\n        assert.equal(moment([1985, 1,  9]).weekday(), 0, 'Feb  9 1985 is Staturday -- 0th day');\n        assert.equal(moment([2029, 8, 23]).weekday(), 1, 'Sep 23 2029 is Sunday    -- 1st day');\n        assert.equal(moment([2013, 3, 29]).weekday(), 2, 'Apr 29 2013 is Monday    -- 2nd day');\n        assert.equal(moment([2015, 2, 10]).weekday(), 3, 'Mar 10 2015 is Tuesday   -- 3nd day');\n        assert.equal(moment([1970, 0,  7]).weekday(), 4, 'Jan  7 1970 is Wednesday -- 4th day');\n        assert.equal(moment([2001, 4, 17]).weekday(), 5, 'May 17 2001 is Thursday  -- 5th day');\n        assert.equal(moment([2000, 0,  7]).weekday(), 6, 'Jan  7 2000 is Friday    -- 6th day');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('weeks');\n\n    test('day of year', function (assert) {\n        assert.equal(moment([2000,  0,  1]).dayOfYear(),   1, 'Jan  1 2000 should be day 1 of the year');\n        assert.equal(moment([2000,  1, 28]).dayOfYear(),  59, 'Feb 28 2000 should be day 59 of the year');\n        assert.equal(moment([2000,  1, 29]).dayOfYear(),  60, 'Feb 28 2000 should be day 60 of the year');\n        assert.equal(moment([2000, 11, 31]).dayOfYear(), 366, 'Dec 31 2000 should be day 366 of the year');\n        assert.equal(moment([2001,  0,  1]).dayOfYear(),   1, 'Jan  1 2001 should be day 1 of the year');\n        assert.equal(moment([2001,  1, 28]).dayOfYear(),  59, 'Feb 28 2001 should be day 59 of the year');\n        assert.equal(moment([2001,  2,  1]).dayOfYear(),  60, 'Mar  1 2001 should be day 60 of the year');\n        assert.equal(moment([2001, 11, 31]).dayOfYear(), 365, 'Dec 31 2001 should be day 365 of the year');\n    });\n\n    test('day of year setters', function (assert) {\n        assert.equal(moment([2000,  0,  1]).dayOfYear(200).dayOfYear(), 200, 'Setting Jan  1 2000 day of the year to 200 should work');\n        assert.equal(moment([2000,  1, 28]).dayOfYear(200).dayOfYear(), 200, 'Setting Feb 28 2000 day of the year to 200 should work');\n        assert.equal(moment([2000,  1, 29]).dayOfYear(200).dayOfYear(), 200, 'Setting Feb 28 2000 day of the year to 200 should work');\n        assert.equal(moment([2000, 11, 31]).dayOfYear(200).dayOfYear(), 200, 'Setting Dec 31 2000 day of the year to 200 should work');\n        assert.equal(moment().dayOfYear(1).dayOfYear(),   1, 'Setting day of the year to 1 should work');\n        assert.equal(moment().dayOfYear(59).dayOfYear(),  59, 'Setting day of the year to 59 should work');\n        assert.equal(moment().dayOfYear(60).dayOfYear(),  60, 'Setting day of the year to 60 should work');\n        assert.equal(moment().dayOfYear(365).dayOfYear(), 365, 'Setting day of the year to 365 should work');\n    });\n\n    test('iso weeks year starting sunday', function (assert) {\n        assert.equal(moment([2012, 0, 1]).isoWeek(), 52, 'Jan  1 2012 should be iso week 52');\n        assert.equal(moment([2012, 0, 2]).isoWeek(),  1, 'Jan  2 2012 should be iso week 1');\n        assert.equal(moment([2012, 0, 8]).isoWeek(),  1, 'Jan  8 2012 should be iso week 1');\n        assert.equal(moment([2012, 0, 9]).isoWeek(),  2, 'Jan  9 2012 should be iso week 2');\n        assert.equal(moment([2012, 0, 15]).isoWeek(), 2, 'Jan 15 2012 should be iso week 2');\n    });\n\n    test('iso weeks year starting monday', function (assert) {\n        assert.equal(moment([2007, 0, 1]).isoWeek(),  1, 'Jan  1 2007 should be iso week 1');\n        assert.equal(moment([2007, 0, 7]).isoWeek(),  1, 'Jan  7 2007 should be iso week 1');\n        assert.equal(moment([2007, 0, 8]).isoWeek(),  2, 'Jan  8 2007 should be iso week 2');\n        assert.equal(moment([2007, 0, 14]).isoWeek(), 2, 'Jan 14 2007 should be iso week 2');\n        assert.equal(moment([2007, 0, 15]).isoWeek(), 3, 'Jan 15 2007 should be iso week 3');\n    });\n\n    test('iso weeks year starting tuesday', function (assert) {\n        assert.equal(moment([2007, 11, 31]).isoWeek(), 1, 'Dec 31 2007 should be iso week 1');\n        assert.equal(moment([2008,  0,  1]).isoWeek(), 1, 'Jan  1 2008 should be iso week 1');\n        assert.equal(moment([2008,  0,  6]).isoWeek(), 1, 'Jan  6 2008 should be iso week 1');\n        assert.equal(moment([2008,  0,  7]).isoWeek(), 2, 'Jan  7 2008 should be iso week 2');\n        assert.equal(moment([2008,  0, 13]).isoWeek(), 2, 'Jan 13 2008 should be iso week 2');\n        assert.equal(moment([2008,  0, 14]).isoWeek(), 3, 'Jan 14 2008 should be iso week 3');\n    });\n\n    test('iso weeks year starting wednesday', function (assert) {\n        assert.equal(moment([2002, 11, 30]).isoWeek(), 1, 'Dec 30 2002 should be iso week 1');\n        assert.equal(moment([2003,  0,  1]).isoWeek(), 1, 'Jan  1 2003 should be iso week 1');\n        assert.equal(moment([2003,  0,  5]).isoWeek(), 1, 'Jan  5 2003 should be iso week 1');\n        assert.equal(moment([2003,  0,  6]).isoWeek(), 2, 'Jan  6 2003 should be iso week 2');\n        assert.equal(moment([2003,  0, 12]).isoWeek(), 2, 'Jan 12 2003 should be iso week 2');\n        assert.equal(moment([2003,  0, 13]).isoWeek(), 3, 'Jan 13 2003 should be iso week 3');\n    });\n\n    test('iso weeks year starting thursday', function (assert) {\n        assert.equal(moment([2008, 11, 29]).isoWeek(), 1, 'Dec 29 2008 should be iso week 1');\n        assert.equal(moment([2009,  0,  1]).isoWeek(), 1, 'Jan  1 2009 should be iso week 1');\n        assert.equal(moment([2009,  0,  4]).isoWeek(), 1, 'Jan  4 2009 should be iso week 1');\n        assert.equal(moment([2009,  0,  5]).isoWeek(), 2, 'Jan  5 2009 should be iso week 2');\n        assert.equal(moment([2009,  0, 11]).isoWeek(), 2, 'Jan 11 2009 should be iso week 2');\n        assert.equal(moment([2009,  0, 13]).isoWeek(), 3, 'Jan 12 2009 should be iso week 3');\n    });\n\n    test('iso weeks year starting friday', function (assert) {\n        assert.equal(moment([2009, 11, 28]).isoWeek(), 53, 'Dec 28 2009 should be iso week 53');\n        assert.equal(moment([2010,  0,  1]).isoWeek(), 53, 'Jan  1 2010 should be iso week 53');\n        assert.equal(moment([2010,  0,  3]).isoWeek(), 53, 'Jan  3 2010 should be iso week 53');\n        assert.equal(moment([2010,  0,  4]).isoWeek(),  1, 'Jan  4 2010 should be iso week 1');\n        assert.equal(moment([2010,  0, 10]).isoWeek(),  1, 'Jan 10 2010 should be iso week 1');\n        assert.equal(moment([2010,  0, 11]).isoWeek(),  2, 'Jan 11 2010 should be iso week 2');\n    });\n\n    test('iso weeks year starting saturday', function (assert) {\n        assert.equal(moment([2010, 11, 27]).isoWeek(), 52, 'Dec 27 2010 should be iso week 52');\n        assert.equal(moment([2011,  0,  1]).isoWeek(), 52, 'Jan  1 2011 should be iso week 52');\n        assert.equal(moment([2011,  0,  2]).isoWeek(), 52, 'Jan  2 2011 should be iso week 52');\n        assert.equal(moment([2011,  0,  3]).isoWeek(),  1, 'Jan  3 2011 should be iso week 1');\n        assert.equal(moment([2011,  0,  9]).isoWeek(),  1, 'Jan  9 2011 should be iso week 1');\n        assert.equal(moment([2011,  0, 10]).isoWeek(),  2, 'Jan 10 2011 should be iso week 2');\n    });\n\n    test('iso weeks year starting sunday formatted', function (assert) {\n        assert.equal(moment([2012, 0,  1]).format('W WW Wo'), '52 52 52nd', 'Jan  1 2012 should be iso week 52');\n        assert.equal(moment([2012, 0,  2]).format('W WW Wo'),   '1 01 1st', 'Jan  2 2012 should be iso week 1');\n        assert.equal(moment([2012, 0,  8]).format('W WW Wo'),   '1 01 1st', 'Jan  8 2012 should be iso week 1');\n        assert.equal(moment([2012, 0,  9]).format('W WW Wo'),   '2 02 2nd', 'Jan  9 2012 should be iso week 2');\n        assert.equal(moment([2012, 0, 15]).format('W WW Wo'),   '2 02 2nd', 'Jan 15 2012 should be iso week 2');\n    });\n\n    test('weeks plural year starting sunday', function (assert) {\n        assert.equal(moment([2012, 0,  1]).weeks(), 1, 'Jan  1 2012 should be week 1');\n        assert.equal(moment([2012, 0,  7]).weeks(), 1, 'Jan  7 2012 should be week 1');\n        assert.equal(moment([2012, 0,  8]).weeks(), 2, 'Jan  8 2012 should be week 2');\n        assert.equal(moment([2012, 0, 14]).weeks(), 2, 'Jan 14 2012 should be week 2');\n        assert.equal(moment([2012, 0, 15]).weeks(), 3, 'Jan 15 2012 should be week 3');\n    });\n\n    test('iso weeks plural year starting sunday', function (assert) {\n        assert.equal(moment([2012, 0, 1]).isoWeeks(), 52, 'Jan  1 2012 should be iso week 52');\n        assert.equal(moment([2012, 0, 2]).isoWeeks(),  1, 'Jan  2 2012 should be iso week 1');\n        assert.equal(moment([2012, 0, 8]).isoWeeks(),  1, 'Jan  8 2012 should be iso week 1');\n        assert.equal(moment([2012, 0, 9]).isoWeeks(),  2, 'Jan  9 2012 should be iso week 2');\n        assert.equal(moment([2012, 0, 15]).isoWeeks(), 2, 'Jan 15 2012 should be iso week 2');\n    });\n\n    test('weeks setter', function (assert) {\n        assert.equal(moment([2012, 0,  1]).week(30).week(), 30, 'Setting Jan 1 2012 to week 30 should work');\n        assert.equal(moment([2012, 0,  7]).week(30).week(), 30, 'Setting Jan 7 2012 to week 30 should work');\n        assert.equal(moment([2012, 0,  8]).week(30).week(), 30, 'Setting Jan 8 2012 to week 30 should work');\n        assert.equal(moment([2012, 0, 14]).week(30).week(), 30, 'Setting Jan 14 2012 to week 30 should work');\n        assert.equal(moment([2012, 0, 15]).week(30).week(), 30, 'Setting Jan 15 2012 to week 30 should work');\n    });\n\n    test('iso weeks setter', function (assert) {\n        assert.equal(moment([2012, 0,  1]).isoWeeks(25).isoWeeks(), 25, 'Setting Jan  1 2012 to week 25 should work');\n        assert.equal(moment([2012, 0,  2]).isoWeeks(24).isoWeeks(), 24, 'Setting Jan  2 2012 to week 24 should work');\n        assert.equal(moment([2012, 0,  8]).isoWeeks(23).isoWeeks(), 23, 'Setting Jan  8 2012 to week 23 should work');\n        assert.equal(moment([2012, 0,  9]).isoWeeks(22).isoWeeks(), 22, 'Setting Jan  9 2012 to week 22 should work');\n        assert.equal(moment([2012, 0, 15]).isoWeeks(21).isoWeeks(), 21, 'Setting Jan 15 2012 to week 21 should work');\n    });\n\n    test('iso weeks setter day of year', function (assert) {\n        assert.equal(moment([2012, 0,  1]).isoWeek(1).dayOfYear(), 9, 'Setting Jan  1 2012 to week 1 should be day of year 8');\n        assert.equal(moment([2012, 0,  1]).isoWeek(1).year(),   2011, 'Setting Jan  1 2012 to week 1 should be year 2011');\n        assert.equal(moment([2012, 0,  2]).isoWeek(1).dayOfYear(), 2, 'Setting Jan  2 2012 to week 1 should be day of year 2');\n        assert.equal(moment([2012, 0,  8]).isoWeek(1).dayOfYear(), 8, 'Setting Jan  8 2012 to week 1 should be day of year 8');\n        assert.equal(moment([2012, 0,  9]).isoWeek(1).dayOfYear(), 2, 'Setting Jan  9 2012 to week 1 should be day of year 2');\n        assert.equal(moment([2012, 0, 15]).isoWeek(1).dayOfYear(), 8, 'Setting Jan 15 2012 to week 1 should be day of year 8');\n    });\n\n    test('years with iso week 53', function (assert) {\n        // Based on a table taken from http://en.wikipedia.org/wiki/ISO_week_date\n        // (as downloaded on 2014-01-06) listing the 71 years in a 400-year cycle\n        // that have 53 weeks; in this case reflecting the 2000 based cycle\n        assert.equal(moment([2004, 11, 31]).isoWeek(), 53, 'Dec 31 2004 should be iso week 53');\n        assert.equal(moment([2009, 11, 31]).isoWeek(), 53, 'Dec 31 2009 should be iso week 53');\n        assert.equal(moment([2015, 11, 31]).isoWeek(), 53, 'Dec 31 2015 should be iso week 53');\n        assert.equal(moment([2020, 11, 31]).isoWeek(), 53, 'Dec 31 2020 should be iso week 53');\n        assert.equal(moment([2026, 11, 31]).isoWeek(), 53, 'Dec 31 2026 should be iso week 53');\n        assert.equal(moment([2032, 11, 31]).isoWeek(), 53, 'Dec 31 2032 should be iso week 53');\n        assert.equal(moment([2037, 11, 31]).isoWeek(), 53, 'Dec 31 2037 should be iso week 53');\n        assert.equal(moment([2043, 11, 31]).isoWeek(), 53, 'Dec 31 2043 should be iso week 53');\n        assert.equal(moment([2048, 11, 31]).isoWeek(), 53, 'Dec 31 2048 should be iso week 53');\n        assert.equal(moment([2054, 11, 31]).isoWeek(), 53, 'Dec 31 2054 should be iso week 53');\n        assert.equal(moment([2060, 11, 31]).isoWeek(), 53, 'Dec 31 2060 should be iso week 53');\n        assert.equal(moment([2065, 11, 31]).isoWeek(), 53, 'Dec 31 2065 should be iso week 53');\n        assert.equal(moment([2071, 11, 31]).isoWeek(), 53, 'Dec 31 2071 should be iso week 53');\n        assert.equal(moment([2076, 11, 31]).isoWeek(), 53, 'Dec 31 2076 should be iso week 53');\n        assert.equal(moment([2082, 11, 31]).isoWeek(), 53, 'Dec 31 2082 should be iso week 53');\n        assert.equal(moment([2088, 11, 31]).isoWeek(), 53, 'Dec 31 2088 should be iso week 53');\n        assert.equal(moment([2093, 11, 31]).isoWeek(), 53, 'Dec 31 2093 should be iso week 53');\n        assert.equal(moment([2099, 11, 31]).isoWeek(), 53, 'Dec 31 2099 should be iso week 53');\n        assert.equal(moment([2105, 11, 31]).isoWeek(), 53, 'Dec 31 2105 should be iso week 53');\n        assert.equal(moment([2111, 11, 31]).isoWeek(), 53, 'Dec 31 2111 should be iso week 53');\n        assert.equal(moment([2116, 11, 31]).isoWeek(), 53, 'Dec 31 2116 should be iso week 53');\n        assert.equal(moment([2122, 11, 31]).isoWeek(), 53, 'Dec 31 2122 should be iso week 53');\n        assert.equal(moment([2128, 11, 31]).isoWeek(), 53, 'Dec 31 2128 should be iso week 53');\n        assert.equal(moment([2133, 11, 31]).isoWeek(), 53, 'Dec 31 2133 should be iso week 53');\n        assert.equal(moment([2139, 11, 31]).isoWeek(), 53, 'Dec 31 2139 should be iso week 53');\n        assert.equal(moment([2144, 11, 31]).isoWeek(), 53, 'Dec 31 2144 should be iso week 53');\n        assert.equal(moment([2150, 11, 31]).isoWeek(), 53, 'Dec 31 2150 should be iso week 53');\n        assert.equal(moment([2156, 11, 31]).isoWeek(), 53, 'Dec 31 2156 should be iso week 53');\n        assert.equal(moment([2161, 11, 31]).isoWeek(), 53, 'Dec 31 2161 should be iso week 53');\n        assert.equal(moment([2167, 11, 31]).isoWeek(), 53, 'Dec 31 2167 should be iso week 53');\n        assert.equal(moment([2172, 11, 31]).isoWeek(), 53, 'Dec 31 2172 should be iso week 53');\n        assert.equal(moment([2178, 11, 31]).isoWeek(), 53, 'Dec 31 2178 should be iso week 53');\n        assert.equal(moment([2184, 11, 31]).isoWeek(), 53, 'Dec 31 2184 should be iso week 53');\n        assert.equal(moment([2189, 11, 31]).isoWeek(), 53, 'Dec 31 2189 should be iso week 53');\n        assert.equal(moment([2195, 11, 31]).isoWeek(), 53, 'Dec 31 2195 should be iso week 53');\n        assert.equal(moment([2201, 11, 31]).isoWeek(), 53, 'Dec 31 2201 should be iso week 53');\n        assert.equal(moment([2207, 11, 31]).isoWeek(), 53, 'Dec 31 2207 should be iso week 53');\n        assert.equal(moment([2212, 11, 31]).isoWeek(), 53, 'Dec 31 2212 should be iso week 53');\n        assert.equal(moment([2218, 11, 31]).isoWeek(), 53, 'Dec 31 2218 should be iso week 53');\n        assert.equal(moment([2224, 11, 31]).isoWeek(), 53, 'Dec 31 2224 should be iso week 53');\n        assert.equal(moment([2229, 11, 31]).isoWeek(), 53, 'Dec 31 2229 should be iso week 53');\n        assert.equal(moment([2235, 11, 31]).isoWeek(), 53, 'Dec 31 2235 should be iso week 53');\n        assert.equal(moment([2240, 11, 31]).isoWeek(), 53, 'Dec 31 2240 should be iso week 53');\n        assert.equal(moment([2246, 11, 31]).isoWeek(), 53, 'Dec 31 2246 should be iso week 53');\n        assert.equal(moment([2252, 11, 31]).isoWeek(), 53, 'Dec 31 2252 should be iso week 53');\n        assert.equal(moment([2257, 11, 31]).isoWeek(), 53, 'Dec 31 2257 should be iso week 53');\n        assert.equal(moment([2263, 11, 31]).isoWeek(), 53, 'Dec 31 2263 should be iso week 53');\n        assert.equal(moment([2268, 11, 31]).isoWeek(), 53, 'Dec 31 2268 should be iso week 53');\n        assert.equal(moment([2274, 11, 31]).isoWeek(), 53, 'Dec 31 2274 should be iso week 53');\n        assert.equal(moment([2280, 11, 31]).isoWeek(), 53, 'Dec 31 2280 should be iso week 53');\n        assert.equal(moment([2285, 11, 31]).isoWeek(), 53, 'Dec 31 2285 should be iso week 53');\n        assert.equal(moment([2291, 11, 31]).isoWeek(), 53, 'Dec 31 2291 should be iso week 53');\n        assert.equal(moment([2296, 11, 31]).isoWeek(), 53, 'Dec 31 2296 should be iso week 53');\n        assert.equal(moment([2303, 11, 31]).isoWeek(), 53, 'Dec 31 2303 should be iso week 53');\n        assert.equal(moment([2308, 11, 31]).isoWeek(), 53, 'Dec 31 2308 should be iso week 53');\n        assert.equal(moment([2314, 11, 31]).isoWeek(), 53, 'Dec 31 2314 should be iso week 53');\n        assert.equal(moment([2320, 11, 31]).isoWeek(), 53, 'Dec 31 2320 should be iso week 53');\n        assert.equal(moment([2325, 11, 31]).isoWeek(), 53, 'Dec 31 2325 should be iso week 53');\n        assert.equal(moment([2331, 11, 31]).isoWeek(), 53, 'Dec 31 2331 should be iso week 53');\n        assert.equal(moment([2336, 11, 31]).isoWeek(), 53, 'Dec 31 2336 should be iso week 53');\n        assert.equal(moment([2342, 11, 31]).isoWeek(), 53, 'Dec 31 2342 should be iso week 53');\n        assert.equal(moment([2348, 11, 31]).isoWeek(), 53, 'Dec 31 2348 should be iso week 53');\n        assert.equal(moment([2353, 11, 31]).isoWeek(), 53, 'Dec 31 2353 should be iso week 53');\n        assert.equal(moment([2359, 11, 31]).isoWeek(), 53, 'Dec 31 2359 should be iso week 53');\n        assert.equal(moment([2364, 11, 31]).isoWeek(), 53, 'Dec 31 2364 should be iso week 53');\n        assert.equal(moment([2370, 11, 31]).isoWeek(), 53, 'Dec 31 2370 should be iso week 53');\n        assert.equal(moment([2376, 11, 31]).isoWeek(), 53, 'Dec 31 2376 should be iso week 53');\n        assert.equal(moment([2381, 11, 31]).isoWeek(), 53, 'Dec 31 2381 should be iso week 53');\n        assert.equal(moment([2387, 11, 31]).isoWeek(), 53, 'Dec 31 2387 should be iso week 53');\n        assert.equal(moment([2392, 11, 31]).isoWeek(), 53, 'Dec 31 2392 should be iso week 53');\n        assert.equal(moment([2398, 11, 31]).isoWeek(), 53, 'Dec 31 2398 should be iso week 53');\n    });\n\n    test('count years with iso week 53', function (assert) {\n        // Based on http://en.wikipedia.org/wiki/ISO_week_date (as seen on 2014-01-06)\n        // stating that there are 71 years in a 400-year cycle that have 53 weeks;\n        // in this case reflecting the 2000 based cycle\n        var count = 0, i;\n        for (i = 0; i < 400; i++) {\n            count += (moment([2000 + i, 11, 31]).isoWeek() === 53) ? 1 : 0;\n        }\n        assert.equal(count, 71, 'Should have 71 years in 400-year cycle with iso week 53');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('weeks in year');\n\n    test('isoWeeksInYear', function (assert) {\n        assert.equal(moment([2004]).isoWeeksInYear(), 53, '2004 has 53 iso weeks');\n        assert.equal(moment([2005]).isoWeeksInYear(), 52, '2005 has 53 iso weeks');\n        assert.equal(moment([2006]).isoWeeksInYear(), 52, '2006 has 53 iso weeks');\n        assert.equal(moment([2007]).isoWeeksInYear(), 52, '2007 has 52 iso weeks');\n        assert.equal(moment([2008]).isoWeeksInYear(), 52, '2008 has 53 iso weeks');\n        assert.equal(moment([2009]).isoWeeksInYear(), 53, '2009 has 53 iso weeks');\n        assert.equal(moment([2010]).isoWeeksInYear(), 52, '2010 has 52 iso weeks');\n        assert.equal(moment([2011]).isoWeeksInYear(), 52, '2011 has 52 iso weeks');\n        assert.equal(moment([2012]).isoWeeksInYear(), 52, '2012 has 52 iso weeks');\n        assert.equal(moment([2013]).isoWeeksInYear(), 52, '2013 has 52 iso weeks');\n        assert.equal(moment([2014]).isoWeeksInYear(), 52, '2014 has 52 iso weeks');\n        assert.equal(moment([2015]).isoWeeksInYear(), 53, '2015 has 53 iso weeks');\n    });\n\n    test('weeksInYear doy/dow = 1/4', function (assert) {\n        moment.locale('1/4', {week: {dow: 1, doy: 4}});\n\n        assert.equal(moment([2004]).weeksInYear(), 53, '2004 has 53 weeks');\n        assert.equal(moment([2005]).weeksInYear(), 52, '2005 has 53 weeks');\n        assert.equal(moment([2006]).weeksInYear(), 52, '2006 has 53 weeks');\n        assert.equal(moment([2007]).weeksInYear(), 52, '2007 has 52 weeks');\n        assert.equal(moment([2008]).weeksInYear(), 52, '2008 has 53 weeks');\n        assert.equal(moment([2009]).weeksInYear(), 53, '2009 has 53 weeks');\n        assert.equal(moment([2010]).weeksInYear(), 52, '2010 has 52 weeks');\n        assert.equal(moment([2011]).weeksInYear(), 52, '2011 has 52 weeks');\n        assert.equal(moment([2012]).weeksInYear(), 52, '2012 has 52 weeks');\n        assert.equal(moment([2013]).weeksInYear(), 52, '2013 has 52 weeks');\n        assert.equal(moment([2014]).weeksInYear(), 52, '2014 has 52 weeks');\n        assert.equal(moment([2015]).weeksInYear(), 53, '2015 has 53 weeks');\n    });\n\n    test('weeksInYear doy/dow = 6/12', function (assert) {\n        moment.locale('6/12', {week: {dow: 6, doy: 12}});\n\n        assert.equal(moment([2004]).weeksInYear(), 53, '2004 has 53 weeks');\n        assert.equal(moment([2005]).weeksInYear(), 52, '2005 has 53 weeks');\n        assert.equal(moment([2006]).weeksInYear(), 52, '2006 has 53 weeks');\n        assert.equal(moment([2007]).weeksInYear(), 52, '2007 has 52 weeks');\n        assert.equal(moment([2008]).weeksInYear(), 52, '2008 has 53 weeks');\n        assert.equal(moment([2009]).weeksInYear(), 52, '2009 has 53 weeks');\n        assert.equal(moment([2010]).weeksInYear(), 53, '2010 has 52 weeks');\n        assert.equal(moment([2011]).weeksInYear(), 52, '2011 has 52 weeks');\n        assert.equal(moment([2012]).weeksInYear(), 52, '2012 has 52 weeks');\n        assert.equal(moment([2013]).weeksInYear(), 52, '2013 has 52 weeks');\n        assert.equal(moment([2014]).weeksInYear(), 52, '2014 has 52 weeks');\n        assert.equal(moment([2015]).weeksInYear(), 52, '2015 has 53 weeks');\n    });\n\n    test('weeksInYear doy/dow = 1/7', function (assert) {\n        moment.locale('1/7', {week: {dow: 1, doy: 7}});\n\n        assert.equal(moment([2004]).weeksInYear(), 52, '2004 has 53 weeks');\n        assert.equal(moment([2005]).weeksInYear(), 52, '2005 has 53 weeks');\n        assert.equal(moment([2006]).weeksInYear(), 53, '2006 has 53 weeks');\n        assert.equal(moment([2007]).weeksInYear(), 52, '2007 has 52 weeks');\n        assert.equal(moment([2008]).weeksInYear(), 52, '2008 has 53 weeks');\n        assert.equal(moment([2009]).weeksInYear(), 52, '2009 has 53 weeks');\n        assert.equal(moment([2010]).weeksInYear(), 52, '2010 has 52 weeks');\n        assert.equal(moment([2011]).weeksInYear(), 52, '2011 has 52 weeks');\n        assert.equal(moment([2012]).weeksInYear(), 53, '2012 has 52 weeks');\n        assert.equal(moment([2013]).weeksInYear(), 52, '2013 has 52 weeks');\n        assert.equal(moment([2014]).weeksInYear(), 52, '2014 has 52 weeks');\n        assert.equal(moment([2015]).weeksInYear(), 52, '2015 has 53 weeks');\n    });\n\n    test('weeksInYear doy/dow = 0/6', function (assert) {\n        moment.locale('0/6', {week: {dow: 0, doy: 6}});\n\n        assert.equal(moment([2004]).weeksInYear(), 52, '2004 has 53 weeks');\n        assert.equal(moment([2005]).weeksInYear(), 53, '2005 has 53 weeks');\n        assert.equal(moment([2006]).weeksInYear(), 52, '2006 has 53 weeks');\n        assert.equal(moment([2007]).weeksInYear(), 52, '2007 has 52 weeks');\n        assert.equal(moment([2008]).weeksInYear(), 52, '2008 has 53 weeks');\n        assert.equal(moment([2009]).weeksInYear(), 52, '2009 has 53 weeks');\n        assert.equal(moment([2010]).weeksInYear(), 52, '2010 has 52 weeks');\n        assert.equal(moment([2011]).weeksInYear(), 53, '2011 has 52 weeks');\n        assert.equal(moment([2012]).weeksInYear(), 52, '2012 has 52 weeks');\n        assert.equal(moment([2013]).weeksInYear(), 52, '2013 has 52 weeks');\n        assert.equal(moment([2014]).weeksInYear(), 52, '2014 has 52 weeks');\n        assert.equal(moment([2015]).weeksInYear(), 52, '2015 has 53 weeks');\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    function isNearSpringDST() {\n        return moment().subtract(1, 'day').utcOffset() !== moment().add(1, 'day').utcOffset();\n    }\n\n    module('zone switching');\n\n    test('local to utc, keepLocalTime = true', function (assert) {\n        var m = moment(),\n            fmt = 'YYYY-DD-MM HH:mm:ss';\n        assert.equal(m.clone().utc(true).format(fmt), m.format(fmt), 'local to utc failed to keep local time');\n    });\n\n    test('local to utc, keepLocalTime = false', function (assert) {\n        var m = moment();\n        assert.equal(m.clone().utc().valueOf(), m.valueOf(), 'local to utc failed to keep utc time (implicit)');\n        assert.equal(m.clone().utc(false).valueOf(), m.valueOf(), 'local to utc failed to keep utc time (explicit)');\n    });\n\n    test('local to zone, keepLocalTime = true', function (assert) {\n        test.expectedDeprecations('moment().zone');\n        var m = moment(),\n            fmt = 'YYYY-DD-MM HH:mm:ss',\n            z;\n\n        // Apparently there is -12:00 and +14:00\n        // http://en.wikipedia.org/wiki/UTC+14:00\n        // http://en.wikipedia.org/wiki/UTC-12:00\n        for (z = -12; z <= 14; ++z) {\n            assert.equal(m.clone().zone(z * 60, true).format(fmt), m.format(fmt),\n                    'local to zone(' + z + ':00) failed to keep local time');\n        }\n    });\n\n    test('local to zone, keepLocalTime = false', function (assert) {\n        test.expectedDeprecations('moment().zone');\n        var m = moment(),\n            z;\n\n        // Apparently there is -12:00 and +14:00\n        // http://en.wikipedia.org/wiki/UTC+14:00\n        // http://en.wikipedia.org/wiki/UTC-12:00\n        for (z = -12; z <= 14; ++z) {\n            assert.equal(m.clone().zone(z * 60).valueOf(), m.valueOf(),\n                    'local to zone(' + z + ':00) failed to keep utc time (implicit)');\n            assert.equal(m.clone().zone(z * 60, false).valueOf(), m.valueOf(),\n                    'local to zone(' + z + ':00) failed to keep utc time (explicit)');\n        }\n    });\n\n    test('utc to local, keepLocalTime = true', function (assert) {\n        // Don't test near the spring DST transition\n        if (isNearSpringDST()) {\n            expect(0);\n            return;\n        }\n\n        var um = moment.utc(),\n            fmt = 'YYYY-DD-MM HH:mm:ss';\n\n        assert.equal(um.clone().local(true).format(fmt), um.format(fmt), 'utc to local failed to keep local time');\n    });\n\n    test('utc to local, keepLocalTime = false', function (assert) {\n        var um = moment.utc();\n        assert.equal(um.clone().local().valueOf(), um.valueOf(), 'utc to local failed to keep utc time (implicit)');\n        assert.equal(um.clone().local(false).valueOf(), um.valueOf(), 'utc to local failed to keep utc time (explicit)');\n    });\n\n    test('zone to local, keepLocalTime = true', function (assert) {\n        test.expectedDeprecations('moment().zone');\n        // Don't test near the spring DST transition\n        if (isNearSpringDST()) {\n            expect(0);\n            return;\n        }\n\n        var m = moment(),\n            fmt = 'YYYY-DD-MM HH:mm:ss',\n            z;\n\n        // Apparently there is -12:00 and +14:00\n        // http://en.wikipedia.org/wiki/UTC+14:00\n        // http://en.wikipedia.org/wiki/UTC-12:00\n        for (z = -12; z <= 14; ++z) {\n            m.zone(z * 60);\n\n            assert.equal(m.clone().local(true).format(fmt), m.format(fmt),\n                    'zone(' + z + ':00) to local failed to keep local time');\n        }\n    });\n\n    test('zone to local, keepLocalTime = false', function (assert) {\n        test.expectedDeprecations('moment().zone');\n        var m = moment(),\n            z;\n\n        // Apparently there is -12:00 and +14:00\n        // http://en.wikipedia.org/wiki/UTC+14:00\n        // http://en.wikipedia.org/wiki/UTC-12:00\n        for (z = -12; z <= 14; ++z) {\n            m.zone(z * 60);\n\n            assert.equal(m.clone().local(false).valueOf(), m.valueOf(),\n                    'zone(' + z + ':00) to local failed to keep utc time (explicit)');\n            assert.equal(m.clone().local().valueOf(), m.valueOf(),\n                    'zone(' + z + ':00) to local failed to keep utc time (implicit)');\n        }\n    });\n\n}));\n\n;(function (global, factory) {\n   typeof exports === 'object' && typeof module !== 'undefined'\n       && typeof require === 'function' ? factory(require('../../moment')) :\n   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :\n   factory(global.moment)\n}(this, function (moment) { 'use strict';\n\n    function each(array, callback) {\n        var i;\n        for (i = 0; i < array.length; i++) {\n            callback(array[i], i, array);\n        }\n    }\n\n    function objectKeys(obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        } else {\n            // IE8\n            var res = [], i;\n            for (i in obj) {\n                if (obj.hasOwnProperty(i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        }\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function defineCommonLocaleTests(locale, options) {\n        test('lenient ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing ' + i + ' date check');\n            }\n        });\n\n        test('lenient ordinal parsing of number', function (assert) {\n            var i, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                testMoment = moment('2014 01 ' + i, 'YYYY MM Do');\n                assert.equal(testMoment.year(), 2014,\n                        'lenient ordinal parsing of number ' + i + ' year check');\n                assert.equal(testMoment.month(), 0,\n                        'lenient ordinal parsing of number ' + i + ' month check');\n                assert.equal(testMoment.date(), i,\n                        'lenient ordinal parsing of number ' + i + ' date check');\n            }\n        });\n\n        test('strict ordinal parsing', function (assert) {\n            var i, ordinalStr, testMoment;\n            for (i = 1; i <= 31; ++i) {\n                ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');\n                testMoment = moment(ordinalStr, 'YYYY MM Do', true);\n                assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);\n            }\n        });\n\n        test('meridiem invariant', function (assert) {\n            var h, m, t1, t2;\n            for (h = 0; h < 24; ++h) {\n                for (m = 0; m < 60; m += 15) {\n                    t1 = moment.utc([2000, 0, 1, h, m]);\n                    t2 = moment.utc(t1.format('A h:mm'), 'A h:mm');\n                    assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),\n                            'meridiem at ' + t1.format('HH:mm'));\n                }\n            }\n        });\n\n        test('date format correctness', function (assert) {\n            var data, tokens;\n            data = moment.localeData()._longDateFormat;\n            tokens = objectKeys(data);\n            each(tokens, function (srchToken) {\n                // Check each format string to make sure it does not contain any\n                // tokens that need to be expanded.\n                each(tokens, function (baseToken) {\n                    // strip escaped sequences\n                    var format = data[baseToken].replace(/(\\[[^\\]]*\\])/g, '');\n                    assert.equal(false, !!~format.indexOf(srchToken),\n                            'contains ' + srchToken + ' in ' + baseToken);\n                });\n            });\n        });\n\n        test('month parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr') {\n                // I can't fix it :(\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r;\n                r = moment(m.format(format), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.month(), m.month(), 'month ' + i + ' fmt ' + format + ' lower strict');\n            }\n\n            for (i = 0; i < 12; ++i) {\n                m = moment([2015, i, 15, 18]);\n                tester('MMM');\n                tester('MMM.');\n                tester('MMMM');\n                tester('MMMM.');\n            }\n        });\n\n        test('weekday parsing correctness', function (assert) {\n            var i, m;\n\n            if (locale === 'tr' || locale === 'az') {\n                // There is a lower-case letter (\u00c4\u00b1), that converted to upper then\n                // lower changes to i\n                expect(0);\n                return;\n            }\n            function tester(format) {\n                var r, baseMsg = 'weekday ' + m.weekday() + ' fmt ' + format;\n                r = moment(m.format(format), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg);\n                r = moment(m.format(format).toLocaleUpperCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper');\n                r = moment(m.format(format).toLocaleLowerCase(), format);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower');\n\n                r = moment(m.format(format), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' strict');\n                r = moment(m.format(format).toLocaleUpperCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' upper strict');\n                r = moment(m.format(format).toLocaleLowerCase(), format, true);\n                assert.equal(r.weekday(), m.weekday(), baseMsg + ' lower strict');\n            }\n\n            for (i = 0; i < 7; ++i) {\n                m = moment.utc([2015, i, 15, 18]);\n                tester('dd');\n                tester('ddd');\n                tester('dddd');\n            }\n        });\n    }\n\n    function setupDeprecationHandler(test, moment, scope) {\n        test._expectedDeprecations = null;\n        test._observedDeprecations = null;\n        test._oldSupress = moment.suppressDeprecationWarnings;\n        moment.suppressDeprecationWarnings = true;\n        test.expectedDeprecations = function () {\n            test._expectedDeprecations = arguments;\n            test._observedDeprecations = [];\n        };\n        moment.deprecationHandler = function (name, msg) {\n            var deprecationId = matchedDeprecation(name, msg, test._expectedDeprecations);\n            if (deprecationId === -1) {\n                throw new Error('Unexpected deprecation thrown name=' +\n                        name + ' msg=' + msg);\n            }\n            test._observedDeprecations[deprecationId] = 1;\n        };\n    }\n\n    function teardownDeprecationHandler(test, moment, scope) {\n        moment.suppressDeprecationWarnings = test._oldSupress;\n\n        if (test._expectedDeprecations != null) {\n            var missedDeprecations = [];\n            each(test._expectedDeprecations, function (deprecationPattern, id) {\n                if (test._observedDeprecations[id] !== 1) {\n                    missedDeprecations.push(deprecationPattern);\n                }\n            });\n            if (missedDeprecations.length !== 0) {\n                throw new Error('Expected deprecation warnings did not happen: ' +\n                        missedDeprecations.join(' '));\n            }\n        }\n    }\n\n    function matchedDeprecation(name, msg, deprecations) {\n        if (deprecations == null) {\n            return -1;\n        }\n        for (var i = 0; i < deprecations.length; ++i) {\n            if (name != null && name === deprecations[i]) {\n                return i;\n            }\n            if (msg != null && msg.substring(0, deprecations[i].length) === deprecations[i]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /*global QUnit:false*/\n\n    var test = QUnit.test;\n\n    var expect = QUnit.expect;\n\n    function module (name, lifecycle) {\n        QUnit.module(name, {\n            setup : function () {\n                moment.locale('en');\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                teardownDeprecationHandler(test, moment, 'core');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n    }\n\n    function localeModule (name, lifecycle) {\n        QUnit.module('locale:' + name, {\n            setup : function () {\n                moment.locale(name);\n                moment.createFromInputFallback = function (config) {\n                    throw new Error('input not handled by moment: ' + config._i);\n                };\n                setupDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.setup) {\n                    lifecycle.setup();\n                }\n            },\n            teardown : function () {\n                moment.locale('en');\n                teardownDeprecationHandler(test, moment, 'locale');\n                if (lifecycle && lifecycle.teardown) {\n                    lifecycle.teardown();\n                }\n            }\n        });\n        defineCommonLocaleTests(name, -1, -1);\n    }\n\n    module('zones', {\n        'setup': function () {\n            test.expectedDeprecations('moment().zone');\n        }\n    });\n\n    test('set zone', function (assert) {\n        var zone = moment();\n\n        zone.zone(0);\n        assert.equal(zone.zone(), 0, 'should be able to set the zone to 0');\n\n        zone.zone(60);\n        assert.equal(zone.zone(), 60, 'should be able to set the zone to 60');\n\n        zone.zone(-60);\n        assert.equal(zone.zone(), -60, 'should be able to set the zone to -60');\n    });\n\n    test('set zone shorthand', function (assert) {\n        var zone = moment();\n\n        zone.zone(1);\n        assert.equal(zone.zone(), 60, 'setting the zone to 1 should imply hours and convert to 60');\n\n        zone.zone(-1);\n        assert.equal(zone.zone(), -60, 'setting the zone to -1 should imply hours and convert to -60');\n\n        zone.zone(15);\n        assert.equal(zone.zone(), 900, 'setting the zone to 15 should imply hours and convert to 900');\n\n        zone.zone(-15);\n        assert.equal(zone.zone(), -900, 'setting the zone to -15 should imply hours and convert to -900');\n\n        zone.zone(16);\n        assert.equal(zone.zone(), 16, 'setting the zone to 16 should imply minutes');\n\n        zone.zone(-16);\n        assert.equal(zone.zone(), -16, 'setting the zone to -16 should imply minutes');\n    });\n\n    test('set zone with string', function (assert) {\n        var zone = moment();\n\n        zone.zone('+00:00');\n        assert.equal(zone.zone(), 0, 'set the zone with a timezone string');\n\n        zone.zone('2013-03-07T07:00:00-08:00');\n        assert.equal(zone.zone(), 480, 'set the zone with a string that does not begin with the timezone');\n\n        zone.zone('2013-03-07T07:00:00+0100');\n        assert.equal(zone.zone(), -60, 'set the zone with a string that uses the +0000 syntax');\n\n        zone.zone('2013-03-07T07:00:00+02');\n        assert.equal(zone.zone(), -120, 'set the zone with a string that uses the +00 syntax');\n\n        zone.zone('03-07-2013T07:00:00-08:00');\n        assert.equal(zone.zone(), 480, 'set the zone with a string with a non-ISO 8601 date');\n    });\n\n    test('change hours when changing the zone', function (assert) {\n        var zone = moment.utc([2000, 0, 1, 6]);\n\n        zone.zone(0);\n        assert.equal(zone.hour(), 6, 'UTC 6AM should be 6AM at +0000');\n\n        zone.zone(60);\n        assert.equal(zone.hour(), 5, 'UTC 6AM should be 5AM at -0100');\n\n        zone.zone(-60);\n        assert.equal(zone.hour(), 7, 'UTC 6AM should be 7AM at +0100');\n    });\n\n    test('change minutes when changing the zone', function (assert) {\n        var zone = moment.utc([2000, 0, 1, 6, 31]);\n\n        zone.zone(0);\n        assert.equal(zone.format('HH:mm'), '06:31', 'UTC 6:31AM should be 6:31AM at +0000');\n\n        zone.zone(30);\n        assert.equal(zone.format('HH:mm'), '06:01', 'UTC 6:31AM should be 6:01AM at -0030');\n\n        zone.zone(-30);\n        assert.equal(zone.format('HH:mm'), '07:01', 'UTC 6:31AM should be 7:01AM at +0030');\n\n        zone.zone(1380);\n        assert.equal(zone.format('HH:mm'), '07:31', 'UTC 6:31AM should be 7:31AM at +1380');\n    });\n\n    test('distance from the unix epoch', function (assert) {\n        var zoneA = moment(),\n            zoneB = moment(zoneA),\n            zoneC = moment(zoneA),\n            zoneD = moment(zoneA),\n            zoneE = moment(zoneA);\n\n        zoneB.utc();\n        assert.equal(+zoneA, +zoneB, 'moment should equal moment.utc');\n\n        zoneC.zone(-60);\n        assert.equal(+zoneA, +zoneC, 'moment should equal moment.zone(-60)');\n\n        zoneD.zone(480);\n        assert.equal(+zoneA, +zoneD, 'moment should equal moment.zone(480)');\n\n        zoneE.zone(1000);\n        assert.equal(+zoneA, +zoneE, 'moment should equal moment.zone(1000)');\n    });\n\n    test('update offset after changing any values', function (assert) {\n        var oldOffset = moment.updateOffset,\n            m = moment.utc([2000, 6, 1]);\n\n        moment.updateOffset = function (mom, keepTime) {\n            if (mom.__doChange) {\n                if (+mom > 962409600000) {\n                    mom.zone(120, keepTime);\n                } else {\n                    mom.zone(60, keepTime);\n                }\n            }\n        };\n\n        assert.equal(m.format('ZZ'), '+0000', 'should be at +0000');\n        assert.equal(m.format('HH:mm'), '00:00', 'should start 12AM at +0000 timezone');\n\n        m.__doChange = true;\n        m.add(1, 'h');\n\n        assert.equal(m.format('ZZ'), '-0200', 'should be at -0200');\n        assert.equal(m.format('HH:mm'), '23:00', '1AM at +0000 should be 11PM at -0200 timezone');\n\n        m.subtract(1, 'h');\n\n        assert.equal(m.format('ZZ'), '-0100', 'should be at -0100');\n        assert.equal(m.format('HH:mm'), '23:00', '12AM at +0000 should be 11PM at -0100 timezone');\n\n        moment.updateOffset = oldOffset;\n    });\n\n    test('getters and setters', function (assert) {\n        var a = moment([2011, 5, 20]);\n\n        assert.equal(a.clone().zone(120).year(2012).year(), 2012, 'should get and set year correctly');\n        assert.equal(a.clone().zone(120).month(1).month(), 1, 'should get and set month correctly');\n        assert.equal(a.clone().zone(120).date(2).date(), 2, 'should get and set date correctly');\n        assert.equal(a.clone().zone(120).day(1).day(), 1, 'should get and set day correctly');\n        assert.equal(a.clone().zone(120).hour(1).hour(), 1, 'should get and set hour correctly');\n        assert.equal(a.clone().zone(120).minute(1).minute(), 1, 'should get and set minute correctly');\n    });\n\n    test('getters', function (assert) {\n        var a = moment.utc([2012, 0, 1, 0, 0, 0]);\n\n        assert.equal(a.clone().zone(120).year(),  2011, 'should get year correctly');\n        assert.equal(a.clone().zone(120).month(),   11, 'should get month correctly');\n        assert.equal(a.clone().zone(120).date(),    31, 'should get date correctly');\n        assert.equal(a.clone().zone(120).hour(),    22, 'should get hour correctly');\n        assert.equal(a.clone().zone(120).minute(),   0, 'should get minute correctly');\n\n        assert.equal(a.clone().zone(-120).year(),  2012, 'should get year correctly');\n        assert.equal(a.clone().zone(-120).month(),    0, 'should get month correctly');\n        assert.equal(a.clone().zone(-120).date(),     1, 'should get date correctly');\n        assert.equal(a.clone().zone(-120).hour(),     2, 'should get hour correctly');\n        assert.equal(a.clone().zone(-120).minute(),   0, 'should get minute correctly');\n\n        assert.equal(a.clone().zone(-90).year(),  2012, 'should get year correctly');\n        assert.equal(a.clone().zone(-90).month(),    0, 'should get month correctly');\n        assert.equal(a.clone().zone(-90).date(),     1, 'should get date correctly');\n        assert.equal(a.clone().zone(-90).hour(),     1, 'should get hour correctly');\n        assert.equal(a.clone().zone(-90).minute(),  30, 'should get minute correctly');\n    });\n\n    test('from', function (assert) {\n        var zoneA = moment(),\n            zoneB = moment(zoneA).zone(720),\n            zoneC = moment(zoneA).zone(360),\n            zoneD = moment(zoneA).zone(-690),\n            other = moment(zoneA).add(35, 'm');\n\n        assert.equal(zoneA.from(other), zoneB.from(other), 'moment#from should be the same in all zones');\n        assert.equal(zoneA.from(other), zoneC.from(other), 'moment#from should be the same in all zones');\n        assert.equal(zoneA.from(other), zoneD.from(other), 'moment#from should be the same in all zones');\n    });\n\n    test('diff', function (assert) {\n        var zoneA = moment(),\n            zoneB = moment(zoneA).zone(720),\n            zoneC = moment(zoneA).zone(360),\n            zoneD = moment(zoneA).zone(-690),\n            other = moment(zoneA).add(35, 'm');\n\n        assert.equal(zoneA.diff(other), zoneB.diff(other), 'moment#diff should be the same in all zones');\n        assert.equal(zoneA.diff(other), zoneC.diff(other), 'moment#diff should be the same in all zones');\n        assert.equal(zoneA.diff(other), zoneD.diff(other), 'moment#diff should be the same in all zones');\n\n        assert.equal(zoneA.diff(other, 'minute', true), zoneB.diff(other, 'minute', true), 'moment#diff should be the same in all zones');\n        assert.equal(zoneA.diff(other, 'minute', true), zoneC.diff(other, 'minute', true), 'moment#diff should be the same in all zones');\n        assert.equal(zoneA.diff(other, 'minute', true), zoneD.diff(other, 'minute', true), 'moment#diff should be the same in all zones');\n\n        assert.equal(zoneA.diff(other, 'hour', true), zoneB.diff(other, 'hour', true), 'moment#diff should be the same in all zones');\n        assert.equal(zoneA.diff(other, 'hour', true), zoneC.diff(other, 'hour', true), 'moment#diff should be the same in all zones');\n        assert.equal(zoneA.diff(other, 'hour', true), zoneD.diff(other, 'hour', true), 'moment#diff should be the same in all zones');\n    });\n\n    test('unix offset and timestamp', function (assert) {\n        var zoneA = moment(),\n            zoneB = moment(zoneA).zone(720),\n            zoneC = moment(zoneA).zone(360),\n            zoneD = moment(zoneA).zone(-690);\n\n        assert.equal(zoneA.unix(), zoneB.unix(), 'moment#unix should be the same in all zones');\n        assert.equal(zoneA.unix(), zoneC.unix(), 'moment#unix should be the same in all zones');\n        assert.equal(zoneA.unix(), zoneD.unix(), 'moment#unix should be the same in all zones');\n\n        assert.equal(+zoneA, +zoneB, 'moment#valueOf should be the same in all zones');\n        assert.equal(+zoneA, +zoneC, 'moment#valueOf should be the same in all zones');\n        assert.equal(+zoneA, +zoneD, 'moment#valueOf should be the same in all zones');\n    });\n\n    test('cloning', function (assert) {\n        assert.equal(moment().zone(120).clone().zone(),   120, 'explicit cloning should retain the zone');\n        assert.equal(moment().zone(-120).clone().zone(), -120, 'explicit cloning should retain the zone');\n        assert.equal(moment(moment().zone(120)).zone(),   120, 'implicit cloning should retain the zone');\n        assert.equal(moment(moment().zone(-120)).zone(), -120, 'implicit cloning should retain the zone');\n    });\n\n    test('start of / end of', function (assert) {\n        var a = moment.utc([2010, 1, 2, 0, 0, 0]).zone(450);\n\n        assert.equal(a.clone().startOf('day').hour(), 0, 'start of day should work on moments with a zone');\n        assert.equal(a.clone().startOf('day').minute(), 0, 'start of day should work on moments with a zone');\n        assert.equal(a.clone().startOf('hour').minute(), 0, 'start of hour should work on moments with a zone');\n\n        assert.equal(a.clone().endOf('day').hour(), 23, 'end of day should work on moments with a zone');\n        assert.equal(a.clone().endOf('day').minute(), 59, 'end of day should work on moments with a zone');\n        assert.equal(a.clone().endOf('hour').minute(), 59, 'end of hour should work on moments with a zone');\n    });\n\n    test('reset zone with moment#utc', function (assert) {\n        var a = moment.utc([2012]).zone(480);\n\n        assert.equal(a.clone().hour(),      16, 'different zone should have different hour');\n        assert.equal(a.clone().utc().hour(), 0, 'calling moment#utc should reset the offset');\n    });\n\n    test('reset zone with moment#local', function (assert) {\n        var a = moment([2012]).zone(480);\n\n        assert.equal(a.clone().local().hour(), 0, 'calling moment#local should reset the offset');\n    });\n\n    test('toDate', function (assert) {\n        var zoneA = new Date(),\n            zoneB = moment(zoneA).zone(720).toDate(),\n            zoneC = moment(zoneA).zone(360).toDate(),\n            zoneD = moment(zoneA).zone(-690).toDate();\n\n        assert.equal(+zoneA, +zoneB, 'moment#toDate should output a date with the right unix timestamp');\n        assert.equal(+zoneA, +zoneC, 'moment#toDate should output a date with the right unix timestamp');\n        assert.equal(+zoneA, +zoneD, 'moment#toDate should output a date with the right unix timestamp');\n    });\n\n    test('same / before / after', function (assert) {\n        var zoneA = moment().utc(),\n            zoneB = moment(zoneA).zone(120),\n            zoneC = moment(zoneA).zone(-120);\n\n        assert.ok(zoneA.isSame(zoneB), 'two moments with different offsets should be the same');\n        assert.ok(zoneA.isSame(zoneC), 'two moments with different offsets should be the same');\n\n        assert.ok(zoneA.isSame(zoneB, 'hour'), 'two moments with different offsets should be the same hour');\n        assert.ok(zoneA.isSame(zoneC, 'hour'), 'two moments with different offsets should be the same hour');\n\n        zoneA.add(1, 'hour');\n\n        assert.ok(zoneA.isAfter(zoneB), 'isAfter should work with two moments with different offsets');\n        assert.ok(zoneA.isAfter(zoneC), 'isAfter should work with two moments with different offsets');\n\n        assert.ok(zoneA.isAfter(zoneB, 'hour'), 'isAfter:hour should work with two moments with different offsets');\n        assert.ok(zoneA.isAfter(zoneC, 'hour'), 'isAfter:hour should work with two moments with different offsets');\n\n        zoneA.subtract(2, 'hour');\n\n        assert.ok(zoneA.isBefore(zoneB), 'isBefore should work with two moments with different offsets');\n        assert.ok(zoneA.isBefore(zoneC), 'isBefore should work with two moments with different offsets');\n\n        assert.ok(zoneA.isBefore(zoneB, 'hour'), 'isBefore:hour should work with two moments with different offsets');\n        assert.ok(zoneA.isBefore(zoneC, 'hour'), 'isBefore:hour should work with two moments with different offsets');\n    });\n\n    test('add / subtract over dst', function (assert) {\n        var oldOffset = moment.updateOffset,\n            m = moment.utc([2000, 2, 31, 3]);\n\n        moment.updateOffset = function (mom, keepTime) {\n            if (mom.clone().utc().month() > 2) {\n                mom.zone(-60, keepTime);\n            } else {\n                mom.zone(0, keepTime);\n            }\n        };\n\n        assert.equal(m.hour(), 3, 'should start at 00:00');\n\n        m.add(24, 'hour');\n\n        assert.equal(m.hour(), 4, 'adding 24 hours should disregard dst');\n\n        m.subtract(24, 'hour');\n\n        assert.equal(m.hour(), 3, 'subtracting 24 hours should disregard dst');\n\n        m.add(1, 'day');\n\n        assert.equal(m.hour(), 3, 'adding 1 day should have the same hour');\n\n        m.subtract(1, 'day');\n\n        assert.equal(m.hour(), 3, 'subtracting 1 day should have the same hour');\n\n        m.add(1, 'month');\n\n        assert.equal(m.hour(), 3, 'adding 1 month should have the same hour');\n\n        m.subtract(1, 'month');\n\n        assert.equal(m.hour(), 3, 'subtracting 1 month should have the same hour');\n\n        moment.updateOffset = oldOffset;\n    });\n\n    test('isDST', function (assert) {\n        var oldOffset = moment.updateOffset;\n\n        moment.updateOffset = function (mom, keepTime) {\n            if (mom.month() > 2 && mom.month() < 9) {\n                mom.zone(-60, keepTime);\n            } else {\n                mom.zone(0, keepTime);\n            }\n        };\n\n        assert.ok(!moment().month(0).isDST(),  'Jan should not be summer dst');\n        assert.ok(moment().month(6).isDST(),   'Jul should be summer dst');\n        assert.ok(!moment().month(11).isDST(), 'Dec should not be summer dst');\n\n        moment.updateOffset = function (mom) {\n            if (mom.month() > 2 && mom.month() < 9) {\n                mom.zone(0);\n            } else {\n                mom.zone(-60);\n            }\n        };\n\n        assert.ok(moment().month(0).isDST(),  'Jan should be winter dst');\n        assert.ok(!moment().month(6).isDST(), 'Jul should not be winter dst');\n        assert.ok(moment().month(11).isDST(), 'Dec should be winter dst');\n\n        moment.updateOffset = oldOffset;\n    });\n\n    test('zone names', function (assert) {\n        test.expectedDeprecations();\n        assert.equal(moment().zoneAbbr(),   '', 'Local zone abbr should be empty');\n        assert.equal(moment().format('z'),  '', 'Local zone formatted abbr should be empty');\n        assert.equal(moment().zoneName(),   '', 'Local zone name should be empty');\n        assert.equal(moment().format('zz'), '', 'Local zone formatted name should be empty');\n\n        assert.equal(moment.utc().zoneAbbr(),   'UTC', 'UTC zone abbr should be UTC');\n        assert.equal(moment.utc().format('z'),  'UTC', 'UTC zone formatted abbr should be UTC');\n        assert.equal(moment.utc().zoneName(),   'Coordinated Universal Time', 'UTC zone abbr should be Coordinated Universal Time');\n        assert.equal(moment.utc().format('zz'), 'Coordinated Universal Time', 'UTC zone formatted abbr should be Coordinated Universal Time');\n    });\n\n    test('hours alignment with UTC', function (assert) {\n        assert.equal(moment().zone(120).hasAlignedHourOffset(), true);\n        assert.equal(moment().zone(-180).hasAlignedHourOffset(), true);\n        assert.equal(moment().zone(90).hasAlignedHourOffset(), false);\n        assert.equal(moment().zone(-90).hasAlignedHourOffset(), false);\n    });\n\n    test('hours alignment with other zone', function (assert) {\n        var m = moment().zone(120);\n\n        assert.equal(m.hasAlignedHourOffset(moment().zone(180)), true);\n        assert.equal(m.hasAlignedHourOffset(moment().zone(-180)), true);\n        assert.equal(m.hasAlignedHourOffset(moment().zone(90)), false);\n        assert.equal(m.hasAlignedHourOffset(moment().zone(-90)), false);\n\n        m = moment().zone(90);\n\n        assert.equal(m.hasAlignedHourOffset(moment().zone(180)), false);\n        assert.equal(m.hasAlignedHourOffset(moment().zone(-180)), false);\n        assert.equal(m.hasAlignedHourOffset(moment().zone(30)), true);\n        assert.equal(m.hasAlignedHourOffset(moment().zone(-30)), true);\n\n        m = moment().zone(-60);\n\n        assert.equal(m.hasAlignedHourOffset(moment().zone(180)), true);\n        assert.equal(m.hasAlignedHourOffset(moment().zone(-180)), true);\n        assert.equal(m.hasAlignedHourOffset(moment().zone(90)), false);\n        assert.equal(m.hasAlignedHourOffset(moment().zone(-90)), false);\n\n        m = moment().zone(25);\n\n        assert.equal(m.hasAlignedHourOffset(moment().zone(-35)), true);\n        assert.equal(m.hasAlignedHourOffset(moment().zone(85)), true);\n\n        assert.equal(m.hasAlignedHourOffset(moment().zone(35)), false);\n        assert.equal(m.hasAlignedHourOffset(moment().zone(-85)), false);\n    });\n\n    test('parse zone', function (assert) {\n        var m = moment('2013-01-01T00:00:00-13:00').parseZone();\n        assert.equal(m.zone(), 13 * 60);\n        assert.equal(m.hours(), 0);\n    });\n\n    test('parse zone static', function (assert) {\n        var m = moment.parseZone('2013-01-01T00:00:00-13:00');\n        assert.equal(m.zone(), 13 * 60);\n        assert.equal(m.hours(), 0);\n    });\n\n    test('parse zone with more arguments', function (assert) {\n        test.expectedDeprecations();\n        var m;\n        m = moment.parseZone('2013 01 01 05 -13:00', 'YYYY MM DD HH ZZ');\n        assert.equal(m.format(), '2013-01-01T05:00:00-13:00', 'accept input and format');\n        m = moment.parseZone('2013-01-01-13:00', 'YYYY MM DD ZZ', true);\n        assert.equal(m.isValid(), false, 'accept input, format and strict flag');\n        m = moment.parseZone('2013-01-01-13:00', ['DD MM YYYY ZZ', 'YYYY MM DD ZZ']);\n        assert.equal(m.format(), '2013-01-01T00:00:00-13:00', 'accept input and array of formats');\n    });\n\n    test('parse zone with a timezone from the format string', function (assert) {\n        var m = moment('11-12-2013 -0400 +1100', 'DD-MM-YYYY ZZ #####').parseZone();\n\n        assert.equal(m.zone(), 4 * 60);\n    });\n\n    test('parse zone without a timezone included in the format string', function (assert) {\n        var m = moment('11-12-2013 -0400 +1100', 'DD-MM-YYYY').parseZone();\n\n        assert.equal(m.zone(), -11 * 60);\n    });\n\n    test('timezone format', function (assert) {\n        assert.equal(moment().zone(-60).format('ZZ'), '+0100', '-60 -> +0100');\n        assert.equal(moment().zone(-90).format('ZZ'), '+0130', '-90 -> +0130');\n        assert.equal(moment().zone(-120).format('ZZ'), '+0200', '-120 -> +0200');\n\n        assert.equal(moment().zone(+60).format('ZZ'), '-0100', '+60 -> -0100');\n        assert.equal(moment().zone(+90).format('ZZ'), '-0130', '+90 -> -0130');\n        assert.equal(moment().zone(+120).format('ZZ'), '-0200', '+120 -> -0200');\n    });\n\n}));"}
    }
});
