require.config({
    config: {
        'jsbuild':{"Milople_Personalizedcool/js/personalized_based.js":"/**\r\n*\r\n* Do not edit or add to this file if you wish to upgrade the module to newer\r\n* versions in the future. If you wish to customize the module for your\r\n* needs please contact us to https://www.milople.com/contact-us.html\r\n*\r\n* @category    Ecommerce\r\n* @package     Milople_Personlized\r\n* @copyright   Copyright (c) 2016 Milople Technologies Pvt. Ltd. All Rights Reserved.\r\n* @url         https://www.milople.com/magento2-extensions/personalized-products-m2.html\r\n*\r\n**/\r\n\r\nvar fabric = fabric || { version: \"1.6.0-rc.1\" };\r\nif (typeof exports !== 'undefined') {\r\n  exports.fabric = fabric;\r\n}\r\n\r\nif (typeof document !== 'undefined' && typeof window !== 'undefined') {\r\n  fabric.document = document;\r\n  fabric.window = window;\r\n  // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)\r\n  window.fabric = fabric;\r\n}\r\nelse {\r\n  // assume we're running under node.js when document/window are not present\r\n  fabric.document = require(\"jsdom\")\r\n    .jsdom(\"<!DOCTYPE html><html><head></head><body></body></html>\");\r\n\r\n  if (fabric.document.createWindow) {\r\n    fabric.window = fabric.document.createWindow();\r\n  } else {\r\n    fabric.window = fabric.document.parentWindow;\r\n  }\r\n}\r\n\r\n/**\r\n * True when in environment that supports touch events\r\n * @type boolean\r\n */\r\nfabric.isTouchSupported = \"ontouchstart\" in fabric.document.documentElement;\r\n\r\n/**\r\n * True when in environment that's probably Node.js\r\n * @type boolean\r\n */\r\nfabric.isLikelyNode = typeof Buffer !== 'undefined' &&\r\n                      typeof window === 'undefined';\r\n\r\n/* _FROM_SVG_START_ */\r\n/**\r\n * Attributes parsed from all SVG elements\r\n * @type array\r\n */\r\nfabric.SHARED_ATTRIBUTES = [\r\n  \"display\",\r\n  \"transform\",\r\n  \"fill\", \"fill-opacity\", \"fill-rule\",\r\n  \"opacity\",\r\n  \"stroke\", \"stroke-dasharray\", \"stroke-linecap\",\r\n  \"stroke-linejoin\", \"stroke-miterlimit\",\r\n  \"stroke-opacity\", \"stroke-width\",\r\n  \"id\"\r\n];\r\n/* _FROM_SVG_END_ */\r\n\r\n/**\r\n * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.\r\n */\r\nfabric.DPI = 96;\r\nfabric.reNum = '(?:[-+]?(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:e[-+]?\\\\d+)?)';\r\n\r\n\r\n/**\r\n * Device Pixel Ratio\r\n * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html\r\n */\r\nfabric.devicePixelRatio = fabric.window.devicePixelRatio ||\r\n                          fabric.window.webkitDevicePixelRatio ||\r\n                          fabric.window.mozDevicePixelRatio ||\r\n                          1;\r\n\r\n\r\n(function() {\r\n\r\n  /**\r\n   * @private\r\n   * @param {String} eventName\r\n   * @param {Function} handler\r\n   */\r\n  function _removeEventListener(eventName, handler) {\r\n    if (!this.__eventListeners[eventName]) {\r\n      return;\r\n    }\r\n\r\n    if (handler) {\r\n      fabric.util.removeFromArray(this.__eventListeners[eventName], handler);\r\n    }\r\n    else {\r\n      this.__eventListeners[eventName].length = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Observes specified event\r\n   * @deprecated `observe` deprecated since 0.8.34 (use `on` instead)\r\n   * @memberOf fabric.Observable\r\n   * @alias on\r\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\r\n   * @param {Function} handler Function that receives a notification when an event of the specified type occurs\r\n   * @return {Self} thisArg\r\n   * @chainable\r\n   */\r\n  function observe(eventName, handler) {\r\n    if (!this.__eventListeners) {\r\n      this.__eventListeners = { };\r\n    }\r\n    // one object with key/value pairs was passed\r\n    if (arguments.length === 1) {\r\n      for (var prop in eventName) {\r\n        this.on(prop, eventName[prop]);\r\n      }\r\n    }\r\n    else {\r\n      if (!this.__eventListeners[eventName]) {\r\n        this.__eventListeners[eventName] = [ ];\r\n      }\r\n      this.__eventListeners[eventName].push(handler);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Stops event observing for a particular event handler. Calling this method\r\n   * without arguments removes all handlers for all events\r\n   * @deprecated `stopObserving` deprecated since 0.8.34 (use `off` instead)\r\n   * @memberOf fabric.Observable\r\n   * @alias off\r\n   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\r\n   * @param {Function} handler Function to be deleted from EventListeners\r\n   * @return {Self} thisArg\r\n   * @chainable\r\n   */\r\n  function stopObserving(eventName, handler) {\r\n    if (!this.__eventListeners) {\r\n      return;\r\n    }\r\n\r\n    // remove all key/value pairs (event name -> event handler)\r\n    if (arguments.length === 0) {\r\n      this.__eventListeners = { };\r\n    }\r\n    // one object with key/value pairs was passed\r\n    else if (arguments.length === 1 && typeof arguments[0] === 'object') {\r\n      for (var prop in eventName) {\r\n        _removeEventListener.call(this, prop, eventName[prop]);\r\n      }\r\n    }\r\n    else {\r\n      _removeEventListener.call(this, eventName, handler);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Fires event with an optional options object\r\n   * @deprecated `fire` deprecated since 1.0.7 (use `trigger` instead)\r\n   * @memberOf fabric.Observable\r\n   * @alias trigger\r\n   * @param {String} eventName Event name to fire\r\n   * @param {Object} [options] Options object\r\n   * @return {Self} thisArg\r\n   * @chainable\r\n   */\r\n  function fire(eventName, options) {\r\n    if (!this.__eventListeners) {\r\n      return;\r\n    }\r\n\r\n    var listenersForEvent = this.__eventListeners[eventName];\r\n    if (!listenersForEvent) {\r\n      return;\r\n    }\r\n\r\n    for (var i = 0, len = listenersForEvent.length; i < len; i++) {\r\n      // avoiding try/catch for perf. reasons\r\n      listenersForEvent[i].call(this, options || { });\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * @namespace fabric.Observable\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#events}\r\n   * @see {@link http://fabricjs.com/events/|Events demo}\r\n   */\r\n  fabric.Observable = {\r\n    observe: observe,\r\n    stopObserving: stopObserving,\r\n    fire: fire,\r\n\r\n    on: observe,\r\n    off: stopObserving,\r\n    trigger: fire\r\n  };\r\n})();\r\n\r\n\r\n/**\r\n * @namespace fabric.Collection\r\n */\r\nfabric.Collection = {\r\n\r\n  /**\r\n   * Adds objects to collection, then renders canvas (if `renderOnAddRemove` is not `false`)\r\n   * Objects should be instances of (or inherit from) fabric.Object\r\n   * @param {...fabric.Object} object Zero or more fabric instances\r\n   * @return {Self} thisArg\r\n   */\r\n  add: function () {\r\n    this._objects.push.apply(this._objects, arguments);\r\n    for (var i = 0, length = arguments.length; i < length; i++) {\r\n      this._onObjectAdded(arguments[i]);\r\n    }\r\n    this.renderOnAddRemove && this.renderAll();\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)\r\n   * An object should be an instance of (or inherit from) fabric.Object\r\n   * @param {Object} object Object to insert\r\n   * @param {Number} index Index to insert object at\r\n   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs\r\n   * @return {Self} thisArg\r\n   * @chainable\r\n   */\r\n  insertAt: function (object, index, nonSplicing) {\r\n    var objects = this.getObjects();\r\n    if (nonSplicing) {\r\n      objects[index] = object;\r\n    }\r\n    else {\r\n      objects.splice(index, 0, object);\r\n    }\r\n    this._onObjectAdded(object);\r\n    this.renderOnAddRemove && this.renderAll();\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)\r\n   * @param {...fabric.Object} object Zero or more fabric instances\r\n   * @return {Self} thisArg\r\n   * @chainable\r\n   */\r\n  remove: function() {\r\n    var objects = this.getObjects(),\r\n        index;\r\n\r\n    for (var i = 0, length = arguments.length; i < length; i++) {\r\n      index = objects.indexOf(arguments[i]);\r\n\r\n      // only call onObjectRemoved if an object was actually removed\r\n      if (index !== -1) {\r\n        objects.splice(index, 1);\r\n        this._onObjectRemoved(arguments[i]);\r\n      }\r\n    }\r\n\r\n    this.renderOnAddRemove && this.renderAll();\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Executes given function for each object in this group\r\n   * @param {Function} callback\r\n   *                   Callback invoked with current object as first argument,\r\n   *                   index - as second and an array of all objects - as third.\r\n   *                   Iteration happens in reverse order (for performance reasons).\r\n   *                   Callback is invoked in a context of Global Object (e.g. `window`)\r\n   *                   when no `context` argument is given\r\n   *\r\n   * @param {Object} context Context (aka thisObject)\r\n   * @return {Self} thisArg\r\n   */\r\n  forEachObject: function(callback, context) {\r\n    var objects = this.getObjects(),\r\n        i = objects.length;\r\n    while (i--) {\r\n      callback.call(context, objects[i], i, objects);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Returns an array of children objects of this instance\r\n   * Type parameter introduced in 1.3.10\r\n   * @param {String} [type] When specified, only objects of this type are returned\r\n   * @return {Array}\r\n   */\r\n  getObjects: function(type) {\r\n    if (typeof type === 'undefined') {\r\n      return this._objects;\r\n    }\r\n    return this._objects.filter(function(o) {\r\n      return o.type === type;\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Returns object at specified index\r\n   * @param {Number} index\r\n   * @return {Self} thisArg\r\n   */\r\n  item: function (index) {\r\n    return this.getObjects()[index];\r\n  },\r\n\r\n  /**\r\n   * Returns true if collection contains no objects\r\n   * @return {Boolean} true if collection is empty\r\n   */\r\n  isEmpty: function () {\r\n    return this.getObjects().length === 0;\r\n  },\r\n\r\n  /**\r\n   * Returns a size of a collection (i.e: length of an array containing its objects)\r\n   * @return {Number} Collection size\r\n   */\r\n  size: function() {\r\n    return this.getObjects().length;\r\n  },\r\n\r\n  /**\r\n   * Returns true if collection contains an object\r\n   * @param {Object} object Object to check against\r\n   * @return {Boolean} `true` if collection contains an object\r\n   */\r\n  contains: function(object) {\r\n    return this.getObjects().indexOf(object) > -1;\r\n  },\r\n\r\n  /**\r\n   * Returns number representation of a collection complexity\r\n   * @return {Number} complexity\r\n   */\r\n  complexity: function () {\r\n    return this.getObjects().reduce(function (memo, current) {\r\n      memo += current.complexity ? current.complexity() : 0;\r\n      return memo;\r\n    }, 0);\r\n  }\r\n};\r\n\r\n\r\n(function(global) {\r\n\r\n  var sqrt = Math.sqrt,\r\n      atan2 = Math.atan2,\r\n      PiBy180 = Math.PI / 180;\r\n\r\n  /**\r\n   * @namespace fabric.util\r\n   */\r\n  fabric.util = {\r\n\r\n    /**\r\n     * Removes value from an array.\r\n     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Array} array\r\n     * @param {Any} value\r\n     * @return {Array} original array\r\n     */\r\n    removeFromArray: function(array, value) {\r\n      var idx = array.indexOf(value);\r\n      if (idx !== -1) {\r\n        array.splice(idx, 1);\r\n      }\r\n      return array;\r\n    },\r\n\r\n    /**\r\n     * Returns random number between 2 specified ones.\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Number} min lower limit\r\n     * @param {Number} max upper limit\r\n     * @return {Number} random value (between min and max)\r\n     */\r\n    getRandomInt: function(min, max) {\r\n      return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    },\r\n\r\n    /**\r\n     * Transforms degrees to radians.\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Number} degrees value in degrees\r\n     * @return {Number} value in radians\r\n     */\r\n    degreesToRadians: function(degrees) {\r\n      return degrees * PiBy180;\r\n    },\r\n\r\n    /**\r\n     * Transforms radians to degrees.\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Number} radians value in radians\r\n     * @return {Number} value in degrees\r\n     */\r\n    radiansToDegrees: function(radians) {\r\n      return radians / PiBy180;\r\n    },\r\n\r\n    /**\r\n     * Rotates `point` around `origin` with `radians`\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {fabric.Point} point The point to rotate\r\n     * @param {fabric.Point} origin The origin of the rotation\r\n     * @param {Number} radians The radians of the angle for the rotation\r\n     * @return {fabric.Point} The new rotated point\r\n     */\r\n    rotatePoint: function(point, origin, radians) {\r\n      point.subtractEquals(origin);\r\n      var sin = Math.sin(radians),\r\n          cos = Math.cos(radians),\r\n          rx = point.x * cos - point.y * sin,\r\n          ry = point.x * sin + point.y * cos;\r\n      return new fabric.Point(rx, ry).addEquals(origin);\r\n    },\r\n\r\n    /**\r\n     * Apply transform t to point p\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param  {fabric.Point} p The point to transform\r\n     * @param  {Array} t The transform\r\n     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied\r\n     * @return {fabric.Point} The transformed point\r\n     */\r\n    transformPoint: function(p, t, ignoreOffset) {\r\n      if (ignoreOffset) {\r\n        return new fabric.Point(\r\n          t[0] * p.x + t[2] * p.y,\r\n          t[1] * p.x + t[3] * p.y\r\n        );\r\n      }\r\n      return new fabric.Point(\r\n        t[0] * p.x + t[2] * p.y + t[4],\r\n        t[1] * p.x + t[3] * p.y + t[5]\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Invert transformation t\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Array} t The transform\r\n     * @return {Array} The inverted transform\r\n     */\r\n    invertTransform: function(t) {\r\n      var a = 1 / (t[0] * t[3] - t[1] * t[2]),\r\n          r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],\r\n          o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);\r\n      r[4] = -o.x;\r\n      r[5] = -o.y;\r\n      return r;\r\n    },\r\n\r\n    /**\r\n     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Number|String} number number to operate on\r\n     * @param {Number} fractionDigits number of fraction digits to \"leave\"\r\n     * @return {Number}\r\n     */\r\n    toFixed: function(number, fractionDigits) {\r\n      return parseFloat(Number(number).toFixed(fractionDigits));\r\n    },\r\n\r\n    /**\r\n     * Converts from attribute value to pixel value if applicable.\r\n     * Returns converted pixels or original value not converted.\r\n     * @param {Number|String} value number to operate on\r\n     * @return {Number|String}\r\n     */\r\n    parseUnit: function(value, fontSize) {\r\n      var unit = /\\D{0,2}$/.exec(value),\r\n          number = parseFloat(value);\r\n      if (!fontSize) {\r\n        fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\r\n      }\r\n      switch (unit[0]) {\r\n        case 'mm':\r\n          return number * fabric.DPI / 25.4;\r\n\r\n        case 'cm':\r\n          return number * fabric.DPI / 2.54;\r\n\r\n        case 'in':\r\n          return number * fabric.DPI;\r\n\r\n        case 'pt':\r\n          return number * fabric.DPI / 72; // or * 4 / 3\r\n\r\n        case 'pc':\r\n          return number * fabric.DPI / 72 * 12; // or * 16\r\n\r\n        case 'em':\r\n          return number * fontSize;\r\n\r\n        default:\r\n          return number;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Function which always returns `false`.\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @return {Boolean}\r\n     */\r\n    falseFunction: function() {\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Returns klass \"Class\" object of given namespace\r\n     * @memberOf fabric.util\r\n     * @param {String} type Type of object (eg. 'circle')\r\n     * @param {String} namespace Namespace to get klass \"Class\" object from\r\n     * @return {Object} klass \"Class\"\r\n     */\r\n    getKlass: function(type, namespace) {\r\n      // capitalize first letter only\r\n      type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));\r\n      return fabric.util.resolveNamespace(namespace)[type];\r\n    },\r\n\r\n    /**\r\n     * Returns object of given namespace\r\n     * @memberOf fabric.util\r\n     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'\r\n     * @return {Object} Object for given namespace (default fabric)\r\n     */\r\n    resolveNamespace: function(namespace) {\r\n      if (!namespace) {\r\n        return fabric;\r\n      }\r\n\r\n      var parts = namespace.split('.'),\r\n          len = parts.length,\r\n          obj = global || fabric.window;\r\n\r\n      for (var i = 0; i < len; ++i) {\r\n        obj = obj[parts[i]];\r\n      }\r\n\r\n      return obj;\r\n    },\r\n\r\n    /**\r\n     * Loads image element from given url and passes it to a callback\r\n     * @memberOf fabric.util\r\n     * @param {String} url URL representing an image\r\n     * @param {Function} callback Callback; invoked with loaded image\r\n     * @param {Any} [context] Context to invoke callback in\r\n     * @param {Object} [crossOrigin] crossOrigin value to set image element to\r\n     */\r\n    loadImage: function(url, callback, context, crossOrigin) {\r\n      if (!url) {\r\n        callback && callback.call(context, url);\r\n        return;\r\n      }\r\n\r\n      var img = fabric.util.createImage();\r\n\r\n      /** @ignore */\r\n      img.onload = function () {\r\n        callback && callback.call(context, img);\r\n        img = img.onload = img.onerror = null;\r\n      };\r\n\r\n      /** @ignore */\r\n      img.onerror = function() {\r\n        fabric.log('Error loading ' + img.src);\r\n        callback && callback.call(context, null, true);\r\n        img = img.onload = img.onerror = null;\r\n      };\r\n\r\n      // data-urls appear to be buggy with crossOrigin\r\n      // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767\r\n      // see https://code.google.com/p/chromium/issues/detail?id=315152\r\n      //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069\r\n      if (url.indexOf('data') !== 0 && typeof crossOrigin !== 'undefined') {\r\n        img.crossOrigin = crossOrigin;\r\n      }\r\n\r\n      img.src = url;\r\n    },\r\n\r\n    /**\r\n     * Creates corresponding fabric instances from their object representations\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Array} objects Objects to enliven\r\n     * @param {Function} callback Callback to invoke when all objects are created\r\n     * @param {String} namespace Namespace to get klass \"Class\" object from\r\n     * @param {Function} reviver Method for further parsing of object elements,\r\n     * called after each fabric object created.\r\n     */\r\n    enlivenObjects: function(objects, callback, namespace, reviver) {\r\n      objects = objects || [ ];\r\n\r\n      function onLoaded() {\r\n        if (++numLoadedObjects === numTotalObjects) {\r\n          callback && callback(enlivenedObjects);\r\n        }\r\n      }\r\n\r\n      var enlivenedObjects = [ ],\r\n          numLoadedObjects = 0,\r\n          numTotalObjects = objects.length;\r\n\r\n      if (!numTotalObjects) {\r\n        callback && callback(enlivenedObjects);\r\n        return;\r\n      }\r\n\r\n      objects.forEach(function (o, index) {\r\n        // if sparse array\r\n        if (!o || !o.type) {\r\n          onLoaded();\r\n          return;\r\n        }\r\n        var klass = fabric.util.getKlass(o.type, namespace);\r\n        if (klass.async) {\r\n          klass.fromObject(o, function (obj, error) {\r\n            if (!error) {\r\n              enlivenedObjects[index] = obj;\r\n              reviver && reviver(o, enlivenedObjects[index]);\r\n            }\r\n            onLoaded();\r\n          });\r\n        }\r\n        else {\r\n          enlivenedObjects[index] = klass.fromObject(o);\r\n          reviver && reviver(o, enlivenedObjects[index]);\r\n          onLoaded();\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Groups SVG elements (usually those retrieved from SVG document)\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Array} elements SVG elements to group\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Object|fabric.PathGroup}\r\n     */\r\n    groupSVGElements: function(elements, options, path) {\r\n      var object;\r\n\r\n      object = new fabric.PathGroup(elements, options);\r\n\r\n      if (typeof path !== 'undefined') {\r\n        object.setSourcePath(path);\r\n      }\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Populates an object with properties of another object\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Object} source Source object\r\n     * @param {Object} destination Destination object\r\n     * @return {Array} properties Propertie names to include\r\n     */\r\n    populateWithProperties: function(source, destination, properties) {\r\n      if (properties && Object.prototype.toString.call(properties) === '[object Array]') {\r\n        for (var i = 0, len = properties.length; i < len; i++) {\r\n          if (properties[i] in source) {\r\n            destination[properties[i]] = source[properties[i]];\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Draws a dashed line between two points\r\n     *\r\n     * This method is used to draw dashed line around selection area.\r\n     * See <a href=\"http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas\">dotted stroke in canvas</a>\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx context\r\n     * @param {Number} x  start x coordinate\r\n     * @param {Number} y start y coordinate\r\n     * @param {Number} x2 end x coordinate\r\n     * @param {Number} y2 end y coordinate\r\n     * @param {Array} da dash array pattern\r\n     */\r\n    drawDashedLine: function(ctx, x, y, x2, y2, da) {\r\n      var dx = x2 - x,\r\n          dy = y2 - y,\r\n          len = sqrt(dx * dx + dy * dy),\r\n          rot = atan2(dy, dx),\r\n          dc = da.length,\r\n          di = 0,\r\n          draw = true;\r\n\r\n      ctx.save();\r\n      ctx.translate(x, y);\r\n      ctx.moveTo(0, 0);\r\n      ctx.rotate(rot);\r\n\r\n      x = 0;\r\n      while (len > x) {\r\n        x += da[di++ % dc];\r\n        if (x > len) {\r\n          x = len;\r\n        }\r\n        ctx[draw ? 'lineTo' : 'moveTo'](x, 0);\r\n        draw = !draw;\r\n      }\r\n\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Creates canvas element and initializes it via excanvas if necessary\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {CanvasElement} [canvasEl] optional canvas element to initialize;\r\n     * when not given, element is created implicitly\r\n     * @return {CanvasElement} initialized canvas element\r\n     */\r\n    createCanvasElement: function(canvasEl) {\r\n      canvasEl || (canvasEl = fabric.document.createElement('canvas'));\r\n      //jscs:disable requireCamelCaseOrUpperCaseIdentifiers\r\n      if (!canvasEl.getContext && typeof G_vmlCanvasManager !== 'undefined') {\r\n        G_vmlCanvasManager.initElement(canvasEl);\r\n      }\r\n      //jscs:enable requireCamelCaseOrUpperCaseIdentifiers\r\n      return canvasEl;\r\n    },\r\n\r\n    /**\r\n     * Creates image element (works on client and node)\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @return {HTMLImageElement} HTML image element\r\n     */\r\n    createImage: function() {\r\n      return fabric.isLikelyNode\r\n        ? new (require('canvas').Image)()\r\n        : fabric.document.createElement('img');\r\n    },\r\n\r\n    /**\r\n     * Creates accessors (getXXX, setXXX) for a \"class\", based on \"stateProperties\" array\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {Object} klass \"Class\" to create accessors for\r\n     */\r\n    createAccessors: function(klass) {\r\n      var proto = klass.prototype;\r\n\r\n      for (var i = proto.stateProperties.length; i--; ) {\r\n\r\n        var propName = proto.stateProperties[i],\r\n            capitalizedPropName = propName.charAt(0).toUpperCase() + propName.slice(1),\r\n            setterName = 'set' + capitalizedPropName,\r\n            getterName = 'get' + capitalizedPropName;\r\n\r\n        // using `new Function` for better introspection\r\n        if (!proto[getterName]) {\r\n          proto[getterName] = (function(property) {\r\n            return new Function('return this.get(\"' + property + '\")');\r\n          })(propName);\r\n        }\r\n        if (!proto[setterName]) {\r\n          proto[setterName] = (function(property) {\r\n            return new Function('value', 'return this.set(\"' + property + '\", value)');\r\n          })(propName);\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param {fabric.Object} receiver Object implementing `clipTo` method\r\n     * @param {CanvasRenderingContext2D} ctx Context to clip\r\n     */\r\n    clipContext: function(receiver, ctx) {\r\n      ctx.save();\r\n      ctx.beginPath();\r\n      receiver.clipTo(ctx);\r\n      ctx.clip();\r\n    },\r\n\r\n    /**\r\n     * Multiply matrix A by matrix B to nest transformations\r\n     * @static\r\n     * @memberOf fabric.util\r\n     * @param  {Array} a First transformMatrix\r\n     * @param  {Array} b Second transformMatrix\r\n     * @return {Array} The product of the two transform matrices\r\n     */\r\n    multiplyTransformMatrices: function(a, b) {\r\n      // Matrix multiply a * b\r\n      return [\r\n        a[0] * b[0] + a[2] * b[1],\r\n        a[1] * b[0] + a[3] * b[1],\r\n        a[0] * b[2] + a[2] * b[3],\r\n        a[1] * b[2] + a[3] * b[3],\r\n        a[0] * b[4] + a[2] * b[5] + a[4],\r\n        a[1] * b[4] + a[3] * b[5] + a[5]\r\n      ];\r\n    },\r\n\r\n    /**\r\n     * Returns string representation of function body\r\n     * @param {Function} fn Function to get body of\r\n     * @return {String} Function body\r\n     */\r\n    getFunctionBody: function(fn) {\r\n      return (String(fn).match(/function[^{]*\\{([\\s\\S]*)\\}/) || {})[1];\r\n    },\r\n\r\n    /**\r\n     * Returns true if context has transparent pixel\r\n     * at specified location (taking tolerance into account)\r\n     * @param {CanvasRenderingContext2D} ctx context\r\n     * @param {Number} x x coordinate\r\n     * @param {Number} y y coordinate\r\n     * @param {Number} tolerance Tolerance\r\n     */\r\n    isTransparent: function(ctx, x, y, tolerance) {\r\n\r\n      // If tolerance is > 0 adjust start coords to take into account.\r\n      // If moves off Canvas fix to 0\r\n      if (tolerance > 0) {\r\n        if (x > tolerance) {\r\n          x -= tolerance;\r\n        }\r\n        else {\r\n          x = 0;\r\n        }\r\n        if (y > tolerance) {\r\n          y -= tolerance;\r\n        }\r\n        else {\r\n          y = 0;\r\n        }\r\n      }\r\n\r\n      var _isTransparent = true,\r\n          imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1);\r\n\r\n      // Split image data - for tolerance > 1, pixelDataSize = 4;\r\n      for (var i = 3, l = imageData.data.length; i < l; i += 4) {\r\n        var temp = imageData.data[i];\r\n        _isTransparent = temp <= 0;\r\n        if (_isTransparent === false) {\r\n          break; // Stop if colour found\r\n        }\r\n      }\r\n\r\n      imageData = null;\r\n\r\n      return _isTransparent;\r\n    },\r\n\r\n    /**\r\n     * Parse preserveAspectRatio attribute from element\r\n     * @param {string} attribute to be parsed\r\n     * @return {Object} an object containing align and meetOrSlice attribute\r\n     */\r\n    parsePreserveAspectRatioAttribute: function(attribute) {\r\n      var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',\r\n          aspectRatioAttrs = attribute.split(' '), align;\r\n\r\n      if (aspectRatioAttrs && aspectRatioAttrs.length) {\r\n        meetOrSlice = aspectRatioAttrs.pop();\r\n        if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {\r\n          align = meetOrSlice;\r\n          meetOrSlice = 'meet';\r\n        }\r\n        else if (aspectRatioAttrs.length) {\r\n          align = aspectRatioAttrs.pop();\r\n        }\r\n      }\r\n      //divide align in alignX and alignY\r\n      alignX = align !== 'none' ? align.slice(1, 4) : 'none';\r\n      alignY = align !== 'none' ? align.slice(5, 8) : 'none';\r\n      return {\r\n        meetOrSlice: meetOrSlice,\r\n        alignX: alignX,\r\n        alignY: alignY\r\n      };\r\n    }\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function() {\r\n\r\n  var arcToSegmentsCache = { },\r\n      segmentToBezierCache = { },\r\n      boundsOfCurveCache = { },\r\n      _join = Array.prototype.join;\r\n\r\n  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp\r\n   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here\r\n   * http://mozilla.org/MPL/2.0/\r\n   */\r\n  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {\r\n    var argsString = _join.call(arguments);\r\n    if (arcToSegmentsCache[argsString]) {\r\n      return arcToSegmentsCache[argsString];\r\n    }\r\n\r\n    var PI = Math.PI, th = rotateX * PI / 180,\r\n        sinTh = Math.sin(th),\r\n        cosTh = Math.cos(th),\r\n        fromX = 0, fromY = 0;\r\n\r\n    rx = Math.abs(rx);\r\n    ry = Math.abs(ry);\r\n\r\n    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,\r\n        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,\r\n        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,\r\n        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,\r\n        root = 0;\r\n\r\n    if (pl < 0) {\r\n      var s = Math.sqrt(1 - pl/(rx2 * ry2));\r\n      rx *= s;\r\n      ry *= s;\r\n    }\r\n    else {\r\n      root = (large === sweep ? -1.0 : 1.0) *\r\n              Math.sqrt( pl /(rx2 * py2 + ry2 * px2));\r\n    }\r\n\r\n    var cx = root * rx * py / ry,\r\n        cy = -root * ry * px / rx,\r\n        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,\r\n        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,\r\n        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),\r\n        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);\r\n\r\n    if (sweep === 0 && dtheta > 0) {\r\n      dtheta -= 2 * PI;\r\n    }\r\n    else if (sweep === 1 && dtheta < 0) {\r\n      dtheta += 2 * PI;\r\n    }\r\n\r\n    // Convert into cubic bezier segments <= 90deg\r\n    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),\r\n        result = [], mDelta = dtheta / segments,\r\n        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),\r\n        th3 = mTheta + mDelta;\r\n\r\n    for (var i = 0; i < segments; i++) {\r\n      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);\r\n      fromX = result[i][4];\r\n      fromY = result[i][5];\r\n      mTheta = th3;\r\n      th3 += mDelta;\r\n    }\r\n    arcToSegmentsCache[argsString] = result;\r\n    return result;\r\n  }\r\n\r\n  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {\r\n    var argsString2 = _join.call(arguments);\r\n    if (segmentToBezierCache[argsString2]) {\r\n      return segmentToBezierCache[argsString2];\r\n    }\r\n\r\n    var costh2 = Math.cos(th2),\r\n        sinth2 = Math.sin(th2),\r\n        costh3 = Math.cos(th3),\r\n        sinth3 = Math.sin(th3),\r\n        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,\r\n        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,\r\n        cp1X = fromX + mT * ( - cosTh * rx * sinth2 - sinTh * ry * costh2),\r\n        cp1Y = fromY + mT * ( - sinTh * rx * sinth2 + cosTh * ry * costh2),\r\n        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),\r\n        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);\r\n\r\n    segmentToBezierCache[argsString2] = [\r\n      cp1X, cp1Y,\r\n      cp2X, cp2Y,\r\n      toX, toY\r\n    ];\r\n    return segmentToBezierCache[argsString2];\r\n  }\r\n\r\n  /*\r\n   * Private\r\n   */\r\n  function calcVectorAngle(ux, uy, vx, vy) {\r\n    var ta = Math.atan2(uy, ux),\r\n        tb = Math.atan2(vy, vx);\r\n    if (tb >= ta) {\r\n      return tb - ta;\r\n    }\r\n    else {\r\n      return 2 * Math.PI - (ta - tb);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draws arc\r\n   * @param {CanvasRenderingContext2D} ctx\r\n   * @param {Number} fx\r\n   * @param {Number} fy\r\n   * @param {Array} coords\r\n   */\r\n  fabric.util.drawArc = function(ctx, fx, fy, coords) {\r\n    var rx = coords[0],\r\n        ry = coords[1],\r\n        rot = coords[2],\r\n        large = coords[3],\r\n        sweep = coords[4],\r\n        tx = coords[5],\r\n        ty = coords[6],\r\n        segs = [[ ], [ ], [ ], [ ]],\r\n        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);\r\n\r\n    for (var i = 0, len = segsNorm.length; i < len; i++) {\r\n      segs[i][0] = segsNorm[i][0] + fx;\r\n      segs[i][1] = segsNorm[i][1] + fy;\r\n      segs[i][2] = segsNorm[i][2] + fx;\r\n      segs[i][3] = segsNorm[i][3] + fy;\r\n      segs[i][4] = segsNorm[i][4] + fx;\r\n      segs[i][5] = segsNorm[i][5] + fy;\r\n      ctx.bezierCurveTo.apply(ctx, segs[i]);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Calculate bounding box of a elliptic-arc\r\n   * @param {Number} fx start point of arc\r\n   * @param {Number} fy\r\n   * @param {Number} rx horizontal radius\r\n   * @param {Number} ry vertical radius\r\n   * @param {Number} rot angle of horizontal axe\r\n   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points\r\n   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction\r\n   * @param {Number} tx end point of arc\r\n   * @param {Number} ty\r\n   */\r\n  fabric.util.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {\r\n\r\n    var fromX = 0, fromY = 0, bound = [ ], bounds = [ ],\r\n    segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot),\r\n    boundCopy = [[ ], [ ]];\r\n\r\n    for (var i = 0, len = segs.length; i < len; i++) {\r\n      bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);\r\n      boundCopy[0].x = bound[0].x + fx;\r\n      boundCopy[0].y = bound[0].y + fy;\r\n      boundCopy[1].x = bound[1].x + fx;\r\n      boundCopy[1].y = bound[1].y + fy;\r\n      bounds.push(boundCopy[0]);\r\n      bounds.push(boundCopy[1]);\r\n      fromX = segs[i][4];\r\n      fromY = segs[i][5];\r\n    }\r\n    return bounds;\r\n  };\r\n\r\n  /**\r\n   * Calculate bounding box of a beziercurve\r\n   * @param {Number} x0 starting point\r\n   * @param {Number} y0\r\n   * @param {Number} x1 first control point\r\n   * @param {Number} y1\r\n   * @param {Number} x2 secondo control point\r\n   * @param {Number} y2\r\n   * @param {Number} x3 end of beizer\r\n   * @param {Number} y3\r\n   */\r\n  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.\r\n  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {\r\n    var argsString = _join.call(arguments);\r\n    if (boundsOfCurveCache[argsString]) {\r\n      return boundsOfCurveCache[argsString];\r\n    }\r\n\r\n    var sqrt = Math.sqrt,\r\n        min = Math.min, max = Math.max,\r\n        abs = Math.abs, tvalues = [ ],\r\n        bounds = [[ ], [ ]],\r\n        a, b, c, t, t1, t2, b2ac, sqrtb2ac;\r\n\r\n    b = 6 * x0 - 12 * x1 + 6 * x2;\r\n    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\r\n    c = 3 * x1 - 3 * x0;\r\n\r\n    for (var i = 0; i < 2; ++i) {\r\n      if (i > 0) {\r\n        b = 6 * y0 - 12 * y1 + 6 * y2;\r\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\r\n        c = 3 * y1 - 3 * y0;\r\n      }\r\n\r\n      if (abs(a) < 1e-12) {\r\n        if (abs(b) < 1e-12) {\r\n          continue;\r\n        }\r\n        t = -c / b;\r\n        if (0 < t && t < 1) {\r\n          tvalues.push(t);\r\n        }\r\n        continue;\r\n      }\r\n      b2ac = b * b - 4 * c * a;\r\n      if (b2ac < 0) {\r\n        continue;\r\n      }\r\n      sqrtb2ac = sqrt(b2ac);\r\n      t1 = (-b + sqrtb2ac) / (2 * a);\r\n      if (0 < t1 && t1 < 1) {\r\n        tvalues.push(t1);\r\n      }\r\n      t2 = (-b - sqrtb2ac) / (2 * a);\r\n      if (0 < t2 && t2 < 1) {\r\n        tvalues.push(t2);\r\n      }\r\n    }\r\n\r\n    var x, y, j = tvalues.length, jlen = j, mt;\r\n    while (j--) {\r\n      t = tvalues[j];\r\n      mt = 1 - t;\r\n      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\r\n      bounds[0][j] = x;\r\n\r\n      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\r\n      bounds[1][j] = y;\r\n    }\r\n\r\n    bounds[0][jlen] = x0;\r\n    bounds[1][jlen] = y0;\r\n    bounds[0][jlen + 1] = x3;\r\n    bounds[1][jlen + 1] = y3;\r\n    var result = [\r\n      {\r\n        x: min.apply(null, bounds[0]),\r\n        y: min.apply(null, bounds[1])\r\n      },\r\n      {\r\n        x: max.apply(null, bounds[0]),\r\n        y: max.apply(null, bounds[1])\r\n      }\r\n    ];\r\n    boundsOfCurveCache[argsString] = result;\r\n    return result;\r\n  }\r\n\r\n  fabric.util.getBoundsOfCurve = getBoundsOfCurve;\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  var slice = Array.prototype.slice;\r\n\r\n  /* _ES5_COMPAT_START_ */\r\n\r\n  if (!Array.prototype.indexOf) {\r\n    /**\r\n     * Finds index of an element in an array\r\n     * @param {Any} searchElement\r\n     * @param {Number} [fromIndex]\r\n     * @return {Number}\r\n     */\r\n    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\r\n      if (this === void 0 || this === null) {\r\n        throw new TypeError();\r\n      }\r\n      var t = Object(this), len = t.length >>> 0;\r\n      if (len === 0) {\r\n        return -1;\r\n      }\r\n      var n = 0;\r\n      if (arguments.length > 0) {\r\n        n = Number(arguments[1]);\r\n        if (n !== n) { // shortcut for verifying if it's NaN\r\n          n = 0;\r\n        }\r\n        else if (n !== 0 && n !== Number.POSITIVE_INFINITY && n !== Number.NEGATIVE_INFINITY) {\r\n          n = (n > 0 || -1) * Math.floor(Math.abs(n));\r\n        }\r\n      }\r\n      if (n >= len) {\r\n        return -1;\r\n      }\r\n      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\r\n      for (; k < len; k++) {\r\n        if (k in t && t[k] === searchElement) {\r\n          return k;\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n  }\r\n\r\n  if (!Array.prototype.forEach) {\r\n    /**\r\n     * Iterates an array, invoking callback for each element\r\n     * @param {Function} fn Callback to invoke for each element\r\n     * @param {Object} [context] Context to invoke callback in\r\n     * @return {Array}\r\n     */\r\n    Array.prototype.forEach = function(fn, context) {\r\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\r\n        if (i in this) {\r\n          fn.call(context, this[i], i, this);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  if (!Array.prototype.map) {\r\n    /**\r\n     * Returns a result of iterating over an array, invoking callback for each element\r\n     * @param {Function} fn Callback to invoke for each element\r\n     * @param {Object} [context] Context to invoke callback in\r\n     * @return {Array}\r\n     */\r\n    Array.prototype.map = function(fn, context) {\r\n      var result = [ ];\r\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\r\n        if (i in this) {\r\n          result[i] = fn.call(context, this[i], i, this);\r\n        }\r\n      }\r\n      return result;\r\n    };\r\n  }\r\n\r\n  if (!Array.prototype.every) {\r\n    /**\r\n     * Returns true if a callback returns truthy value for all elements in an array\r\n     * @param {Function} fn Callback to invoke for each element\r\n     * @param {Object} [context] Context to invoke callback in\r\n     * @return {Boolean}\r\n     */\r\n    Array.prototype.every = function(fn, context) {\r\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\r\n        if (i in this && !fn.call(context, this[i], i, this)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n  }\r\n\r\n  if (!Array.prototype.some) {\r\n    /**\r\n     * Returns true if a callback returns truthy value for at least one element in an array\r\n     * @param {Function} fn Callback to invoke for each element\r\n     * @param {Object} [context] Context to invoke callback in\r\n     * @return {Boolean}\r\n     */\r\n    Array.prototype.some = function(fn, context) {\r\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\r\n        if (i in this && fn.call(context, this[i], i, this)) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n  }\r\n\r\n  if (!Array.prototype.filter) {\r\n    /**\r\n     * Returns the result of iterating over elements in an array\r\n     * @param {Function} fn Callback to invoke for each element\r\n     * @param {Object} [context] Context to invoke callback in\r\n     * @return {Array}\r\n     */\r\n    Array.prototype.filter = function(fn, context) {\r\n      var result = [ ], val;\r\n      for (var i = 0, len = this.length >>> 0; i < len; i++) {\r\n        if (i in this) {\r\n          val = this[i]; // in case fn mutates this\r\n          if (fn.call(context, val, i, this)) {\r\n            result.push(val);\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    };\r\n  }\r\n\r\n  if (!Array.prototype.reduce) {\r\n    /**\r\n     * Returns \"folded\" (reduced) result of iterating over elements in an array\r\n     * @param {Function} fn Callback to invoke for each element\r\n     * @param {Object} [initial] Object to use as the first argument to the first call of the callback\r\n     * @return {Any}\r\n     */\r\n    Array.prototype.reduce = function(fn /*, initial*/) {\r\n      var len = this.length >>> 0,\r\n          i = 0,\r\n          rv;\r\n\r\n      if (arguments.length > 1) {\r\n        rv = arguments[1];\r\n      }\r\n      else {\r\n        do {\r\n          if (i in this) {\r\n            rv = this[i++];\r\n            break;\r\n          }\r\n          // if array contains no values, no initial value to return\r\n          if (++i >= len) {\r\n            throw new TypeError();\r\n          }\r\n        }\r\n        while (true);\r\n      }\r\n      for (; i < len; i++) {\r\n        if (i in this) {\r\n          rv = fn.call(null, rv, this[i], i, this);\r\n        }\r\n      }\r\n      return rv;\r\n    };\r\n  }\r\n\r\n  /* _ES5_COMPAT_END_ */\r\n\r\n  /**\r\n   * Invokes method on all items in a given array\r\n   * @memberOf fabric.util.array\r\n   * @param {Array} array Array to iterate over\r\n   * @param {String} method Name of a method to invoke\r\n   * @return {Array}\r\n   */\r\n  function invoke(array, method) {\r\n    var args = slice.call(arguments, 2), result = [ ];\r\n    for (var i = 0, len = array.length; i < len; i++) {\r\n      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Finds maximum value in array (not necessarily \"first\" one)\r\n   * @memberOf fabric.util.array\r\n   * @param {Array} array Array to iterate over\r\n   * @param {String} byProperty\r\n   * @return {Any}\r\n   */\r\n  function max(array, byProperty) {\r\n    return find(array, byProperty, function(value1, value2) {\r\n      return value1 >= value2;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Finds minimum value in array (not necessarily \"first\" one)\r\n   * @memberOf fabric.util.array\r\n   * @param {Array} array Array to iterate over\r\n   * @param {String} byProperty\r\n   * @return {Any}\r\n   */\r\n  function min(array, byProperty) {\r\n    return find(array, byProperty, function(value1, value2) {\r\n      return value1 < value2;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function find(array, byProperty, condition) {\r\n    if (!array || array.length === 0) {\r\n      return;\r\n    }\r\n\r\n    var i = array.length - 1,\r\n        result = byProperty ? array[i][byProperty] : array[i];\r\n    if (byProperty) {\r\n      while (i--) {\r\n        if (condition(array[i][byProperty], result)) {\r\n          result = array[i][byProperty];\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      while (i--) {\r\n        if (condition(array[i], result)) {\r\n          result = array[i];\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * @namespace fabric.util.array\r\n   */\r\n  fabric.util.array = {\r\n    invoke: invoke,\r\n    min: min,\r\n    max: max\r\n  };\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  /**\r\n   * Copies all enumerable properties of one object to another\r\n   * @memberOf fabric.util.object\r\n   * @param {Object} destination Where to copy to\r\n   * @param {Object} source Where to copy from\r\n   * @return {Object}\r\n   */\r\n  function extend(destination, source) {\r\n    // JScript DontEnum bug is not taken care of\r\n    for (var property in source) {\r\n      destination[property] = source[property];\r\n    }\r\n    return destination;\r\n  }\r\n\r\n  /**\r\n   * Creates an empty object and copies all enumerable properties of another object to it\r\n   * @memberOf fabric.util.object\r\n   * @param {Object} object Object to clone\r\n   * @return {Object}\r\n   */\r\n  function clone(object) {\r\n    return extend({ }, object);\r\n  }\r\n\r\n  /** @namespace fabric.util.object */\r\n  fabric.util.object = {\r\n    extend: extend,\r\n    clone: clone\r\n  };\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  /* _ES5_COMPAT_START_ */\r\n  if (!String.prototype.trim) {\r\n    /**\r\n     * Trims a string (removing whitespace from the beginning and the end)\r\n     * @function external:String#trim\r\n     * @see <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/Trim\">String#trim on MDN</a>\r\n     */\r\n    String.prototype.trim = function () {\r\n      // this trim is not fully ES3 or ES5 compliant, but it should cover most cases for now\r\n      return this.replace(/^[\\s\\xA0]+/, '').replace(/[\\s\\xA0]+$/, '');\r\n    };\r\n  }\r\n  /* _ES5_COMPAT_END_ */\r\n\r\n  /**\r\n   * Camelizes a string\r\n   * @memberOf fabric.util.string\r\n   * @param {String} string String to camelize\r\n   * @return {String} Camelized version of a string\r\n   */\r\n  function camelize(string) {\r\n    return string.replace(/-+(.)?/g, function(match, character) {\r\n      return character ? character.toUpperCase() : '';\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Capitalizes a string\r\n   * @memberOf fabric.util.string\r\n   * @param {String} string String to capitalize\r\n   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized\r\n   * and other letters stay untouched, if false first letter is capitalized\r\n   * and other letters are converted to lowercase.\r\n   * @return {String} Capitalized version of a string\r\n   */\r\n  function capitalize(string, firstLetterOnly) {\r\n    return string.charAt(0).toUpperCase() +\r\n      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());\r\n  }\r\n\r\n  /**\r\n   * Escapes XML in a string\r\n   * @memberOf fabric.util.string\r\n   * @param {String} string String to escape\r\n   * @return {String} Escaped version of a string\r\n   */\r\n  function escapeXml(string) {\r\n    return string.replace(/&/g, '&amp;')\r\n       .replace(/\"/g, '&quot;')\r\n       .replace(/'/g, '&apos;')\r\n       .replace(/</g, '&lt;')\r\n       .replace(/>/g, '&gt;');\r\n  }\r\n\r\n  /**\r\n   * String utilities\r\n   * @namespace fabric.util.string\r\n   */\r\n  fabric.util.string = {\r\n    camelize: camelize,\r\n    capitalize: capitalize,\r\n    escapeXml: escapeXml\r\n  };\r\n}());\r\n\r\n\r\n/* _ES5_COMPAT_START_ */\r\n(function() {\r\n\r\n  var slice = Array.prototype.slice,\r\n      apply = Function.prototype.apply,\r\n      Dummy = function() { };\r\n\r\n  if (!Function.prototype.bind) {\r\n    /**\r\n     * Cross-browser approximation of ES5 Function.prototype.bind (not fully spec conforming)\r\n     * @see <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind\">Function#bind on MDN</a>\r\n     * @param {Object} thisArg Object to bind function to\r\n     * @param {Any[]} Values to pass to a bound function\r\n     * @return {Function}\r\n     */\r\n    Function.prototype.bind = function(thisArg) {\r\n      var _this = this, args = slice.call(arguments, 1), bound;\r\n      if (args.length) {\r\n        bound = function() {\r\n          return apply.call(_this, this instanceof Dummy ? this : thisArg, args.concat(slice.call(arguments)));\r\n        };\r\n      }\r\n      else {\r\n        /** @ignore */\r\n        bound = function() {\r\n          return apply.call(_this, this instanceof Dummy ? this : thisArg, arguments);\r\n        };\r\n      }\r\n      Dummy.prototype = this.prototype;\r\n      bound.prototype = new Dummy();\r\n\r\n      return bound;\r\n    };\r\n  }\r\n\r\n})();\r\n/* _ES5_COMPAT_END_ */\r\n\r\n\r\n(function() {\r\n\r\n  var slice = Array.prototype.slice, emptyFunction = function() { },\r\n\r\n      IS_DONTENUM_BUGGY = (function() {\r\n        for (var p in { toString: 1 }) {\r\n          if (p === 'toString') {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      })(),\r\n\r\n      /** @ignore */\r\n      addMethods = function(klass, source, parent) {\r\n        for (var property in source) {\r\n\r\n          if (property in klass.prototype &&\r\n              typeof klass.prototype[property] === 'function' &&\r\n              (source[property] + '').indexOf('callSuper') > -1) {\r\n\r\n            klass.prototype[property] = (function(property) {\r\n              return function() {\r\n\r\n                var superclass = this.constructor.superclass;\r\n                this.constructor.superclass = parent;\r\n                var returnValue = source[property].apply(this, arguments);\r\n                this.constructor.superclass = superclass;\r\n\r\n                if (property !== 'initialize') {\r\n                  return returnValue;\r\n                }\r\n              };\r\n            })(property);\r\n          }\r\n          else {\r\n            klass.prototype[property] = source[property];\r\n          }\r\n\r\n          if (IS_DONTENUM_BUGGY) {\r\n            if (source.toString !== Object.prototype.toString) {\r\n              klass.prototype.toString = source.toString;\r\n            }\r\n            if (source.valueOf !== Object.prototype.valueOf) {\r\n              klass.prototype.valueOf = source.valueOf;\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n  function Subclass() { }\r\n\r\n  function callSuper(methodName) {\r\n    var fn = this.constructor.superclass.prototype[methodName];\r\n    return (arguments.length > 1)\r\n      ? fn.apply(this, slice.call(arguments, 1))\r\n      : fn.call(this);\r\n  }\r\n\r\n  /**\r\n   * Helper for creation of \"classes\".\r\n   * @memberOf fabric.util\r\n   * @param {Function} [parent] optional \"Class\" to inherit from\r\n   * @param {Object} [properties] Properties shared by all instances of this class\r\n   *                  (be careful modifying objects defined here as this would affect all instances)\r\n   */\r\n  function createClass() {\r\n    var parent = null,\r\n        properties = slice.call(arguments, 0);\r\n\r\n    if (typeof properties[0] === 'function') {\r\n      parent = properties.shift();\r\n    }\r\n    function klass() {\r\n      this.initialize.apply(this, arguments);\r\n    }\r\n\r\n    klass.superclass = parent;\r\n    klass.subclasses = [ ];\r\n\r\n    if (parent) {\r\n      Subclass.prototype = parent.prototype;\r\n      klass.prototype = new Subclass();\r\n      parent.subclasses.push(klass);\r\n    }\r\n    for (var i = 0, length = properties.length; i < length; i++) {\r\n      addMethods(klass, properties[i], parent);\r\n    }\r\n    if (!klass.prototype.initialize) {\r\n      klass.prototype.initialize = emptyFunction;\r\n    }\r\n    klass.prototype.constructor = klass;\r\n    klass.prototype.callSuper = callSuper;\r\n    return klass;\r\n  }\r\n\r\n  fabric.util.createClass = createClass;\r\n})();\r\n\r\n\r\n(function () {\r\n\r\n  var unknown = 'unknown';\r\n\r\n  /* EVENT HANDLING */\r\n\r\n  function areHostMethods(object) {\r\n    var methodNames = Array.prototype.slice.call(arguments, 1),\r\n        t, i, len = methodNames.length;\r\n    for (i = 0; i < len; i++) {\r\n      t = typeof object[methodNames[i]];\r\n      if (!(/^(?:function|object|unknown)$/).test(t)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** @ignore */\r\n  var getElement,\r\n      setElement,\r\n      getUniqueId = (function () {\r\n        var uid = 0;\r\n        return function (element) {\r\n          return element.__uniqueID || (element.__uniqueID = 'uniqueID__' + uid++);\r\n        };\r\n      })();\r\n\r\n  (function () {\r\n    var elements = { };\r\n    /** @ignore */\r\n    getElement = function (uid) {\r\n      return elements[uid];\r\n    };\r\n    /** @ignore */\r\n    setElement = function (uid, element) {\r\n      elements[uid] = element;\r\n    };\r\n  })();\r\n\r\n  function createListener(uid, handler) {\r\n    return {\r\n      handler: handler,\r\n      wrappedHandler: createWrappedHandler(uid, handler)\r\n    };\r\n  }\r\n\r\n  function createWrappedHandler(uid, handler) {\r\n    return function (e) {\r\n      handler.call(getElement(uid), e || fabric.window.event);\r\n    };\r\n  }\r\n\r\n  function createDispatcher(uid, eventName) {\r\n    return function (e) {\r\n      if (handlers[uid] && handlers[uid][eventName]) {\r\n        var handlersForEvent = handlers[uid][eventName];\r\n        for (var i = 0, len = handlersForEvent.length; i < len; i++) {\r\n          handlersForEvent[i].call(this, e || fabric.window.event);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  var shouldUseAddListenerRemoveListener = (\r\n        areHostMethods(fabric.document.documentElement, 'addEventListener', 'removeEventListener') &&\r\n        areHostMethods(fabric.window, 'addEventListener', 'removeEventListener')),\r\n\r\n      shouldUseAttachEventDetachEvent = (\r\n        areHostMethods(fabric.document.documentElement, 'attachEvent', 'detachEvent') &&\r\n        areHostMethods(fabric.window, 'attachEvent', 'detachEvent')),\r\n\r\n      // IE branch\r\n      listeners = { },\r\n\r\n      // DOM L0 branch\r\n      handlers = { },\r\n\r\n      addListener, removeListener;\r\n\r\n  if (shouldUseAddListenerRemoveListener) {\r\n    /** @ignore */\r\n    addListener = function (element, eventName, handler) {\r\n      element.addEventListener(eventName, handler, false);\r\n    };\r\n    /** @ignore */\r\n    removeListener = function (element, eventName, handler) {\r\n      element.removeEventListener(eventName, handler, false);\r\n    };\r\n  }\r\n\r\n  else if (shouldUseAttachEventDetachEvent) {\r\n    /** @ignore */\r\n    addListener = function (element, eventName, handler) {\r\n      var uid = getUniqueId(element);\r\n      setElement(uid, element);\r\n      if (!listeners[uid]) {\r\n        listeners[uid] = { };\r\n      }\r\n      if (!listeners[uid][eventName]) {\r\n        listeners[uid][eventName] = [ ];\r\n\r\n      }\r\n      var listener = createListener(uid, handler);\r\n      listeners[uid][eventName].push(listener);\r\n      element.attachEvent('on' + eventName, listener.wrappedHandler);\r\n    };\r\n    /** @ignore */\r\n    removeListener = function (element, eventName, handler) {\r\n      var uid = getUniqueId(element), listener;\r\n      if (listeners[uid] && listeners[uid][eventName]) {\r\n        for (var i = 0, len = listeners[uid][eventName].length; i < len; i++) {\r\n          listener = listeners[uid][eventName][i];\r\n          if (listener && listener.handler === handler) {\r\n            element.detachEvent('on' + eventName, listener.wrappedHandler);\r\n            listeners[uid][eventName][i] = null;\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n  else {\r\n    /** @ignore */\r\n    addListener = function (element, eventName, handler) {\r\n      var uid = getUniqueId(element);\r\n      if (!handlers[uid]) {\r\n        handlers[uid] = { };\r\n      }\r\n      if (!handlers[uid][eventName]) {\r\n        handlers[uid][eventName] = [ ];\r\n        var existingHandler = element['on' + eventName];\r\n        if (existingHandler) {\r\n          handlers[uid][eventName].push(existingHandler);\r\n        }\r\n        element['on' + eventName] = createDispatcher(uid, eventName);\r\n      }\r\n      handlers[uid][eventName].push(handler);\r\n    };\r\n    /** @ignore */\r\n    removeListener = function (element, eventName, handler) {\r\n      var uid = getUniqueId(element);\r\n      if (handlers[uid] && handlers[uid][eventName]) {\r\n        var handlersForEvent = handlers[uid][eventName];\r\n        for (var i = 0, len = handlersForEvent.length; i < len; i++) {\r\n          if (handlersForEvent[i] === handler) {\r\n            handlersForEvent.splice(i, 1);\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Adds an event listener to an element\r\n   * @function\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element\r\n   * @param {String} eventName\r\n   * @param {Function} handler\r\n   */\r\n  fabric.util.addListener = addListener;\r\n\r\n  /**\r\n   * Removes an event listener from an element\r\n   * @function\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element\r\n   * @param {String} eventName\r\n   * @param {Function} handler\r\n   */\r\n  fabric.util.removeListener = removeListener;\r\n\r\n  /**\r\n   * Cross-browser wrapper for getting event's coordinates\r\n   * @memberOf fabric.util\r\n   * @param {Event} event Event object\r\n   */\r\n  function getPointer(event) {\r\n    event || (event = fabric.window.event);\r\n\r\n    var element = event.target ||\r\n                  (typeof event.srcElement !== unknown ? event.srcElement : null),\r\n\r\n        scroll = fabric.util.getScrollLeftTop(element);\r\n\r\n    return {\r\n      x: pointerX(event) + scroll.left,\r\n      y: pointerY(event) + scroll.top\r\n    };\r\n  }\r\n\r\n  var pointerX = function(event) {\r\n    // looks like in IE (<9) clientX at certain point (apparently when mouseup fires on VML element)\r\n    // is represented as COM object, with all the consequences, like \"unknown\" type and error on [[Get]]\r\n    // need to investigate later\r\n    return (typeof event.clientX !== unknown ? event.clientX : 0);\r\n  },\r\n\r\n  pointerY = function(event) {\r\n    return (typeof event.clientY !== unknown ? event.clientY : 0);\r\n  };\r\n\r\n  function _getPointer(event, pageProp, clientProp) {\r\n    var touchProp = event.type === 'touchend' ? 'changedTouches' : 'touches';\r\n\r\n    return (event[touchProp] && event[touchProp][0]\r\n      ? (event[touchProp][0][pageProp] - (event[touchProp][0][pageProp] - event[touchProp][0][clientProp]))\r\n        || event[clientProp]\r\n      : event[clientProp]);\r\n  }\r\n\r\n  if (fabric.isTouchSupported) {\r\n    pointerX = function(event) {\r\n      return _getPointer(event, 'pageX', 'clientX');\r\n    };\r\n    pointerY = function(event) {\r\n      return _getPointer(event, 'pageY', 'clientY');\r\n    };\r\n  }\r\n\r\n  fabric.util.getPointer = getPointer;\r\n\r\n  fabric.util.object.extend(fabric.util, fabric.Observable);\r\n\r\n})();\r\n\r\n\r\n(function () {\r\n\r\n  /**\r\n   * Cross-browser wrapper for setting element's style\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element\r\n   * @param {Object} styles\r\n   * @return {HTMLElement} Element that was passed as a first argument\r\n   */\r\n  function setStyle(element, styles) {\r\n    var elementStyle = element.style;\r\n    if (!elementStyle) {\r\n      return element;\r\n    }\r\n    if (typeof styles === 'string') {\r\n      element.style.cssText += ';' + styles;\r\n      return styles.indexOf('opacity') > -1\r\n        ? setOpacity(element, styles.match(/opacity:\\s*(\\d?\\.?\\d*)/)[1])\r\n        : element;\r\n    }\r\n    for (var property in styles) {\r\n      if (property === 'opacity') {\r\n        setOpacity(element, styles[property]);\r\n      }\r\n      else {\r\n        var normalizedProperty = (property === 'float' || property === 'cssFloat')\r\n          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')\r\n          : property;\r\n        elementStyle[normalizedProperty] = styles[property];\r\n      }\r\n    }\r\n    return element;\r\n  }\r\n\r\n  var parseEl = fabric.document.createElement('div'),\r\n      supportsOpacity = typeof parseEl.style.opacity === 'string',\r\n      supportsFilters = typeof parseEl.style.filter === 'string',\r\n      reOpacity = /alpha\\s*\\(\\s*opacity\\s*=\\s*([^\\)]+)\\)/,\r\n\r\n      /** @ignore */\r\n      setOpacity = function (element) { return element; };\r\n\r\n  if (supportsOpacity) {\r\n    /** @ignore */\r\n    setOpacity = function(element, value) {\r\n      element.style.opacity = value;\r\n      return element;\r\n    };\r\n  }\r\n  else if (supportsFilters) {\r\n    /** @ignore */\r\n    setOpacity = function(element, value) {\r\n      var es = element.style;\r\n      if (element.currentStyle && !element.currentStyle.hasLayout) {\r\n        es.zoom = 1;\r\n      }\r\n      if (reOpacity.test(es.filter)) {\r\n        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');\r\n        es.filter = es.filter.replace(reOpacity, value);\r\n      }\r\n      else {\r\n        es.filter += ' alpha(opacity=' + (value * 100) + ')';\r\n      }\r\n      return element;\r\n    };\r\n  }\r\n\r\n  fabric.util.setStyle = setStyle;\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  var _slice = Array.prototype.slice;\r\n\r\n  /**\r\n   * Takes id and returns an element with that id (if one exists in a document)\r\n   * @memberOf fabric.util\r\n   * @param {String|HTMLElement} id\r\n   * @return {HTMLElement|null}\r\n   */\r\n  function getById(id) {\r\n    return typeof id === 'string' ? fabric.document.getElementById(id) : id;\r\n  }\r\n\r\n  var sliceCanConvertNodelists,\r\n      /**\r\n       * Converts an array-like object (e.g. arguments or NodeList) to an array\r\n       * @memberOf fabric.util\r\n       * @param {Object} arrayLike\r\n       * @return {Array}\r\n       */\r\n      toArray = function(arrayLike) {\r\n        return _slice.call(arrayLike, 0);\r\n      };\r\n\r\n  try {\r\n    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;\r\n  }\r\n  catch (err) { }\r\n\r\n  if (!sliceCanConvertNodelists) {\r\n    toArray = function(arrayLike) {\r\n      var arr = new Array(arrayLike.length), i = arrayLike.length;\r\n      while (i--) {\r\n        arr[i] = arrayLike[i];\r\n      }\r\n      return arr;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Creates specified element with specified attributes\r\n   * @memberOf fabric.util\r\n   * @param {String} tagName Type of an element to create\r\n   * @param {Object} [attributes] Attributes to set on an element\r\n   * @return {HTMLElement} Newly created element\r\n   */\r\n  function makeElement(tagName, attributes) {\r\n    var el = fabric.document.createElement(tagName);\r\n    for (var prop in attributes) {\r\n      if (prop === 'class') {\r\n        el.className = attributes[prop];\r\n      }\r\n      else if (prop === 'for') {\r\n        el.htmlFor = attributes[prop];\r\n      }\r\n      else {\r\n        el.setAttribute(prop, attributes[prop]);\r\n      }\r\n    }\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Adds class to an element\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element Element to add class to\r\n   * @param {String} className Class to add to an element\r\n   */\r\n  function addClass(element, className) {\r\n    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {\r\n      element.className += (element.className ? ' ' : '') + className;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Wraps element with another element\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element Element to wrap\r\n   * @param {HTMLElement|String} wrapper Element to wrap with\r\n   * @param {Object} [attributes] Attributes to set on a wrapper\r\n   * @return {HTMLElement} wrapper\r\n   */\r\n  function wrapElement(element, wrapper, attributes) {\r\n    if (typeof wrapper === 'string') {\r\n      wrapper = makeElement(wrapper, attributes);\r\n    }\r\n    if (element.parentNode) {\r\n      element.parentNode.replaceChild(wrapper, element);\r\n    }\r\n    wrapper.appendChild(element);\r\n    return wrapper;\r\n  }\r\n\r\n  /**\r\n   * Returns element scroll offsets\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element Element to operate on\r\n   * @return {Object} Object with left/top values\r\n   */\r\n  function getScrollLeftTop(element) {\r\n\r\n    var left = 0,\r\n        top = 0,\r\n        docElement = fabric.document.documentElement,\r\n        body = fabric.document.body || {\r\n          scrollLeft: 0, scrollTop: 0\r\n        };\r\n\r\n    while (element && element.parentNode) {\r\n\r\n      element = element.parentNode;\r\n\r\n      if (element === fabric.document) {\r\n        left = body.scrollLeft || docElement.scrollLeft || 0;\r\n        top = body.scrollTop ||  docElement.scrollTop || 0;\r\n      }\r\n      else {\r\n        left += element.scrollLeft || 0;\r\n        top += element.scrollTop || 0;\r\n      }\r\n\r\n      if (element.nodeType === 1 &&\r\n          fabric.util.getElementStyle(element, 'position') === 'fixed') {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return { left: left, top: top };\r\n  }\r\n\r\n  /**\r\n   * Returns offset for a given element\r\n   * @function\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element Element to get offset for\r\n   * @return {Object} Object with \"left\" and \"top\" properties\r\n   */\r\n  function getElementOffset(element) {\r\n    var docElem,\r\n        doc = element && element.ownerDocument,\r\n        box = { left: 0, top: 0 },\r\n        offset = { left: 0, top: 0 },\r\n        scrollLeftTop,\r\n        offsetAttributes = {\r\n          borderLeftWidth: 'left',\r\n          borderTopWidth:  'top',\r\n          paddingLeft:     'left',\r\n          paddingTop:      'top'\r\n        };\r\n\r\n    if (!doc) {\r\n      return offset;\r\n    }\r\n\r\n    for (var attr in offsetAttributes) {\r\n      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;\r\n    }\r\n\r\n    docElem = doc.documentElement;\r\n    if ( typeof element.getBoundingClientRect !== 'undefined' ) {\r\n      box = element.getBoundingClientRect();\r\n    }\r\n\r\n    scrollLeftTop = getScrollLeftTop(element);\r\n\r\n    return {\r\n      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,\r\n      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Returns style attribute value of a given element\r\n   * @memberOf fabric.util\r\n   * @param {HTMLElement} element Element to get style attribute for\r\n   * @param {String} attr Style attribute to get for element\r\n   * @return {String} Style attribute value of the given element.\r\n   */\r\n  var getElementStyle;\r\n  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {\r\n    getElementStyle = function(element, attr) {\r\n      var style = fabric.document.defaultView.getComputedStyle(element, null);\r\n      return style ? style[attr] : undefined;\r\n    };\r\n  }\r\n  else {\r\n    getElementStyle = function(element, attr) {\r\n      var value = element.style[attr];\r\n      if (!value && element.currentStyle) {\r\n        value = element.currentStyle[attr];\r\n      }\r\n      return value;\r\n    };\r\n  }\r\n\r\n  (function () {\r\n    var style = fabric.document.documentElement.style,\r\n        selectProp = 'userSelect' in style\r\n          ? 'userSelect'\r\n          : 'MozUserSelect' in style\r\n            ? 'MozUserSelect'\r\n            : 'WebkitUserSelect' in style\r\n              ? 'WebkitUserSelect'\r\n              : 'KhtmlUserSelect' in style\r\n                ? 'KhtmlUserSelect'\r\n                : '';\r\n\r\n    /**\r\n     * Makes element unselectable\r\n     * @memberOf fabric.util\r\n     * @param {HTMLElement} element Element to make unselectable\r\n     * @return {HTMLElement} Element that was passed in\r\n     */\r\n    function makeElementUnselectable(element) {\r\n      if (typeof element.onselectstart !== 'undefined') {\r\n        element.onselectstart = fabric.util.falseFunction;\r\n      }\r\n      if (selectProp) {\r\n        element.style[selectProp] = 'none';\r\n      }\r\n      else if (typeof element.unselectable === 'string') {\r\n        element.unselectable = 'on';\r\n      }\r\n      return element;\r\n    }\r\n\r\n    /**\r\n     * Makes element selectable\r\n     * @memberOf fabric.util\r\n     * @param {HTMLElement} element Element to make selectable\r\n     * @return {HTMLElement} Element that was passed in\r\n     */\r\n    function makeElementSelectable(element) {\r\n      if (typeof element.onselectstart !== 'undefined') {\r\n        element.onselectstart = null;\r\n      }\r\n      if (selectProp) {\r\n        element.style[selectProp] = '';\r\n      }\r\n      else if (typeof element.unselectable === 'string') {\r\n        element.unselectable = '';\r\n      }\r\n      return element;\r\n    }\r\n\r\n    fabric.util.makeElementUnselectable = makeElementUnselectable;\r\n    fabric.util.makeElementSelectable = makeElementSelectable;\r\n  })();\r\n\r\n  (function() {\r\n\r\n    /**\r\n     * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading\r\n     * @memberOf fabric.util\r\n     * @param {String} url URL of a script to load\r\n     * @param {Function} callback Callback to execute when script is finished loading\r\n     */\r\n    function getScript(url, callback) {\r\n      var headEl = fabric.document.getElementsByTagName('head')[0],\r\n          scriptEl = fabric.document.createElement('script'),\r\n          loading = true;\r\n\r\n      /** @ignore */\r\n      scriptEl.onload = /** @ignore */ scriptEl.onreadystatechange = function(e) {\r\n        if (loading) {\r\n          if (typeof this.readyState === 'string' &&\r\n              this.readyState !== 'loaded' &&\r\n              this.readyState !== 'complete') {\r\n            return;\r\n          }\r\n          loading = false;\r\n          callback(e || fabric.window.event);\r\n          scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;\r\n        }\r\n      };\r\n      scriptEl.src = url;\r\n      headEl.appendChild(scriptEl);\r\n      // causes issue in Opera\r\n      // headEl.removeChild(scriptEl);\r\n    }\r\n\r\n    fabric.util.getScript = getScript;\r\n  })();\r\n\r\n  fabric.util.getById = getById;\r\n  fabric.util.toArray = toArray;\r\n  fabric.util.makeElement = makeElement;\r\n  fabric.util.addClass = addClass;\r\n  fabric.util.wrapElement = wrapElement;\r\n  fabric.util.getScrollLeftTop = getScrollLeftTop;\r\n  fabric.util.getElementOffset = getElementOffset;\r\n  fabric.util.getElementStyle = getElementStyle;\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  function addParamToUrl(url, param) {\r\n    return url + (/\\?/.test(url) ? '&' : '?') + param;\r\n  }\r\n\r\n  var makeXHR = (function() {\r\n    var factories = [\r\n      function() { return new ActiveXObject('Microsoft.XMLHTTP'); },\r\n      function() { return new ActiveXObject('Msxml2.XMLHTTP'); },\r\n      function() { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); },\r\n      function() { return new XMLHttpRequest(); }\r\n    ];\r\n    for (var i = factories.length; i--; ) {\r\n      try {\r\n        var req = factories[i]();\r\n        if (req) {\r\n          return factories[i];\r\n        }\r\n      }\r\n      catch (err) { }\r\n    }\r\n  })();\r\n\r\n  function emptyFn() { }\r\n\r\n  /**\r\n   * Cross-browser abstraction for sending XMLHttpRequest\r\n   * @memberOf fabric.util\r\n   * @param {String} url URL to send XMLHttpRequest to\r\n   * @param {Object} [options] Options object\r\n   * @param {String} [options.method=\"GET\"]\r\n   * @param {Function} options.onComplete Callback to invoke when request is completed\r\n   * @return {XMLHttpRequest} request\r\n   */\r\n  function request(url, options) {\r\n\r\n    options || (options = { });\r\n\r\n    var method = options.method ? options.method.toUpperCase() : 'GET',\r\n        onComplete = options.onComplete || function() { },\r\n        xhr = makeXHR(),\r\n        body;\r\n\r\n    /** @ignore */\r\n    xhr.onreadystatechange = function() {\r\n      if (xhr.readyState === 4) {\r\n        onComplete(xhr);\r\n        xhr.onreadystatechange = emptyFn;\r\n      }\r\n    };\r\n\r\n    if (method === 'GET') {\r\n      body = null;\r\n      if (typeof options.parameters === 'string') {\r\n        url = addParamToUrl(url, options.parameters);\r\n      }\r\n    }\r\n\r\n    xhr.open(method, url, true);\r\n\r\n    if (method === 'POST' || method === 'PUT') {\r\n      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\r\n    }\r\n\r\n    xhr.send(body);\r\n    return xhr;\r\n  }\r\n\r\n  fabric.util.request = request;\r\n})();\r\n\r\n\r\n/**\r\n * Wrapper around `console.log` (when available)\r\n * @param {Any} [values] Values to log\r\n */\r\nfabric.log = function() { };\r\n\r\n/**\r\n * Wrapper around `console.warn` (when available)\r\n * @param {Any} [values] Values to log as a warning\r\n */\r\nfabric.warn = function() { };\r\n\r\n/* jshint ignore:start */\r\nif (typeof console !== 'undefined') {\r\n\r\n  ['log', 'warn'].forEach(function(methodName) {\r\n\r\n    if (typeof console[methodName] !== 'undefined' &&\r\n        typeof console[methodName].apply === 'function') {\r\n\r\n      fabric[methodName] = function() {\r\n        return console[methodName].apply(console, arguments);\r\n      };\r\n    }\r\n  });\r\n}\r\n/* jshint ignore:end */\r\n\r\n\r\n(function() {\r\n\r\n  /**\r\n   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.\r\n   * @memberOf fabric.util\r\n   * @param {Object} [options] Animation options\r\n   * @param {Function} [options.onChange] Callback; invoked on every value change\r\n   * @param {Function} [options.onComplete] Callback; invoked when value change is completed\r\n   * @param {Number} [options.startValue=0] Starting value\r\n   * @param {Number} [options.endValue=100] Ending value\r\n   * @param {Number} [options.byValue=100] Value to modify the property by\r\n   * @param {Function} [options.easing] Easing function\r\n   * @param {Number} [options.duration=500] Duration of change (in ms)\r\n   */\r\n  function animate(options) {\r\n\r\n    requestAnimFrame(function(timestamp) {\r\n      options || (options = { });\r\n\r\n      var start = timestamp || +new Date(),\r\n          duration = options.duration || 500,\r\n          finish = start + duration, time,\r\n          onChange = options.onChange || function() { },\r\n          abort = options.abort || function() { return false; },\r\n          easing = options.easing || function(t, b, c, d) {return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;},\r\n          startValue = 'startValue' in options ? options.startValue : 0,\r\n          endValue = 'endValue' in options ? options.endValue : 100,\r\n          byValue = options.byValue || endValue - startValue;\r\n\r\n      options.onStart && options.onStart();\r\n\r\n      (function tick(ticktime) {\r\n        time = ticktime || +new Date();\r\n        var currentTime = time > finish ? duration : (time - start);\r\n        if (abort()) {\r\n          options.onComplete && options.onComplete();\r\n          return;\r\n        }\r\n        onChange(easing(currentTime, startValue, byValue, duration));\r\n        if (time > finish) {\r\n          options.onComplete && options.onComplete();\r\n          return;\r\n        }\r\n        requestAnimFrame(tick);\r\n      })(start);\r\n    });\r\n\r\n  }\r\n\r\n  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||\r\n                          fabric.window.webkitRequestAnimationFrame ||\r\n                          fabric.window.mozRequestAnimationFrame    ||\r\n                          fabric.window.oRequestAnimationFrame      ||\r\n                          fabric.window.msRequestAnimationFrame     ||\r\n                          function(callback) {\r\n                            fabric.window.setTimeout(callback, 1000 / 60);\r\n                          };\r\n\r\n  /**\r\n   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method\r\n   * @memberOf fabric.util\r\n   * @param {Function} callback Callback to invoke\r\n   * @param {DOMElement} element optional Element to associate with animation\r\n   */\r\n  function requestAnimFrame() {\r\n    return _requestAnimFrame.apply(fabric.window, arguments);\r\n  }\r\n\r\n  fabric.util.animate = animate;\r\n  fabric.util.requestAnimFrame = requestAnimFrame;\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  function normalize(a, c, p, s) {\r\n    if (a < Math.abs(c)) {\r\n      a = c;\r\n      s = p / 4;\r\n    }\r\n    else {\r\n      s = p / (2 * Math.PI) * Math.asin(c / a);\r\n    }\r\n    return { a: a, c: c, p: p, s: s };\r\n  }\r\n\r\n  function elastic(opts, t, d) {\r\n    return opts.a *\r\n      Math.pow(2, 10 * (t -= 1)) *\r\n      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );\r\n  }\r\n\r\n  /**\r\n   * Cubic easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutCubic(t, b, c, d) {\r\n    return c * ((t = t / d - 1) * t * t + 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Cubic easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutCubic(t, b, c, d) {\r\n    t /= d/2;\r\n    if (t < 1) {\r\n      return c / 2 * t * t * t + b;\r\n    }\r\n    return c / 2 * ((t -= 2) * t * t + 2) + b;\r\n  }\r\n\r\n  /**\r\n   * Quartic easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInQuart(t, b, c, d) {\r\n    return c * (t /= d) * t * t * t + b;\r\n  }\r\n\r\n  /**\r\n   * Quartic easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutQuart(t, b, c, d) {\r\n    return -c * ((t = t / d - 1) * t * t * t - 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Quartic easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutQuart(t, b, c, d) {\r\n    t /= d / 2;\r\n    if (t < 1) {\r\n      return c / 2 * t * t * t * t + b;\r\n    }\r\n    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\r\n  }\r\n\r\n  /**\r\n   * Quintic easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInQuint(t, b, c, d) {\r\n    return c * (t /= d) * t * t * t * t + b;\r\n  }\r\n\r\n  /**\r\n   * Quintic easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutQuint(t, b, c, d) {\r\n    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Quintic easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutQuint(t, b, c, d) {\r\n    t /= d / 2;\r\n    if (t < 1) {\r\n      return c / 2 * t * t * t * t * t + b;\r\n    }\r\n    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\r\n  }\r\n\r\n  /**\r\n   * Sinusoidal easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInSine(t, b, c, d) {\r\n    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\r\n  }\r\n\r\n  /**\r\n   * Sinusoidal easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutSine(t, b, c, d) {\r\n    return c * Math.sin(t / d * (Math.PI / 2)) + b;\r\n  }\r\n\r\n  /**\r\n   * Sinusoidal easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutSine(t, b, c, d) {\r\n    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Exponential easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInExpo(t, b, c, d) {\r\n    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\r\n  }\r\n\r\n  /**\r\n   * Exponential easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutExpo(t, b, c, d) {\r\n    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Exponential easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutExpo(t, b, c, d) {\r\n    if (t === 0) {\r\n      return b;\r\n    }\r\n    if (t === d) {\r\n      return b + c;\r\n    }\r\n    t /= d / 2;\r\n    if (t < 1) {\r\n      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\r\n    }\r\n    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\r\n  }\r\n\r\n  /**\r\n   * Circular easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInCirc(t, b, c, d) {\r\n    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Circular easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutCirc(t, b, c, d) {\r\n    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\r\n  }\r\n\r\n  /**\r\n   * Circular easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutCirc(t, b, c, d) {\r\n    t /= d / 2;\r\n    if (t < 1) {\r\n      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\r\n    }\r\n    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Elastic easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInElastic(t, b, c, d) {\r\n    var s = 1.70158, p = 0, a = c;\r\n    if (t === 0) {\r\n      return b;\r\n    }\r\n    t /= d;\r\n    if (t === 1) {\r\n      return b + c;\r\n    }\r\n    if (!p) {\r\n      p = d * 0.3;\r\n    }\r\n    var opts = normalize(a, c, p, s);\r\n    return -elastic(opts, t, d) + b;\r\n  }\r\n\r\n  /**\r\n   * Elastic easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutElastic(t, b, c, d) {\r\n    var s = 1.70158, p = 0, a = c;\r\n    if (t === 0) {\r\n      return b;\r\n    }\r\n    t /= d;\r\n    if (t === 1) {\r\n      return b + c;\r\n    }\r\n    if (!p) {\r\n      p = d * 0.3;\r\n    }\r\n    var opts = normalize(a, c, p, s);\r\n    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;\r\n  }\r\n\r\n  /**\r\n   * Elastic easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutElastic(t, b, c, d) {\r\n    var s = 1.70158, p = 0, a = c;\r\n    if (t === 0) {\r\n      return b;\r\n    }\r\n    t /= d / 2;\r\n    if (t === 2) {\r\n      return b + c;\r\n    }\r\n    if (!p) {\r\n      p = d * (0.3 * 1.5);\r\n    }\r\n    var opts = normalize(a, c, p, s);\r\n    if (t < 1) {\r\n      return -0.5 * elastic(opts, t, d) + b;\r\n    }\r\n    return opts.a * Math.pow(2, -10 * (t -= 1)) *\r\n      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;\r\n  }\r\n\r\n  /**\r\n   * Backwards easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInBack(t, b, c, d, s) {\r\n    if (s === undefined) {\r\n      s = 1.70158;\r\n    }\r\n    return c * (t /= d) * t * ((s + 1) * t - s) + b;\r\n  }\r\n\r\n  /**\r\n   * Backwards easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutBack(t, b, c, d, s) {\r\n    if (s === undefined) {\r\n      s = 1.70158;\r\n    }\r\n    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\r\n  }\r\n\r\n  /**\r\n   * Backwards easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutBack(t, b, c, d, s) {\r\n    if (s === undefined) {\r\n      s = 1.70158;\r\n    }\r\n    t /= d / 2;\r\n    if (t < 1) {\r\n      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;\r\n    }\r\n    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\r\n  }\r\n\r\n  /**\r\n   * Bouncing easing in\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInBounce(t, b, c, d) {\r\n    return c - easeOutBounce (d - t, 0, c, d) + b;\r\n  }\r\n\r\n  /**\r\n   * Bouncing easing out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeOutBounce(t, b, c, d) {\r\n    if ((t /= d) < (1 / 2.75)) {\r\n      return c * (7.5625 * t * t) + b;\r\n    }\r\n    else if (t < (2/2.75)) {\r\n      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;\r\n    }\r\n    else if (t < (2.5/2.75)) {\r\n      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;\r\n    }\r\n    else {\r\n      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bouncing easing in and out\r\n   * @memberOf fabric.util.ease\r\n   */\r\n  function easeInOutBounce(t, b, c, d) {\r\n    if (t < d / 2) {\r\n      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;\r\n    }\r\n    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;\r\n  }\r\n\r\n  /**\r\n   * Easing functions\r\n   * See <a href=\"http://gizma.com/easing/\">Easing Equations by Robert Penner</a>\r\n   * @namespace fabric.util.ease\r\n   */\r\n  fabric.util.ease = {\r\n\r\n    /**\r\n     * Quadratic easing in\r\n     * @memberOf fabric.util.ease\r\n     */\r\n    easeInQuad: function(t, b, c, d) {\r\n      return c * (t /= d) * t + b;\r\n    },\r\n\r\n    /**\r\n     * Quadratic easing out\r\n     * @memberOf fabric.util.ease\r\n     */\r\n    easeOutQuad: function(t, b, c, d) {\r\n      return -c * (t /= d) * (t - 2) + b;\r\n    },\r\n\r\n    /**\r\n     * Quadratic easing in and out\r\n     * @memberOf fabric.util.ease\r\n     */\r\n    easeInOutQuad: function(t, b, c, d) {\r\n      t /= (d / 2);\r\n      if (t < 1) {\r\n        return c / 2 * t * t + b;\r\n      }\r\n      return -c / 2 * ((--t) * (t - 2) - 1) + b;\r\n    },\r\n\r\n    /**\r\n     * Cubic easing in\r\n     * @memberOf fabric.util.ease\r\n     */\r\n    easeInCubic: function(t, b, c, d) {\r\n      return c * (t /= d) * t * t + b;\r\n    },\r\n\r\n    easeOutCubic: easeOutCubic,\r\n    easeInOutCubic: easeInOutCubic,\r\n    easeInQuart: easeInQuart,\r\n    easeOutQuart: easeOutQuart,\r\n    easeInOutQuart: easeInOutQuart,\r\n    easeInQuint: easeInQuint,\r\n    easeOutQuint: easeOutQuint,\r\n    easeInOutQuint: easeInOutQuint,\r\n    easeInSine: easeInSine,\r\n    easeOutSine: easeOutSine,\r\n    easeInOutSine: easeInOutSine,\r\n    easeInExpo: easeInExpo,\r\n    easeOutExpo: easeOutExpo,\r\n    easeInOutExpo: easeInOutExpo,\r\n    easeInCirc: easeInCirc,\r\n    easeOutCirc: easeOutCirc,\r\n    easeInOutCirc: easeInOutCirc,\r\n    easeInElastic: easeInElastic,\r\n    easeOutElastic: easeOutElastic,\r\n    easeInOutElastic: easeInOutElastic,\r\n    easeInBack: easeInBack,\r\n    easeOutBack: easeOutBack,\r\n    easeInOutBack: easeInOutBack,\r\n    easeInBounce: easeInBounce,\r\n    easeOutBounce: easeOutBounce,\r\n    easeInOutBounce: easeInOutBounce\r\n  };\r\n\r\n}());\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  /**\r\n   * @name fabric\r\n   * @namespace\r\n   */\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      capitalize = fabric.util.string.capitalize,\r\n      clone = fabric.util.object.clone,\r\n      toFixed = fabric.util.toFixed,\r\n      parseUnit = fabric.util.parseUnit,\r\n      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,\r\n\r\n      reAllowedSVGTagNames = /^(path|circle|polygon|polyline|ellipse|rect|line|image|text)$/i,\r\n      reViewBoxTagNames = /^(symbol|image|marker|pattern|view|svg)$/i,\r\n      reNotAllowedAncestors = /^(?:pattern|defs|symbol|metadata)$/i,\r\n      reAllowedParents = /^(symbol|g|a|svg)$/i,\r\n\r\n      attributesMap = {\r\n        cx:                   'left',\r\n        x:                    'left',\r\n        r:                    'radius',\r\n        cy:                   'top',\r\n        y:                    'top',\r\n        display:              'visible',\r\n        visibility:           'visible',\r\n        transform:            'transformMatrix',\r\n        'fill-opacity':       'fillOpacity',\r\n        'fill-rule':          'fillRule',\r\n        'font-family':        'fontFamily',\r\n        'font-size':          'fontSize',\r\n        'font-style':         'fontStyle',\r\n        'font-weight':        'fontWeight',\r\n        'stroke-dasharray':   'strokeDashArray',\r\n        'stroke-linecap':     'strokeLineCap',\r\n        'stroke-linejoin':    'strokeLineJoin',\r\n        'stroke-miterlimit':  'strokeMiterLimit',\r\n        'stroke-opacity':     'strokeOpacity',\r\n        'stroke-width':       'strokeWidth',\r\n        'text-decoration':    'textDecoration',\r\n        'text-anchor':        'originX'\r\n      },\r\n\r\n      colorAttributes = {\r\n        stroke: 'strokeOpacity',\r\n        fill:   'fillOpacity'\r\n      };\r\n\r\n  fabric.cssRules = { };\r\n  fabric.gradientDefs = { };\r\n\r\n  function normalizeAttr(attr) {\r\n    // transform attribute names\r\n    if (attr in attributesMap) {\r\n      return attributesMap[attr];\r\n    }\r\n    return attr;\r\n  }\r\n\r\n  function normalizeValue(attr, value, parentAttributes, fontSize) {\r\n    var isArray = Object.prototype.toString.call(value) === '[object Array]',\r\n        parsed;\r\n\r\n    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {\r\n      value = '';\r\n    }\r\n    else if (attr === 'strokeDashArray') {\r\n      value = value.replace(/,/g, ' ').split(/\\s+/).map(function(n) {\r\n        return parseFloat(n);\r\n      });\r\n    }\r\n    else if (attr === 'transformMatrix') {\r\n      if (parentAttributes && parentAttributes.transformMatrix) {\r\n        value = multiplyTransformMatrices(\r\n          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));\r\n      }\r\n      else {\r\n        value = fabric.parseTransformAttribute(value);\r\n      }\r\n    }\r\n    else if (attr === 'visible') {\r\n      value = (value === 'none' || value === 'hidden') ? false : true;\r\n      // display=none on parent element always takes precedence over child element\r\n      if (parentAttributes && parentAttributes.visible === false) {\r\n        value = false;\r\n      }\r\n    }\r\n    else if (attr === 'originX' /* text-anchor */) {\r\n      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';\r\n    }\r\n    else {\r\n      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);\r\n    }\r\n\r\n    return (!isArray && isNaN(parsed) ? value : parsed);\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @param {Object} attributes Array of attributes to parse\r\n   */\r\n  function _setStrokeFillOpacity(attributes) {\r\n    for (var attr in colorAttributes) {\r\n\r\n      if (!attributes[attr] || typeof attributes[colorAttributes[attr]] === 'undefined') {\r\n        continue;\r\n      }\r\n\r\n      if (attributes[attr].indexOf('url(') === 0) {\r\n        continue;\r\n      }\r\n\r\n      var color = new fabric.Color(attributes[attr]);\r\n      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();\r\n    }\r\n    return attributes;\r\n  }\r\n\r\n  /**\r\n   * Parses \"transform\" attribute, returning an array of values\r\n   * @static\r\n   * @function\r\n   * @memberOf fabric\r\n   * @param {String} attributeValue String containing attribute value\r\n   * @return {Array} Array of 6 elements representing transformation matrix\r\n   */\r\n  fabric.parseTransformAttribute = (function() {\r\n    function rotateMatrix(matrix, args) {\r\n      var angle = args[0];\r\n\r\n      matrix[0] = Math.cos(angle);\r\n      matrix[1] = Math.sin(angle);\r\n      matrix[2] = -Math.sin(angle);\r\n      matrix[3] = Math.cos(angle);\r\n    }\r\n\r\n    function scaleMatrix(matrix, args) {\r\n      var multiplierX = args[0],\r\n          multiplierY = (args.length === 2) ? args[1] : args[0];\r\n\r\n      matrix[0] = multiplierX;\r\n      matrix[3] = multiplierY;\r\n    }\r\n\r\n    function skewXMatrix(matrix, args) {\r\n      matrix[2] = Math.tan(fabric.util.degreesToRadians(args[0]));\r\n    }\r\n\r\n    function skewYMatrix(matrix, args) {\r\n      matrix[1] = Math.tan(fabric.util.degreesToRadians(args[0]));\r\n    }\r\n\r\n    function translateMatrix(matrix, args) {\r\n      matrix[4] = args[0];\r\n      if (args.length === 2) {\r\n        matrix[5] = args[1];\r\n      }\r\n    }\r\n\r\n    // identity matrix\r\n    var iMatrix = [\r\n          1, // a\r\n          0, // b\r\n          0, // c\r\n          1, // d\r\n          0, // e\r\n          0  // f\r\n        ],\r\n\r\n        // == begin transform regexp\r\n        number = fabric.reNum,\r\n\r\n        commaWsp = '(?:\\\\s+,?\\\\s*|,\\\\s*)',\r\n\r\n        skewX = '(?:(skewX)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*\\\\))',\r\n\r\n        skewY = '(?:(skewY)\\\\s*\\\\(\\\\s*(' + number + ')\\\\s*\\\\))',\r\n\r\n        rotate = '(?:(rotate)\\\\s*\\\\(\\\\s*(' + number + ')(?:' +\r\n                    commaWsp + '(' + number + ')' +\r\n                    commaWsp + '(' + number + '))?\\\\s*\\\\))',\r\n\r\n        scale = '(?:(scale)\\\\s*\\\\(\\\\s*(' + number + ')(?:' +\r\n                    commaWsp + '(' + number + '))?\\\\s*\\\\))',\r\n\r\n        translate = '(?:(translate)\\\\s*\\\\(\\\\s*(' + number + ')(?:' +\r\n                    commaWsp + '(' + number + '))?\\\\s*\\\\))',\r\n\r\n        matrix = '(?:(matrix)\\\\s*\\\\(\\\\s*' +\r\n                  '(' + number + ')' + commaWsp +\r\n                  '(' + number + ')' + commaWsp +\r\n                  '(' + number + ')' + commaWsp +\r\n                  '(' + number + ')' + commaWsp +\r\n                  '(' + number + ')' + commaWsp +\r\n                  '(' + number + ')' +\r\n                  '\\\\s*\\\\))',\r\n\r\n        transform = '(?:' +\r\n                    matrix + '|' +\r\n                    translate + '|' +\r\n                    scale + '|' +\r\n                    rotate + '|' +\r\n                    skewX + '|' +\r\n                    skewY +\r\n                    ')',\r\n\r\n        transforms = '(?:' + transform + '(?:' + commaWsp + transform + ')*' + ')',\r\n\r\n        transformList = '^\\\\s*(?:' + transforms + '?)\\\\s*$',\r\n\r\n        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute\r\n        reTransformList = new RegExp(transformList),\r\n        // == end transform regexp\r\n\r\n        reTransform = new RegExp(transform, 'g');\r\n\r\n    return function(attributeValue) {\r\n\r\n      // start with identity matrix\r\n      var matrix = iMatrix.concat(),\r\n          matrices = [ ];\r\n\r\n      // return if no argument was given or\r\n      // an argument does not match transform attribute regexp\r\n      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {\r\n        return matrix;\r\n      }\r\n\r\n      attributeValue.replace(reTransform, function(match) {\r\n\r\n        var m = new RegExp(transform).exec(match).filter(function (match) {\r\n              return (match !== '' && match != null);\r\n            }),\r\n            operation = m[1],\r\n            args = m.slice(2).map(parseFloat);\r\n\r\n        switch (operation) {\r\n          case 'translate':\r\n            translateMatrix(matrix, args);\r\n            break;\r\n          case 'rotate':\r\n            args[0] = fabric.util.degreesToRadians(args[0]);\r\n            rotateMatrix(matrix, args);\r\n            break;\r\n          case 'scale':\r\n            scaleMatrix(matrix, args);\r\n            break;\r\n          case 'skewX':\r\n            skewXMatrix(matrix, args);\r\n            break;\r\n          case 'skewY':\r\n            skewYMatrix(matrix, args);\r\n            break;\r\n          case 'matrix':\r\n            matrix = args;\r\n            break;\r\n        }\r\n\r\n        // snapshot current matrix into matrices array\r\n        matrices.push(matrix.concat());\r\n        // reset\r\n        matrix = iMatrix.concat();\r\n      });\r\n\r\n      var combinedMatrix = matrices[0];\r\n      while (matrices.length > 1) {\r\n        matrices.shift();\r\n        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);\r\n      }\r\n      return combinedMatrix;\r\n    };\r\n  })();\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function parseStyleString(style, oStyle) {\r\n    var attr, value;\r\n    style.replace(/;\\s*$/, '').split(';').forEach(function (chunk) {\r\n      var pair = chunk.split(':');\r\n\r\n      attr = normalizeAttr(pair[0].trim().toLowerCase());\r\n      value = normalizeValue(attr, pair[1].trim());\r\n\r\n      oStyle[attr] = value;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function parseStyleObject(style, oStyle) {\r\n    var attr, value;\r\n    for (var prop in style) {\r\n      if (typeof style[prop] === 'undefined') {\r\n        continue;\r\n      }\r\n\r\n      attr = normalizeAttr(prop.toLowerCase());\r\n      value = normalizeValue(attr, style[prop]);\r\n\r\n      oStyle[attr] = value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function getGlobalStylesForElement(element, svgUid) {\r\n    var styles = { };\r\n    for (var rule in fabric.cssRules[svgUid]) {\r\n      if (elementMatchesRule(element, rule.split(' '))) {\r\n        for (var property in fabric.cssRules[svgUid][rule]) {\r\n          styles[property] = fabric.cssRules[svgUid][rule][property];\r\n        }\r\n      }\r\n    }\r\n    return styles;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function elementMatchesRule(element, selectors) {\r\n    var firstMatching, parentMatching = true;\r\n    //start from rightmost selector.\r\n    firstMatching = selectorMatches(element, selectors.pop());\r\n    if (firstMatching && selectors.length) {\r\n      parentMatching = doesSomeParentMatch(element, selectors);\r\n    }\r\n    return firstMatching && parentMatching && (selectors.length === 0);\r\n  }\r\n\r\n  function doesSomeParentMatch(element, selectors) {\r\n    var selector, parentMatching = true;\r\n    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {\r\n      if (parentMatching) {\r\n        selector = selectors.pop();\r\n      }\r\n      element = element.parentNode;\r\n      parentMatching = selectorMatches(element, selector);\r\n    }\r\n    return selectors.length === 0;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function selectorMatches(element, selector) {\r\n    var nodeName = element.nodeName,\r\n        classNames = element.getAttribute('class'),\r\n        id = element.getAttribute('id'), matcher;\r\n    // i check if a selector matches slicing away part from it.\r\n    // if i get empty string i should match\r\n    matcher = new RegExp('^' + nodeName, 'i');\r\n    selector = selector.replace(matcher, '');\r\n    if (id && selector.length) {\r\n      matcher = new RegExp('#' + id + '(?![a-zA-Z\\\\-]+)', 'i');\r\n      selector = selector.replace(matcher, '');\r\n    }\r\n    if (classNames && selector.length) {\r\n      classNames = classNames.split(' ');\r\n      for (var i = classNames.length; i--;) {\r\n        matcher = new RegExp('\\\\.' + classNames[i] + '(?![a-zA-Z\\\\-]+)', 'i');\r\n        selector = selector.replace(matcher, '');\r\n      }\r\n    }\r\n    return selector.length === 0;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * to support IE8 missing getElementById on SVGdocument\r\n   */\r\n  function elementById(doc, id) {\r\n    var el;\r\n    doc.getElementById && (el = doc.getElementById(id));\r\n    if (el) {\r\n      return el;\r\n    }\r\n    var node, i, idAttr, nodelist = doc.getElementsByTagName('*');\r\n    for (i = 0; i < nodelist.length; i++) {\r\n      node = nodelist[i];\r\n      if (idAttr === node.getAttribute('id')) {\r\n        return node;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function parseUseDirectives(doc) {\r\n    var nodelist = doc.getElementsByTagName('use'), i = 0;\r\n    while (nodelist.length && i < nodelist.length) {\r\n      var el = nodelist[i],\r\n          xlink = el.getAttribute('xlink:href').substr(1),\r\n          x = el.getAttribute('x') || 0,\r\n          y = el.getAttribute('y') || 0,\r\n          el2 = elementById(doc, xlink).cloneNode(true),\r\n          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',\r\n          parentNode, oldLength = nodelist.length, attr, j, attrs, l;\r\n\r\n      applyViewboxTransform(el2);\r\n      if (/^svg$/i.test(el2.nodeName)) {\r\n        var el3 = el2.ownerDocument.createElement('g');\r\n        for (j = 0, attrs = el2.attributes, l = attrs.length; j < l; j++) {\r\n          attr = attrs.item(j);\r\n          el3.setAttribute(attr.nodeName, attr.nodeValue);\r\n        }\r\n        while (el2.firstChild != null) {\r\n          el3.appendChild(el2.firstChild);\r\n        }\r\n        el2 = el3;\r\n      }\r\n\r\n      for (j = 0, attrs = el.attributes, l = attrs.length; j < l; j++) {\r\n        attr = attrs.item(j);\r\n        if (attr.nodeName === 'x' || attr.nodeName === 'y' || attr.nodeName === 'xlink:href') {\r\n          continue;\r\n        }\r\n\r\n        if (attr.nodeName === 'transform') {\r\n          currentTrans = attr.nodeValue + ' ' + currentTrans;\r\n        }\r\n        else {\r\n          el2.setAttribute(attr.nodeName, attr.nodeValue);\r\n        }\r\n      }\r\n\r\n      el2.setAttribute('transform', currentTrans);\r\n      el2.setAttribute('instantiated_by_use', '1');\r\n      el2.removeAttribute('id');\r\n      parentNode = el.parentNode;\r\n      parentNode.replaceChild(el2, el);\r\n      // some browsers do not shorten nodelist after replaceChild (IE8)\r\n      if (nodelist.length === oldLength) {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n\r\n  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute\r\n  // matches, e.g.: +14.56e-12, etc.\r\n  var reViewBoxAttrValue = new RegExp(\r\n    '^' +\r\n    '\\\\s*(' + fabric.reNum + '+)\\\\s*,?' +\r\n    '\\\\s*(' + fabric.reNum + '+)\\\\s*,?' +\r\n    '\\\\s*(' + fabric.reNum + '+)\\\\s*,?' +\r\n    '\\\\s*(' + fabric.reNum + '+)\\\\s*' +\r\n    '$'\r\n  );\r\n\r\n  /**\r\n   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements\r\n   */\r\n  function applyViewboxTransform(element) {\r\n\r\n    var viewBoxAttr = element.getAttribute('viewBox'),\r\n        scaleX = 1,\r\n        scaleY = 1,\r\n        minX = 0,\r\n        minY = 0,\r\n        viewBoxWidth, viewBoxHeight, matrix, el,\r\n        widthAttr = element.getAttribute('width'),\r\n        heightAttr = element.getAttribute('height'),\r\n        x = element.getAttribute('x') || 0,\r\n        y = element.getAttribute('y') || 0,\r\n        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',\r\n        missingViewBox = (!viewBoxAttr || !reViewBoxTagNames.test(element.tagName)\r\n                           || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),\r\n        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),\r\n        toBeParsed = missingViewBox && missingDimAttr,\r\n        parsedDim = { }, translateMatrix = '';\r\n\r\n    parsedDim.width = 0;\r\n    parsedDim.height = 0;\r\n    parsedDim.toBeParsed = toBeParsed;\r\n\r\n    if (toBeParsed) {\r\n      return parsedDim;\r\n    }\r\n\r\n    if (missingViewBox) {\r\n      parsedDim.width = parseUnit(widthAttr);\r\n      parsedDim.height = parseUnit(heightAttr);\r\n      return parsedDim;\r\n    }\r\n\r\n    minX = -parseFloat(viewBoxAttr[1]),\r\n    minY = -parseFloat(viewBoxAttr[2]),\r\n    viewBoxWidth = parseFloat(viewBoxAttr[3]),\r\n    viewBoxHeight = parseFloat(viewBoxAttr[4]);\r\n\r\n    if (!missingDimAttr) {\r\n      parsedDim.width = parseUnit(widthAttr);\r\n      parsedDim.height = parseUnit(heightAttr);\r\n      scaleX = parsedDim.width / viewBoxWidth;\r\n      scaleY = parsedDim.height / viewBoxHeight;\r\n    }\r\n    else {\r\n      parsedDim.width = viewBoxWidth;\r\n      parsedDim.height = viewBoxHeight;\r\n    }\r\n\r\n    // default is to preserve aspect ratio\r\n    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);\r\n    if (preserveAspectRatio.alignX !== 'none') {\r\n      //translate all container for the effect of Mid, Min, Max\r\n      scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);\r\n    }\r\n\r\n    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {\r\n      return parsedDim;\r\n    }\r\n\r\n    if (x || y) {\r\n      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';\r\n    }\r\n\r\n    matrix = translateMatrix + ' matrix(' + scaleX +\r\n                  ' 0' +\r\n                  ' 0 ' +\r\n                  scaleY + ' ' +\r\n                  (minX * scaleX) + ' ' +\r\n                  (minY * scaleY) + ') ';\r\n\r\n    if (element.tagName === 'svg') {\r\n      el = element.ownerDocument.createElement('g');\r\n      while (element.firstChild != null) {\r\n        el.appendChild(element.firstChild);\r\n      }\r\n      element.appendChild(el);\r\n    }\r\n    else {\r\n      el = element;\r\n      matrix = el.getAttribute('transform') + matrix;\r\n    }\r\n\r\n    el.setAttribute('transform', matrix);\r\n    return parsedDim;\r\n  }\r\n\r\n  /**\r\n   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback\r\n   * @static\r\n   * @function\r\n   * @memberOf fabric\r\n   * @param {SVGDocument} doc SVG document to parse\r\n   * @param {Function} callback Callback to call when parsing is finished; It's being passed an array of elements (parsed from a document).\r\n   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\r\n   */\r\n  fabric.parseSVGDocument = (function() {\r\n\r\n    function hasAncestorWithNodeName(element, nodeName) {\r\n      while (element && (element = element.parentNode)) {\r\n        if (nodeName.test(element.nodeName) && !element.getAttribute('instantiated_by_use')) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    return function(doc, callback, reviver) {\r\n      if (!doc) {\r\n        return;\r\n      }\r\n\r\n      parseUseDirectives(doc);\r\n\r\n      var startTime = new Date(),\r\n          svgUid =  fabric.Object.__uid++,\r\n          options = applyViewboxTransform(doc),\r\n          descendants = fabric.util.toArray(doc.getElementsByTagName('*'));\r\n\r\n      options.svgUid = svgUid;\r\n\r\n      if (descendants.length === 0 && fabric.isLikelyNode) {\r\n        // we're likely in node, where \"o3-xml\" library fails to gEBTN(\"*\")\r\n        // https://github.com/ajaxorg/node-o3-xml/issues/21\r\n        descendants = doc.selectNodes('//*[name(.)!=\"svg\"]');\r\n        var arr = [ ];\r\n        for (var i = 0, len = descendants.length; i < len; i++) {\r\n          arr[i] = descendants[i];\r\n        }\r\n        descendants = arr;\r\n      }\r\n\r\n      var elements = descendants.filter(function(el) {\r\n        applyViewboxTransform(el);\r\n        return reAllowedSVGTagNames.test(el.tagName) &&\r\n              !hasAncestorWithNodeName(el, reNotAllowedAncestors); // http://www.w3.org/TR/SVG/struct.html#DefsElement\r\n      });\r\n\r\n      if (!elements || (elements && !elements.length)) {\r\n        callback && callback([], {});\r\n        return;\r\n      }\r\n\r\n      fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);\r\n      fabric.cssRules[svgUid] = fabric.getCSSRules(doc);\r\n      // Precedence of rules:   style > class > attribute\r\n      fabric.parseElements(elements, function(instances) {\r\n        fabric.documentParsingTime = new Date() - startTime;\r\n        if (callback) {\r\n          callback(instances, options);\r\n        }\r\n      }, clone(options), reviver);\r\n    };\r\n  })();\r\n\r\n  /**\r\n   * Used for caching SVG documents (loaded via `fabric.Canvas#loadSVGFromURL`)\r\n   * @namespace\r\n   */\r\n  var svgCache = {\r\n\r\n    /**\r\n     * @param {String} name\r\n     * @param {Function} callback\r\n     */\r\n    has: function (name, callback) {\r\n      callback(false);\r\n    },\r\n\r\n    get: function () {\r\n      /* NOOP */\r\n    },\r\n\r\n    set: function () {\r\n      /* NOOP */\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function _enlivenCachedObject(cachedObject) {\r\n\r\n    var objects = cachedObject.objects,\r\n        options = cachedObject.options;\r\n\r\n    objects = objects.map(function (o) {\r\n      return fabric[capitalize(o.type)].fromObject(o);\r\n    });\r\n\r\n    return ({ objects: objects, options: options });\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function _createSVGPattern(markup, canvas, property) {\r\n    if (canvas[property] && canvas[property].toSVG) {\r\n      markup.push(\r\n        '\\t<pattern x=\"0\" y=\"0\" id=\"', property, 'Pattern\" ',\r\n          'width=\"', canvas[property].source.width,\r\n          '\" height=\"', canvas[property].source.height,\r\n          '\" patternUnits=\"userSpaceOnUse\">\\n',\r\n        '\\t\\t<image x=\"0\" y=\"0\" ',\r\n        'width=\"', canvas[property].source.width,\r\n        '\" height=\"', canvas[property].source.height,\r\n        '\" xlink:href=\"', canvas[property].source.src,\r\n        '\"></image>\\n\\t</pattern>\\n'\r\n      );\r\n    }\r\n  }\r\n\r\n  var reFontDeclaration = new RegExp(\r\n    '(normal|italic)?\\\\s*(normal|small-caps)?\\\\s*' +\r\n    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\\\s*(' +\r\n      fabric.reNum +\r\n    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\\\/(normal|' + fabric.reNum + '))?\\\\s+(.*)');\r\n\r\n  extend(fabric, {\r\n    /**\r\n     * Parses a short font declaration, building adding its properties to a style object\r\n     * @static\r\n     * @function\r\n     * @memberOf fabric\r\n     * @param {String} value font declaration\r\n     * @param {Object} oStyle definition\r\n     */\r\n    parseFontDeclaration: function(value, oStyle) {\r\n      var match = value.match(reFontDeclaration);\r\n\r\n      if (!match) {\r\n        return;\r\n      }\r\n      var fontStyle = match[1],\r\n          // font variant is not used\r\n          // fontVariant = match[2],\r\n          fontWeight = match[3],\r\n          fontSize = match[4],\r\n          lineHeight = match[5],\r\n          fontFamily = match[6];\r\n\r\n      if (fontStyle) {\r\n        oStyle.fontStyle = fontStyle;\r\n      }\r\n      if (fontWeight) {\r\n        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);\r\n      }\r\n      if (fontSize) {\r\n        oStyle.fontSize = parseUnit(fontSize);\r\n      }\r\n      if (fontFamily) {\r\n        oStyle.fontFamily = fontFamily;\r\n      }\r\n      if (lineHeight) {\r\n        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Parses an SVG document, returning all of the gradient declarations found in it\r\n     * @static\r\n     * @function\r\n     * @memberOf fabric\r\n     * @param {SVGDocument} doc SVG document to parse\r\n     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element\r\n     */\r\n    getGradientDefs: function(doc) {\r\n      var linearGradientEls = doc.getElementsByTagName('linearGradient'),\r\n          radialGradientEls = doc.getElementsByTagName('radialGradient'),\r\n          el, i, j = 0, id, xlink, elList = [ ],\r\n          gradientDefs = { }, idsToXlinkMap = { };\r\n\r\n      elList.length = linearGradientEls.length + radialGradientEls.length;\r\n      i = linearGradientEls.length;\r\n      while (i--) {\r\n        elList[j++] = linearGradientEls[i];\r\n      }\r\n      i = radialGradientEls.length;\r\n      while (i--) {\r\n        elList[j++] = radialGradientEls[i];\r\n      }\r\n\r\n      while (j--) {\r\n        el = elList[j];\r\n        xlink = el.getAttribute('xlink:href');\r\n        id = el.getAttribute('id');\r\n        if (xlink) {\r\n          idsToXlinkMap[id] = xlink.substr(1);\r\n        }\r\n        gradientDefs[id] = el;\r\n      }\r\n\r\n      for (id in idsToXlinkMap) {\r\n        var el2 = gradientDefs[idsToXlinkMap[id]].cloneNode(true);\r\n        el = gradientDefs[id];\r\n        while (el2.firstChild) {\r\n          el.appendChild(el2.firstChild);\r\n        }\r\n      }\r\n      return gradientDefs;\r\n    },\r\n\r\n    /**\r\n     * Returns an object of attributes' name/value, given element and an array of attribute names;\r\n     * Parses parent \"g\" nodes recursively upwards.\r\n     * @static\r\n     * @memberOf fabric\r\n     * @param {DOMElement} element Element to parse\r\n     * @param {Array} attributes Array of attributes to parse\r\n     * @return {Object} object containing parsed attributes' names/values\r\n     */\r\n    parseAttributes: function(element, attributes, svgUid) {\r\n\r\n      if (!element) {\r\n        return;\r\n      }\r\n\r\n      var value,\r\n          parentAttributes = { },\r\n          fontSize;\r\n\r\n      if (typeof svgUid === 'undefined') {\r\n        svgUid = element.getAttribute('svgUid');\r\n      }\r\n      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards\r\n      if (element.parentNode && reAllowedParents.test(element.parentNode.nodeName)) {\r\n        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);\r\n      }\r\n      fontSize = (parentAttributes && parentAttributes.fontSize ) ||\r\n                 element.getAttribute('font-size') || fabric.Text.DEFAULT_SVG_FONT_SIZE;\r\n\r\n      var ownAttributes = attributes.reduce(function(memo, attr) {\r\n        value = element.getAttribute(attr);\r\n        if (value) {\r\n          attr = normalizeAttr(attr);\r\n          value = normalizeValue(attr, value, parentAttributes, fontSize);\r\n\r\n          memo[attr] = value;\r\n        }\r\n        return memo;\r\n      }, { });\r\n\r\n      // add values parsed from style, which take precedence over attributes\r\n      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)\r\n      ownAttributes = extend(ownAttributes,\r\n        extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element)));\r\n      if (ownAttributes.font) {\r\n        fabric.parseFontDeclaration(ownAttributes.font, ownAttributes);\r\n      }\r\n      return _setStrokeFillOpacity(extend(parentAttributes, ownAttributes));\r\n    },\r\n\r\n    /**\r\n     * Transforms an array of svg elements to corresponding fabric.* instances\r\n     * @static\r\n     * @memberOf fabric\r\n     * @param {Array} elements Array of elements to parse\r\n     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)\r\n     * @param {Object} [options] Options object\r\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\r\n     */\r\n    parseElements: function(elements, callback, options, reviver) {\r\n      new fabric.ElementsParser(elements, callback, options, reviver).parse();\r\n    },\r\n\r\n    /**\r\n     * Parses \"style\" attribute, retuning an object with values\r\n     * @static\r\n     * @memberOf fabric\r\n     * @param {SVGElement} element Element to parse\r\n     * @return {Object} Objects with values parsed from style attribute of an element\r\n     */\r\n    parseStyleAttribute: function(element) {\r\n      var oStyle = { },\r\n          style = element.getAttribute('style');\r\n\r\n      if (!style) {\r\n        return oStyle;\r\n      }\r\n\r\n      if (typeof style === 'string') {\r\n        parseStyleString(style, oStyle);\r\n      }\r\n      else {\r\n        parseStyleObject(style, oStyle);\r\n      }\r\n\r\n      return oStyle;\r\n    },\r\n\r\n    /**\r\n     * Parses \"points\" attribute, returning an array of values\r\n     * @static\r\n     * @memberOf fabric\r\n     * @param {String} points points attribute string\r\n     * @return {Array} array of points\r\n     */\r\n    parsePointsAttribute: function(points) {\r\n\r\n      // points attribute is required and must not be empty\r\n      if (!points) {\r\n        return null;\r\n      }\r\n\r\n      // replace commas with whitespace and remove bookending whitespace\r\n      points = points.replace(/,/g, ' ').trim();\r\n\r\n      points = points.split(/\\s+/);\r\n      var parsedPoints = [ ], i, len;\r\n\r\n      i = 0;\r\n      len = points.length;\r\n      for (; i < len; i+=2) {\r\n        parsedPoints.push({\r\n          x: parseFloat(points[i]),\r\n          y: parseFloat(points[i + 1])\r\n        });\r\n      }\r\n\r\n      // odd number of points is an error\r\n      // if (parsedPoints.length % 2 !== 0) {\r\n      //   return null;\r\n      // }\r\n\r\n      return parsedPoints;\r\n    },\r\n\r\n    /**\r\n     * Returns CSS rules for a given SVG document\r\n     * @static\r\n     * @function\r\n     * @memberOf fabric\r\n     * @param {SVGDocument} doc SVG document to parse\r\n     * @return {Object} CSS rules of this document\r\n     */\r\n    getCSSRules: function(doc) {\r\n      var styles = doc.getElementsByTagName('style'),\r\n          allRules = { }, rules;\r\n\r\n      // very crude parsing of style contents\r\n      for (var i = 0, len = styles.length; i < len; i++) {\r\n        var styleContents = styles[i].textContent;\r\n\r\n        // remove comments\r\n        styleContents = styleContents.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');\r\n        if (styleContents.trim() === '') {\r\n          continue;\r\n        }\r\n        rules = styleContents.match(/[^{]*\\{[\\s\\S]*?\\}/g);\r\n        rules = rules.map(function(rule) { return rule.trim(); });\r\n\r\n        rules.forEach(function(rule) {\r\n\r\n          var match = rule.match(/([\\s\\S]*?)\\s*\\{([^}]*)\\}/),\r\n          ruleObj = { }, declaration = match[2].trim(),\r\n          propertyValuePairs = declaration.replace(/;$/, '').split(/\\s*;\\s*/);\r\n\r\n          for (var i = 0, len = propertyValuePairs.length; i < len; i++) {\r\n            var pair = propertyValuePairs[i].split(/\\s*:\\s*/),\r\n                property = normalizeAttr(pair[0]),\r\n                value = normalizeValue(property, pair[1], pair[0]);\r\n            ruleObj[property] = value;\r\n          }\r\n          rule = match[1];\r\n          rule.split(',').forEach(function(_rule) {\r\n            _rule = _rule.replace(/^svg/i, '').trim();\r\n            if (_rule === '') {\r\n              return;\r\n            }\r\n            allRules[_rule] = fabric.util.object.clone(ruleObj);\r\n          });\r\n        });\r\n      }\r\n      return allRules;\r\n    },\r\n\r\n    /**\r\n     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects. Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)\r\n     * @memberOf fabric\r\n     * @param {String} url\r\n     * @param {Function} callback\r\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\r\n     */\r\n    loadSVGFromURL: function(url, callback, reviver) {\r\n\r\n      url = url.replace(/^\\n\\s*/, '').trim();\r\n      svgCache.has(url, function (hasUrl) {\r\n        if (hasUrl) {\r\n          svgCache.get(url, function (value) {\r\n            var enlivedRecord = _enlivenCachedObject(value);\r\n            callback(enlivedRecord.objects, enlivedRecord.options);\r\n          });\r\n        }\r\n        else {\r\n          new fabric.util.request(url, {\r\n            method: 'get',\r\n            onComplete: onComplete\r\n          });\r\n        }\r\n      });\r\n\r\n      function onComplete(r) {\r\n\r\n        var xml = r.responseXML;\r\n        if (xml && !xml.documentElement && fabric.window.ActiveXObject && r.responseText) {\r\n          xml = new ActiveXObject('Microsoft.XMLDOM');\r\n          xml.async = 'false';\r\n          //IE chokes on DOCTYPE\r\n          xml.loadXML(r.responseText.replace(/<!DOCTYPE[\\s\\S]*?(\\[[\\s\\S]*\\])*?>/i, ''));\r\n        }\r\n        if (!xml || !xml.documentElement) {\r\n          return;\r\n        }\r\n\r\n        fabric.parseSVGDocument(xml.documentElement, function (results, options) {\r\n          svgCache.set(url, {\r\n            objects: fabric.util.array.invoke(results, 'toObject'),\r\n            options: options\r\n          });\r\n          callback(results, options);\r\n        }, reviver);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects\r\n     * @memberOf fabric\r\n     * @param {String} string\r\n     * @param {Function} callback\r\n     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.\r\n     */\r\n    loadSVGFromString: function(string, callback, reviver) {\r\n      string = string.trim();\r\n      var doc;\r\n      if (typeof DOMParser !== 'undefined') {\r\n        var parser = new DOMParser();\r\n        if (parser && parser.parseFromString) {\r\n          doc = parser.parseFromString(string, 'text/xml');\r\n        }\r\n      }\r\n      else if (fabric.window.ActiveXObject) {\r\n        doc = new ActiveXObject('Microsoft.XMLDOM');\r\n        doc.async = 'false';\r\n        // IE chokes on DOCTYPE\r\n        doc.loadXML(string.replace(/<!DOCTYPE[\\s\\S]*?(\\[[\\s\\S]*\\])*?>/i, ''));\r\n      }\r\n\r\n      fabric.parseSVGDocument(doc.documentElement, function (results, options) {\r\n        callback(results, options);\r\n      }, reviver);\r\n    },\r\n\r\n    /**\r\n     * Creates markup containing SVG font faces\r\n     * @param {Array} objects Array of fabric objects\r\n     * @return {String}\r\n     */\r\n    createSVGFontFacesMarkup: function(objects) {\r\n      var markup = '';\r\n\r\n      for (var i = 0, len = objects.length; i < len; i++) {\r\n        if (objects[i].type !== 'text' || !objects[i].path) {\r\n          continue;\r\n        }\r\n\r\n        markup += [\r\n          //jscs:disable validateIndentation\r\n          '@font-face {',\r\n            'font-family: ', objects[i].fontFamily, '; ',\r\n            'src: url(\\'', objects[i].path, '\\')',\r\n          '}\\n'\r\n          //jscs:enable validateIndentation\r\n        ].join('');\r\n      }\r\n\r\n      if (markup) {\r\n        markup = [\r\n          //jscs:disable validateIndentation\r\n          '\\t<style type=\"text/css\">',\r\n            '<![CDATA[',\r\n              markup,\r\n            ']]>',\r\n          '</style>\\n'\r\n          //jscs:enable validateIndentation\r\n        ].join('');\r\n      }\r\n\r\n      return markup;\r\n    },\r\n\r\n    /**\r\n     * Creates markup containing SVG referenced elements like patterns, gradients etc.\r\n     * @param {fabric.Canvas} canvas instance of fabric.Canvas\r\n     * @return {String}\r\n     */\r\n    createSVGRefElementsMarkup: function(canvas) {\r\n      var markup = [ ];\r\n\r\n      _createSVGPattern(markup, canvas, 'backgroundColor');\r\n      _createSVGPattern(markup, canvas, 'overlayColor');\r\n\r\n      return markup.join('');\r\n    }\r\n  });\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\nfabric.ElementsParser = function(elements, callback, options, reviver) {\r\n  this.elements = elements;\r\n  this.callback = callback;\r\n  this.options = options;\r\n  this.reviver = reviver;\r\n  this.svgUid = (options && options.svgUid) || 0;\r\n};\r\n\r\nfabric.ElementsParser.prototype.parse = function() {\r\n  this.instances = new Array(this.elements.length);\r\n  this.numElements = this.elements.length;\r\n\r\n  this.createObjects();\r\n};\r\n\r\nfabric.ElementsParser.prototype.createObjects = function() {\r\n  for (var i = 0, len = this.elements.length; i < len; i++) {\r\n    this.elements[i].setAttribute('svgUid', this.svgUid);\r\n    (function(_this, i) {\r\n      setTimeout(function() {\r\n        _this.createObject(_this.elements[i], i);\r\n      }, 0);\r\n    })(this, i);\r\n  }\r\n};\r\n\r\nfabric.ElementsParser.prototype.createObject = function(el, index) {\r\n  var klass = fabric[fabric.util.string.capitalize(el.tagName)];\r\n  if (klass && klass.fromElement) {\r\n    try {\r\n      this._createObject(klass, el, index);\r\n    }\r\n    catch (err) {\r\n      fabric.log(err);\r\n    }\r\n  }\r\n  else {\r\n    this.checkIfDone();\r\n  }\r\n};\r\n\r\nfabric.ElementsParser.prototype._createObject = function(klass, el, index) {\r\n  if (klass.async) {\r\n    klass.fromElement(el, this.createCallback(index, el), this.options);\r\n  }\r\n  else {\r\n    var obj = klass.fromElement(el, this.options);\r\n    this.resolveGradient(obj, 'fill');\r\n    this.resolveGradient(obj, 'stroke');\r\n    this.reviver && this.reviver(el, obj);\r\n    this.instances[index] = obj;\r\n    this.checkIfDone();\r\n  }\r\n};\r\n\r\nfabric.ElementsParser.prototype.createCallback = function(index, el) {\r\n  var _this = this;\r\n  return function(obj) {\r\n    _this.resolveGradient(obj, 'fill');\r\n    _this.resolveGradient(obj, 'stroke');\r\n    _this.reviver && _this.reviver(el, obj);\r\n    _this.instances[index] = obj;\r\n    _this.checkIfDone();\r\n  };\r\n};\r\n\r\nfabric.ElementsParser.prototype.resolveGradient = function(obj, property) {\r\n\r\n  var instanceFillValue = obj.get(property);\r\n  if (!(/^url\\(/).test(instanceFillValue)) {\r\n    return;\r\n  }\r\n  var gradientId = instanceFillValue.slice(5, instanceFillValue.length - 1);\r\n  if (fabric.gradientDefs[this.svgUid][gradientId]) {\r\n    obj.set(property,\r\n      fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][gradientId], obj));\r\n  }\r\n};\r\n\r\nfabric.ElementsParser.prototype.checkIfDone = function() {\r\n  if (--this.numElements === 0) {\r\n    this.instances = this.instances.filter(function(el) {\r\n      return el != null;\r\n    });\r\n    this.callback(this.instances);\r\n  }\r\n};\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */\r\n\r\n  var fabric = global.fabric || (global.fabric = { });\r\n\r\n  if (fabric.Point) {\r\n    fabric.warn('fabric.Point is already defined');\r\n    return;\r\n  }\r\n\r\n  fabric.Point = Point;\r\n\r\n  /**\r\n   * Point class\r\n   * @class fabric.Point\r\n   * @memberOf fabric\r\n   * @constructor\r\n   * @param {Number} x\r\n   * @param {Number} y\r\n   * @return {fabric.Point} thisArg\r\n   */\r\n  function Point(x, y) {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n\r\n  Point.prototype = /** @lends fabric.Point.prototype */ {\r\n\r\n    constructor: Point,\r\n\r\n    /**\r\n     * Adds another point to this one and returns another one\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point} new Point instance with added values\r\n     */\r\n    add: function (that) {\r\n      return new Point(this.x + that.x, this.y + that.y);\r\n    },\r\n\r\n    /**\r\n     * Adds another point to this one\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point} thisArg\r\n     */\r\n    addEquals: function (that) {\r\n      this.x += that.x;\r\n      this.y += that.y;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Adds value to this point and returns a new one\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point} new Point with added value\r\n     */\r\n    scalarAdd: function (scalar) {\r\n      return new Point(this.x + scalar, this.y + scalar);\r\n    },\r\n\r\n    /**\r\n     * Adds value to this point\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point} thisArg\r\n     */\r\n    scalarAddEquals: function (scalar) {\r\n      this.x += scalar;\r\n      this.y += scalar;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Subtracts another point from this point and returns a new one\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point} new Point object with subtracted values\r\n     */\r\n    subtract: function (that) {\r\n      return new Point(this.x - that.x, this.y - that.y);\r\n    },\r\n\r\n    /**\r\n     * Subtracts another point from this point\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point} thisArg\r\n     */\r\n    subtractEquals: function (that) {\r\n      this.x -= that.x;\r\n      this.y -= that.y;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Subtracts value from this point and returns a new one\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point}\r\n     */\r\n    scalarSubtract: function (scalar) {\r\n      return new Point(this.x - scalar, this.y - scalar);\r\n    },\r\n\r\n    /**\r\n     * Subtracts value from this point\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point} thisArg\r\n     */\r\n    scalarSubtractEquals: function (scalar) {\r\n      this.x -= scalar;\r\n      this.y -= scalar;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Miltiplies this point by a value and returns a new one\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point}\r\n     */\r\n    multiply: function (scalar) {\r\n      return new Point(this.x * scalar, this.y * scalar);\r\n    },\r\n\r\n    /**\r\n     * Miltiplies this point by a value\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point} thisArg\r\n     */\r\n    multiplyEquals: function (scalar) {\r\n      this.x *= scalar;\r\n      this.y *= scalar;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Divides this point by a value and returns a new one\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point}\r\n     */\r\n    divide: function (scalar) {\r\n      return new Point(this.x / scalar, this.y / scalar);\r\n    },\r\n\r\n    /**\r\n     * Divides this point by a value\r\n     * @param {Number} scalar\r\n     * @return {fabric.Point} thisArg\r\n     */\r\n    divideEquals: function (scalar) {\r\n      this.x /= scalar;\r\n      this.y /= scalar;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns true if this point is equal to another one\r\n     * @param {fabric.Point} that\r\n     * @return {Boolean}\r\n     */\r\n    eq: function (that) {\r\n      return (this.x === that.x && this.y === that.y);\r\n    },\r\n\r\n    /**\r\n     * Returns true if this point is less than another one\r\n     * @param {fabric.Point} that\r\n     * @return {Boolean}\r\n     */\r\n    lt: function (that) {\r\n      return (this.x < that.x && this.y < that.y);\r\n    },\r\n\r\n    /**\r\n     * Returns true if this point is less than or equal to another one\r\n     * @param {fabric.Point} that\r\n     * @return {Boolean}\r\n     */\r\n    lte: function (that) {\r\n      return (this.x <= that.x && this.y <= that.y);\r\n    },\r\n\r\n    /**\r\n\r\n     * Returns true if this point is greater another one\r\n     * @param {fabric.Point} that\r\n     * @return {Boolean}\r\n     */\r\n    gt: function (that) {\r\n      return (this.x > that.x && this.y > that.y);\r\n    },\r\n\r\n    /**\r\n     * Returns true if this point is greater than or equal to another one\r\n     * @param {fabric.Point} that\r\n     * @return {Boolean}\r\n     */\r\n    gte: function (that) {\r\n      return (this.x >= that.x && this.y >= that.y);\r\n    },\r\n\r\n    /**\r\n     * Returns new point which is the result of linear interpolation with this one and another one\r\n     * @param {fabric.Point} that\r\n     * @param {Number} t\r\n     * @return {fabric.Point}\r\n     */\r\n    lerp: function (that, t) {\r\n      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);\r\n    },\r\n\r\n    /**\r\n     * Returns distance from this point and another one\r\n     * @param {fabric.Point} that\r\n     * @return {Number}\r\n     */\r\n    distanceFrom: function (that) {\r\n      var dx = this.x - that.x,\r\n          dy = this.y - that.y;\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n    },\r\n\r\n    /**\r\n     * Returns the point between this point and another one\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point}\r\n     */\r\n    midPointFrom: function (that) {\r\n      return new Point(this.x + (that.x - this.x)/2, this.y + (that.y - this.y)/2);\r\n    },\r\n\r\n    /**\r\n     * Returns a new point which is the min of this and another one\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point}\r\n     */\r\n    min: function (that) {\r\n      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));\r\n    },\r\n\r\n    /**\r\n     * Returns a new point which is the max of this and another one\r\n     * @param {fabric.Point} that\r\n     * @return {fabric.Point}\r\n     */\r\n    max: function (that) {\r\n      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));\r\n    },\r\n\r\n    /**\r\n     * Returns string representation of this point\r\n     * @return {String}\r\n     */\r\n    toString: function () {\r\n      return this.x + ',' + this.y;\r\n    },\r\n\r\n    /**\r\n     * Sets x/y of this point\r\n     * @param {Number} x\r\n     * @param {Number} y\r\n     */\r\n    setXY: function (x, y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    },\r\n\r\n    /**\r\n     * Sets x/y of this point from another point\r\n     * @param {fabric.Point} that\r\n     */\r\n    setFromPoint: function (that) {\r\n      this.x = that.x;\r\n      this.y = that.y;\r\n    },\r\n\r\n    /**\r\n     * Swaps x/y of this point and another point\r\n     * @param {fabric.Point} that\r\n     */\r\n    swap: function (that) {\r\n      var x = this.x,\r\n          y = this.y;\r\n      this.x = that.x;\r\n      this.y = that.y;\r\n      that.x = x;\r\n      that.y = y;\r\n    }\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */\r\n  var fabric = global.fabric || (global.fabric = { });\r\n\r\n  if (fabric.Intersection) {\r\n    fabric.warn('fabric.Intersection is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Intersection class\r\n   * @class fabric.Intersection\r\n   * @memberOf fabric\r\n   * @constructor\r\n   */\r\n  function Intersection(status) {\r\n    this.status = status;\r\n    this.points = [];\r\n  }\r\n\r\n  fabric.Intersection = Intersection;\r\n\r\n  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {\r\n\r\n    /**\r\n     * Appends a point to intersection\r\n     * @param {fabric.Point} point\r\n     */\r\n    appendPoint: function (point) {\r\n      this.points.push(point);\r\n    },\r\n\r\n    /**\r\n     * Appends points to intersection\r\n     * @param {Array} points\r\n     */\r\n    appendPoints: function (points) {\r\n      this.points = this.points.concat(points);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Checks if one line intersects another\r\n   * @static\r\n   * @param {fabric.Point} a1\r\n   * @param {fabric.Point} a2\r\n   * @param {fabric.Point} b1\r\n   * @param {fabric.Point} b2\r\n   * @return {fabric.Intersection}\r\n   */\r\n  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {\r\n    var result,\r\n        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),\r\n        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),\r\n        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\r\n    if (uB !== 0) {\r\n      var ua = uaT / uB,\r\n          ub = ubT / uB;\r\n      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {\r\n        result = new Intersection('Intersection');\r\n        result.points.push(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));\r\n      }\r\n      else {\r\n        result = new Intersection();\r\n      }\r\n    }\r\n    else {\r\n      if (uaT === 0 || ubT === 0) {\r\n        result = new Intersection('Coincident');\r\n      }\r\n      else {\r\n        result = new Intersection('Parallel');\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Checks if line intersects polygon\r\n   * @static\r\n   * @param {fabric.Point} a1\r\n   * @param {fabric.Point} a2\r\n   * @param {Array} points\r\n   * @return {fabric.Intersection}\r\n   */\r\n  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {\r\n    var result = new Intersection(),\r\n        length = points.length;\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      var b1 = points[i],\r\n          b2 = points[(i + 1) % length],\r\n          inter = Intersection.intersectLineLine(a1, a2, b1, b2);\r\n\r\n      result.appendPoints(inter.points);\r\n    }\r\n    if (result.points.length > 0) {\r\n      result.status = 'Intersection';\r\n    }\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Checks if polygon intersects another polygon\r\n   * @static\r\n   * @param {Array} points1\r\n   * @param {Array} points2\r\n   * @return {fabric.Intersection}\r\n   */\r\n  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {\r\n    var result = new Intersection(),\r\n        length = points1.length;\r\n\r\n    for (var i = 0; i < length; i++) {\r\n      var a1 = points1[i],\r\n          a2 = points1[(i + 1) % length],\r\n          inter = Intersection.intersectLinePolygon(a1, a2, points2);\r\n\r\n      result.appendPoints(inter.points);\r\n    }\r\n    if (result.points.length > 0) {\r\n      result.status = 'Intersection';\r\n    }\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * Checks if polygon intersects rectangle\r\n   * @static\r\n   * @param {Array} points\r\n   * @param {Number} r1\r\n   * @param {Number} r2\r\n   * @return {fabric.Intersection}\r\n   */\r\n  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {\r\n    var min = r1.min(r2),\r\n        max = r1.max(r2),\r\n        topRight = new fabric.Point(max.x, min.y),\r\n        bottomLeft = new fabric.Point(min.x, max.y),\r\n        inter1 = Intersection.intersectLinePolygon(min, topRight, points),\r\n        inter2 = Intersection.intersectLinePolygon(topRight, max, points),\r\n        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),\r\n        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),\r\n        result = new Intersection();\r\n\r\n    result.appendPoints(inter1.points);\r\n    result.appendPoints(inter2.points);\r\n    result.appendPoints(inter3.points);\r\n    result.appendPoints(inter4.points);\r\n\r\n    if (result.points.length > 0) {\r\n      result.status = 'Intersection';\r\n    }\r\n    return result;\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { });\r\n\r\n  if (fabric.Color) {\r\n    fabric.warn('fabric.Color is already defined.');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Color class\r\n   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;\r\n   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.\r\n   *\r\n   * @class fabric.Color\r\n   * @param {String} color optional in hex or rgb(a) format\r\n   * @return {fabric.Color} thisArg\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}\r\n   */\r\n  function Color(color) {\r\n    if (!color) {\r\n      this.setSource([0, 0, 0, 1]);\r\n    }\r\n    else {\r\n      this._tryParsingColor(color);\r\n    }\r\n  }\r\n\r\n  fabric.Color = Color;\r\n\r\n  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {\r\n\r\n    /**\r\n     * @private\r\n     * @param {String|Array} color Color value to parse\r\n     */\r\n    _tryParsingColor: function(color) {\r\n      var source;\r\n\r\n      if (color in Color.colorNameMap) {\r\n        color = Color.colorNameMap[color];\r\n      }\r\n\r\n      if (color === 'transparent') {\r\n        this.setSource([255, 255, 255, 0]);\r\n        return;\r\n      }\r\n\r\n      source = Color.sourceFromHex(color);\r\n\r\n      if (!source) {\r\n        source = Color.sourceFromRgb(color);\r\n      }\r\n      if (!source) {\r\n        source = Color.sourceFromHsl(color);\r\n      }\r\n      if (source) {\r\n        this.setSource(source);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\r\n     * @private\r\n     * @param {Number} r Red color value\r\n     * @param {Number} g Green color value\r\n     * @param {Number} b Blue color value\r\n     * @return {Array} Hsl color\r\n     */\r\n    _rgbToHsl: function(r, g, b) {\r\n      r /= 255, g /= 255, b /= 255;\r\n\r\n      var h, s, l,\r\n          max = fabric.util.array.max([r, g, b]),\r\n          min = fabric.util.array.min([r, g, b]);\r\n\r\n      l = (max + min) / 2;\r\n\r\n      if (max === min) {\r\n        h = s = 0; // achromatic\r\n      }\r\n      else {\r\n        var d = max - min;\r\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n        switch (max) {\r\n          case r:\r\n            h = (g - b) / d + (g < b ? 6 : 0);\r\n            break;\r\n          case g:\r\n            h = (b - r) / d + 2;\r\n            break;\r\n          case b:\r\n            h = (r - g) / d + 4;\r\n            break;\r\n        }\r\n        h /= 6;\r\n      }\r\n\r\n      return [\r\n        Math.round(h * 360),\r\n        Math.round(s * 100),\r\n        Math.round(l * 100)\r\n      ];\r\n    },\r\n\r\n    /**\r\n     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])\r\n     * @return {Array}\r\n     */\r\n    getSource: function() {\r\n      return this._source;\r\n    },\r\n\r\n    /**\r\n     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])\r\n     * @param {Array} source\r\n     */\r\n    setSource: function(source) {\r\n      this._source = source;\r\n    },\r\n\r\n    /**\r\n     * Returns color represenation in RGB format\r\n     * @return {String} ex: rgb(0-255,0-255,0-255)\r\n     */\r\n    toRgb: function() {\r\n      var source = this.getSource();\r\n      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';\r\n    },\r\n\r\n    /**\r\n     * Returns color represenation in RGBA format\r\n     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)\r\n     */\r\n    toRgba: function() {\r\n      var source = this.getSource();\r\n      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';\r\n    },\r\n\r\n    /**\r\n     * Returns color represenation in HSL format\r\n     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)\r\n     */\r\n    toHsl: function() {\r\n      var source = this.getSource(),\r\n          hsl = this._rgbToHsl(source[0], source[1], source[2]);\r\n\r\n      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';\r\n    },\r\n\r\n    /**\r\n     * Returns color represenation in HSLA format\r\n     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)\r\n     */\r\n    toHsla: function() {\r\n      var source = this.getSource(),\r\n          hsl = this._rgbToHsl(source[0], source[1], source[2]);\r\n\r\n      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';\r\n    },\r\n\r\n    /**\r\n     * Returns color represenation in HEX format\r\n     * @return {String} ex: FF5555\r\n     */\r\n    toHex: function() {\r\n      var source = this.getSource(), r, g, b;\r\n\r\n      r = source[0].toString(16);\r\n      r = (r.length === 1) ? ('0' + r) : r;\r\n\r\n      g = source[1].toString(16);\r\n      g = (g.length === 1) ? ('0' + g) : g;\r\n\r\n      b = source[2].toString(16);\r\n      b = (b.length === 1) ? ('0' + b) : b;\r\n\r\n      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();\r\n    },\r\n\r\n    /**\r\n     * Gets value of alpha channel for this color\r\n     * @return {Number} 0-1\r\n     */\r\n    getAlpha: function() {\r\n      return this.getSource()[3];\r\n    },\r\n\r\n    /**\r\n     * Sets value of alpha channel for this color\r\n     * @param {Number} alpha Alpha value 0-1\r\n     * @return {fabric.Color} thisArg\r\n     */\r\n    setAlpha: function(alpha) {\r\n      var source = this.getSource();\r\n      source[3] = alpha;\r\n      this.setSource(source);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Transforms color to its grayscale representation\r\n     * @return {fabric.Color} thisArg\r\n     */\r\n    toGrayscale: function() {\r\n      var source = this.getSource(),\r\n          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),\r\n          currentAlpha = source[3];\r\n      this.setSource([average, average, average, currentAlpha]);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Transforms color to its black and white representation\r\n     * @param {Number} threshold\r\n     * @return {fabric.Color} thisArg\r\n     */\r\n    toBlackWhite: function(threshold) {\r\n      var source = this.getSource(),\r\n          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),\r\n          currentAlpha = source[3];\r\n\r\n      threshold = threshold || 127;\r\n\r\n      average = (Number(average) < Number(threshold)) ? 0 : 255;\r\n      this.setSource([average, average, average, currentAlpha]);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Overlays color with another color\r\n     * @param {String|fabric.Color} otherColor\r\n     * @return {fabric.Color} thisArg\r\n     */\r\n    overlayWith: function(otherColor) {\r\n      if (!(otherColor instanceof Color)) {\r\n        otherColor = new Color(otherColor);\r\n      }\r\n\r\n      var result = [],\r\n          alpha = this.getAlpha(),\r\n          otherAlpha = 0.5,\r\n          source = this.getSource(),\r\n          otherSource = otherColor.getSource();\r\n\r\n      for (var i = 0; i < 3; i++) {\r\n        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));\r\n      }\r\n\r\n      result[3] = alpha;\r\n      this.setSource(result);\r\n      return this;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))\r\n   * @static\r\n   * @field\r\n   * @memberOf fabric.Color\r\n   */\r\n  fabric.Color.reRGBa = /^rgba?\\(\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*,\\s*(\\d{1,3}(?:\\.\\d+)?\\%?)\\s*(?:\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/;\r\n\r\n  /**\r\n   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))\r\n   * @static\r\n   * @field\r\n   * @memberOf fabric.Color\r\n   */\r\n  fabric.Color.reHSLa = /^hsla?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}\\%)\\s*,\\s*(\\d{1,3}\\%)\\s*(?:\\s*,\\s*(\\d+(?:\\.\\d+)?)\\s*)?\\)$/;\r\n\r\n  /**\r\n   * Regex matching color in HEX format (ex: #FF5555, 010155, aff)\r\n   * @static\r\n   * @field\r\n   * @memberOf fabric.Color\r\n   */\r\n  fabric.Color.reHex = /^#?([0-9a-f]{6}|[0-9a-f]{3})$/i;\r\n\r\n  /**\r\n   * Map of the 17 basic color names with HEX code\r\n   * @static\r\n   * @field\r\n   * @memberOf fabric.Color\r\n   * @see: http://www.w3.org/TR/CSS2/syndata.html#color-units\r\n   */\r\n  fabric.Color.colorNameMap = {\r\n    aqua:    '#00FFFF',\r\n    black:   '#000000',\r\n    blue:    '#0000FF',\r\n    fuchsia: '#FF00FF',\r\n    gray:    '#808080',\r\n    green:   '#008000',\r\n    lime:    '#00FF00',\r\n    maroon:  '#800000',\r\n    navy:    '#000080',\r\n    olive:   '#808000',\r\n    orange:  '#FFA500',\r\n    purple:  '#800080',\r\n    red:     '#FF0000',\r\n    silver:  '#C0C0C0',\r\n    teal:    '#008080',\r\n    white:   '#FFFFFF',\r\n    yellow:  '#FFFF00'\r\n  };\r\n\r\n  /**\r\n   * @private\r\n   * @param {Number} p\r\n   * @param {Number} q\r\n   * @param {Number} t\r\n   * @return {Number}\r\n   */\r\n  function hue2rgb(p, q, t) {\r\n    if (t < 0) {\r\n      t += 1;\r\n    }\r\n    if (t > 1) {\r\n      t -= 1;\r\n    }\r\n    if (t < 1/6) {\r\n      return p + (q - p) * 6 * t;\r\n    }\r\n    if (t < 1/2) {\r\n      return q;\r\n    }\r\n    if (t < 2/3) {\r\n      return p + (q - p) * (2/3 - t) * 6;\r\n    }\r\n    return p;\r\n  }\r\n\r\n  /**\r\n   * Returns new color object, when given a color in RGB format\r\n   * @memberOf fabric.Color\r\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)\r\n   * @return {fabric.Color}\r\n   */\r\n  fabric.Color.fromRgb = function(color) {\r\n    return Color.fromSource(Color.sourceFromRgb(color));\r\n  };\r\n\r\n  /**\r\n   * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format\r\n   * @memberOf fabric.Color\r\n   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)\r\n   * @return {Array} source\r\n   */\r\n  fabric.Color.sourceFromRgb = function(color) {\r\n    var match = color.match(Color.reRGBa);\r\n    if (match) {\r\n      var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),\r\n          g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),\r\n          b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);\r\n\r\n      return [\r\n        parseInt(r, 10),\r\n        parseInt(g, 10),\r\n        parseInt(b, 10),\r\n        match[4] ? parseFloat(match[4]) : 1\r\n      ];\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns new color object, when given a color in RGBA format\r\n   * @static\r\n   * @function\r\n   * @memberOf fabric.Color\r\n   * @param {String} color\r\n   * @return {fabric.Color}\r\n   */\r\n  fabric.Color.fromRgba = Color.fromRgb;\r\n\r\n  /**\r\n   * Returns new color object, when given a color in HSL format\r\n   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)\r\n   * @memberOf fabric.Color\r\n   * @return {fabric.Color}\r\n   */\r\n  fabric.Color.fromHsl = function(color) {\r\n    return Color.fromSource(Color.sourceFromHsl(color));\r\n  };\r\n\r\n  /**\r\n   * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.\r\n   * Adapted from <a href=\"https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html\">https://github.com/mjijackson</a>\r\n   * @memberOf fabric.Color\r\n   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)\r\n   * @return {Array} source\r\n   * @see http://http://www.w3.org/TR/css3-color/#hsl-color\r\n   */\r\n  fabric.Color.sourceFromHsl = function(color) {\r\n    var match = color.match(Color.reHSLa);\r\n    if (!match) {\r\n      return;\r\n    }\r\n\r\n    var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,\r\n        s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),\r\n        l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),\r\n        r, g, b;\r\n\r\n    if (s === 0) {\r\n      r = g = b = l;\r\n    }\r\n    else {\r\n      var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,\r\n          p = l * 2 - q;\r\n\r\n      r = hue2rgb(p, q, h + 1/3);\r\n      g = hue2rgb(p, q, h);\r\n      b = hue2rgb(p, q, h - 1/3);\r\n    }\r\n\r\n    return [\r\n      Math.round(r * 255),\r\n      Math.round(g * 255),\r\n      Math.round(b * 255),\r\n      match[4] ? parseFloat(match[4]) : 1\r\n    ];\r\n  };\r\n\r\n  /**\r\n   * Returns new color object, when given a color in HSLA format\r\n   * @static\r\n   * @function\r\n   * @memberOf fabric.Color\r\n   * @param {String} color\r\n   * @return {fabric.Color}\r\n   */\r\n  fabric.Color.fromHsla = Color.fromHsl;\r\n\r\n  /**\r\n   * Returns new color object, when given a color in HEX format\r\n   * @static\r\n   * @memberOf fabric.Color\r\n   * @param {String} color Color value ex: FF5555\r\n   * @return {fabric.Color}\r\n   */\r\n  fabric.Color.fromHex = function(color) {\r\n    return Color.fromSource(Color.sourceFromHex(color));\r\n  };\r\n\r\n  /**\r\n   * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in HEX format\r\n   * @static\r\n   * @memberOf fabric.Color\r\n   * @param {String} color ex: FF5555\r\n   * @return {Array} source\r\n   */\r\n  fabric.Color.sourceFromHex = function(color) {\r\n    if (color.match(Color.reHex)) {\r\n      var value = color.slice(color.indexOf('#') + 1),\r\n          isShortNotation = (value.length === 3),\r\n          r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),\r\n          g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),\r\n          b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6);\r\n\r\n      return [\r\n        parseInt(r, 16),\r\n        parseInt(g, 16),\r\n        parseInt(b, 16),\r\n        1\r\n      ];\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])\r\n   * @static\r\n   * @memberOf fabric.Color\r\n   * @param {Array} source\r\n   * @return {fabric.Color}\r\n   */\r\n  fabric.Color.fromSource = function(source) {\r\n    var oColor = new Color();\r\n    oColor.setSource(source);\r\n    return oColor;\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function() {\r\n\r\n  /* _FROM_SVG_START_ */\r\n  function getColorStop(el) {\r\n    var style = el.getAttribute('style'),\r\n        offset = el.getAttribute('offset') || 0,\r\n        color, colorAlpha, opacity;\r\n\r\n    // convert percents to absolute values\r\n    offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);\r\n    offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;\r\n    if (style) {\r\n      var keyValuePairs = style.split(/\\s*;\\s*/);\r\n\r\n      if (keyValuePairs[keyValuePairs.length - 1] === '') {\r\n        keyValuePairs.pop();\r\n      }\r\n\r\n      for (var i = keyValuePairs.length; i--; ) {\r\n\r\n        var split = keyValuePairs[i].split(/\\s*:\\s*/),\r\n            key = split[0].trim(),\r\n            value = split[1].trim();\r\n\r\n        if (key === 'stop-color') {\r\n          color = value;\r\n        }\r\n        else if (key === 'stop-opacity') {\r\n          opacity = value;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!color) {\r\n      color = el.getAttribute('stop-color') || 'rgb(0,0,0)';\r\n    }\r\n    if (!opacity) {\r\n      opacity = el.getAttribute('stop-opacity');\r\n    }\r\n\r\n    color = new fabric.Color(color);\r\n    colorAlpha = color.getAlpha();\r\n    opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);\r\n    opacity *= colorAlpha;\r\n\r\n    return {\r\n      offset: offset,\r\n      color: color.toRgb(),\r\n      opacity: opacity\r\n    };\r\n  }\r\n\r\n  function getLinearCoords(el) {\r\n    return {\r\n      x1: el.getAttribute('x1') || 0,\r\n      y1: el.getAttribute('y1') || 0,\r\n      x2: el.getAttribute('x2') || '100%',\r\n      y2: el.getAttribute('y2') || 0\r\n    };\r\n  }\r\n\r\n  function getRadialCoords(el) {\r\n    return {\r\n      x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',\r\n      y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',\r\n      r1: 0,\r\n      x2: el.getAttribute('cx') || '50%',\r\n      y2: el.getAttribute('cy') || '50%',\r\n      r2: el.getAttribute('r') || '50%'\r\n    };\r\n  }\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Gradient class\r\n   * @class fabric.Gradient\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#gradients}\r\n   * @see {@link fabric.Gradient#initialize} for constructor definition\r\n   */\r\n  fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {\r\n\r\n    /**\r\n     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups\r\n     * @type Number\r\n     * @default 0\r\n     */\r\n    offsetX: 0,\r\n\r\n    /**\r\n     * Vertical offset for aligning gradients coming from SVG when outside pathgroups\r\n     * @type Number\r\n     * @default 0\r\n     */\r\n    offsetY: 0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} [options] Options object with type, coords, gradientUnits and colorStops\r\n     * @return {fabric.Gradient} thisArg\r\n     */\r\n    initialize: function(options) {\r\n      options || (options = { });\r\n\r\n      var coords = { };\r\n\r\n      this.id = fabric.Object.__uid++;\r\n      this.type = options.type || 'linear';\r\n\r\n      coords = {\r\n        x1: options.coords.x1 || 0,\r\n        y1: options.coords.y1 || 0,\r\n        x2: options.coords.x2 || 0,\r\n        y2: options.coords.y2 || 0\r\n      };\r\n\r\n      if (this.type === 'radial') {\r\n        coords.r1 = options.coords.r1 || 0;\r\n        coords.r2 = options.coords.r2 || 0;\r\n      }\r\n      this.coords = coords;\r\n      this.colorStops = options.colorStops.slice();\r\n      if (options.gradientTransform) {\r\n        this.gradientTransform = options.gradientTransform;\r\n      }\r\n      this.offsetX = options.offsetX || this.offsetX;\r\n      this.offsetY = options.offsetY || this.offsetY;\r\n    },\r\n\r\n    /**\r\n     * Adds another colorStop\r\n     * @param {Object} colorStop Object with offset and color\r\n     * @return {fabric.Gradient} thisArg\r\n     */\r\n    addColorStop: function(colorStop) {\r\n      for (var position in colorStop) {\r\n        var color = new fabric.Color(colorStop[position]);\r\n        this.colorStops.push({\r\n          offset: position,\r\n          color: color.toRgb(),\r\n          opacity: color.getAlpha()\r\n        });\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of a gradient\r\n     * @return {Object}\r\n     */\r\n    toObject: function() {\r\n      return {\r\n        type: this.type,\r\n        coords: this.coords,\r\n        colorStops: this.colorStops,\r\n        offsetX: this.offsetX,\r\n        offsetY: this.offsetY\r\n      };\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of an gradient\r\n     * @param {Object} object Object to create a gradient for\r\n     * @param {Boolean} normalize Whether coords should be normalized\r\n     * @return {String} SVG representation of an gradient (linear/radial)\r\n     */\r\n    toSVG: function(object) {\r\n      var coords = fabric.util.object.clone(this.coords),\r\n          markup, commonAttributes;\r\n\r\n      // colorStops must be sorted ascending\r\n      this.colorStops.sort(function(a, b) {\r\n        return a.offset - b.offset;\r\n      });\r\n\r\n      if (!(object.group && object.group.type === 'path-group')) {\r\n        for (var prop in coords) {\r\n          if (prop === 'x1' || prop === 'x2' || prop === 'r2') {\r\n            coords[prop] += this.offsetX - object.width / 2;\r\n          }\r\n          else if (prop === 'y1' || prop === 'y2') {\r\n            coords[prop] += this.offsetY - object.height / 2;\r\n          }\r\n        }\r\n      }\r\n\r\n      commonAttributes = 'id=\"SVGID_' + this.id +\r\n                     '\" gradientUnits=\"userSpaceOnUse\"';\r\n      if (this.gradientTransform) {\r\n        commonAttributes += ' gradientTransform=\"matrix(' + this.gradientTransform.join(' ') + ')\" ';\r\n      }\r\n      if (this.type === 'linear') {\r\n        markup = [\r\n          //jscs:disable validateIndentation\r\n          '<linearGradient ',\r\n            commonAttributes,\r\n            ' x1=\"', coords.x1,\r\n            '\" y1=\"', coords.y1,\r\n            '\" x2=\"', coords.x2,\r\n            '\" y2=\"', coords.y2,\r\n          '\">\\n'\r\n          //jscs:enable validateIndentation\r\n        ];\r\n      }\r\n      else if (this.type === 'radial') {\r\n        markup = [\r\n          //jscs:disable validateIndentation\r\n          '<radialGradient ',\r\n            commonAttributes,\r\n            ' cx=\"', coords.x2,\r\n            '\" cy=\"', coords.y2,\r\n            '\" r=\"', coords.r2,\r\n            '\" fx=\"', coords.x1,\r\n            '\" fy=\"', coords.y1,\r\n          '\">\\n'\r\n          //jscs:enable validateIndentation\r\n        ];\r\n      }\r\n\r\n      for (var i = 0; i < this.colorStops.length; i++) {\r\n        markup.push(\r\n          //jscs:disable validateIndentation\r\n          '<stop ',\r\n            'offset=\"', (this.colorStops[i].offset * 100) + '%',\r\n            '\" style=\"stop-color:', this.colorStops[i].color,\r\n            (this.colorStops[i].opacity != null ? ';stop-opacity: ' + this.colorStops[i].opacity : ';'),\r\n          '\"/>\\n'\r\n          //jscs:enable validateIndentation\r\n        );\r\n      }\r\n\r\n      markup.push((this.type === 'linear' ? '</linearGradient>\\n' : '</radialGradient>\\n'));\r\n\r\n      return markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns an instance of CanvasGradient\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @return {CanvasGradient}\r\n     */\r\n    toLive: function(ctx, object) {\r\n      var gradient, prop, coords = fabric.util.object.clone(this.coords);\r\n\r\n      if (!this.type) {\r\n        return;\r\n      }\r\n\r\n      if (object.group && object.group.type === 'path-group') {\r\n        for (prop in coords) {\r\n          if (prop === 'x1' || prop === 'x2') {\r\n            coords[prop] += -this.offsetX + object.width / 2;\r\n          }\r\n          else if (prop === 'y1' || prop === 'y2') {\r\n            coords[prop] += -this.offsetY + object.height / 2;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.type === 'linear') {\r\n        gradient = ctx.createLinearGradient(\r\n          coords.x1, coords.y1, coords.x2, coords.y2);\r\n      }\r\n      else if (this.type === 'radial') {\r\n        gradient = ctx.createRadialGradient(\r\n          coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);\r\n      }\r\n\r\n      for (var i = 0, len = this.colorStops.length; i < len; i++) {\r\n        var color = this.colorStops[i].color,\r\n            opacity = this.colorStops[i].opacity,\r\n            offset = this.colorStops[i].offset;\r\n\r\n        if (typeof opacity !== 'undefined') {\r\n          color = new fabric.Color(color).setAlpha(opacity).toRgba();\r\n        }\r\n        gradient.addColorStop(parseFloat(offset), color);\r\n      }\r\n\r\n      return gradient;\r\n    }\r\n  });\r\n\r\n  fabric.util.object.extend(fabric.Gradient, {\r\n\r\n    /* _FROM_SVG_START_ */\r\n    /**\r\n     * Returns {@link fabric.Gradient} instance from an SVG element\r\n     * @static\r\n     * @memberOf fabric.Gradient\r\n     * @param {SVGGradientElement} el SVG gradient element\r\n     * @param {fabric.Object} instance\r\n     * @return {fabric.Gradient} Gradient instance\r\n     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement\r\n     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement\r\n     */\r\n    fromElement: function(el, instance) {\r\n\r\n      /**\r\n       *  @example:\r\n       *\r\n       *  <linearGradient id=\"linearGrad1\">\r\n       *    <stop offset=\"0%\" stop-color=\"white\"/>\r\n       *    <stop offset=\"100%\" stop-color=\"black\"/>\r\n       *  </linearGradient>\r\n       *\r\n       *  OR\r\n       *\r\n       *  <linearGradient id=\"linearGrad2\">\r\n       *    <stop offset=\"0\" style=\"stop-color:rgb(255,255,255)\"/>\r\n       *    <stop offset=\"1\" style=\"stop-color:rgb(0,0,0)\"/>\r\n       *  </linearGradient>\r\n       *\r\n       *  OR\r\n       *\r\n       *  <radialGradient id=\"radialGrad1\">\r\n       *    <stop offset=\"0%\" stop-color=\"white\" stop-opacity=\"1\" />\r\n       *    <stop offset=\"50%\" stop-color=\"black\" stop-opacity=\"0.5\" />\r\n       *    <stop offset=\"100%\" stop-color=\"white\" stop-opacity=\"1\" />\r\n       *  </radialGradient>\r\n       *\r\n       *  OR\r\n       *\r\n       *  <radialGradient id=\"radialGrad2\">\r\n       *    <stop offset=\"0\" stop-color=\"rgb(255,255,255)\" />\r\n       *    <stop offset=\"0.5\" stop-color=\"rgb(0,0,0)\" />\r\n       *    <stop offset=\"1\" stop-color=\"rgb(255,255,255)\" />\r\n       *  </radialGradient>\r\n       *\r\n       */\r\n\r\n      var colorStopEls = el.getElementsByTagName('stop'),\r\n          type = (el.nodeName === 'linearGradient' ? 'linear' : 'radial'),\r\n          gradientUnits = el.getAttribute('gradientUnits') || 'objectBoundingBox',\r\n          gradientTransform = el.getAttribute('gradientTransform'),\r\n          colorStops = [],\r\n          coords = { }, ellipseMatrix;\r\n\r\n      if (type === 'linear') {\r\n        coords = getLinearCoords(el);\r\n      }\r\n      else if (type === 'radial') {\r\n        coords = getRadialCoords(el);\r\n      }\r\n\r\n      for (var i = colorStopEls.length; i--; ) {\r\n        colorStops.push(getColorStop(colorStopEls[i]));\r\n      }\r\n\r\n      ellipseMatrix = _convertPercentUnitsToValues(instance, coords, gradientUnits);\r\n\r\n      var gradient = new fabric.Gradient({\r\n        type: type,\r\n        coords: coords,\r\n        colorStops: colorStops,\r\n        offsetX: -instance.left,\r\n        offsetY: -instance.top\r\n      });\r\n\r\n      if (gradientTransform || ellipseMatrix !== '') {\r\n        gradient.gradientTransform = fabric.parseTransformAttribute((gradientTransform || '') + ellipseMatrix);\r\n      }\r\n      return gradient;\r\n    },\r\n    /* _FROM_SVG_END_ */\r\n\r\n    /**\r\n     * Returns {@link fabric.Gradient} instance from its object representation\r\n     * @static\r\n     * @memberOf fabric.Gradient\r\n     * @param {Object} obj\r\n     * @param {Object} [options] Options object\r\n     */\r\n    forObject: function(obj, options) {\r\n      options || (options = { });\r\n      _convertPercentUnitsToValues(obj, options.coords, 'userSpaceOnUse');\r\n      return new fabric.Gradient(options);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function _convertPercentUnitsToValues(object, options, gradientUnits) {\r\n    var propValue, addFactor = 0, multFactor = 1, ellipseMatrix = '';\r\n    for (var prop in options) {\r\n      propValue = parseFloat(options[prop], 10);\r\n      if (typeof options[prop] === 'string' && /^\\d+%$/.test(options[prop])) {\r\n        multFactor = 0.01;\r\n      }\r\n      else {\r\n        multFactor = 1;\r\n      }\r\n      if (prop === 'x1' || prop === 'x2' || prop === 'r2') {\r\n        multFactor *= gradientUnits === 'objectBoundingBox' ? object.width : 1;\r\n        addFactor = gradientUnits === 'objectBoundingBox' ? object.left || 0 : 0;\r\n      }\r\n      else if (prop === 'y1' || prop === 'y2') {\r\n        multFactor *= gradientUnits === 'objectBoundingBox' ? object.height : 1;\r\n        addFactor = gradientUnits === 'objectBoundingBox' ? object.top || 0 : 0;\r\n      }\r\n      options[prop] = propValue * multFactor + addFactor;\r\n    }\r\n    if (object.type === 'ellipse' &&\r\n        options.r2 !== null &&\r\n        gradientUnits === 'objectBoundingBox' &&\r\n        object.rx !== object.ry) {\r\n\r\n      var scaleFactor = object.ry/object.rx;\r\n      ellipseMatrix = ' scale(1, ' + scaleFactor + ')';\r\n      if (options.y1) {\r\n        options.y1 /= scaleFactor;\r\n      }\r\n      if (options.y2) {\r\n        options.y2 /= scaleFactor;\r\n      }\r\n    }\r\n    return ellipseMatrix;\r\n  }\r\n})();\r\n\r\n\r\n/**\r\n * Pattern class\r\n * @class fabric.Pattern\r\n * @see {@link http://fabricjs.com/patterns/|Pattern demo}\r\n * @see {@link http://fabricjs.com/dynamic-patterns/|DynamicPattern demo}\r\n * @see {@link fabric.Pattern#initialize} for constructor definition\r\n */\r\nfabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {\r\n\r\n  /**\r\n   * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)\r\n   * @type String\r\n   * @default\r\n   */\r\n  repeat: 'repeat',\r\n\r\n  /**\r\n   * Pattern horizontal offset from object's left/top corner\r\n   * @type Number\r\n   * @default\r\n   */\r\n  offsetX: 0,\r\n\r\n  /**\r\n   * Pattern vertical offset from object's left/top corner\r\n   * @type Number\r\n   * @default\r\n   */\r\n  offsetY: 0,\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Pattern} thisArg\r\n   */\r\n  initialize: function(options) {\r\n    options || (options = { });\r\n\r\n    this.id = fabric.Object.__uid++;\r\n\r\n    if (options.source) {\r\n      if (typeof options.source === 'string') {\r\n        // function string\r\n        if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {\r\n          this.source = new Function(fabric.util.getFunctionBody(options.source));\r\n        }\r\n        else {\r\n          // img src string\r\n          var _this = this;\r\n          this.source = fabric.util.createImage();\r\n          fabric.util.loadImage(options.source, function(img) {\r\n            _this.source = img;\r\n          });\r\n        }\r\n      }\r\n      else {\r\n        // img element\r\n        this.source = options.source;\r\n      }\r\n    }\r\n    if (options.repeat) {\r\n      this.repeat = options.repeat;\r\n    }\r\n    if (options.offsetX) {\r\n      this.offsetX = options.offsetX;\r\n    }\r\n    if (options.offsetY) {\r\n      this.offsetY = options.offsetY;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns object representation of a pattern\r\n   * @return {Object} Object representation of a pattern instance\r\n   */\r\n  toObject: function() {\r\n\r\n    var source;\r\n\r\n    // callback\r\n    if (typeof this.source === 'function') {\r\n      source = String(this.source);\r\n    }\r\n    // <img> element\r\n    else if (typeof this.source.src === 'string') {\r\n      source = this.source.src;\r\n    }\r\n    // <canvas> element\r\n    else if (typeof this.source === 'object' && this.source.toDataURL) {\r\n      source = this.source.toDataURL();\r\n    }\r\n\r\n    return {\r\n      source: source,\r\n      repeat: this.repeat,\r\n      offsetX: this.offsetX,\r\n      offsetY: this.offsetY\r\n    };\r\n  },\r\n\r\n  /* _TO_SVG_START_ */\r\n  /**\r\n   * Returns SVG representation of a pattern\r\n   * @param {fabric.Object} object\r\n   * @return {String} SVG representation of a pattern\r\n   */\r\n  toSVG: function(object) {\r\n    var patternSource = typeof this.source === 'function' ? this.source() : this.source,\r\n        patternWidth = patternSource.width / object.getWidth(),\r\n        patternHeight = patternSource.height / object.getHeight(),\r\n        patternOffsetX = this.offsetX / object.getWidth(),\r\n        patternOffsetY = this.offsetY / object.getHeight(),\r\n        patternImgSrc = '';\r\n    if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {\r\n      patternHeight = 1;\r\n    }\r\n    if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {\r\n      patternWidth = 1;\r\n    }\r\n    if (patternSource.src) {\r\n      patternImgSrc = patternSource.src;\r\n    }\r\n    else if (patternSource.toDataURL) {\r\n      patternImgSrc = patternSource.toDataURL();\r\n    }\r\n\r\n    return '<pattern id=\"SVGID_' + this.id +\r\n                  '\" x=\"' + patternOffsetX +\r\n                  '\" y=\"' + patternOffsetY +\r\n                  '\" width=\"' + patternWidth +\r\n                  '\" height=\"' + patternHeight + '\">\\n' +\r\n             '<image x=\"0\" y=\"0\"' +\r\n                    ' width=\"' + patternSource.width +\r\n                    '\" height=\"' + patternSource.height +\r\n                    '\" xlink:href=\"' + patternImgSrc +\r\n             '\"></image>\\n' +\r\n           '</pattern>\\n';\r\n  },\r\n  /* _TO_SVG_END_ */\r\n\r\n  /**\r\n   * Returns an instance of CanvasPattern\r\n   * @param {CanvasRenderingContext2D} ctx Context to create pattern\r\n   * @return {CanvasPattern}\r\n   */\r\n  toLive: function(ctx) {\r\n    var source = typeof this.source === 'function'\r\n      ? this.source()\r\n      : this.source;\r\n\r\n    // if the image failed to load, return, and allow rest to continue loading\r\n    if (!source) {\r\n      return '';\r\n    }\r\n\r\n    // if an image\r\n    if (typeof source.src !== 'undefined') {\r\n      if (!source.complete) {\r\n        return '';\r\n      }\r\n      if (source.naturalWidth === 0 || source.naturalHeight === 0) {\r\n        return '';\r\n      }\r\n    }\r\n    return ctx.createPattern(source, this.repeat);\r\n  }\r\n});\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      toFixed = fabric.util.toFixed;\r\n\r\n  if (fabric.Shadow) {\r\n    fabric.warn('fabric.Shadow is already defined.');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Shadow class\r\n   * @class fabric.Shadow\r\n   * @see {@link http://fabricjs.com/shadows/|Shadow demo}\r\n   * @see {@link fabric.Shadow#initialize} for constructor definition\r\n   */\r\n  fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {\r\n\r\n    /**\r\n     * Shadow color\r\n     * @type String\r\n     * @default\r\n     */\r\n    color: 'rgb(0,0,0)',\r\n\r\n    /**\r\n     * Shadow blur\r\n     * @type Number\r\n     */\r\n    blur: 0,\r\n\r\n    /**\r\n     * Shadow horizontal offset\r\n     * @type Number\r\n     * @default\r\n     */\r\n    offsetX: 0,\r\n\r\n    /**\r\n     * Shadow vertical offset\r\n     * @type Number\r\n     * @default\r\n     */\r\n    offsetY: 0,\r\n\r\n    /**\r\n     * Whether the shadow should affect stroke operations\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    affectStroke: false,\r\n\r\n    /**\r\n     * Indicates whether toObject should include default values\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    includeDefaultValues: true,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetX properties or string (e.g. \"rgba(0,0,0,0.2) 2px 2px 10px, \"2px 2px 10px rgba(0,0,0,0.2)\")\r\n     * @return {fabric.Shadow} thisArg\r\n     */\r\n    initialize: function(options) {\r\n\r\n      if (typeof options === 'string') {\r\n        options = this._parseShadow(options);\r\n      }\r\n\r\n      for (var prop in options) {\r\n        this[prop] = options[prop];\r\n      }\r\n\r\n      this.id = fabric.Object.__uid++;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} shadow Shadow value to parse\r\n     * @return {Object} Shadow object with color, offsetX, offsetY and blur\r\n     */\r\n    _parseShadow: function(shadow) {\r\n      var shadowStr = shadow.trim(),\r\n          offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [ ],\r\n          color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';\r\n\r\n      return {\r\n        color: color.trim(),\r\n        offsetX: parseInt(offsetsAndBlur[1], 10) || 0,\r\n        offsetY: parseInt(offsetsAndBlur[2], 10) || 0,\r\n        blur: parseInt(offsetsAndBlur[3], 10) || 0\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Returns a string representation of an instance\r\n     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow\r\n     * @return {String} Returns CSS3 text-shadow declaration\r\n     */\r\n    toString: function() {\r\n      return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of a shadow\r\n     * @param {fabric.Object} object\r\n     * @return {String} SVG representation of a shadow\r\n     */\r\n    toSVG: function(object) {\r\n      var fBoxX = 40, fBoxY = 40;\r\n\r\n      if (object.width && object.height) {\r\n        //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion\r\n        // we add some extra space to filter box to contain the blur ( 20 )\r\n        fBoxX = toFixed((Math.abs(this.offsetX) + this.blur) / object.width, 2) * 100 + 20;\r\n        fBoxY = toFixed((Math.abs(this.offsetY) + this.blur) / object.height, 2) * 100 + 20;\r\n      }\r\n\r\n      return (\r\n        '<filter id=\"SVGID_' + this.id + '\" y=\"-' + fBoxY + '%\" height=\"' + (100 + 2 * fBoxY) + '%\" ' +\r\n          'x=\"-' + fBoxX + '%\" width=\"' + (100 + 2 * fBoxX) + '%\" ' + '>\\n' +\r\n          '\\t<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"' +\r\n            toFixed(this.blur ? this.blur / 2 : 0, 3) + '\"></feGaussianBlur>\\n' +\r\n          '\\t<feOffset dx=\"' + this.offsetX + '\" dy=\"' + this.offsetY + '\" result=\"oBlur\" ></feOffset>\\n' +\r\n          '\\t<feFlood flood-color=\"' + this.color + '\"/>\\n' +\r\n          '\\t<feComposite in2=\"oBlur\" operator=\"in\" />\\n' +\r\n          '\\t<feMerge>\\n' +\r\n            '\\t\\t<feMergeNode></feMergeNode>\\n' +\r\n            '\\t\\t<feMergeNode in=\"SourceGraphic\"></feMergeNode>\\n' +\r\n          '\\t</feMerge>\\n' +\r\n        '</filter>\\n');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns object representation of a shadow\r\n     * @return {Object} Object representation of a shadow instance\r\n     */\r\n    toObject: function() {\r\n      if (this.includeDefaultValues) {\r\n        return {\r\n          color: this.color,\r\n          blur: this.blur,\r\n          offsetX: this.offsetX,\r\n          offsetY: this.offsetY\r\n        };\r\n      }\r\n      var obj = { }, proto = fabric.Shadow.prototype;\r\n      if (this.color !== proto.color) {\r\n        obj.color = this.color;\r\n      }\r\n      if (this.blur !== proto.blur) {\r\n        obj.blur = this.blur;\r\n      }\r\n      if (this.offsetX !== proto.offsetX) {\r\n        obj.offsetX = this.offsetX;\r\n      }\r\n      if (this.offsetY !== proto.offsetY) {\r\n        obj.offsetY = this.offsetY;\r\n      }\r\n      return obj;\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Regex matching shadow offsetX, offsetY and blur (ex: \"2px 2px 10px rgba(0,0,0,0.2)\", \"rgb(0,255,0) 2px 2px\")\r\n   * @static\r\n   * @field\r\n   * @memberOf fabric.Shadow\r\n   */\r\n  fabric.Shadow.reOffsetsAndBlur = /(?:\\s|^)(-?\\d+(?:px)?(?:\\s?|$))?(-?\\d+(?:px)?(?:\\s?|$))?(\\d+(?:px)?)?(?:\\s?|$)(?:$|\\s)/;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function () {\r\n\r\n  'use strict';\r\n\r\n  if (fabric.StaticCanvas) {\r\n    fabric.warn('fabric.StaticCanvas is already defined.');\r\n    return;\r\n  }\r\n\r\n  // aliases for faster resolution\r\n  var extend = fabric.util.object.extend,\r\n      getElementOffset = fabric.util.getElementOffset,\r\n      removeFromArray = fabric.util.removeFromArray,\r\n\r\n      CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');\r\n\r\n  /**\r\n   * Static canvas class\r\n   * @class fabric.StaticCanvas\r\n   * @mixes fabric.Collection\r\n   * @mixes fabric.Observable\r\n   * @see {@link http://fabricjs.com/static_canvas/|StaticCanvas demo}\r\n   * @see {@link fabric.StaticCanvas#initialize} for constructor definition\r\n   * @fires before:render\r\n   * @fires after:render\r\n   * @fires canvas:cleared\r\n   * @fires object:added\r\n   * @fires object:removed\r\n   */\r\n  fabric.StaticCanvas = fabric.util.createClass(/** @lends fabric.StaticCanvas.prototype */ {\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\r\n     * @param {Object} [options] Options object\r\n     * @return {Object} thisArg\r\n     */\r\n    initialize: function(el, options) {\r\n      options || (options = { });\r\n\r\n      this._initStatic(el, options);\r\n      fabric.StaticCanvas.activeInstance = this;\r\n    },\r\n\r\n    /**\r\n     * Background color of canvas instance.\r\n     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.\r\n     * @type {(String|fabric.Pattern)}\r\n     * @default\r\n     */\r\n    backgroundColor: '',\r\n\r\n    /**\r\n     * Background image of canvas instance.\r\n     * Should be set via {@link fabric.StaticCanvas#setBackgroundImage}.\r\n     * <b>Backwards incompatibility note:</b> The \"backgroundImageOpacity\"\r\n     * and \"backgroundImageStretch\" properties are deprecated since 1.3.9.\r\n     * Use {@link fabric.Image#opacity}, {@link fabric.Image#width} and {@link fabric.Image#height}.\r\n     * @type fabric.Image\r\n     * @default\r\n     */\r\n    backgroundImage: null,\r\n\r\n    /**\r\n     * Overlay color of canvas instance.\r\n     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}\r\n     * @since 1.3.9\r\n     * @type {(String|fabric.Pattern)}\r\n     * @default\r\n     */\r\n    overlayColor: '',\r\n\r\n    /**\r\n     * Overlay image of canvas instance.\r\n     * Should be set via {@link fabric.StaticCanvas#setOverlayImage}.\r\n     * <b>Backwards incompatibility note:</b> The \"overlayImageLeft\"\r\n     * and \"overlayImageTop\" properties are deprecated since 1.3.9.\r\n     * Use {@link fabric.Image#left} and {@link fabric.Image#top}.\r\n     * @type fabric.Image\r\n     * @default\r\n     */\r\n    overlayImage: null,\r\n\r\n    /**\r\n     * Indicates whether toObject/toDatalessObject should include default values\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    includeDefaultValues: true,\r\n\r\n    /**\r\n     * Indicates whether objects' state should be saved\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    stateful: true,\r\n\r\n    /**\r\n     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove} should also re-render canvas.\r\n     * Disabling this option could give a great performance boost when adding/removing a lot of objects to/from canvas at once\r\n     * (followed by a manual rendering after addition/deletion)\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    renderOnAddRemove: true,\r\n\r\n    /**\r\n     * Function that determines clipping of entire canvas area\r\n     * Being passed context as first argument. See clipping canvas area in {@link https://github.com/kangax/fabric.js/wiki/FAQ}\r\n     * @type Function\r\n     * @default\r\n     */\r\n    clipTo: null,\r\n\r\n    /**\r\n     * Indicates whether object controls (borders/controls) are rendered above overlay image\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    controlsAboveOverlay: false,\r\n\r\n    /**\r\n     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    allowTouchScrolling: false,\r\n\r\n    /**\r\n     * Indicates whether this canvas will use image smoothing, this is on by default in browsers\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    imageSmoothingEnabled: true,\r\n\r\n    /**\r\n     * Indicates whether objects should remain in current stack position when selected. When false objects are brought to top and rendered as part of the selection group\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    preserveObjectStacking: false,\r\n\r\n    /**\r\n     * The transformation (in the format of Canvas transform) which focuses the viewport\r\n     * @type Array\r\n     * @default\r\n     */\r\n    viewportTransform: [1, 0, 0, 1, 0, 0],\r\n\r\n    /**\r\n     * Callback; invoked right before object is about to be scaled/rotated\r\n     */\r\n    onBeforeScaleRotate: function () {\r\n      /* NOOP */\r\n    },\r\n\r\n    /**\r\n     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens\r\n     */\r\n    enableRetinaScaling: true,\r\n\r\n    /**\r\n     * @private\r\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initStatic: function(el, options) {\r\n      this._objects = [];\r\n\r\n      this._createLowerCanvas(el);\r\n      this._initOptions(options);\r\n      this._setImageSmoothing();\r\n\r\n      // only initialize retina scaling once\r\n      if (!this.interactive) {\r\n        this._initRetinaScaling();\r\n      }\r\n\r\n      if (options.overlayImage) {\r\n        this.setOverlayImage(options.overlayImage, this.renderAll.bind(this));\r\n      }\r\n      if (options.backgroundImage) {\r\n        this.setBackgroundImage(options.backgroundImage, this.renderAll.bind(this));\r\n      }\r\n      if (options.backgroundColor) {\r\n        this.setBackgroundColor(options.backgroundColor, this.renderAll.bind(this));\r\n      }\r\n      if (options.overlayColor) {\r\n        this.setOverlayColor(options.overlayColor, this.renderAll.bind(this));\r\n      }\r\n      this.calcOffset();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _initRetinaScaling: function() {\r\n      if (fabric.devicePixelRatio === 1 || !this.enableRetinaScaling) {\r\n        return;\r\n      }\r\n\r\n      this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);\r\n      this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);\r\n\r\n      this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);\r\n    },\r\n\r\n    /**\r\n     * Calculates canvas element offset relative to the document\r\n     * This method is also attached as \"resize\" event handler of window\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable\r\n     */\r\n    calcOffset: function () {\r\n      this._offset = getElementOffset(this.lowerCanvasEl);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas\r\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to\r\n     * @param {Function} callback callback to invoke when image is loaded and set as an overlay\r\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}\r\n     * @example <caption>Normal overlayImage with left/top = 0</caption>\r\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\r\n     *   // Needed to position overlayImage at 0/0\r\n     *   originX: 'left',\r\n     *   originY: 'top'\r\n     * });\r\n     * @example <caption>overlayImage with different properties</caption>\r\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\r\n     *   opacity: 0.5,\r\n     *   angle: 45,\r\n     *   left: 400,\r\n     *   top: 400,\r\n     *   originX: 'left',\r\n     *   originY: 'top'\r\n     * });\r\n     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>\r\n     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img) {\r\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\r\n     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));\r\n     * });\r\n     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>\r\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\r\n     *   width: canvas.width,\r\n     *   height: canvas.height,\r\n     *   // Needed to position overlayImage at 0/0\r\n     *   originX: 'left',\r\n     *   originY: 'top'\r\n     * });\r\n     * @example <caption>overlayImage loaded from cross-origin</caption>\r\n     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {\r\n     *   opacity: 0.5,\r\n     *   angle: 45,\r\n     *   left: 400,\r\n     *   top: 400,\r\n     *   originX: 'left',\r\n     *   originY: 'top',\r\n     *   crossOrigin: 'anonymous'\r\n     * });\r\n     */\r\n    setOverlayImage: function (image, callback, options) {\r\n      return this.__setBgOverlayImage('overlayImage', image, callback, options);\r\n    },\r\n\r\n    /**\r\n     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas\r\n     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to\r\n     * @param {Function} callback Callback to invoke when image is loaded and set as background\r\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/YH9yD/|jsFiddle demo}\r\n     * @example <caption>Normal backgroundImage with left/top = 0</caption>\r\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\r\n     *   // Needed to position backgroundImage at 0/0\r\n     *   originX: 'left',\r\n     *   originY: 'top'\r\n     * });\r\n     * @example <caption>backgroundImage with different properties</caption>\r\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\r\n     *   opacity: 0.5,\r\n     *   angle: 45,\r\n     *   left: 400,\r\n     *   top: 400,\r\n     *   originX: 'left',\r\n     *   originY: 'top'\r\n     * });\r\n     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>\r\n     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img) {\r\n     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});\r\n     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));\r\n     * });\r\n     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>\r\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\r\n     *   width: canvas.width,\r\n     *   height: canvas.height,\r\n     *   // Needed to position backgroundImage at 0/0\r\n     *   originX: 'left',\r\n     *   originY: 'top'\r\n     * });\r\n     * @example <caption>backgroundImage loaded from cross-origin</caption>\r\n     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {\r\n     *   opacity: 0.5,\r\n     *   angle: 45,\r\n     *   left: 400,\r\n     *   top: 400,\r\n     *   originX: 'left',\r\n     *   originY: 'top',\r\n     *   crossOrigin: 'anonymous'\r\n     * });\r\n     */\r\n    setBackgroundImage: function (image, callback, options) {\r\n      return this.__setBgOverlayImage('backgroundImage', image, callback, options);\r\n    },\r\n\r\n    /**\r\n     * Sets {@link fabric.StaticCanvas#overlayColor|background color} for this canvas\r\n     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set background color to\r\n     * @param {Function} callback Callback to invoke when background color is set\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}\r\n     * @example <caption>Normal overlayColor - color value</caption>\r\n     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\r\n     * @example <caption>fabric.Pattern used as overlayColor</caption>\r\n     * canvas.setOverlayColor({\r\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\r\n     * }, canvas.renderAll.bind(canvas));\r\n     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>\r\n     * canvas.setOverlayColor({\r\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\r\n     *   repeat: 'repeat',\r\n     *   offsetX: 200,\r\n     *   offsetY: 100\r\n     * }, canvas.renderAll.bind(canvas));\r\n     */\r\n    setOverlayColor: function(overlayColor, callback) {\r\n      return this.__setBgOverlayColor('overlayColor', overlayColor, callback);\r\n    },\r\n\r\n    /**\r\n     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas\r\n     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to\r\n     * @param {Function} callback Callback to invoke when background color is set\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}\r\n     * @example <caption>Normal backgroundColor - color value</caption>\r\n     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));\r\n     * @example <caption>fabric.Pattern used as backgroundColor</caption>\r\n     * canvas.setBackgroundColor({\r\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'\r\n     * }, canvas.renderAll.bind(canvas));\r\n     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>\r\n     * canvas.setBackgroundColor({\r\n     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',\r\n     *   repeat: 'repeat',\r\n     *   offsetX: 200,\r\n     *   offsetY: 100\r\n     * }, canvas.renderAll.bind(canvas));\r\n     */\r\n    setBackgroundColor: function(backgroundColor, callback) {\r\n      return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-imagesmoothingenabled|WhatWG Canvas Standard}\r\n     */\r\n    _setImageSmoothing: function() {\r\n      var ctx = this.getContext();\r\n\r\n      if (typeof ctx.imageSmoothingEnabled !== 'undefined') {\r\n        ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;\r\n        return;\r\n      }\r\n      ctx.webkitImageSmoothingEnabled = this.imageSmoothingEnabled;\r\n      ctx.mozImageSmoothingEnabled    = this.imageSmoothingEnabled;\r\n      ctx.msImageSmoothingEnabled     = this.imageSmoothingEnabled;\r\n      ctx.oImageSmoothingEnabled      = this.imageSmoothingEnabled;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}\r\n     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})\r\n     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to\r\n     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay\r\n     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.\r\n     */\r\n    __setBgOverlayImage: function(property, image, callback, options) {\r\n      if (typeof image === 'string') {\r\n        fabric.util.loadImage(image, function(img) {\r\n          this[property] = new fabric.Image(img, options);\r\n          callback && callback();\r\n        }, this, options && options.crossOrigin);\r\n      }\r\n      else {\r\n        options && image.setOptions(options);\r\n        this[property] = image;\r\n        callback && callback();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}\r\n     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})\r\n     * @param {(Object|String|null)} color Object with pattern information, color value or null\r\n     * @param {Function} [callback] Callback is invoked when color is set\r\n     */\r\n    __setBgOverlayColor: function(property, color, callback) {\r\n      if (color && color.source) {\r\n        var _this = this;\r\n        fabric.util.loadImage(color.source, function(img) {\r\n          _this[property] = new fabric.Pattern({\r\n            source: img,\r\n            repeat: color.repeat,\r\n            offsetX: color.offsetX,\r\n            offsetY: color.offsetY\r\n          });\r\n          callback && callback();\r\n        });\r\n      }\r\n      else {\r\n        this[property] = color;\r\n        callback && callback();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _createCanvasElement: function() {\r\n      var element = fabric.document.createElement('canvas');\r\n      if (!element.style) {\r\n        element.style = { };\r\n      }\r\n      if (!element) {\r\n        throw CANVAS_INIT_ERROR;\r\n      }\r\n      this._initCanvasElement(element);\r\n      return element;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {HTMLElement} element\r\n     */\r\n    _initCanvasElement: function(element) {\r\n      fabric.util.createCanvasElement(element);\r\n\r\n      if (typeof element.getContext === 'undefined') {\r\n        throw CANVAS_INIT_ERROR;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initOptions: function (options) {\r\n      for (var prop in options) {\r\n        this[prop] = options[prop];\r\n      }\r\n\r\n      this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0;\r\n      this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0;\r\n\r\n      if (!this.lowerCanvasEl.style) {\r\n        return;\r\n      }\r\n\r\n      this.lowerCanvasEl.width = this.width;\r\n      this.lowerCanvasEl.height = this.height;\r\n\r\n      this.lowerCanvasEl.style.width = this.width + 'px';\r\n      this.lowerCanvasEl.style.height = this.height + 'px';\r\n\r\n      this.viewportTransform = this.viewportTransform.slice();\r\n    },\r\n\r\n    /**\r\n     * Creates a bottom canvas\r\n     * @private\r\n     * @param {HTMLElement} [canvasEl]\r\n     */\r\n    _createLowerCanvas: function (canvasEl) {\r\n      this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();\r\n      this._initCanvasElement(this.lowerCanvasEl);\r\n\r\n      fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');\r\n\r\n      if (this.interactive) {\r\n        this._applyCanvasStyle(this.lowerCanvasEl);\r\n      }\r\n\r\n      this.contextContainer = this.lowerCanvasEl.getContext('2d');\r\n    },\r\n\r\n    /**\r\n     * Returns canvas width (in px)\r\n     * @return {Number}\r\n     */\r\n    getWidth: function () {\r\n      return this.width;\r\n    },\r\n\r\n    /**\r\n     * Returns canvas height (in px)\r\n     * @return {Number}\r\n     */\r\n    getHeight: function () {\r\n      return this.height;\r\n    },\r\n\r\n    /**\r\n     * Sets width of this canvas instance\r\n     * @param {Number|String} value                         Value to set width to\r\n     * @param {Object}        [options]                     Options object\r\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\r\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    setWidth: function (value, options) {\r\n      return this.setDimensions({ width: value }, options);\r\n    },\r\n\r\n    /**\r\n     * Sets height of this canvas instance\r\n     * @param {Number|String} value                         Value to set height to\r\n     * @param {Object}        [options]                     Options object\r\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\r\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    setHeight: function (value, options) {\r\n      return this.setDimensions({ height: value }, options);\r\n    },\r\n\r\n    /**\r\n     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)\r\n     * @param {Object}        dimensions                    Object with width/height properties\r\n     * @param {Number|String} [dimensions.width]            Width of canvas element\r\n     * @param {Number|String} [dimensions.height]           Height of canvas element\r\n     * @param {Object}        [options]                     Options object\r\n     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions\r\n     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    setDimensions: function (dimensions, options) {\r\n      var cssValue;\r\n\r\n      options = options || {};\r\n\r\n      for (var prop in dimensions) {\r\n        cssValue = dimensions[prop];\r\n\r\n        if (!options.cssOnly) {\r\n          this._setBackstoreDimension(prop, dimensions[prop]);\r\n          cssValue += 'px';\r\n        }\r\n\r\n        if (!options.backstoreOnly) {\r\n          this._setCssDimension(prop, cssValue);\r\n        }\r\n      }\r\n\r\n      this._setImageSmoothing();\r\n      this.calcOffset();\r\n\r\n      if (!options.cssOnly) {\r\n        this.renderAll();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Helper for setting width/height\r\n     * @private\r\n     * @param {String} prop property (width|height)\r\n     * @param {Number} value value to set property to\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    _setBackstoreDimension: function (prop, value) {\r\n      this.lowerCanvasEl[prop] = value;\r\n\r\n      if (this.upperCanvasEl) {\r\n        this.upperCanvasEl[prop] = value;\r\n      }\r\n\r\n      if (this.cacheCanvasEl) {\r\n        this.cacheCanvasEl[prop] = value;\r\n      }\r\n\r\n      this[prop] = value;\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Helper for setting css width/height\r\n     * @private\r\n     * @param {String} prop property (width|height)\r\n     * @param {String} value value to set property to\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    _setCssDimension: function (prop, value) {\r\n      this.lowerCanvasEl.style[prop] = value;\r\n\r\n      if (this.upperCanvasEl) {\r\n        this.upperCanvasEl.style[prop] = value;\r\n      }\r\n\r\n      if (this.wrapperEl) {\r\n        this.wrapperEl.style[prop] = value;\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns canvas zoom level\r\n     * @return {Number}\r\n     */\r\n    getZoom: function () {\r\n      return Math.sqrt(this.viewportTransform[0] * this.viewportTransform[3]);\r\n    },\r\n\r\n    /**\r\n     * Sets viewport transform of this canvas instance\r\n     * @param {Array} vpt the transform in the form of context.transform\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    setViewportTransform: function (vpt) {\r\n      var activeGroup = this.getActiveGroup();\r\n      this.viewportTransform = vpt;\r\n      this.renderAll();\r\n      for (var i = 0, len = this._objects.length; i < len; i++) {\r\n        this._objects[i].setCoords();\r\n      }\r\n      if (activeGroup) {\r\n        activeGroup.setCoords();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets zoom level of this canvas instance, zoom centered around point\r\n     * @param {fabric.Point} point to zoom with respect to\r\n     * @param {Number} value to set zoom to, less than 1 zooms out\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    zoomToPoint: function (point, value) {\r\n      // TODO: just change the scale, preserve other transformations\r\n      var before = point;\r\n      point = fabric.util.transformPoint(point, fabric.util.invertTransform(this.viewportTransform));\r\n      this.viewportTransform[0] = value;\r\n      this.viewportTransform[3] = value;\r\n      var after = fabric.util.transformPoint(point, this.viewportTransform);\r\n      this.viewportTransform[4] += before.x - after.x;\r\n      this.viewportTransform[5] += before.y - after.y;\r\n      this.renderAll();\r\n      for (var i = 0, len = this._objects.length; i < len; i++) {\r\n        this._objects[i].setCoords();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets zoom level of this canvas instance\r\n     * @param {Number} value to set zoom to, less than 1 zooms out\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    setZoom: function (value) {\r\n      this.zoomToPoint(new fabric.Point(0, 0), value);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Pan viewport so as to place point at top left corner of canvas\r\n     * @param {fabric.Point} point to move to\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    absolutePan: function (point) {\r\n      this.viewportTransform[4] = -point.x;\r\n      this.viewportTransform[5] = -point.y;\r\n      this.renderAll();\r\n      for (var i = 0, len = this._objects.length; i < len; i++) {\r\n        this._objects[i].setCoords();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Pans viewpoint relatively\r\n     * @param {fabric.Point} point (position vector) to move by\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable true\r\n     */\r\n    relativePan: function (point) {\r\n      return this.absolutePan(new fabric.Point(\r\n        -point.x - this.viewportTransform[4],\r\n        -point.y - this.viewportTransform[5]\r\n      ));\r\n    },\r\n\r\n    /**\r\n     * Returns &lt;canvas> element corresponding to this instance\r\n     * @return {HTMLCanvasElement}\r\n     */\r\n    getElement: function () {\r\n      return this.lowerCanvasEl;\r\n    },\r\n\r\n    /**\r\n     * Returns currently selected object, if any\r\n     * @return {fabric.Object}\r\n     */\r\n    getActiveObject: function() {\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Returns currently selected group of object, if any\r\n     * @return {fabric.Group}\r\n     */\r\n    getActiveGroup: function() {\r\n      return null;\r\n    },\r\n\r\n    /**\r\n     * Given a context, renders an object on that context\r\n     * @param {CanvasRenderingContext2D} ctx Context to render object on\r\n     * @param {fabric.Object} object Object to render\r\n     * @private\r\n     */\r\n    _draw: function (ctx, object) {\r\n      if (!object) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n      var v = this.viewportTransform;\r\n      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\r\n      if (this._shouldRenderObject(object)) {\r\n        object.render(ctx);\r\n      }\r\n      ctx.restore();\r\n      if (!this.controlsAboveOverlay) {\r\n        object._renderControls(ctx);\r\n      }\r\n    },\r\n\r\n    _shouldRenderObject: function(object) {\r\n      if (!object) {\r\n        return false;\r\n      }\r\n      return (object !== this.getActiveGroup() || !this.preserveObjectStacking);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {fabric.Object} obj Object that was added\r\n     */\r\n    _onObjectAdded: function(obj) {\r\n      this.stateful && obj.setupState();\r\n      obj._set('canvas', this);\r\n      obj.setCoords();\r\n      this.fire('object:added', { target: obj });\r\n      obj.fire('added');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {fabric.Object} obj Object that was removed\r\n     */\r\n    _onObjectRemoved: function(obj) {\r\n      // removing active object should fire \"selection:cleared\" events\r\n      if (this.getActiveObject() === obj) {\r\n        this.fire('before:selection:cleared', { target: obj });\r\n        this._discardActiveObject();\r\n        this.fire('selection:cleared');\r\n      }\r\n\r\n      this.fire('object:removed', { target: obj });\r\n      obj.fire('removed');\r\n    },\r\n\r\n    /**\r\n     * Clears specified context of canvas element\r\n     * @param {CanvasRenderingContext2D} ctx Context to clear\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    clearContext: function(ctx) {\r\n      ctx.clearRect(0, 0, this.width, this.height);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns context of canvas where objects are drawn\r\n     * @return {CanvasRenderingContext2D}\r\n     */\r\n    getContext: function () {\r\n      return this.contextContainer;\r\n    },\r\n\r\n    /**\r\n     * Clears all contexts (background, main, top) of an instance\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    clear: function () {\r\n      this._objects.length = 0;\r\n      if (this.discardActiveGroup) {\r\n        this.discardActiveGroup();\r\n      }\r\n      if (this.discardActiveObject) {\r\n        this.discardActiveObject();\r\n      }\r\n      this.clearContext(this.contextContainer);\r\n      if (this.contextTop) {\r\n        this.clearContext(this.contextTop);\r\n      }\r\n      this.fire('canvas:cleared');\r\n      this.renderAll();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Renders both the top canvas and the secondary container canvas.\r\n     * @param {Boolean} [allOnTop] Whether we want to force all images to be rendered on the top canvas\r\n     * @return {fabric.Canvas} instance\r\n     * @chainable\r\n     */\r\n    renderAll: function (allOnTop) {\r\n      var canvasToDrawOn = this[(allOnTop === true && this.interactive) ? 'contextTop' : 'contextContainer'],\r\n          activeGroup = this.getActiveGroup();\r\n\r\n      if (this.contextTop && this.selection && !this._groupSelector) {\r\n        this.clearContext(this.contextTop);\r\n      }\r\n\r\n      if (!allOnTop) {\r\n        this.clearContext(canvasToDrawOn);\r\n      }\r\n\r\n      this.fire('before:render');\r\n\r\n      if (this.clipTo) {\r\n        fabric.util.clipContext(this, canvasToDrawOn);\r\n      }\r\n\r\n      this._renderBackground(canvasToDrawOn);\r\n      this._renderObjects(canvasToDrawOn, activeGroup);\r\n      this._renderActiveGroup(canvasToDrawOn, activeGroup);\r\n\r\n      if (this.clipTo) {\r\n        canvasToDrawOn.restore();\r\n      }\r\n\r\n      this._renderOverlay(canvasToDrawOn);\r\n\r\n      if (this.controlsAboveOverlay && this.interactive) {\r\n        this.drawControls(canvasToDrawOn);\r\n      }\r\n\r\n      this.fire('after:render');\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {fabric.Group} activeGroup\r\n     */\r\n    _renderObjects: function(ctx, activeGroup) {\r\n      var i, length;\r\n\r\n      // fast path\r\n      if (!activeGroup || this.preserveObjectStacking) {\r\n        for (i = 0, length = this._objects.length; i < length; ++i) {\r\n          this._draw(ctx, this._objects[i]);\r\n        }\r\n      }\r\n      else {\r\n        for (i = 0, length = this._objects.length; i < length; ++i) {\r\n          if (this._objects[i] && !activeGroup.contains(this._objects[i])) {\r\n            this._draw(ctx, this._objects[i]);\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {fabric.Group} activeGroup\r\n     */\r\n    _renderActiveGroup: function(ctx, activeGroup) {\r\n\r\n      // delegate rendering to group selection (if one exists)\r\n      if (activeGroup) {\r\n\r\n        //Store objects in group preserving order, then replace\r\n        var sortedObjects = [];\r\n        this.forEachObject(function (object) {\r\n          if (activeGroup.contains(object)) {\r\n            sortedObjects.push(object);\r\n          }\r\n        });\r\n        // forEachObject reverses the object, so we reverse again\r\n        activeGroup._set('_objects', sortedObjects.reverse());\r\n        this._draw(ctx, activeGroup);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderBackground: function(ctx) {\r\n      if (this.backgroundColor) {\r\n        ctx.fillStyle = this.backgroundColor.toLive\r\n          ? this.backgroundColor.toLive(ctx)\r\n          : this.backgroundColor;\r\n\r\n        ctx.fillRect(\r\n          this.backgroundColor.offsetX || 0,\r\n          this.backgroundColor.offsetY || 0,\r\n          this.width,\r\n          this.height);\r\n      }\r\n      if (this.backgroundImage) {\r\n        this._draw(ctx, this.backgroundImage);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderOverlay: function(ctx) {\r\n      if (this.overlayColor) {\r\n        ctx.fillStyle = this.overlayColor.toLive\r\n          ? this.overlayColor.toLive(ctx)\r\n          : this.overlayColor;\r\n\r\n        ctx.fillRect(\r\n          this.overlayColor.offsetX || 0,\r\n          this.overlayColor.offsetY || 0,\r\n          this.width,\r\n          this.height);\r\n      }\r\n      if (this.overlayImage) {\r\n        this._draw(ctx, this.overlayImage);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Method to render only the top canvas.\r\n     * Also used to render the group selection box.\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    renderTop: function () {\r\n      var ctx = this.contextTop || this.contextContainer;\r\n      this.clearContext(ctx);\r\n\r\n      // we render the top context - last object\r\n      if (this.selection && this._groupSelector) {\r\n        this._drawSelection();\r\n      }\r\n\r\n      // delegate rendering to group selection if one exists\r\n      // used for drawing selection borders/controls\r\n      var activeGroup = this.getActiveGroup();\r\n      if (activeGroup) {\r\n        activeGroup.render(ctx);\r\n      }\r\n\r\n      this._renderOverlay(ctx);\r\n\r\n      this.fire('after:render');\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns coordinates of a center of canvas.\r\n     * Returned value is an object with top and left properties\r\n     * @return {Object} object with \"top\" and \"left\" number values\r\n     */\r\n    getCenter: function () {\r\n      return {\r\n        top: this.getHeight() / 2,\r\n        left: this.getWidth() / 2\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Centers object horizontally.\r\n     * You might need to call `setCoords` on an object after centering, to update controls area.\r\n     * @param {fabric.Object} object Object to center horizontally\r\n     * @return {fabric.Canvas} thisArg\r\n     */\r\n    centerObjectH: function (object) {\r\n      this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));\r\n      this.renderAll();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Centers object vertically.\r\n     * You might need to call `setCoords` on an object after centering, to update controls area.\r\n     * @param {fabric.Object} object Object to center vertically\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    centerObjectV: function (object) {\r\n      this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));\r\n      this.renderAll();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Centers object vertically and horizontally.\r\n     * You might need to call `setCoords` on an object after centering, to update controls area.\r\n     * @param {fabric.Object} object Object to center vertically and horizontally\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    centerObject: function(object) {\r\n      var center = this.getCenter();\r\n\r\n      this._centerObject(object, new fabric.Point(center.left, center.top));\r\n      this.renderAll();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {fabric.Object} object Object to center\r\n     * @param {fabric.Point} center Center point\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    _centerObject: function(object, center) {\r\n      object.setPositionByOrigin(center, 'center', 'center');\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returs dataless JSON representation of canvas\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {String} json string\r\n     */\r\n    toDatalessJSON: function (propertiesToInclude) {\r\n      return this.toDatalessObject(propertiesToInclude);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of canvas\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function (propertiesToInclude) {\r\n      return this._toObjectMethod('toObject', propertiesToInclude);\r\n    },\r\n\r\n    /**\r\n     * Returns dataless object representation of canvas\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toDatalessObject: function (propertiesToInclude) {\r\n      return this._toObjectMethod('toDatalessObject', propertiesToInclude);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _toObjectMethod: function (methodName, propertiesToInclude) {\r\n\r\n      var data = {\r\n        objects: this._toObjects(methodName, propertiesToInclude)\r\n      };\r\n\r\n      extend(data, this.__serializeBgOverlay());\r\n\r\n      fabric.util.populateWithProperties(this, data, propertiesToInclude);\r\n\r\n      return data;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _toObjects: function(methodName, propertiesToInclude) {\r\n      return this.getObjects().map(function(instance) {\r\n        return this._toObject(instance, methodName, propertiesToInclude);\r\n      }, this);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _toObject: function(instance, methodName, propertiesToInclude) {\r\n      var originalValue;\r\n\r\n      if (!this.includeDefaultValues) {\r\n        originalValue = instance.includeDefaultValues;\r\n        instance.includeDefaultValues = false;\r\n      }\r\n\r\n      //If the object is part of the current selection group, it should\r\n      //be transformed appropriately\r\n      //i.e. it should be serialised as it would appear if the selection group\r\n      //were to be destroyed.\r\n      var originalProperties = this._realizeGroupTransformOnObject(instance),\r\n          object = instance[methodName](propertiesToInclude);\r\n      if (!this.includeDefaultValues) {\r\n        instance.includeDefaultValues = originalValue;\r\n      }\r\n\r\n      //Undo the damage we did by changing all of its properties\r\n      this._unwindGroupTransformOnObject(instance, originalProperties);\r\n\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Realises an object's group transformation on it\r\n     * @private\r\n     * @param {fabric.Object} [instance] the object to transform (gets mutated)\r\n     * @returns the original values of instance which were changed\r\n     */\r\n    _realizeGroupTransformOnObject: function(instance) {\r\n      var layoutProps = ['angle', 'flipX', 'flipY', 'height', 'left', 'scaleX', 'scaleY', 'top', 'width'];\r\n      if (instance.group && instance.group === this.getActiveGroup()) {\r\n        //Copy all the positionally relevant properties across now\r\n        var originalValues = {};\r\n        layoutProps.forEach(function(prop) {\r\n          originalValues[prop] = instance[prop];\r\n        });\r\n        this.getActiveGroup().realizeTransform(instance);\r\n        return originalValues;\r\n      }\r\n      else {\r\n        return null;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Restores the changed properties of instance\r\n     * @private\r\n     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)\r\n     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject\r\n     */\r\n    _unwindGroupTransformOnObject: function(instance, originalValues) {\r\n      if (originalValues) {\r\n        instance.set(originalValues);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    __serializeBgOverlay: function() {\r\n      var data = {\r\n        background: (this.backgroundColor && this.backgroundColor.toObject)\r\n          ? this.backgroundColor.toObject()\r\n          : this.backgroundColor\r\n      };\r\n\r\n      if (this.overlayColor) {\r\n        data.overlay = this.overlayColor.toObject\r\n          ? this.overlayColor.toObject()\r\n          : this.overlayColor;\r\n      }\r\n      if (this.backgroundImage) {\r\n        data.backgroundImage = this.backgroundImage.toObject();\r\n      }\r\n      if (this.overlayImage) {\r\n        data.overlayImage = this.overlayImage.toObject();\r\n      }\r\n\r\n      return data;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,\r\n     * a zoomed canvas will then produce zoomed SVG output.\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    svgViewportTransformation: true,\r\n\r\n    /**\r\n     * Returns SVG representation of canvas\r\n     * @function\r\n     * @param {Object} [options] Options object for SVG output\r\n     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included\r\n     * @param {Object} [options.viewBox] SVG viewbox object\r\n     * @param {Number} [options.viewBox.x] x-cooridnate of viewbox\r\n     * @param {Number} [options.viewBox.y] y-coordinate of viewbox\r\n     * @param {Number} [options.viewBox.width] Width of viewbox\r\n     * @param {Number} [options.viewBox.height] Height of viewbox\r\n     * @param {String} [options.encoding=UTF-8] Encoding of SVG output\r\n     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.\r\n     * @return {String} SVG string\r\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#serialization}\r\n     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}\r\n     * @example <caption>Normal SVG output</caption>\r\n     * var svg = canvas.toSVG();\r\n     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>\r\n     * var svg = canvas.toSVG({suppressPreamble: true});\r\n     * @example <caption>SVG output with viewBox attribute</caption>\r\n     * var svg = canvas.toSVG({\r\n     *   viewBox: {\r\n     *     x: 100,\r\n     *     y: 100,\r\n     *     width: 200,\r\n     *     height: 300\r\n     *   }\r\n     * });\r\n     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>\r\n     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});\r\n     * @example <caption>Modify SVG output with reviver function</caption>\r\n     * var svg = canvas.toSVG(null, function(svg) {\r\n     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');\r\n     * });\r\n     */\r\n    toSVG: function(options, reviver) {\r\n      options || (options = { });\r\n\r\n      var markup = [];\r\n\r\n      this._setSVGPreamble(markup, options);\r\n      this._setSVGHeader(markup, options);\r\n\r\n      this._setSVGBgOverlayColor(markup, 'backgroundColor');\r\n      this._setSVGBgOverlayImage(markup, 'backgroundImage');\r\n\r\n      this._setSVGObjects(markup, reviver);\r\n\r\n      this._setSVGBgOverlayColor(markup, 'overlayColor');\r\n      this._setSVGBgOverlayImage(markup, 'overlayImage');\r\n\r\n      markup.push('</svg>');\r\n\r\n      return markup.join('');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGPreamble: function(markup, options) {\r\n      if (!options.suppressPreamble) {\r\n        markup.push(\r\n          '<?xml version=\"1.0\" encoding=\"', (options.encoding || 'UTF-8'), '\" standalone=\"no\" ?>\\n',\r\n            '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" ',\r\n              '\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n'\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGHeader: function(markup, options) {\r\n      var width, height, vpt;\r\n\r\n      if (options.viewBox) {\r\n        width = options.viewBox.width;\r\n        height = options.viewBox.height;\r\n      }\r\n      else {\r\n        width = this.width;\r\n        height = this.height;\r\n        if (!this.svgViewportTransformation) {\r\n          vpt = this.viewportTransform;\r\n          width /= vpt[0];\r\n          height /= vpt[3];\r\n        }\r\n      }\r\n\r\n      markup.push(\r\n        '<svg ',\r\n          'xmlns=\"http://www.w3.org/2000/svg\" ',\r\n          'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ',\r\n          'version=\"1.1\" ',\r\n          'width=\"', width, '\" ',\r\n          'height=\"', height, '\" ',\r\n          (this.backgroundColor && !this.backgroundColor.toLive\r\n            ? 'style=\"background-color: ' + this.backgroundColor + '\" '\r\n            : null),\r\n          (options.viewBox\r\n              ? 'viewBox=\"' +\r\n                options.viewBox.x + ' ' +\r\n                options.viewBox.y + ' ' +\r\n                options.viewBox.width + ' ' +\r\n                options.viewBox.height + '\" '\r\n              : null),\r\n          'xml:space=\"preserve\">\\n',\r\n        '<desc>Created with Fabric.js ', fabric.version, '</desc>\\n',\r\n        '<defs>',\r\n          fabric.createSVGFontFacesMarkup(this.getObjects()),\r\n          fabric.createSVGRefElementsMarkup(this),\r\n        '</defs>\\n'\r\n      );\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGObjects: function(markup, reviver) {\r\n      for (var i = 0, objects = this.getObjects(), len = objects.length; i < len; i++) {\r\n        var instance = objects[i],\r\n            //If the object is in a selection group, simulate what would happen to that\r\n            //object when the group is deselected\r\n            originalProperties = this._realizeGroupTransformOnObject(instance);\r\n        markup.push(instance.toSVG(reviver));\r\n        this._unwindGroupTransformOnObject(instance, originalProperties);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGBgOverlayImage: function(markup, property) {\r\n      if (this[property] && this[property].toSVG) {\r\n        markup.push(this[property].toSVG());\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGBgOverlayColor: function(markup, property) {\r\n      if (this[property] && this[property].source) {\r\n        markup.push(\r\n          '<rect x=\"', this[property].offsetX, '\" y=\"', this[property].offsetY, '\" ',\r\n            'width=\"',\r\n              (this[property].repeat === 'repeat-y' || this[property].repeat === 'no-repeat'\r\n                ? this[property].source.width\r\n                : this.width),\r\n            '\" height=\"',\r\n              (this[property].repeat === 'repeat-x' || this[property].repeat === 'no-repeat'\r\n                ? this[property].source.height\r\n                : this.height),\r\n            '\" fill=\"url(#' + property + 'Pattern)\"',\r\n          '></rect>\\n'\r\n        );\r\n      }\r\n      else if (this[property] && property === 'overlayColor') {\r\n        markup.push(\r\n          '<rect x=\"0\" y=\"0\" ',\r\n            'width=\"', this.width,\r\n            '\" height=\"', this.height,\r\n            '\" fill=\"', this[property], '\"',\r\n          '></rect>\\n'\r\n        );\r\n      }\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Moves an object to the bottom of the stack of drawn objects\r\n     * @param {fabric.Object} object Object to send to back\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    sendToBack: function (object) {\r\n      removeFromArray(this._objects, object);\r\n      this._objects.unshift(object);\r\n      return this.renderAll && this.renderAll();\r\n    },\r\n\r\n    /**\r\n     * Moves an object to the top of the stack of drawn objects\r\n     * @param {fabric.Object} object Object to send\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    bringToFront: function (object) {\r\n      removeFromArray(this._objects, object);\r\n      this._objects.push(object);\r\n      return this.renderAll && this.renderAll();\r\n    },\r\n\r\n    /**\r\n     * Moves an object down in stack of drawn objects\r\n     * @param {fabric.Object} object Object to send\r\n     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    sendBackwards: function (object, intersecting) {\r\n      var idx = this._objects.indexOf(object);\r\n\r\n      // if object is not on the bottom of stack\r\n      if (idx !== 0) {\r\n        var newIdx = this._findNewLowerIndex(object, idx, intersecting);\r\n\r\n        removeFromArray(this._objects, object);\r\n        this._objects.splice(newIdx, 0, object);\r\n        this.renderAll && this.renderAll();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _findNewLowerIndex: function(object, idx, intersecting) {\r\n      var newIdx;\r\n\r\n      if (intersecting) {\r\n        newIdx = idx;\r\n\r\n        // traverse down the stack looking for the nearest intersecting object\r\n        for (var i = idx - 1; i >= 0; --i) {\r\n\r\n          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||\r\n                               object.isContainedWithinObject(this._objects[i]) ||\r\n                               this._objects[i].isContainedWithinObject(object);\r\n\r\n          if (isIntersecting) {\r\n            newIdx = i;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        newIdx = idx - 1;\r\n      }\r\n\r\n      return newIdx;\r\n    },\r\n\r\n    /**\r\n     * Moves an object up in stack of drawn objects\r\n     * @param {fabric.Object} object Object to send\r\n     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    bringForward: function (object, intersecting) {\r\n      var idx = this._objects.indexOf(object);\r\n\r\n      // if object is not on top of stack (last item in an array)\r\n      if (idx !== this._objects.length - 1) {\r\n        var newIdx = this._findNewUpperIndex(object, idx, intersecting);\r\n\r\n        removeFromArray(this._objects, object);\r\n        this._objects.splice(newIdx, 0, object);\r\n        this.renderAll && this.renderAll();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _findNewUpperIndex: function(object, idx, intersecting) {\r\n      var newIdx;\r\n\r\n      if (intersecting) {\r\n        newIdx = idx;\r\n\r\n        // traverse up the stack looking for the nearest intersecting object\r\n        for (var i = idx + 1; i < this._objects.length; ++i) {\r\n\r\n          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||\r\n                               object.isContainedWithinObject(this._objects[i]) ||\r\n                               this._objects[i].isContainedWithinObject(object);\r\n\r\n          if (isIntersecting) {\r\n            newIdx = i;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      else {\r\n        newIdx = idx + 1;\r\n      }\r\n\r\n      return newIdx;\r\n    },\r\n\r\n    /**\r\n     * Moves an object to specified level in stack of drawn objects\r\n     * @param {fabric.Object} object Object to send\r\n     * @param {Number} index Position to move to\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    moveTo: function (object, index) {\r\n      removeFromArray(this._objects, object);\r\n      this._objects.splice(index, 0, object);\r\n      return this.renderAll && this.renderAll();\r\n    },\r\n\r\n    /**\r\n     * Clears a canvas element and removes all event listeners\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    dispose: function () {\r\n      this.clear();\r\n      this.interactive && this.removeListeners();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns a string representation of an instance\r\n     * @return {String} string representation of an instance\r\n     */\r\n    toString: function () {\r\n      return '#<fabric.Canvas (' + this.complexity() + '): ' +\r\n               '{ objects: ' + this.getObjects().length + ' }>';\r\n    }\r\n  });\r\n\r\n  extend(fabric.StaticCanvas.prototype, fabric.Observable);\r\n  extend(fabric.StaticCanvas.prototype, fabric.Collection);\r\n  extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);\r\n\r\n  extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {\r\n\r\n    /**\r\n     * @static\r\n     * @type String\r\n     * @default\r\n     */\r\n    EMPTY_JSON: '{\"objects\": [], \"background\": \"white\"}',\r\n\r\n    /**\r\n     * Provides a way to check support of some of the canvas methods\r\n     * (either those of HTMLCanvasElement itself, or rendering context)\r\n     *\r\n     * @param {String} methodName Method to check support for;\r\n     *                            Could be one of \"getImageData\", \"toDataURL\", \"toDataURLWithQuality\" or \"setLineDash\"\r\n     * @return {Boolean | null} `true` if method is supported (or at least exists),\r\n     *                          `null` if canvas element or context can not be initialized\r\n     */\r\n    supports: function (methodName) {\r\n      var el = fabric.util.createCanvasElement();\r\n\r\n      if (!el || !el.getContext) {\r\n        return null;\r\n      }\r\n\r\n      var ctx = el.getContext('2d');\r\n      if (!ctx) {\r\n        return null;\r\n      }\r\n\r\n      switch (methodName) {\r\n\r\n        case 'getImageData':\r\n          return typeof ctx.getImageData !== 'undefined';\r\n\r\n        case 'setLineDash':\r\n          return typeof ctx.setLineDash !== 'undefined';\r\n\r\n        case 'toDataURL':\r\n          return typeof el.toDataURL !== 'undefined';\r\n\r\n        case 'toDataURLWithQuality':\r\n          try {\r\n            el.toDataURL('image/jpeg', 0);\r\n            return true;\r\n          }\r\n          catch (e) { }\r\n          return false;\r\n\r\n        default:\r\n          return null;\r\n      }\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns JSON representation of canvas\r\n   * @function\r\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n   * @return {String} JSON string\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#serialization}\r\n   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}\r\n   * @example <caption>JSON without additional properties</caption>\r\n   * var json = canvas.toJSON();\r\n   * @example <caption>JSON with additional properties included</caption>\r\n   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'lockUniScaling']);\r\n   * @example <caption>JSON without default values</caption>\r\n   * canvas.includeDefaultValues = false;\r\n   * var json = canvas.toJSON();\r\n   */\r\n  fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;\r\n\r\n})();\r\n\r\n\r\n/**\r\n * BaseBrush class\r\n * @class fabric.BaseBrush\r\n * @see {@link http://fabricjs.com/freedrawing/|Freedrawing demo}\r\n */\r\nfabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {\r\n\r\n  /**\r\n   * Color of a brush\r\n   * @type String\r\n   * @default\r\n   */\r\n  color:            'rgb(0, 0, 0)',\r\n\r\n  /**\r\n   * Width of a brush\r\n   * @type Number\r\n   * @default\r\n   */\r\n  width:            1,\r\n\r\n  /**\r\n   * Shadow object representing shadow of this shape.\r\n   * <b>Backwards incompatibility note:</b> This property replaces \"shadowColor\" (String), \"shadowOffsetX\" (Number),\r\n   * \"shadowOffsetY\" (Number) and \"shadowBlur\" (Number) since v1.2.12\r\n   * @type fabric.Shadow\r\n   * @default\r\n   */\r\n  shadow:           null,\r\n\r\n  /**\r\n   * Line endings style of a brush (one of \"butt\", \"round\", \"square\")\r\n   * @type String\r\n   * @default\r\n   */\r\n  strokeLineCap:    'round',\r\n\r\n  /**\r\n   * Corner style of a brush (one of \"bevil\", \"round\", \"miter\")\r\n   * @type String\r\n   * @default\r\n   */\r\n  strokeLineJoin:   'round',\r\n\r\n  /**\r\n   * Stroke Dash Array.\r\n   * @type Array\r\n   * @default\r\n   */\r\n  strokeDashArray:  null,\r\n\r\n  /**\r\n   * Sets shadow of an object\r\n   * @param {Object|String} [options] Options object or string (e.g. \"2px 2px 10px rgba(0,0,0,0.2)\")\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  setShadow: function(options) {\r\n    this.shadow = new fabric.Shadow(options);\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Sets brush styles\r\n   * @private\r\n   */\r\n  _setBrushStyles: function() {\r\n    var ctx = this.canvas.contextTop;\r\n\r\n    ctx.strokeStyle = this.color;\r\n    ctx.lineWidth = this.width;\r\n    ctx.lineCap = this.strokeLineCap;\r\n    ctx.lineJoin = this.strokeLineJoin;\r\n    if (this.strokeDashArray && fabric.StaticCanvas.supports('setLineDash')) {\r\n      ctx.setLineDash(this.strokeDashArray);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets brush shadow styles\r\n   * @private\r\n   */\r\n  _setShadow: function() {\r\n    if (!this.shadow) {\r\n      return;\r\n    }\r\n\r\n    var ctx = this.canvas.contextTop;\r\n\r\n    ctx.shadowColor = this.shadow.color;\r\n    ctx.shadowBlur = this.shadow.blur;\r\n    ctx.shadowOffsetX = this.shadow.offsetX;\r\n    ctx.shadowOffsetY = this.shadow.offsetY;\r\n  },\r\n\r\n  /**\r\n   * Removes brush shadow styles\r\n   * @private\r\n   */\r\n  _resetShadow: function() {\r\n    var ctx = this.canvas.contextTop;\r\n\r\n    ctx.shadowColor = '';\r\n    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\r\n  }\r\n});\r\n\r\n\r\n(function() {\r\n\r\n  /**\r\n   * PencilBrush class\r\n   * @class fabric.PencilBrush\r\n   * @extends fabric.BaseBrush\r\n   */\r\n  fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {fabric.Canvas} canvas\r\n     * @return {fabric.PencilBrush} Instance of a pencil brush\r\n     */\r\n    initialize: function(canvas) {\r\n      this.canvas = canvas;\r\n      this._points = [ ];\r\n    },\r\n\r\n    /**\r\n     * Inovoked on mouse down\r\n     * @param {Object} pointer\r\n     */\r\n    onMouseDown: function(pointer) {\r\n      this._prepareForDrawing(pointer);\r\n      // capture coordinates immediately\r\n      // this allows to draw dots (when movement never occurs)\r\n      this._captureDrawingPath(pointer);\r\n      this._render();\r\n    },\r\n\r\n    /**\r\n     * Inovoked on mouse move\r\n     * @param {Object} pointer\r\n     */\r\n    onMouseMove: function(pointer) {\r\n      this._captureDrawingPath(pointer);\r\n      // redraw curve\r\n      // clear top canvas\r\n      this.canvas.clearContext(this.canvas.contextTop);\r\n      this._render();\r\n    },\r\n\r\n    /**\r\n     * Invoked on mouse up\r\n     */\r\n    onMouseUp: function() {\r\n      this._finalizeAndAddPath();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} pointer Actual mouse position related to the canvas.\r\n     */\r\n    _prepareForDrawing: function(pointer) {\r\n\r\n      var p = new fabric.Point(pointer.x, pointer.y);\r\n\r\n      this._reset();\r\n      this._addPoint(p);\r\n\r\n      this.canvas.contextTop.moveTo(p.x, p.y);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {fabric.Point} point Point to be added to points array\r\n     */\r\n    _addPoint: function(point) {\r\n      this._points.push(point);\r\n    },\r\n\r\n    /**\r\n     * Clear points array and set contextTop canvas style.\r\n     * @private\r\n     */\r\n    _reset: function() {\r\n      this._points.length = 0;\r\n\r\n      this._setBrushStyles();\r\n      this._setShadow();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} pointer Actual mouse position related to the canvas.\r\n     */\r\n    _captureDrawingPath: function(pointer) {\r\n      var pointerPoint = new fabric.Point(pointer.x, pointer.y);\r\n      this._addPoint(pointerPoint);\r\n    },\r\n\r\n    /**\r\n     * Draw a smooth path on the topCanvas using quadraticCurveTo\r\n     * @private\r\n     */\r\n    _render: function() {\r\n      var ctx  = this.canvas.contextTop,\r\n          v = this.canvas.viewportTransform,\r\n          p1 = this._points[0],\r\n          p2 = this._points[1];\r\n\r\n      ctx.save();\r\n      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\r\n      ctx.beginPath();\r\n\r\n      //if we only have 2 points in the path and they are the same\r\n      //it means that the user only clicked the canvas without moving the mouse\r\n      //then we should be drawing a dot. A path isn't drawn between two identical dots\r\n      //that's why we set them apart a bit\r\n      if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {\r\n        p1.x -= 0.5;\r\n        p2.x += 0.5;\r\n      }\r\n      ctx.moveTo(p1.x, p1.y);\r\n\r\n      for (var i = 1, len = this._points.length; i < len; i++) {\r\n        // we pick the point between pi + 1 & pi + 2 as the\r\n        // end point and p1 as our control point.\r\n        var midPoint = p1.midPointFrom(p2);\r\n        ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);\r\n\r\n        p1 = this._points[i];\r\n        p2 = this._points[i + 1];\r\n      }\r\n      // Draw last line as a straight line while\r\n      // we wait for the next point to be able to calculate\r\n      // the bezier control point\r\n      ctx.lineTo(p1.x, p1.y);\r\n      ctx.stroke();\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Converts points to SVG path\r\n     * @param {Array} points Array of points\r\n     * @param {Number} minX\r\n     * @param {Number} minY\r\n     * @return {String} SVG path\r\n     */\r\n    convertPointsToSVGPath: function(points) {\r\n      var path = [],\r\n          p1 = new fabric.Point(points[0].x, points[0].y),\r\n          p2 = new fabric.Point(points[1].x, points[1].y);\r\n\r\n      path.push('M ', points[0].x, ' ', points[0].y, ' ');\r\n      for (var i = 1, len = points.length; i < len; i++) {\r\n        var midPoint = p1.midPointFrom(p2);\r\n        // p1 is our bezier control point\r\n        // midpoint is our endpoint\r\n        // start point is p(i-1) value.\r\n        path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');\r\n        p1 = new fabric.Point(points[i].x, points[i].y);\r\n        if ((i + 1) < points.length) {\r\n          p2 = new fabric.Point(points[i + 1].x, points[i + 1].y);\r\n        }\r\n      }\r\n      path.push('L ', p1.x, ' ', p1.y, ' ');\r\n      return path;\r\n    },\r\n\r\n    /**\r\n     * Creates fabric.Path object to add on canvas\r\n     * @param {String} pathData Path data\r\n     * @return {fabric.Path} Path to add on canvas\r\n     */\r\n    createPath: function(pathData) {\r\n      var path = new fabric.Path(pathData, {\r\n                   fill: null,\r\n                   stroke: this.color,\r\n                   strokeWidth: this.width,\r\n                   strokeLineCap: this.strokeLineCap,\r\n                   strokeLineJoin: this.strokeLineJoin,\r\n                   strokeDashArray: this.strokeDashArray,\r\n                   originX: 'center',\r\n                   originY: 'center'\r\n                 });\r\n\r\n      if (this.shadow) {\r\n        this.shadow.affectStroke = true;\r\n        path.setShadow(this.shadow);\r\n      }\r\n\r\n      return path;\r\n    },\r\n\r\n    /**\r\n     * On mouseup after drawing the path on contextTop canvas\r\n     * we use the points captured to create an new fabric path object\r\n     * and add it to the fabric canvas.\r\n     */\r\n    _finalizeAndAddPath: function() {\r\n      var ctx = this.canvas.contextTop;\r\n      ctx.closePath();\r\n\r\n      var pathData = this.convertPointsToSVGPath(this._points).join('');\r\n      if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {\r\n        // do not create 0 width/height paths, as they are\r\n        // rendered inconsistently across browsers\r\n        // Firefox 4, for example, renders a dot,\r\n        // whereas Chrome 10 renders nothing\r\n        this.canvas.renderAll();\r\n        return;\r\n      }\r\n\r\n      var path = this.createPath(pathData);\r\n\r\n      this.canvas.add(path);\r\n      path.setCoords();\r\n\r\n      this.canvas.clearContext(this.canvas.contextTop);\r\n      this._resetShadow();\r\n      this.canvas.renderAll();\r\n\r\n      // fire event 'path' created\r\n      this.canvas.fire('path:created', { path: path });\r\n    }\r\n  });\r\n})();\r\n\r\n\r\n/**\r\n * CircleBrush class\r\n * @class fabric.CircleBrush\r\n */\r\nfabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {\r\n\r\n  /**\r\n   * Width of a brush\r\n   * @type Number\r\n   * @default\r\n   */\r\n  width: 10,\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {fabric.Canvas} canvas\r\n   * @return {fabric.CircleBrush} Instance of a circle brush\r\n   */\r\n  initialize: function(canvas) {\r\n    this.canvas = canvas;\r\n    this.points = [ ];\r\n  },\r\n\r\n  /**\r\n   * Invoked inside on mouse down and mouse move\r\n   * @param {Object} pointer\r\n   */\r\n  drawDot: function(pointer) {\r\n    var point = this.addPoint(pointer),\r\n        ctx = this.canvas.contextTop,\r\n        v = this.canvas.viewportTransform;\r\n    ctx.save();\r\n    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\r\n\r\n    ctx.fillStyle = point.fill;\r\n    ctx.beginPath();\r\n    ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n\r\n    ctx.restore();\r\n  },\r\n\r\n  /**\r\n   * Invoked on mouse down\r\n   */\r\n  onMouseDown: function(pointer) {\r\n    this.points.length = 0;\r\n    this.canvas.clearContext(this.canvas.contextTop);\r\n    this._setShadow();\r\n    this.drawDot(pointer);\r\n  },\r\n\r\n  /**\r\n   * Invoked on mouse move\r\n   * @param {Object} pointer\r\n   */\r\n  onMouseMove: function(pointer) {\r\n    this.drawDot(pointer);\r\n  },\r\n\r\n  /**\r\n   * Invoked on mouse up\r\n   */\r\n  onMouseUp: function() {\r\n    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;\r\n    this.canvas.renderOnAddRemove = false;\r\n\r\n    var circles = [ ];\r\n\r\n    for (var i = 0, len = this.points.length; i < len; i++) {\r\n      var point = this.points[i],\r\n          circle = new fabric.Circle({\r\n            radius: point.radius,\r\n            left: point.x,\r\n            top: point.y,\r\n            originX: 'center',\r\n            originY: 'center',\r\n            fill: point.fill\r\n          });\r\n\r\n      this.shadow && circle.setShadow(this.shadow);\r\n\r\n      circles.push(circle);\r\n    }\r\n    var group = new fabric.Group(circles, { originX: 'center', originY: 'center' });\r\n    group.canvas = this.canvas;\r\n\r\n    this.canvas.add(group);\r\n    this.canvas.fire('path:created', { path: group });\r\n\r\n    this.canvas.clearContext(this.canvas.contextTop);\r\n    this._resetShadow();\r\n    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\r\n    this.canvas.renderAll();\r\n  },\r\n\r\n  /**\r\n   * @param {Object} pointer\r\n   * @return {fabric.Point} Just added pointer point\r\n   */\r\n  addPoint: function(pointer) {\r\n    var pointerPoint = new fabric.Point(pointer.x, pointer.y),\r\n\r\n        circleRadius = fabric.util.getRandomInt(\r\n                        Math.max(0, this.width - 20), this.width + 20) / 2,\r\n\r\n        circleColor = new fabric.Color(this.color)\r\n                        .setAlpha(fabric.util.getRandomInt(0, 100) / 100)\r\n                        .toRgba();\r\n\r\n    pointerPoint.radius = circleRadius;\r\n    pointerPoint.fill = circleColor;\r\n\r\n    this.points.push(pointerPoint);\r\n\r\n    return pointerPoint;\r\n  }\r\n});\r\n\r\n\r\n/**\r\n * SprayBrush class\r\n * @class fabric.SprayBrush\r\n */\r\nfabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {\r\n\r\n  /**\r\n   * Width of a spray\r\n   * @type Number\r\n   * @default\r\n   */\r\n  width:              10,\r\n\r\n  /**\r\n   * Density of a spray (number of dots per chunk)\r\n   * @type Number\r\n   * @default\r\n   */\r\n  density:            20,\r\n\r\n  /**\r\n   * Width of spray dots\r\n   * @type Number\r\n   * @default\r\n   */\r\n  dotWidth:           1,\r\n\r\n  /**\r\n   * Width variance of spray dots\r\n   * @type Number\r\n   * @default\r\n   */\r\n  dotWidthVariance:   1,\r\n\r\n  /**\r\n   * Whether opacity of a dot should be random\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  randomOpacity:        false,\r\n\r\n  /**\r\n   * Whether overlapping dots (rectangles) should be removed (for performance reasons)\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  optimizeOverlapping:  true,\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {fabric.Canvas} canvas\r\n   * @return {fabric.SprayBrush} Instance of a spray brush\r\n   */\r\n  initialize: function(canvas) {\r\n    this.canvas = canvas;\r\n    this.sprayChunks = [ ];\r\n  },\r\n\r\n  /**\r\n   * Invoked on mouse down\r\n   * @param {Object} pointer\r\n   */\r\n  onMouseDown: function(pointer) {\r\n    this.sprayChunks.length = 0;\r\n    this.canvas.clearContext(this.canvas.contextTop);\r\n    this._setShadow();\r\n\r\n    this.addSprayChunk(pointer);\r\n    this.render();\r\n  },\r\n\r\n  /**\r\n   * Invoked on mouse move\r\n   * @param {Object} pointer\r\n   */\r\n  onMouseMove: function(pointer) {\r\n    this.addSprayChunk(pointer);\r\n    this.render();\r\n  },\r\n\r\n  /**\r\n   * Invoked on mouse up\r\n   */\r\n  onMouseUp: function() {\r\n    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;\r\n    this.canvas.renderOnAddRemove = false;\r\n\r\n    var rects = [ ];\r\n\r\n    for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {\r\n      var sprayChunk = this.sprayChunks[i];\r\n\r\n      for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {\r\n\r\n        var rect = new fabric.Rect({\r\n          width: sprayChunk[j].width,\r\n          height: sprayChunk[j].width,\r\n          left: sprayChunk[j].x + 1,\r\n          top: sprayChunk[j].y + 1,\r\n          originX: 'center',\r\n          originY: 'center',\r\n          fill: this.color\r\n        });\r\n\r\n        this.shadow && rect.setShadow(this.shadow);\r\n        rects.push(rect);\r\n      }\r\n    }\r\n\r\n    if (this.optimizeOverlapping) {\r\n      rects = this._getOptimizedRects(rects);\r\n    }\r\n\r\n    var group = new fabric.Group(rects, { originX: 'center', originY: 'center' });\r\n    group.canvas = this.canvas;\r\n\r\n    this.canvas.add(group);\r\n    this.canvas.fire('path:created', { path: group });\r\n\r\n    this.canvas.clearContext(this.canvas.contextTop);\r\n    this._resetShadow();\r\n    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;\r\n    this.canvas.renderAll();\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {Array} rects\r\n   */\r\n  _getOptimizedRects: function(rects) {\r\n\r\n    // avoid creating duplicate rects at the same coordinates\r\n    var uniqueRects = { }, key;\r\n\r\n    for (var i = 0, len = rects.length; i < len; i++) {\r\n      key = rects[i].left + '' + rects[i].top;\r\n      if (!uniqueRects[key]) {\r\n        uniqueRects[key] = rects[i];\r\n      }\r\n    }\r\n    var uniqueRectsArray = [ ];\r\n    for (key in uniqueRects) {\r\n      uniqueRectsArray.push(uniqueRects[key]);\r\n    }\r\n\r\n    return uniqueRectsArray;\r\n  },\r\n\r\n  /**\r\n   * Renders brush\r\n   */\r\n  render: function() {\r\n    var ctx = this.canvas.contextTop;\r\n    ctx.fillStyle = this.color;\r\n\r\n    var v = this.canvas.viewportTransform;\r\n    ctx.save();\r\n    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\r\n\r\n    for (var i = 0, len = this.sprayChunkPoints.length; i < len; i++) {\r\n      var point = this.sprayChunkPoints[i];\r\n      if (typeof point.opacity !== 'undefined') {\r\n        ctx.globalAlpha = point.opacity;\r\n      }\r\n      ctx.fillRect(point.x, point.y, point.width, point.width);\r\n    }\r\n    ctx.restore();\r\n  },\r\n\r\n  /**\r\n   * @param {Object} pointer\r\n   */\r\n  addSprayChunk: function(pointer) {\r\n    this.sprayChunkPoints = [ ];\r\n\r\n    var x, y, width, radius = this.width / 2;\r\n\r\n    for (var i = 0; i < this.density; i++) {\r\n\r\n      x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);\r\n      y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);\r\n\r\n      if (this.dotWidthVariance) {\r\n        width = fabric.util.getRandomInt(\r\n          // bottom clamp width to 1\r\n          Math.max(1, this.dotWidth - this.dotWidthVariance),\r\n          this.dotWidth + this.dotWidthVariance);\r\n      }\r\n      else {\r\n        width = this.dotWidth;\r\n      }\r\n\r\n      var point = new fabric.Point(x, y);\r\n      point.width = width;\r\n\r\n      if (this.randomOpacity) {\r\n        point.opacity = fabric.util.getRandomInt(0, 100) / 100;\r\n      }\r\n\r\n      this.sprayChunkPoints.push(point);\r\n    }\r\n\r\n    this.sprayChunks.push(this.sprayChunkPoints);\r\n  }\r\n});\r\n\r\n\r\n/**\r\n * PatternBrush class\r\n * @class fabric.PatternBrush\r\n * @extends fabric.BaseBrush\r\n */\r\nfabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {\r\n\r\n  getPatternSrc: function() {\r\n\r\n    var dotWidth = 20,\r\n        dotDistance = 5,\r\n        patternCanvas = fabric.document.createElement('canvas'),\r\n        patternCtx = patternCanvas.getContext('2d');\r\n\r\n    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;\r\n\r\n    patternCtx.fillStyle = this.color;\r\n    patternCtx.beginPath();\r\n    patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);\r\n    patternCtx.closePath();\r\n    patternCtx.fill();\r\n\r\n    return patternCanvas;\r\n  },\r\n\r\n  getPatternSrcFunction: function() {\r\n    return String(this.getPatternSrc).replace('this.color', '\"' + this.color + '\"');\r\n  },\r\n\r\n  /**\r\n   * Creates \"pattern\" instance property\r\n   */\r\n  getPattern: function() {\r\n    return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');\r\n  },\r\n\r\n  /**\r\n   * Sets brush styles\r\n   */\r\n  _setBrushStyles: function() {\r\n    this.callSuper('_setBrushStyles');\r\n    this.canvas.contextTop.strokeStyle = this.getPattern();\r\n  },\r\n\r\n  /**\r\n   * Creates path\r\n   */\r\n  createPath: function(pathData) {\r\n    var path = this.callSuper('createPath', pathData);\r\n    path.stroke = new fabric.Pattern({\r\n      source: this.source || this.getPatternSrcFunction()\r\n    });\r\n    return path;\r\n  }\r\n});\r\n\r\n\r\n(function() {\r\n\r\n  var getPointer = fabric.util.getPointer,\r\n      degreesToRadians = fabric.util.degreesToRadians,\r\n      radiansToDegrees = fabric.util.radiansToDegrees,\r\n      atan2 = Math.atan2,\r\n      abs = Math.abs,\r\n\r\n      STROKE_OFFSET = 0.5;\r\n\r\n  /**\r\n   * Canvas class\r\n   * @class fabric.Canvas\r\n   * @extends fabric.StaticCanvas\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#canvas}\r\n   * @see {@link fabric.Canvas#initialize} for constructor definition\r\n   *\r\n   * @fires object:modified\r\n   * @fires object:rotating\r\n   * @fires object:scaling\r\n   * @fires object:moving\r\n   * @fires object:selected\r\n   *\r\n   * @fires before:selection:cleared\r\n   * @fires selection:cleared\r\n   * @fires selection:created\r\n   *\r\n   * @fires path:created\r\n   * @fires mouse:down\r\n   * @fires mouse:move\r\n   * @fires mouse:up\r\n   * @fires mouse:over\r\n   * @fires mouse:out\r\n   *\r\n   */\r\n  fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on\r\n     * @param {Object} [options] Options object\r\n     * @return {Object} thisArg\r\n     */\r\n    initialize: function(el, options) {\r\n      options || (options = { });\r\n\r\n      this._initStatic(el, options);\r\n      this._initInteractive();\r\n      this._createCacheCanvas();\r\n\r\n      fabric.Canvas.activeInstance = this;\r\n    },\r\n\r\n    /**\r\n     * When true, objects can be transformed by one side (unproportionally)\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    uniScaleTransform:      false,\r\n\r\n    /**\r\n     * When true, objects use center point as the origin of scale transformation.\r\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\r\n     * @since 1.3.4\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    centeredScaling:        false,\r\n\r\n    /**\r\n     * When true, objects use center point as the origin of rotate transformation.\r\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\r\n     * @since 1.3.4\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    centeredRotation:       false,\r\n\r\n    /**\r\n     * Indicates that canvas is interactive. This property should not be changed.\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    interactive:            true,\r\n\r\n    /**\r\n     * Indicates whether group selection should be enabled\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    selection:              true,\r\n\r\n    /**\r\n     * Color of selection\r\n     * @type String\r\n     * @default\r\n     */\r\n    selectionColor:         'rgba(100, 100, 255, 0.3)', // blue\r\n\r\n    /**\r\n     * Default dash array pattern\r\n     * If not empty the selection border is dashed\r\n     * @type Array\r\n     */\r\n    selectionDashArray:     [ ],\r\n\r\n    /**\r\n     * Color of the border of selection (usually slightly darker than color of selection itself)\r\n     * @type String\r\n     * @default\r\n     */\r\n    selectionBorderColor:   'rgba(255, 255, 255, 0.3)',\r\n\r\n    /**\r\n     * Width of a line used in object/group selection\r\n     * @type Number\r\n     * @default\r\n     */\r\n    selectionLineWidth:     1,\r\n\r\n    /**\r\n     * Default cursor value used when hovering over an object on canvas\r\n     * @type String\r\n     * @default\r\n     */\r\n    hoverCursor:            'move',\r\n\r\n    /**\r\n     * Default cursor value used when moving an object on canvas\r\n     * @type String\r\n     * @default\r\n     */\r\n    moveCursor:             'move',\r\n\r\n    /**\r\n     * Default cursor value used for the entire canvas\r\n     * @type String\r\n     * @default\r\n     */\r\n    defaultCursor:          'default',\r\n\r\n    /**\r\n     * Cursor value used during free drawing\r\n     * @type String\r\n     * @default\r\n     */\r\n    freeDrawingCursor:      'crosshair',\r\n\r\n    /**\r\n     * Cursor value used for rotation point\r\n     * @type String\r\n     * @default\r\n     */\r\n    rotationCursor:         'crosshair',\r\n\r\n    /**\r\n     * Default element class that's given to wrapper (div) element of canvas\r\n     * @type String\r\n     * @default\r\n     */\r\n    containerClass:         'canvas-container',\r\n\r\n    /**\r\n     * When true, object detection happens on per-pixel basis rather than on per-bounding-box\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    perPixelTargetFind:     false,\r\n\r\n    /**\r\n     * Number of pixels around target pixel to tolerate (consider active) during object detection\r\n     * @type Number\r\n     * @default\r\n     */\r\n    targetFindTolerance:    0,\r\n\r\n    /**\r\n     * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    skipTargetFind:         false,\r\n\r\n    /**\r\n     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.\r\n     * After mousedown, mousemove creates a shape,\r\n     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.\r\n     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4/#free_drawing}\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    isDrawingMode:          false,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _initInteractive: function() {\r\n      this._currentTransform = null;\r\n      this._groupSelector = null;\r\n      this._initWrapperElement();\r\n      this._createUpperCanvas();\r\n      this._initEventListeners();\r\n\r\n      this._initRetinaScaling();\r\n\r\n      this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);\r\n\r\n      this.calcOffset();\r\n    },\r\n\r\n    /**\r\n     * Resets the current transform to its original values and chooses the type of resizing based on the event\r\n     * @private\r\n     * @param {Event} e Event object fired on mousemove\r\n     */\r\n    _resetCurrentTransform: function(e) {\r\n      var t = this._currentTransform;\r\n\r\n      t.target.set({\r\n        scaleX: t.original.scaleX,\r\n        scaleY: t.original.scaleY,\r\n        left: t.original.left,\r\n        top: t.original.top\r\n      });\r\n\r\n      if (this._shouldCenterTransform(e, t.target)) {\r\n        if (t.action === 'rotate') {\r\n          this._setOriginToCenter(t.target);\r\n        }\r\n        else {\r\n          if (t.originX !== 'center') {\r\n            if (t.originX === 'right') {\r\n              t.mouseXSign = -1;\r\n            }\r\n            else {\r\n              t.mouseXSign = 1;\r\n            }\r\n          }\r\n          if (t.originY !== 'center') {\r\n            if (t.originY === 'bottom') {\r\n              t.mouseYSign = -1;\r\n            }\r\n            else {\r\n              t.mouseYSign = 1;\r\n            }\r\n          }\r\n\r\n          t.originX = 'center';\r\n          t.originY = 'center';\r\n        }\r\n      }\r\n      else {\r\n        t.originX = t.original.originX;\r\n        t.originY = t.original.originY;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Checks if point is contained within an area of given object\r\n     * @param {Event} e Event object\r\n     * @param {fabric.Object} target Object to test against\r\n     * @return {Boolean} true if point is contained within an area of given object\r\n     */\r\n    containsPoint: function (e, target) {\r\n      var pointer = this.getPointer(e, true),\r\n          xy = this._normalizePointer(target, pointer);\r\n\r\n      // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html\r\n      // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html\r\n      return (target.containsPoint(xy) || target._findTargetCorner(pointer));\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _normalizePointer: function (object, pointer) {\r\n      var activeGroup = this.getActiveGroup(),\r\n          x = pointer.x,\r\n          y = pointer.y,\r\n          isObjectInGroup = (\r\n            activeGroup &&\r\n            object.type !== 'group' &&\r\n            activeGroup.contains(object)),\r\n          lt;\r\n\r\n      if (isObjectInGroup) {\r\n        lt = fabric.util.transformPoint(activeGroup.getCenterPoint(), this.viewportTransform, true);\r\n        x -= lt.x;\r\n        y -= lt.y;\r\n        x /= activeGroup.scaleX;\r\n        y /= activeGroup.scaleY;\r\n      }\r\n      return { x: x, y: y };\r\n    },\r\n\r\n    /**\r\n     * Returns true if object is transparent at a certain location\r\n     * @param {fabric.Object} target Object to check\r\n     * @param {Number} x Left coordinate\r\n     * @param {Number} y Top coordinate\r\n     * @return {Boolean}\r\n     */\r\n    isTargetTransparent: function (target, x, y) {\r\n      var hasBorders = target.hasBorders,\r\n          transparentCorners = target.transparentCorners;\r\n\r\n      target.hasBorders = target.transparentCorners = false;\r\n\r\n      this._draw(this.contextCache, target);\r\n\r\n      target.hasBorders = hasBorders;\r\n      target.transparentCorners = transparentCorners;\r\n\r\n      var isTransparent = fabric.util.isTransparent(\r\n        this.contextCache, x, y, this.targetFindTolerance);\r\n\r\n      this.clearContext(this.contextCache);\r\n\r\n      return isTransparent;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object\r\n     * @param {fabric.Object} target\r\n     */\r\n    _shouldClearSelection: function (e, target) {\r\n      var activeGroup = this.getActiveGroup(),\r\n          activeObject = this.getActiveObject();\r\n\r\n      return (\r\n        !target\r\n        ||\r\n        (target &&\r\n          activeGroup &&\r\n          !activeGroup.contains(target) &&\r\n          activeGroup !== target &&\r\n          !e.shiftKey)\r\n        ||\r\n        (target && !target.evented)\r\n        ||\r\n        (target &&\r\n          !target.selectable &&\r\n          activeObject &&\r\n          activeObject !== target)\r\n      );\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object\r\n     * @param {fabric.Object} target\r\n     */\r\n    _shouldCenterTransform: function (e, target) {\r\n      if (!target) {\r\n        return;\r\n      }\r\n      \r\n      var t = this._currentTransform,\r\n          centerTransform;\r\n\r\n      if (t.action === 'scale' || t.action === 'scaleX' || t.action === 'scaleY') {\r\n        centerTransform = this.centeredScaling || target.centeredScaling;\r\n      }\r\n      else if (t.action === 'rotate') {\r\n        centerTransform = this.centeredRotation || target.centeredRotation;\r\n      }\r\n      //return centerTransform ? !e.altKey : e.altKey;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getOriginFromCorner: function(target, corner) {\r\n      var origin = {\r\n        x: target.originX,\r\n        y: target.originY\r\n      };\r\n\r\n      if (corner === 'ml' || corner === 'tl' || corner === 'bl') {\r\n        origin.x = 'right';\r\n      }\r\n      else if (corner === 'mr' || corner === 'tr' || corner === 'br') {\r\n        origin.x = 'left';\r\n      }\r\n\r\n      if (corner === 'tl' || corner === 'mt' || corner === 'tr') {\r\n        origin.y = 'bottom';\r\n      }\r\n      else if (corner === 'bl' || corner === 'mb' || corner === 'br') {\r\n        origin.y = 'top';\r\n      }\r\n\r\n      return origin;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getActionFromCorner: function(target, corner) {\r\n      var action = 'drag';\r\n      if (corner) {\r\n        action = (corner === 'ml' || corner === 'mr')\r\n          ? 'scaleX'\r\n          : (corner === 'mt' || corner === 'mb')\r\n            ? 'scaleY'\r\n            : corner === 'mtr'\r\n              ? 'rotate'\r\n              : 'scale';\r\n      }\r\n      return action;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object\r\n     * @param {fabric.Object} target\r\n     */\r\n    _setupCurrentTransform: function (e, target) {\r\n      if (!target) {\r\n        return;\r\n      }\r\n\r\n      var pointer = this.getPointer(e),\r\n          corner = target._findTargetCorner(this.getPointer(e, true)),\r\n          action = this._getActionFromCorner(target, corner),\r\n          origin = this._getOriginFromCorner(target, corner);\r\n\r\n      this._currentTransform = {\r\n        target: target,\r\n        action: action,\r\n        scaleX: target.scaleX,\r\n        scaleY: target.scaleY,\r\n        offsetX: pointer.x - target.left,\r\n        offsetY: pointer.y - target.top,\r\n        originX: origin.x,\r\n        originY: origin.y,\r\n        ex: pointer.x,\r\n        ey: pointer.y,\r\n        left: target.left,\r\n        top: target.top,\r\n        theta: degreesToRadians(target.angle),\r\n        width: target.width * target.scaleX,\r\n        mouseXSign: 1,\r\n        mouseYSign: 1\r\n      };\r\n\r\n      this._currentTransform.original = {\r\n        left: target.left,\r\n        top: target.top,\r\n        scaleX: target.scaleX,\r\n        scaleY: target.scaleY,\r\n        originX: origin.x,\r\n        originY: origin.y\r\n      };\r\n\r\n      this._resetCurrentTransform(e);\r\n    },\r\n\r\n    /**\r\n     * Translates object by \"setting\" its left/top\r\n     * @private\r\n     * @param {Number} x pointer's x coordinate\r\n     * @param {Number} y pointer's y coordinate\r\n     */\r\n    _translateObject: function (x, y) {\r\n      var target = this._currentTransform.target;\r\n\r\n      if (!target.get('lockMovementX')) {\r\n        target.set('left', x - this._currentTransform.offsetX);\r\n      }\r\n      if (!target.get('lockMovementY')) {\r\n        target.set('top', y - this._currentTransform.offsetY);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Scales object by invoking its scaleX/scaleY methods\r\n     * @private\r\n     * @param {Number} x pointer's x coordinate\r\n     * @param {Number} y pointer's y coordinate\r\n     * @param {String} by Either 'x' or 'y' - specifies dimension constraint by which to scale an object.\r\n     *                    When not provided, an object is scaled by both dimensions equally\r\n     */\r\n    _scaleObject: function (x, y, by) {\r\n      var t = this._currentTransform,\r\n          target = t.target,\r\n          lockScalingX = target.get('lockScalingX'),\r\n          lockScalingY = target.get('lockScalingY'),\r\n          lockScalingFlip = target.get('lockScalingFlip');\r\n\r\n      if (lockScalingX && lockScalingY) {\r\n        return;\r\n      }\r\n\r\n      // Get the constraint point\r\n      var constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY),\r\n          localMouse = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY);\r\n\r\n      this._setLocalMouse(localMouse, t);\r\n\r\n      // Actually scale the object\r\n      this._setObjectScale(localMouse, t, lockScalingX, lockScalingY, by, lockScalingFlip);\r\n\r\n      // Make sure the constraints apply\r\n      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setObjectScale: function(localMouse, transform, lockScalingX, lockScalingY, by, lockScalingFlip) {\r\n      var target = transform.target, forbidScalingX = false, forbidScalingY = false,\r\n          dim = target._getNonTransformedDimensions();\r\n\r\n      transform.newScaleX = localMouse.x / dim.x;\r\n      transform.newScaleY = localMouse.y / dim.y;\r\n\r\n      if (lockScalingFlip && transform.newScaleX <= 0 && transform.newScaleX < target.scaleX) {\r\n        forbidScalingX = true;\r\n      }\r\n\r\n      if (lockScalingFlip && transform.newScaleY <= 0 && transform.newScaleY < target.scaleY) {\r\n        forbidScalingY = true;\r\n      }\r\n\r\n      if (by === 'equally' && !lockScalingX && !lockScalingY) {\r\n        forbidScalingX || forbidScalingY || this._scaleObjectEqually(localMouse, target, transform);\r\n      }\r\n      else if (!by) {\r\n        forbidScalingX || lockScalingX || target.set('scaleX', transform.newScaleX);\r\n        forbidScalingY || lockScalingY || target.set('scaleY', transform.newScaleY);\r\n      }\r\n      else if (by === 'x' && !target.get('lockUniScaling')) {\r\n        forbidScalingX || lockScalingX || target.set('scaleX', transform.newScaleX);\r\n      }\r\n      else if (by === 'y' && !target.get('lockUniScaling')) {\r\n        forbidScalingY || lockScalingY || target.set('scaleY', transform.newScaleY);\r\n      }\r\n\r\n      forbidScalingX || forbidScalingY || this._flipObject(transform, by);\r\n\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _scaleObjectEqually: function(localMouse, target, transform) {\r\n\r\n      var dist = localMouse.y + localMouse.x,\r\n          dim = target._getNonTransformedDimensions(),\r\n          lastDist = dim.y * transform.original.scaleY +\r\n                     dim.x * transform.original.scaleX;\r\n\r\n      // We use transform.scaleX/Y instead of target.scaleX/Y\r\n      // because the object may have a min scale and we'll loose the proportions\r\n      transform.newScaleX = transform.original.scaleX * dist / lastDist;\r\n      transform.newScaleY = transform.original.scaleY * dist / lastDist;\r\n\r\n      target.set('scaleX', transform.newScaleX);\r\n      target.set('scaleY', transform.newScaleY);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _flipObject: function(transform, by) {\r\n      if (transform.newScaleX < 0 && by !== 'y') {\r\n        if (transform.originX === 'left') {\r\n          transform.originX = 'right';\r\n        }\r\n        else if (transform.originX === 'right') {\r\n          transform.originX = 'left';\r\n        }\r\n      }\r\n\r\n      if (transform.newScaleY < 0 && by !== 'x') {\r\n        if (transform.originY === 'top') {\r\n          transform.originY = 'bottom';\r\n        }\r\n        else if (transform.originY === 'bottom') {\r\n          transform.originY = 'top';\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setLocalMouse: function(localMouse, t) {\r\n      var target = t.target;\r\n\r\n      if (t.originX === 'right') {\r\n        localMouse.x *= -1;\r\n      }\r\n      else if (t.originX === 'center') {\r\n        localMouse.x *= t.mouseXSign * 2;\r\n\r\n        if (localMouse.x < 0) {\r\n          t.mouseXSign = -t.mouseXSign;\r\n        }\r\n      }\r\n\r\n      if (t.originY === 'bottom') {\r\n        localMouse.y *= -1;\r\n      }\r\n      else if (t.originY === 'center') {\r\n        localMouse.y *= t.mouseYSign * 2;\r\n\r\n        if (localMouse.y < 0) {\r\n          t.mouseYSign = -t.mouseYSign;\r\n        }\r\n      }\r\n\r\n      // adjust the mouse coordinates when dealing with padding\r\n      if (abs(localMouse.x) > target.padding) {\r\n        if (localMouse.x < 0) {\r\n          localMouse.x += target.padding;\r\n        }\r\n        else {\r\n          localMouse.x -= target.padding;\r\n        }\r\n      }\r\n      else { // mouse is within the padding, set to 0\r\n        localMouse.x = 0;\r\n      }\r\n\r\n      if (abs(localMouse.y) > target.padding) {\r\n        if (localMouse.y < 0) {\r\n          localMouse.y += target.padding;\r\n        }\r\n        else {\r\n          localMouse.y -= target.padding;\r\n        }\r\n      }\r\n      else {\r\n        localMouse.y = 0;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Rotates object by invoking its rotate method\r\n     * @private\r\n     * @param {Number} x pointer's x coordinate\r\n     * @param {Number} y pointer's y coordinate\r\n     */\r\n    _rotateObject: function (x, y) {\r\n\r\n      var t = this._currentTransform;\r\n\r\n      if (t.target.get('lockRotation')) {\r\n        return;\r\n      }\r\n\r\n      var lastAngle = atan2(t.ey - t.top, t.ex - t.left),\r\n          curAngle = atan2(y - t.top, x - t.left),\r\n          angle = radiansToDegrees(curAngle - lastAngle + t.theta);\r\n\r\n      // normalize angle to positive value\r\n      if (angle < 0) {\r\n        angle = 360 + angle;\r\n      }\r\n\r\n      t.target.angle = angle % 360;\r\n    },\r\n\r\n    /**\r\n     * Set the cursor type of the canvas element\r\n     * @param {String} value Cursor type of the canvas element.\r\n     * @see http://www.w3.org/TR/css3-ui/#cursor\r\n     */\r\n    setCursor: function (value) {\r\n      this.upperCanvasEl.style.cursor = value;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _resetObjectTransform: function (target) {\r\n      target.scaleX = 1;\r\n      target.scaleY = 1;\r\n      target.setAngle(0);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _drawSelection: function () {\r\n      var ctx = this.contextTop,\r\n          groupSelector = this._groupSelector,\r\n          left = groupSelector.left,\r\n          top = groupSelector.top,\r\n          aleft = abs(left),\r\n          atop = abs(top);\r\n\r\n      ctx.fillStyle = this.selectionColor;\r\n\r\n      ctx.fillRect(\r\n        groupSelector.ex - ((left > 0) ? 0 : -left),\r\n        groupSelector.ey - ((top > 0) ? 0 : -top),\r\n        aleft,\r\n        atop\r\n      );\r\n\r\n      ctx.lineWidth = this.selectionLineWidth;\r\n      ctx.strokeStyle = this.selectionBorderColor;\r\n\r\n      // selection border\r\n      if (this.selectionDashArray.length > 1) {\r\n\r\n        var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0: aleft),\r\n            py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0: atop);\r\n\r\n        ctx.beginPath();\r\n\r\n        fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);\r\n        fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);\r\n        fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);\r\n        fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);\r\n\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n      }\r\n      else {\r\n        ctx.strokeRect(\r\n          groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),\r\n          groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),\r\n          aleft,\r\n          atop\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _isLastRenderedObject: function(e) {\r\n      return (\r\n        this.controlsAboveOverlay &&\r\n        this.lastRenderedObjectWithControlsAboveOverlay &&\r\n        this.lastRenderedObjectWithControlsAboveOverlay.visible &&\r\n        this.containsPoint(e, this.lastRenderedObjectWithControlsAboveOverlay) &&\r\n        this.lastRenderedObjectWithControlsAboveOverlay._findTargetCorner(this.getPointer(e, true)));\r\n    },\r\n\r\n    /**\r\n     * Method that determines what object we are clicking on\r\n     * @param {Event} e mouse event\r\n     * @param {Boolean} skipGroup when true, group is skipped and only objects are traversed through\r\n     */\r\n    findTarget: function (e, skipGroup) {\r\n      if (this.skipTargetFind) {\r\n        return;\r\n      }\r\n\r\n      if (this._isLastRenderedObject(e)) {\r\n        return this.lastRenderedObjectWithControlsAboveOverlay;\r\n      }\r\n\r\n      // first check current group (if one exists)\r\n      var activeGroup = this.getActiveGroup();\r\n      if (activeGroup && !skipGroup && this.containsPoint(e, activeGroup)) {\r\n        return activeGroup;\r\n      }\r\n\r\n      var target = this._searchPossibleTargets(e, skipGroup);\r\n      this._fireOverOutEvents(target, e);\r\n\r\n      return target;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _fireOverOutEvents: function(target, e) {\r\n      if (target) {\r\n        if (this._hoveredTarget !== target) {\r\n          if (this._hoveredTarget) {\r\n            this.fire('mouse:out', { target: this._hoveredTarget, e: e });\r\n            this._hoveredTarget.fire('mouseout');\r\n          }\r\n          this.fire('mouse:over', { target: target, e: e });\r\n          target.fire('mouseover');\r\n          this._hoveredTarget = target;\r\n        }\r\n      }\r\n      else if (this._hoveredTarget) {\r\n        this.fire('mouse:out', { target: this._hoveredTarget, e: e });\r\n        this._hoveredTarget.fire('mouseout');\r\n        this._hoveredTarget = null;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _checkTarget: function(e, obj, pointer) {\r\n      if (obj &&\r\n          obj.visible &&\r\n          obj.evented &&\r\n          this.containsPoint(e, obj)){\r\n        if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {\r\n          var isTransparent = this.isTargetTransparent(obj, pointer.x, pointer.y);\r\n          if (!isTransparent) {\r\n            return true;\r\n          }\r\n        }\r\n        else {\r\n          return true;\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _searchPossibleTargets: function(e, skipGroup) {\r\n\r\n      // Cache all targets where their bounding box contains point.\r\n      var target,\r\n          pointer = this.getPointer(e, true),\r\n          i = this._objects.length;\r\n      // Do not check for currently grouped objects, since we check the parent group itself.\r\n      // untill we call this function specifically to search inside the activeGroup\r\n      while (i--) {\r\n        if ((!this._objects[i].group || skipGroup) && this._checkTarget(e, this._objects[i], pointer)){\r\n          this.relatedTarget = this._objects[i];\r\n          target = this._objects[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      return target;\r\n    },\r\n\r\n    /**\r\n     * Returns pointer coordinates relative to canvas.\r\n     * @param {Event} e\r\n     * @return {Object} object with \"x\" and \"y\" number values\r\n     */\r\n    getPointer: function (e, ignoreZoom, upperCanvasEl) {\r\n      if (!upperCanvasEl) {\r\n        upperCanvasEl = this.upperCanvasEl;\r\n      }\r\n      var pointer = getPointer(e),\r\n          bounds = upperCanvasEl.getBoundingClientRect(),\r\n          boundsWidth = bounds.width || 0,\r\n          boundsHeight = bounds.height || 0,\r\n          cssScale;\r\n\r\n      if (!boundsWidth || !boundsHeight ) {\r\n        if ('top' in bounds && 'bottom' in bounds) {\r\n          boundsHeight = Math.abs( bounds.top - bounds.bottom );\r\n        }\r\n        if ('right' in bounds && 'left' in bounds) {\r\n          boundsWidth = Math.abs( bounds.right - bounds.left );\r\n        }\r\n      }\r\n\r\n      this.calcOffset();\r\n\r\n      pointer.x = pointer.x - this._offset.left;\r\n      pointer.y = pointer.y - this._offset.top;\r\n      if (!ignoreZoom) {\r\n        pointer = fabric.util.transformPoint(\r\n          pointer,\r\n          fabric.util.invertTransform(this.viewportTransform)\r\n        );\r\n      }\r\n\r\n      if (boundsWidth === 0 || boundsHeight === 0) {\r\n        // If bounds are not available (i.e. not visible), do not apply scale.\r\n        cssScale = { width: 1, height: 1 };\r\n      }\r\n      else {\r\n        cssScale = {\r\n          width: upperCanvasEl.width / boundsWidth,\r\n          height: upperCanvasEl.height / boundsHeight\r\n        };\r\n      }\r\n\r\n      return {\r\n        x: pointer.x * cssScale.width,\r\n        y: pointer.y * cssScale.height\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized\r\n     */\r\n    _createUpperCanvas: function () {\r\n      var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\\s*lower-canvas\\s*/, '');\r\n\r\n      this.upperCanvasEl = this._createCanvasElement();\r\n      fabric.util.addClass(this.upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);\r\n\r\n      this.wrapperEl.appendChild(this.upperCanvasEl);\r\n\r\n      this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl);\r\n      this._applyCanvasStyle(this.upperCanvasEl);\r\n      this.contextTop = this.upperCanvasEl.getContext('2d');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _createCacheCanvas: function () {\r\n      this.cacheCanvasEl = this._createCanvasElement();\r\n      this.cacheCanvasEl.setAttribute('width', this.width);\r\n      this.cacheCanvasEl.setAttribute('height', this.height);\r\n      this.contextCache = this.cacheCanvasEl.getContext('2d');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _initWrapperElement: function () {\r\n      this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {\r\n        'class': this.containerClass\r\n      });\r\n      fabric.util.setStyle(this.wrapperEl, {\r\n        width: this.getWidth() + 'px',\r\n        height: this.getHeight() + 'px',\r\n        position: 'relative'\r\n      });\r\n      fabric.util.makeElementUnselectable(this.wrapperEl);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {HTMLElement} element canvas element to apply styles on\r\n     */\r\n    _applyCanvasStyle: function (element) {\r\n      var width = this.getWidth() || element.width,\r\n          height = this.getHeight() || element.height;\r\n\r\n      fabric.util.setStyle(element, {\r\n        position: 'absolute',\r\n        width: width + 'px',\r\n        height: height + 'px',\r\n        left: 0,\r\n        top: 0\r\n      });\r\n      element.width = width;\r\n      element.height = height;\r\n      fabric.util.makeElementUnselectable(element);\r\n    },\r\n\r\n    /**\r\n     * Copys the the entire inline style from one element (fromEl) to another (toEl)\r\n     * @private\r\n     * @param {Element} fromEl Element style is copied from\r\n     * @param {Element} toEl Element copied style is applied to\r\n     */\r\n    _copyCanvasStyle: function (fromEl, toEl) {\r\n      toEl.style.cssText = fromEl.style.cssText;\r\n    },\r\n\r\n    /**\r\n     * Returns context of canvas where object selection is drawn\r\n     * @return {CanvasRenderingContext2D}\r\n     */\r\n    getSelectionContext: function() {\r\n      return this.contextTop;\r\n    },\r\n\r\n    /**\r\n     * Returns &lt;canvas> element on which object selection is drawn\r\n     * @return {HTMLCanvasElement}\r\n     */\r\n    getSelectionElement: function () {\r\n      return this.upperCanvasEl;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} object\r\n     */\r\n    _setActiveObject: function(object) {\r\n      if (this._activeObject) {\r\n        this._activeObject.set('active', false);\r\n      }\r\n      this._activeObject = object;\r\n      object.set('active', true);\r\n    },\r\n\r\n    /**\r\n     * Sets given object as the only active object on canvas\r\n     * @param {fabric.Object} object Object to set as an active one\r\n     * @param {Event} [e] Event (passed along when firing \"object:selected\")\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    setActiveObject: function (object, e) {\r\n      this._setActiveObject(object);\r\n      this.renderAll();\r\n      this.fire('object:selected', { target: object, e: e });\r\n      object.fire('selected', { e: e });\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns currently active object\r\n     * @return {fabric.Object} active object\r\n     */\r\n    getActiveObject: function () {\r\n      return this._activeObject;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _discardActiveObject: function() {\r\n      if (this._activeObject) {\r\n        this._activeObject.set('active', false);\r\n      }\r\n      this._activeObject = null;\r\n    },\r\n\r\n    /**\r\n     * Discards currently active object\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    discardActiveObject: function (e) {\r\n      this._discardActiveObject();\r\n      this.renderAll();\r\n      this.fire('selection:cleared', { e: e });\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {fabric.Group} group\r\n     */\r\n    _setActiveGroup: function(group) {\r\n      this._activeGroup = group;\r\n      if (group) {\r\n        group.set('active', true);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets active group to a speicified one\r\n     * @param {fabric.Group} group Group to set as a current one\r\n     * @return {fabric.Canvas} thisArg\r\n     * @chainable\r\n     */\r\n    setActiveGroup: function (group, e) {\r\n      this._setActiveGroup(group);\r\n      if (group) {\r\n        this.fire('object:selected', { target: group, e: e });\r\n        group.fire('selected', { e: e });\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns currently active group\r\n     * @return {fabric.Group} Current group\r\n     */\r\n    getActiveGroup: function () {\r\n      return this._activeGroup;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _discardActiveGroup: function() {\r\n      var g = this.getActiveGroup();\r\n      if (g) {\r\n        g.destroy();\r\n      }\r\n      this.setActiveGroup(null);\r\n    },\r\n\r\n    /**\r\n     * Discards currently active group\r\n     * @return {fabric.Canvas} thisArg\r\n     */\r\n    discardActiveGroup: function (e) {\r\n      this._discardActiveGroup();\r\n      this.fire('selection:cleared', { e: e });\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Deactivates all objects on canvas, removing any active group or object\r\n     * @return {fabric.Canvas} thisArg\r\n     */\r\n    deactivateAll: function () {\r\n      var allObjects = this.getObjects(),\r\n          i = 0,\r\n          len = allObjects.length;\r\n      for ( ; i < len; i++) {\r\n        allObjects[i].set('active', false);\r\n      }\r\n      this._discardActiveGroup();\r\n      this._discardActiveObject();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Deactivates all objects and dispatches appropriate events\r\n     * @return {fabric.Canvas} thisArg\r\n     */\r\n    deactivateAllWithDispatch: function (e) {\r\n      var activeObject = this.getActiveGroup() || this.getActiveObject();\r\n      if (activeObject) {\r\n        this.fire('before:selection:cleared', { target: activeObject, e: e });\r\n      }\r\n      this.deactivateAll();\r\n      if (activeObject) {\r\n        this.fire('selection:cleared', { e: e });\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Draws objects' controls (borders/controls)\r\n     * @param {CanvasRenderingContext2D} ctx Context to render controls on\r\n     */\r\n    drawControls: function(ctx) {\r\n      var activeGroup = this.getActiveGroup();\r\n      if (activeGroup) {\r\n        this._drawGroupControls(ctx, activeGroup);\r\n      }\r\n      else {\r\n        this._drawObjectsControls(ctx);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _drawGroupControls: function(ctx, activeGroup) {\r\n      activeGroup._renderControls(ctx);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _drawObjectsControls: function(ctx) {\r\n      for (var i = 0, len = this._objects.length; i < len; ++i) {\r\n        if (!this._objects[i] || !this._objects[i].active) {\r\n          continue;\r\n        }\r\n        this._objects[i]._renderControls(ctx);\r\n        this.lastRenderedObjectWithControlsAboveOverlay = this._objects[i];\r\n      }\r\n    }\r\n  });\r\n\r\n  // copying static properties manually to work around Opera's bug,\r\n  // where \"prototype\" property is enumerable and overrides existing prototype\r\n  for (var prop in fabric.StaticCanvas) {\r\n    if (prop !== 'prototype') {\r\n      fabric.Canvas[prop] = fabric.StaticCanvas[prop];\r\n    }\r\n  }\r\n\r\n  if (fabric.isTouchSupported) {\r\n    /** @ignore */\r\n    fabric.Canvas.prototype._setCursorFromEvent = function() { };\r\n  }\r\n\r\n  /**\r\n   * @class fabric.Element\r\n   * @alias fabric.Canvas\r\n   * @deprecated Use {@link fabric.Canvas} instead.\r\n   * @constructor\r\n   */\r\n  fabric.Element = fabric.Canvas;\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  var cursorOffset = {\r\n    mt: 0, // n\r\n    tr: 1, // ne\r\n    mr: 2, // e\r\n    br: 3, // se\r\n    mb: 4, // s\r\n    bl: 5, // sw\r\n    ml: 6, // w\r\n    tl: 7 // nw\r\n  },\r\n  addListener = fabric.util.addListener,\r\n  removeListener = fabric.util.removeListener;\r\n\r\n  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\r\n\r\n    /**\r\n     * Map of cursor style values for each of the object controls\r\n     * @private\r\n     */\r\n    cursorMap: [\r\n      'n-resize',\r\n      'ne-resize',\r\n      'e-resize',\r\n      'se-resize',\r\n      's-resize',\r\n      'sw-resize',\r\n      'w-resize',\r\n      'nw-resize'\r\n    ],\r\n\r\n    /**\r\n     * Adds mouse listeners to canvas\r\n     * @private\r\n     */\r\n    _initEventListeners: function () {\r\n\r\n      this._bindEvents();\r\n\r\n      addListener(fabric.window, 'resize', this._onResize);\r\n\r\n      // mouse events\r\n      addListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);\r\n      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);\r\n      addListener(this.upperCanvasEl, 'mousewheel', this._onMouseWheel);\r\n\r\n      // touch events\r\n      addListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);\r\n      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);\r\n\r\n      if (typeof eventjs !== 'undefined' && 'add' in eventjs) {\r\n        eventjs.add(this.upperCanvasEl, 'gesture', this._onGesture);\r\n        eventjs.add(this.upperCanvasEl, 'drag', this._onDrag);\r\n        eventjs.add(this.upperCanvasEl, 'orientation', this._onOrientationChange);\r\n        eventjs.add(this.upperCanvasEl, 'shake', this._onShake);\r\n        eventjs.add(this.upperCanvasEl, 'longpress', this._onLongPress);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _bindEvents: function() {\r\n      this._onMouseDown = this._onMouseDown.bind(this);\r\n      this._onMouseMove = this._onMouseMove.bind(this);\r\n      this._onMouseUp = this._onMouseUp.bind(this);\r\n      this._onResize = this._onResize.bind(this);\r\n      this._onGesture = this._onGesture.bind(this);\r\n      this._onDrag = this._onDrag.bind(this);\r\n      this._onShake = this._onShake.bind(this);\r\n      this._onLongPress = this._onLongPress.bind(this);\r\n      this._onOrientationChange = this._onOrientationChange.bind(this);\r\n      this._onMouseWheel = this._onMouseWheel.bind(this);\r\n    },\r\n\r\n    /**\r\n     * Removes all event listeners\r\n     */\r\n    removeListeners: function() {\r\n      removeListener(fabric.window, 'resize', this._onResize);\r\n\r\n      removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);\r\n      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);\r\n      removeListener(this.upperCanvasEl, 'mousewheel', this._onMouseWheel);\r\n\r\n      removeListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);\r\n      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);\r\n\r\n      if (typeof eventjs !== 'undefined' && 'remove' in eventjs) {\r\n        eventjs.remove(this.upperCanvasEl, 'gesture', this._onGesture);\r\n        eventjs.remove(this.upperCanvasEl, 'drag', this._onDrag);\r\n        eventjs.remove(this.upperCanvasEl, 'orientation', this._onOrientationChange);\r\n        eventjs.remove(this.upperCanvasEl, 'shake', this._onShake);\r\n        eventjs.remove(this.upperCanvasEl, 'longpress', this._onLongPress);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} [e] Event object fired on Event.js gesture\r\n     * @param {Event} [self] Inner Event object\r\n     */\r\n    _onGesture: function(e, self) {\r\n      this.__onTransformGesture && this.__onTransformGesture(e, self);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} [e] Event object fired on Event.js drag\r\n     * @param {Event} [self] Inner Event object\r\n     */\r\n    _onDrag: function(e, self) {\r\n      this.__onDrag && this.__onDrag(e, self);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} [e] Event object fired on Event.js wheel event\r\n     * @param {Event} [self] Inner Event object\r\n     */\r\n    _onMouseWheel: function(e, self) {\r\n      this.__onMouseWheel && this.__onMouseWheel(e, self);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} [e] Event object fired on Event.js orientation change\r\n     * @param {Event} [self] Inner Event object\r\n     */\r\n    _onOrientationChange: function(e, self) {\r\n      this.__onOrientationChange && this.__onOrientationChange(e, self);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} [e] Event object fired on Event.js shake\r\n     * @param {Event} [self] Inner Event object\r\n     */\r\n    _onShake: function(e, self) {\r\n      this.__onShake && this.__onShake(e, self);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} [e] Event object fired on Event.js shake\r\n     * @param {Event} [self] Inner Event object\r\n     */\r\n    _onLongPress: function(e, self) {\r\n      this.__onLongPress && this.__onLongPress(e, self);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object fired on mousedown\r\n     */\r\n    _onMouseDown: function (e) {\r\n      this.__onMouseDown(e);\r\n\r\n      addListener(fabric.document, 'touchend', this._onMouseUp);\r\n      addListener(fabric.document, 'touchmove', this._onMouseMove);\r\n\r\n      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);\r\n      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);\r\n\r\n      if (e.type === 'touchstart') {\r\n        // Unbind mousedown to prevent double triggers from touch devices\r\n        removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);\r\n      }\r\n      else {\r\n        addListener(fabric.document, 'mouseup', this._onMouseUp);\r\n        addListener(fabric.document, 'mousemove', this._onMouseMove);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object fired on mouseup\r\n     */\r\n    _onMouseUp: function (e) {\r\n      this.__onMouseUp(e);\r\n\r\n      removeListener(fabric.document, 'mouseup', this._onMouseUp);\r\n      removeListener(fabric.document, 'touchend', this._onMouseUp);\r\n\r\n      removeListener(fabric.document, 'mousemove', this._onMouseMove);\r\n      removeListener(fabric.document, 'touchmove', this._onMouseMove);\r\n\r\n      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);\r\n      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);\r\n\r\n      if (e.type === 'touchend') {\r\n        // Wait 400ms before rebinding mousedown to prevent double triggers\r\n        // from touch devices\r\n        var _this = this;\r\n        setTimeout(function() {\r\n          addListener(_this.upperCanvasEl, 'mousedown', _this._onMouseDown);\r\n        }, 400);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object fired on mousemove\r\n     */\r\n    _onMouseMove: function (e) {\r\n      !this.allowTouchScrolling && e.preventDefault && e.preventDefault();\r\n      this.__onMouseMove(e);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _onResize: function () {\r\n      this.calcOffset();\r\n    },\r\n\r\n    /**\r\n     * Decides whether the canvas should be redrawn in mouseup and mousedown events.\r\n     * @private\r\n     * @param {Object} target\r\n     * @param {Object} pointer\r\n     */\r\n    _shouldRender: function(target, pointer) {\r\n      var activeObject = this.getActiveGroup() || this.getActiveObject();\r\n\r\n      return !!(\r\n        (target && (\r\n          target.isMoving ||\r\n          target !== activeObject))\r\n        ||\r\n        (!target && !!activeObject)\r\n        ||\r\n        (!target && !activeObject && !this._groupSelector)\r\n        ||\r\n        (pointer &&\r\n          this._previousPointer &&\r\n          this.selection && (\r\n          pointer.x !== this._previousPointer.x ||\r\n          pointer.y !== this._previousPointer.y))\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Method that defines the actions when mouse is released on canvas.\r\n     * The method resets the currentTransform parameters, store the image corner\r\n     * position in the image object and render the canvas on top.\r\n     * @private\r\n     * @param {Event} e Event object fired on mouseup\r\n     */\r\n    __onMouseUp: function (e) {\r\n      var target;\r\n\r\n      if (this.isDrawingMode && this._isCurrentlyDrawing) {\r\n        this._onMouseUpInDrawingMode(e);\r\n        return;\r\n      }\r\n\r\n      if (this._currentTransform) {\r\n        this._finalizeCurrentTransform();\r\n        target = this._currentTransform.target;\r\n      }\r\n      else {\r\n        target = this.findTarget(e, true);\r\n      }\r\n\r\n      var shouldRender = this._shouldRender(target, this.getPointer(e));\r\n\r\n      this._maybeGroupObjects(e);\r\n\r\n      if (target) {\r\n        target.isMoving = false;\r\n      }\r\n\r\n      shouldRender && this.renderAll();\r\n\r\n      this._handleCursorAndEvent(e, target);\r\n    },\r\n\r\n    _handleCursorAndEvent: function(e, target) {\r\n      this._setCursorFromEvent(e, target);\r\n\r\n      // TODO: why are we doing this?\r\n      var _this = this;\r\n      setTimeout(function () {\r\n        _this._setCursorFromEvent(e, target);\r\n      }, 50);\r\n\r\n      this.fire('mouse:up', { target: target, e: e });\r\n      target && target.fire('mouseup', { e: e });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _finalizeCurrentTransform: function() {\r\n\r\n      var transform = this._currentTransform,\r\n          target = transform.target;\r\n\r\n      if (target._scaling) {\r\n        target._scaling = false;\r\n      }\r\n\r\n      target.setCoords();\r\n\r\n      // only fire :modified event if target coordinates were changed during mousedown-mouseup\r\n      if (this.stateful && target.hasStateChanged()) {\r\n        this.fire('object:modified', { target: target });\r\n        target.fire('modified');\r\n      }\r\n\r\n      this._restoreOriginXY(target);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} target Object to restore\r\n     */\r\n    _restoreOriginXY: function(target) {\r\n      if (this._previousOriginX && this._previousOriginY) {\r\n\r\n        var originPoint = target.translateToOriginPoint(\r\n          target.getCenterPoint(),\r\n          this._previousOriginX,\r\n          this._previousOriginY);\r\n\r\n        target.originX = this._previousOriginX;\r\n        target.originY = this._previousOriginY;\r\n\r\n        target.left = originPoint.x;\r\n        target.top = originPoint.y;\r\n\r\n        this._previousOriginX = null;\r\n        this._previousOriginY = null;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object fired on mousedown\r\n     */\r\n    _onMouseDownInDrawingMode: function(e) {\r\n      this._isCurrentlyDrawing = true;\r\n      this.discardActiveObject(e).renderAll();\r\n      if (this.clipTo) {\r\n        fabric.util.clipContext(this, this.contextTop);\r\n      }\r\n      var ivt = fabric.util.invertTransform(this.viewportTransform),\r\n          pointer = fabric.util.transformPoint(this.getPointer(e, true), ivt);\r\n      this.freeDrawingBrush.onMouseDown(pointer);\r\n      this.fire('mouse:down', { e: e });\r\n\r\n      var target = this.findTarget(e);\r\n      if (typeof target !== 'undefined') {\r\n        target.fire('mousedown', { e: e, target: target });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object fired on mousemove\r\n     */\r\n    _onMouseMoveInDrawingMode: function(e) {\r\n      if (this._isCurrentlyDrawing) {\r\n        var ivt = fabric.util.invertTransform(this.viewportTransform),\r\n            pointer = fabric.util.transformPoint(this.getPointer(e, true), ivt);\r\n        this.freeDrawingBrush.onMouseMove(pointer);\r\n      }\r\n      this.setCursor(this.freeDrawingCursor);\r\n      this.fire('mouse:move', { e: e });\r\n\r\n      var target = this.findTarget(e);\r\n      if (typeof target !== 'undefined') {\r\n        target.fire('mousemove', { e: e, target: target });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object fired on mouseup\r\n     */\r\n    _onMouseUpInDrawingMode: function(e) {\r\n      this._isCurrentlyDrawing = false;\r\n      if (this.clipTo) {\r\n        this.contextTop.restore();\r\n      }\r\n      this.freeDrawingBrush.onMouseUp();\r\n      this.fire('mouse:up', { e: e });\r\n\r\n      var target = this.findTarget(e);\r\n      if (typeof target !== 'undefined') {\r\n        target.fire('mouseup', { e: e, target: target });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Method that defines the actions when mouse is clic ked on canvas.\r\n     * The method inits the currentTransform parameters and renders all the\r\n     * canvas so the current image can be placed on the top canvas and the rest\r\n     * in on the container one.\r\n     * @private\r\n     * @param {Event} e Event object fired on mousedown\r\n     */\r\n    __onMouseDown: function (e) {\r\n\r\n      // accept only left clicks\r\n      var isLeftClick  = 'which' in e ? e.which === 1 : e.button === 1;\r\n      if (!isLeftClick && !fabric.isTouchSupported) {\r\n        return;\r\n      }\r\n\r\n      if (this.isDrawingMode) {\r\n        this._onMouseDownInDrawingMode(e);\r\n        return;\r\n      }\r\n\r\n      // ignore if some object is being transformed at this moment\r\n      if (this._currentTransform) {\r\n        return;\r\n      }\r\n\r\n      var target = this.findTarget(e),\r\n          pointer = this.getPointer(e, true);\r\n\r\n      // save pointer for check in __onMouseUp event\r\n      this._previousPointer = pointer;\r\n\r\n      var shouldRender = this._shouldRender(target, pointer),\r\n          shouldGroup = this._shouldGroup(e, target);\r\n\r\n      if (this._shouldClearSelection(e, target)) {\r\n        //this._clearSelection(e, target, pointer);\r\n      }\r\n      else if (shouldGroup) {\r\n        this._handleGrouping(e, target);\r\n        target = this.getActiveGroup();\r\n      }\r\n\r\n      if (target && target.selectable && !shouldGroup) {\r\n        this._beforeTransform(e, target);\r\n        this._setupCurrentTransform(e, target);\r\n      }\r\n      // we must renderAll so that active image is placed on the top canvas\r\n      shouldRender && this.renderAll();\r\n\r\n      this.fire('mouse:down', { target: target, e: e });\r\n      target && target.fire('mousedown', { e: e });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _beforeTransform: function(e, target) {\r\n      this.stateful && target.saveState();\r\n\r\n      // determine if it's a drag or rotate case\r\n      if (target._findTargetCorner(this.getPointer(e))) {\r\n        this.onBeforeScaleRotate(target);\r\n      }\r\n\r\n      if (target !== this.getActiveGroup() && target !== this.getActiveObject()) {\r\n        this.deactivateAll();\r\n        this.setActiveObject(target, e);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _clearSelection: function(e, target, pointer) {\r\n      this.deactivateAllWithDispatch(e);\r\n\r\n      if (target && target.selectable) {\r\n        this.setActiveObject(target, e);\r\n      }\r\n      else if (this.selection) {\r\n        this._groupSelector = {\r\n          ex: pointer.x,\r\n          ey: pointer.y,\r\n          top: 0,\r\n          left: 0\r\n        };\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} target Object for that origin is set to center\r\n     */\r\n    _setOriginToCenter: function(target) {\r\n      this._previousOriginX = this._currentTransform.target.originX;\r\n      this._previousOriginY = this._currentTransform.target.originY;\r\n\r\n      var center = target.getCenterPoint();\r\n\r\n      target.originX = 'center';\r\n      target.originY = 'center';\r\n\r\n      target.left = center.x;\r\n      target.top = center.y;\r\n\r\n      this._currentTransform.left = target.left;\r\n      this._currentTransform.top = target.top;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} target Object for that center is set to origin\r\n     */\r\n    _setCenterToOrigin: function(target) {\r\n      var originPoint = target.translateToOriginPoint(\r\n        target.getCenterPoint(),\r\n        this._previousOriginX,\r\n        this._previousOriginY);\r\n\r\n      target.originX = this._previousOriginX;\r\n      target.originY = this._previousOriginY;\r\n\r\n      target.left = originPoint.x;\r\n      target.top = originPoint.y;\r\n\r\n      this._previousOriginX = null;\r\n      this._previousOriginY = null;\r\n    },\r\n\r\n    /**\r\n     * Method that defines the actions when mouse is hovering the canvas.\r\n     * The currentTransform parameter will definde whether the user is rotating/scaling/translating\r\n     * an image or neither of them (only hovering). A group selection is also possible and would cancel\r\n     * all any other type of action.\r\n     * In case of an image transformation only the top canvas will be rendered.\r\n     * @private\r\n     * @param {Event} e Event object fired on mousemove\r\n     */\r\n    __onMouseMove: function (e) {\r\n\r\n      var target, pointer;\r\n\r\n      if (this.isDrawingMode) {\r\n        this._onMouseMoveInDrawingMode(e);\r\n        return;\r\n      }\r\n      if (typeof e.touches !== 'undefined' && e.touches.length > 1) {\r\n        return;\r\n      }\r\n\r\n      var groupSelector = this._groupSelector;\r\n\r\n      // We initially clicked in an empty area, so we draw a box for multiple selection\r\n      if (groupSelector) {\r\n        pointer = this.getPointer(e, true);\r\n\r\n        groupSelector.left = pointer.x - groupSelector.ex;\r\n        groupSelector.top = pointer.y - groupSelector.ey;\r\n\r\n        this.renderTop();\r\n      }\r\n      else if (!this._currentTransform) {\r\n\r\n        target = this.findTarget(e);\r\n\r\n        if (!target || target && !target.selectable) {\r\n          this.setCursor(this.defaultCursor);\r\n        }\r\n        else {\r\n          this._setCursorFromEvent(e, target);\r\n        }\r\n      }\r\n      else {\r\n        this._transformObject(e);\r\n      }\r\n\r\n      this.fire('mouse:move', { target: target, e: e });\r\n      target && target.fire('mousemove', { e: e });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event fired on mousemove\r\n     */\r\n    _transformObject: function(e) {\r\n      var pointer = this.getPointer(e),\r\n          transform = this._currentTransform;\r\n\r\n      transform.reset = false,\r\n      transform.target.isMoving = true;\r\n\r\n      this._beforeScaleTransform(e, transform);\r\n      this._performTransformAction(e, transform, pointer);\r\n\r\n      this.renderAll();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _performTransformAction: function(e, transform, pointer) {\r\n      var x = pointer.x,\r\n          y = pointer.y,\r\n          target = transform.target,\r\n          action = transform.action;\r\n\r\n      if (action === 'rotate') {\r\n        this._rotateObject(x, y);\r\n        this._fire('rotating', target, e);\r\n      }\r\n      else if (action === 'scale') {\r\n        this._onScale(e, transform, x, y);\r\n        this._fire('scaling', target, e);\r\n      }\r\n      else if (action === 'scaleX') {\r\n        this._scaleObject(x, y, 'x');\r\n        this._fire('scaling', target, e);\r\n      }\r\n      else if (action === 'scaleY') {\r\n        this._scaleObject(x, y, 'y');\r\n        this._fire('scaling', target, e);\r\n      }\r\n      else {\r\n        this._translateObject(x, y);\r\n        this._fire('moving', target, e);\r\n        this.setCursor(this.moveCursor);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _fire: function(eventName, target, e) {\r\n      this.fire('object:' + eventName, { target: target, e: e });\r\n      target.fire(eventName, { e: e });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _beforeScaleTransform: function(e, transform) {\r\n      if (transform.action === 'scale' || transform.action === 'scaleX' || transform.action === 'scaleY') {\r\n        var centerTransform = this._shouldCenterTransform(e, transform.target);\r\n\r\n        // Switch from a normal resize to center-based\r\n        if ((centerTransform && (transform.originX !== 'center' || transform.originY !== 'center')) ||\r\n           // Switch from center-based resize to normal one\r\n           (!centerTransform && transform.originX === 'center' && transform.originY === 'center')\r\n        ) {\r\n          this._resetCurrentTransform(e);\r\n          transform.reset = true;\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _onScale: function(e, transform, x, y) {\r\n      // rotate object only if shift key is not pressed\r\n      // and if it is not a group we are transforming\r\n      if ((e.shiftKey || this.uniScaleTransform) && !transform.target.get('lockUniScaling')) {\r\n        transform.currentAction = 'scale';\r\n        this._scaleObject(x, y);\r\n      }\r\n      else {\r\n        // Switch from a normal resize to proportional\r\n        if (!transform.reset && transform.currentAction === 'scale') {\r\n          this._resetCurrentTransform(e, transform.target);\r\n        }\r\n\r\n        transform.currentAction = 'scaleEqually';\r\n        this._scaleObject(x, y, 'equally');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets the cursor depending on where the canvas is being hovered.\r\n     * Note: very buggy in Opera\r\n     * @param {Event} e Event object\r\n     * @param {Object} target Object that the mouse is hovering, if so.\r\n     */\r\n    _setCursorFromEvent: function (e, target) {\r\n      if (!target || !target.selectable) {\r\n        this.setCursor(this.defaultCursor);\r\n        return false;\r\n      }\r\n      else {\r\n        var activeGroup = this.getActiveGroup(),\r\n            // only show proper corner when group selection is not active\r\n            corner = target._findTargetCorner\r\n                      && (!activeGroup || !activeGroup.contains(target))\r\n                      && target._findTargetCorner(this.getPointer(e, true));\r\n\r\n        if (!corner) {\r\n          this.setCursor(target.hoverCursor || this.hoverCursor);\r\n        }\r\n        else {\r\n          this._setCornerCursor(corner, target);\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setCornerCursor: function(corner, target) {\r\n      if (corner in cursorOffset) {\r\n        this.setCursor(this._getRotatedCornerCursor(corner, target));\r\n      }\r\n      else if (corner === 'mtr' && target.hasRotatingPoint) {\r\n        this.setCursor(this.rotationCursor);\r\n      }\r\n      else {\r\n        this.setCursor(this.defaultCursor);\r\n        return false;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getRotatedCornerCursor: function(corner, target) {\r\n      var n = Math.round((target.getAngle() % 360) / 45);\r\n\r\n      if (n < 0) {\r\n        n += 8; // full circle ahead\r\n      }\r\n      n += cursorOffset[corner];\r\n      // normalize n to be from 0 to 7\r\n      n %= 8;\r\n\r\n      return this.cursorMap[n];\r\n    }\r\n  });\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  var min = Math.min,\r\n      max = Math.max;\r\n\r\n  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object\r\n     * @param {fabric.Object} target\r\n     * @return {Boolean}\r\n     */\r\n    _shouldGroup: function(e, target) {\r\n      var activeObject = this.getActiveObject();\r\n      return e.shiftKey &&\r\n            (this.getActiveGroup() || (activeObject && activeObject !== target))\r\n            && this.selection;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e Event object\r\n     * @param {fabric.Object} target\r\n     */\r\n    _handleGrouping: function (e, target) {\r\n\r\n      if (target === this.getActiveGroup()) {\r\n\r\n        // if it's a group, find target again, this time skipping group\r\n        target = this.findTarget(e, true);\r\n\r\n        // if even object is not found, bail out\r\n        if (!target || target.isType('group')) {\r\n          return;\r\n        }\r\n      }\r\n      if (this.getActiveGroup()) {\r\n        this._updateActiveGroup(target, e);\r\n      }\r\n      else {\r\n        this._createActiveGroup(target, e);\r\n      }\r\n\r\n      if (this._activeGroup) {\r\n        this._activeGroup.saveCoords();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _updateActiveGroup: function(target, e) {\r\n      var activeGroup = this.getActiveGroup();\r\n\r\n      if (activeGroup.contains(target)) {\r\n\r\n        activeGroup.removeWithUpdate(target);\r\n        this._resetObjectTransform(activeGroup);\r\n        target.set('active', false);\r\n\r\n        if (activeGroup.size() === 1) {\r\n          // remove group alltogether if after removal it only contains 1 object\r\n          this.discardActiveGroup(e);\r\n          // activate last remaining object\r\n          this.setActiveObject(activeGroup.item(0));\r\n          return;\r\n        }\r\n      }\r\n      else {\r\n        activeGroup.addWithUpdate(target);\r\n        this._resetObjectTransform(activeGroup);\r\n      }\r\n      this.fire('selection:created', { target: activeGroup, e: e });\r\n      activeGroup.set('active', true);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _createActiveGroup: function(target, e) {\r\n\r\n      if (this._activeObject && target !== this._activeObject) {\r\n\r\n        var group = this._createGroup(target);\r\n        group.addWithUpdate();\r\n\r\n        this.setActiveGroup(group);\r\n        this._activeObject = null;\r\n\r\n        this.fire('selection:created', { target: group, e: e });\r\n      }\r\n\r\n      target.set('active', true);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} target\r\n     */\r\n    _createGroup: function(target) {\r\n\r\n      var objects = this.getObjects(),\r\n          isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),\r\n          groupObjects = isActiveLower\r\n            ? [ this._activeObject, target ]\r\n            : [ target, this._activeObject ];\r\n\r\n      return new fabric.Group(groupObjects, {\r\n        canvas: this\r\n      });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Event} e mouse event\r\n     */\r\n    _groupSelectedObjects: function (e) {\r\n\r\n      var group = this._collectObjects();\r\n\r\n      // do not create group for 1 element only\r\n      if (group.length === 1) {\r\n        this.setActiveObject(group[0], e);\r\n      }\r\n      else if (group.length > 1) {\r\n        group = new fabric.Group(group.reverse(), {\r\n          canvas: this\r\n        });\r\n        group.addWithUpdate();\r\n        this.setActiveGroup(group, e);\r\n        group.saveCoords();\r\n        this.fire('selection:created', { target: group });\r\n        this.renderAll();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _collectObjects: function() {\r\n      var group = [ ],\r\n          currentObject,\r\n          x1 = this._groupSelector.ex,\r\n          y1 = this._groupSelector.ey,\r\n          x2 = x1 + this._groupSelector.left,\r\n          y2 = y1 + this._groupSelector.top,\r\n          selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),\r\n          selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),\r\n          isClick = x1 === x2 && y1 === y2;\r\n\r\n      for (var i = this._objects.length; i--; ) {\r\n        currentObject = this._objects[i];\r\n\r\n        if (!currentObject || !currentObject.selectable || !currentObject.visible) {\r\n          continue;\r\n        }\r\n\r\n        if (currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2) ||\r\n            currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||\r\n            currentObject.containsPoint(selectionX1Y1) ||\r\n            currentObject.containsPoint(selectionX2Y2)\r\n        ) {\r\n          currentObject.set('active', true);\r\n          group.push(currentObject);\r\n\r\n          // only add one object if it's a click\r\n          if (isClick) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return group;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _maybeGroupObjects: function(e) {\r\n      if (this.selection && this._groupSelector) {\r\n        this._groupSelectedObjects(e);\r\n      }\r\n\r\n      var activeGroup = this.getActiveGroup();\r\n      if (activeGroup) {\r\n        activeGroup.setObjectsCoords().setCoords();\r\n        activeGroup.isMoving = false;\r\n        this.setCursor(this.defaultCursor);\r\n      }\r\n\r\n      // clear selection and current transformation\r\n      this._groupSelector = null;\r\n      this._currentTransform = null;\r\n    }\r\n  });\r\n\r\n})();\r\n\r\n\r\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\r\n\r\n  /**\r\n   * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately\r\n   * @param {Object} [options] Options object\r\n   * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\r\n   * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\r\n   * @param {Number} [options.multiplier=1] Multiplier to scale by\r\n   * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\r\n   * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\r\n   * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\r\n   * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\r\n   * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\r\n   * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}\r\n   * @example <caption>Generate jpeg dataURL with lower quality</caption>\r\n   * var dataURL = canvas.toDataURL({\r\n   *   format: 'jpeg',\r\n   *   quality: 0.8\r\n   * });\r\n   * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>\r\n   * var dataURL = canvas.toDataURL({\r\n   *   format: 'png',\r\n   *   left: 100,\r\n   *   top: 100,\r\n   *   width: 200,\r\n   *   height: 200\r\n   * });\r\n   * @example <caption>Generate double scaled png dataURL</caption>\r\n   * var dataURL = canvas.toDataURL({\r\n   *   format: 'png',\r\n   *   multiplier: 2\r\n   * });\r\n   */\r\n  toDataURL: function (options) {\r\n    options || (options = { });\r\n\r\n    var format = options.format || 'png',\r\n        quality = options.quality || 1,\r\n        multiplier = options.multiplier || 1,\r\n        cropping = {\r\n          left: options.left,\r\n          top: options.top,\r\n          width: options.width,\r\n          height: options.height\r\n        };\r\n\r\n    if (multiplier !== 1) {\r\n      return this.__toDataURLWithMultiplier(format, quality, cropping, multiplier);\r\n    }\r\n    else {\r\n      return this.__toDataURL(format, quality, cropping);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  __toDataURL: function(format, quality, cropping) {\r\n\r\n    this.renderAll(true);\r\n\r\n    var canvasEl = this.upperCanvasEl || this.lowerCanvasEl,\r\n        croppedCanvasEl = this.__getCroppedCanvas(canvasEl, cropping);\r\n\r\n    // to avoid common confusion https://github.com/kangax/fabric.js/issues/806\r\n    if (format === 'jpg') {\r\n      format = 'jpeg';\r\n    }\r\n\r\n    var data = (fabric.StaticCanvas.supports('toDataURLWithQuality'))\r\n              ? (croppedCanvasEl || canvasEl).toDataURL('image/' + format, quality)\r\n              : (croppedCanvasEl || canvasEl).toDataURL('image/' + format);\r\n\r\n    this.contextTop && this.clearContext(this.contextTop);\r\n    this.renderAll();\r\n\r\n    if (croppedCanvasEl) {\r\n      croppedCanvasEl = null;\r\n    }\r\n\r\n    return data;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  __getCroppedCanvas: function(canvasEl, cropping) {\r\n\r\n    var croppedCanvasEl,\r\n        croppedCtx,\r\n        shouldCrop = 'left' in cropping ||\r\n                     'top' in cropping ||\r\n                     'width' in cropping ||\r\n                     'height' in cropping;\r\n\r\n    if (shouldCrop) {\r\n\r\n      croppedCanvasEl = fabric.util.createCanvasElement();\r\n      croppedCtx = croppedCanvasEl.getContext('2d');\r\n\r\n      croppedCanvasEl.width = cropping.width || this.width;\r\n      croppedCanvasEl.height = cropping.height || this.height;\r\n\r\n      croppedCtx.drawImage(canvasEl, -cropping.left || 0, -cropping.top || 0);\r\n    }\r\n\r\n    return croppedCanvasEl;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  __toDataURLWithMultiplier: function(format, quality, cropping, multiplier) {\r\n\r\n    var origWidth = this.getWidth(),\r\n        origHeight = this.getHeight(),\r\n        scaledWidth = origWidth * multiplier,\r\n        scaledHeight = origHeight * multiplier,\r\n        activeObject = this.getActiveObject(),\r\n        activeGroup = this.getActiveGroup(),\r\n\r\n        ctx = this.contextTop || this.contextContainer;\r\n\r\n    if (multiplier > 1) {\r\n      this.setWidth(scaledWidth).setHeight(scaledHeight);\r\n    }\r\n    ctx.scale(multiplier, multiplier);\r\n\r\n    if (cropping.left) {\r\n      cropping.left *= multiplier;\r\n    }\r\n    if (cropping.top) {\r\n      cropping.top *= multiplier;\r\n    }\r\n    if (cropping.width) {\r\n      cropping.width *= multiplier;\r\n    }\r\n    else if (multiplier < 1) {\r\n      cropping.width = scaledWidth;\r\n    }\r\n    if (cropping.height) {\r\n      cropping.height *= multiplier;\r\n    }\r\n    else if (multiplier < 1) {\r\n      cropping.height = scaledHeight;\r\n    }\r\n\r\n    if (activeGroup) {\r\n      // not removing group due to complications with restoring it with correct state afterwords\r\n      this._tempRemoveBordersControlsFromGroup(activeGroup);\r\n    }\r\n    else if (activeObject && this.deactivateAll) {\r\n      this.deactivateAll();\r\n    }\r\n\r\n    this.renderAll(true);\r\n\r\n    var data = this.__toDataURL(format, quality, cropping);\r\n\r\n    // restoring width, height for `renderAll` to draw\r\n    // background properly (while context is scaled)\r\n    this.width = origWidth;\r\n    this.height = origHeight;\r\n\r\n    ctx.scale(1 / multiplier,  1 / multiplier);\r\n    this.setWidth(origWidth).setHeight(origHeight);\r\n\r\n    if (activeGroup) {\r\n      this._restoreBordersControlsOnGroup(activeGroup);\r\n    }\r\n    else if (activeObject && this.setActiveObject) {\r\n      this.setActiveObject(activeObject);\r\n    }\r\n\r\n    this.contextTop && this.clearContext(this.contextTop);\r\n    this.renderAll();\r\n\r\n    return data;\r\n  },\r\n\r\n  /**\r\n   * Exports canvas element to a dataurl image (allowing to change image size via multiplier).\r\n   * @deprecated since 1.0.13\r\n   * @param {String} format (png|jpeg)\r\n   * @param {Number} multiplier\r\n   * @param {Number} quality (0..1)\r\n   * @return {String}\r\n   */\r\n  toDataURLWithMultiplier: function (format, multiplier, quality) {\r\n    return this.toDataURL({\r\n      format: format,\r\n      multiplier: multiplier,\r\n      quality: quality\r\n    });\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _tempRemoveBordersControlsFromGroup: function(group) {\r\n    group.origHasControls = group.hasControls;\r\n    group.origBorderColor = group.borderColor;\r\n\r\n    group.hasControls = true;\r\n    group.borderColor = 'rgba(0,0,0,0)';\r\n\r\n    group.forEachObject(function(o) {\r\n      o.origBorderColor = o.borderColor;\r\n      o.borderColor = 'rgba(0,0,0,0)';\r\n    });\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _restoreBordersControlsOnGroup: function(group) {\r\n    group.hideControls = group.origHideControls;\r\n    group.borderColor = group.origBorderColor;\r\n\r\n    group.forEachObject(function(o) {\r\n      o.borderColor = o.origBorderColor;\r\n      delete o.origBorderColor;\r\n    });\r\n  }\r\n});\r\n\r\n\r\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\r\n\r\n  /**\r\n   * Populates canvas with data from the specified dataless JSON.\r\n   * JSON format must conform to the one of {@link fabric.Canvas#toDatalessJSON}\r\n   * @deprecated since 1.2.2\r\n   * @param {String|Object} json JSON string or object\r\n   * @param {Function} callback Callback, invoked when json is parsed\r\n   *                            and corresponding objects (e.g: {@link fabric.Image})\r\n   *                            are initialized\r\n   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.\r\n   * @return {fabric.Canvas} instance\r\n   * @chainable\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#deserialization}\r\n   */\r\n  loadFromDatalessJSON: function (json, callback, reviver) {\r\n    return this.loadFromJSON(json, callback, reviver);\r\n  },\r\n\r\n  /**\r\n   * Populates canvas with data from the specified JSON.\r\n   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}\r\n   * @param {String|Object} json JSON string or object\r\n   * @param {Function} callback Callback, invoked when json is parsed\r\n   *                            and corresponding objects (e.g: {@link fabric.Image})\r\n   *                            are initialized\r\n   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.\r\n   * @return {fabric.Canvas} instance\r\n   * @chainable\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#deserialization}\r\n   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}\r\n   * @example <caption>loadFromJSON</caption>\r\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));\r\n   * @example <caption>loadFromJSON with reviver</caption>\r\n   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {\r\n   *   // `o` = json object\r\n   *   // `object` = fabric.Object instance\r\n   *   // ... do some stuff ...\r\n   * });\r\n   */\r\n  loadFromJSON: function (json, callback, reviver) {\r\n    if (!json) {\r\n      return;\r\n    }\r\n\r\n    // serialize if it wasn't already\r\n    var serialized = (typeof json === 'string')\r\n      ? JSON.parse(json)\r\n      : json;\r\n\r\n    this.clear();\r\n\r\n    var _this = this;\r\n    this._enlivenObjects(serialized.objects, function () {\r\n      _this._setBgOverlay(serialized, callback);\r\n    }, reviver);\r\n\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {Object} serialized Object with background and overlay information\r\n   * @param {Function} callback Invoked after all background and overlay images/patterns loaded\r\n   */\r\n  _setBgOverlay: function(serialized, callback) {\r\n    var _this = this,\r\n        loaded = {\r\n          backgroundColor: false,\r\n          overlayColor: false,\r\n          backgroundImage: false,\r\n          overlayImage: false\r\n        };\r\n\r\n    if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {\r\n      callback && callback();\r\n      return;\r\n    }\r\n\r\n    var cbIfLoaded = function () {\r\n      if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {\r\n        _this.renderAll();\r\n        callback && callback();\r\n      }\r\n    };\r\n\r\n    this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);\r\n    this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);\r\n    this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);\r\n    this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);\r\n\r\n    cbIfLoaded();\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)\r\n   * @param {(Object|String)} value Value to set\r\n   * @param {Object} loaded Set loaded property to true if property is set\r\n   * @param {Object} callback Callback function to invoke after property is set\r\n   */\r\n  __setBgOverlay: function(property, value, loaded, callback) {\r\n    var _this = this;\r\n\r\n    if (!value) {\r\n      loaded[property] = true;\r\n      return;\r\n    }\r\n\r\n    if (property === 'backgroundImage' || property === 'overlayImage') {\r\n      fabric.Image.fromObject(value, function(img) {\r\n        _this[property] = img;\r\n        loaded[property] = true;\r\n        callback && callback();\r\n      });\r\n    }\r\n    else {\r\n      this['set' + fabric.util.string.capitalize(property, true)](value, function() {\r\n        loaded[property] = true;\r\n        callback && callback();\r\n      });\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {Array} objects\r\n   * @param {Function} callback\r\n   * @param {Function} [reviver]\r\n   */\r\n  _enlivenObjects: function (objects, callback, reviver) {\r\n    var _this = this;\r\n\r\n    if (!objects || objects.length === 0) {\r\n      callback && callback();\r\n      return;\r\n    }\r\n\r\n    var renderOnAddRemove = this.renderOnAddRemove;\r\n    this.renderOnAddRemove = false;\r\n\r\n    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {\r\n      enlivenedObjects.forEach(function(obj, index) {\r\n        _this.insertAt(obj, index, true);\r\n      });\r\n\r\n      _this.renderOnAddRemove = renderOnAddRemove;\r\n      callback && callback();\r\n    }, null, reviver);\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {String} format\r\n   * @param {Function} callback\r\n   */\r\n  _toDataURL: function (format, callback) {\r\n    this.clone(function (clone) {\r\n      callback(clone.toDataURL(format));\r\n    });\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {String} format\r\n   * @param {Number} multiplier\r\n   * @param {Function} callback\r\n   */\r\n  _toDataURLWithMultiplier: function (format, multiplier, callback) {\r\n    this.clone(function (clone) {\r\n      callback(clone.toDataURLWithMultiplier(format, multiplier));\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Clones canvas instance\r\n   * @param {Object} [callback] Receives cloned instance as a first argument\r\n   * @param {Array} [properties] Array of properties to include in the cloned canvas and children\r\n   */\r\n  clone: function (callback, properties) {\r\n    var data = JSON.stringify(this.toJSON(properties));\r\n    this.cloneWithoutData(function(clone) {\r\n      clone.loadFromJSON(data, function() {\r\n        callback && callback(clone);\r\n      });\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Clones canvas instance without cloning existing data.\r\n   * This essentially copies canvas dimensions, clipping properties, etc.\r\n   * but leaves data empty (so that you can populate it with your own)\r\n   * @param {Object} [callback] Receives cloned instance as a first argument\r\n   */\r\n  cloneWithoutData: function(callback) {\r\n    var el = fabric.document.createElement('canvas');\r\n\r\n    el.width = this.getWidth();\r\n    el.height = this.getHeight();\r\n\r\n    var clone = new fabric.Canvas(el);\r\n    clone.clipTo = this.clipTo;\r\n    if (this.backgroundImage) {\r\n      clone.setBackgroundImage(this.backgroundImage.src, function() {\r\n        clone.renderAll();\r\n        callback && callback(clone);\r\n      });\r\n      clone.backgroundImageOpacity = this.backgroundImageOpacity;\r\n      clone.backgroundImageStretch = this.backgroundImageStretch;\r\n    }\r\n    else {\r\n      callback && callback(clone);\r\n    }\r\n  }\r\n});\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      toFixed = fabric.util.toFixed,\r\n      capitalize = fabric.util.string.capitalize,\r\n      degreesToRadians = fabric.util.degreesToRadians,\r\n      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');\r\n\r\n  if (fabric.Object) {\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Root object class from which all 2d shape classes inherit from\r\n   * @class fabric.Object\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#objects}\r\n   * @see {@link fabric.Object#initialize} for constructor definition\r\n   *\r\n   * @fires added\r\n   * @fires removed\r\n   *\r\n   * @fires selected\r\n   * @fires modified\r\n   * @fires rotating\r\n   * @fires scaling\r\n   * @fires moving\r\n   *\r\n   * @fires mousedown\r\n   * @fires mouseup\r\n   */\r\n  fabric.Object = fabric.util.createClass(/** @lends fabric.Object.prototype */ {\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#clipTo|clipping function}\r\n     * @method getClipTo\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Function}\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#clipTo|clipping function}\r\n     * @method setClipTo\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Function} clipTo Clipping function\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#transformMatrix|transformMatrix}\r\n     * @method getTransformMatrix\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Array} transformMatrix\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#transformMatrix|transformMatrix}\r\n     * @method setTransformMatrix\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Array} transformMatrix\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#visible|visible} state\r\n     * @method getVisible\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Boolean} True if visible\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#visible|visible} state\r\n     * @method setVisible\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Boolean} value visible value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#shadow|shadow}\r\n     * @method getShadow\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Object} Shadow instance\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#stroke|stroke}\r\n     * @method getStroke\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {String} stroke value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#stroke|stroke}\r\n     * @method setStroke\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {String} value stroke value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#strokeWidth|strokeWidth}\r\n     * @method getStrokeWidth\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number} strokeWidth value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#strokeWidth|strokeWidth}\r\n     * @method setStrokeWidth\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Number} value strokeWidth value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#originX|originX}\r\n     * @method getOriginX\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {String} originX value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#originX|originX}\r\n     * @method setOriginX\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {String} value originX value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#originY|originY}\r\n     * @method getOriginY\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {String} originY value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#originY|originY}\r\n     * @method setOriginY\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {String} value originY value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#fill|fill}\r\n     * @method getFill\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {String} Fill value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#fill|fill}\r\n     * @method setFill\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {String} value Fill value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#opacity|opacity}\r\n     * @method getOpacity\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number} Opacity value (0-1)\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#opacity|opacity}\r\n     * @method setOpacity\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Number} value Opacity value (0-1)\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#angle|angle} (in degrees)\r\n     * @method getAngle\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number}\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#top|top position}\r\n     * @method getTop\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number} Top value (in pixels)\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#top|top position}\r\n     * @method setTop\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Number} value Top value (in pixels)\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#left|left position}\r\n     * @method getLeft\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number} Left value (in pixels)\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#left|left position}\r\n     * @method setLeft\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Number} value Left value (in pixels)\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#scaleX|scaleX} value\r\n     * @method getScaleX\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number} scaleX value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#scaleX|scaleX} value\r\n     * @method setScaleX\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Number} value scaleX value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#scaleY|scaleY} value\r\n     * @method getScaleY\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Number} scaleY value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#scaleY|scaleY} value\r\n     * @method setScaleY\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Number} value scaleY value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#flipX|flipX} value\r\n     * @method getFlipX\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Boolean} flipX value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#flipX|flipX} value\r\n     * @method setFlipX\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Boolean} value flipX value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's {@link fabric.Object#flipY|flipY} value\r\n     * @method getFlipY\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Boolean} flipY value\r\n     */\r\n\r\n    /**\r\n     * Sets object's {@link fabric.Object#flipY|flipY} value\r\n     * @method setFlipY\r\n     * @memberOf fabric.Object.prototype\r\n     * @param {Boolean} value flipY value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Type of an object (rect, circle, path, etc.).\r\n     * Note that this property is meant to be read-only and not meant to be modified.\r\n     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.\r\n     * @type String\r\n     * @default\r\n     */\r\n    type:                     'object',\r\n\r\n    /**\r\n     * Horizontal origin of transformation of an object (one of \"left\", \"right\", \"center\")\r\n     * See http://jsfiddle.net/1ow02gea/40/ on how originX/originY affect objects in groups\r\n     * @type String\r\n     * @default\r\n     */\r\n    originX:                  'left',\r\n\r\n    /**\r\n     * Vertical origin of transformation of an object (one of \"top\", \"bottom\", \"center\")\r\n     * See http://jsfiddle.net/1ow02gea/40/ on how originX/originY affect objects in groups\r\n     * @type String\r\n     * @default\r\n     */\r\n    originY:                  'top',\r\n\r\n    /**\r\n     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}\r\n     * @type Number\r\n     * @default\r\n     */\r\n    top:                      0,\r\n\r\n    /**\r\n     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}\r\n     * @type Number\r\n     * @default\r\n     */\r\n    left:                     0,\r\n\r\n    /**\r\n     * Object width\r\n     * @type Number\r\n     * @default\r\n     */\r\n    width:                    0,\r\n\r\n    /**\r\n     * Object height\r\n     * @type Number\r\n     * @default\r\n     */\r\n    height:                   0,\r\n\r\n    /**\r\n     * Object scale factor (horizontal)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    scaleX:                   1,\r\n\r\n    /**\r\n     * Object scale factor (vertical)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    scaleY:                   1,\r\n\r\n    /**\r\n     * When true, an object is rendered as flipped horizontally\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    flipX:                    false,\r\n\r\n    /**\r\n     * When true, an object is rendered as flipped vertically\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    flipY:                    false,\r\n\r\n    /**\r\n     * Opacity of an object\r\n     * @type Number\r\n     * @default\r\n     */\r\n    opacity:                  1,\r\n\r\n    /**\r\n     * Angle of rotation of an object (in degrees)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    angle:                    0,\r\n\r\n    /**\r\n     * Size of object's controlling corners (in pixels)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    cornerSize:               12,\r\n\r\n    /**\r\n     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    transparentCorners:       true,\r\n\r\n    /**\r\n     * Default cursor value used when hovering over this object on canvas\r\n     * @type String\r\n     * @default\r\n     */\r\n    hoverCursor:              null,\r\n\r\n    /**\r\n     * Padding between object and its controlling borders (in pixels)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    padding:                  0,\r\n\r\n    /**\r\n     * Color of controlling borders of an object (when it's active)\r\n     * @type String\r\n     * @default\r\n     */\r\n    borderColor:              'rgba(102,153,255,0.75)',\r\n\r\n    /**\r\n     * Color of controlling corners of an object (when it's active)\r\n     * @type String\r\n     * @default\r\n     */\r\n    cornerColor:              'rgba(102,153,255,0.5)',\r\n\r\n    /**\r\n     * When true, this object will use center point as the origin of transformation\r\n     * when being scaled via the controls.\r\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\r\n     * @since 1.3.4\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    centeredScaling:          false,\r\n\r\n    /**\r\n     * When true, this object will use center point as the origin of transformation\r\n     * when being rotated via the controls.\r\n     * <b>Backwards incompatibility note:</b> This property replaces \"centerTransform\" (Boolean).\r\n     * @since 1.3.4\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    centeredRotation:         true,\r\n\r\n    /**\r\n     * Color of object's fill\r\n     * @type String\r\n     * @default\r\n     */\r\n    fill:                     'rgb(0,0,0)',\r\n\r\n    /**\r\n     * Fill rule used to fill an object\r\n     * accepted values are nonzero, evenodd\r\n     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)\r\n     * @type String\r\n     * @default\r\n     */\r\n    fillRule:                 'nonzero',\r\n\r\n    /**\r\n     * Composite rule used for canvas globalCompositeOperation\r\n     * @type String\r\n     * @default\r\n     */\r\n    globalCompositeOperation: 'source-over',\r\n\r\n    /**\r\n     * Background color of an object. Only works with text objects at the moment.\r\n     * @type String\r\n     * @default\r\n     */\r\n    backgroundColor:          '',\r\n\r\n    /**\r\n     * When defined, an object is rendered via stroke and this property specifies its color\r\n     * @type String\r\n     * @default\r\n     */\r\n    stroke:                   null,\r\n\r\n    /**\r\n     * Width of a stroke used to render this object\r\n     * @type Number\r\n     * @default\r\n     */\r\n    strokeWidth:              1,\r\n\r\n    /**\r\n     * Array specifying dash pattern of an object's stroke (stroke must be defined)\r\n     * @type Array\r\n     */\r\n    strokeDashArray:          null,\r\n\r\n    /**\r\n     * Line endings style of an object's stroke (one of \"butt\", \"round\", \"square\")\r\n     * @type String\r\n     * @default\r\n     */\r\n    strokeLineCap:            'butt',\r\n\r\n    /**\r\n     * Corner style of an object's stroke (one of \"bevil\", \"round\", \"miter\")\r\n     * @type String\r\n     * @default\r\n     */\r\n    strokeLineJoin:           'miter',\r\n\r\n    /**\r\n     * Maximum miter length (used for strokeLineJoin = \"miter\") of an object's stroke\r\n     * @type Number\r\n     * @default\r\n     */\r\n    strokeMiterLimit:         10,\r\n\r\n    /**\r\n     * Shadow object representing shadow of this shape\r\n     * @type fabric.Shadow\r\n     * @default\r\n     */\r\n    shadow:                   null,\r\n\r\n    /**\r\n     * Opacity of object's controlling borders when object is active and moving\r\n     * @type Number\r\n     * @default\r\n     */\r\n    borderOpacityWhenMoving:  0.4,\r\n\r\n    /**\r\n     * Scale factor of object's controlling borders\r\n     * @type Number\r\n     * @default\r\n     */\r\n    borderScaleFactor:        1,\r\n\r\n    /**\r\n     * Transform matrix (similar to SVG's transform matrix)\r\n     * @type Array\r\n     */\r\n    transformMatrix:          null,\r\n\r\n    /**\r\n     * Minimum allowed scale value of an object\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minScaleLimit:            0.01,\r\n\r\n    /**\r\n     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).\r\n     * But events still fire on it.\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    selectable:               true,\r\n\r\n    /**\r\n     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    evented:                  true,\r\n\r\n    /**\r\n     * When set to `false`, an object is not rendered on canvas\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    visible:                  true,\r\n\r\n    /**\r\n     * When set to `false`, object's controls are not displayed and can not be used to manipulate object\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    hasControls:              true,\r\n\r\n    /**\r\n     * When set to `false`, object's controlling borders are not rendered\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    hasBorders:               true,\r\n\r\n    /**\r\n     * When set to `false`, object's controlling rotating point will not be visible or selectable\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    hasRotatingPoint:         true,\r\n\r\n    /**\r\n     * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    rotatingPointOffset:      40,\r\n\r\n    /**\r\n     * When set to `true`, objects are \"found\" on canvas on per-pixel basis rather than according to bounding box\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    perPixelTargetFind:       false,\r\n\r\n    /**\r\n     * When `false`, default object's values are not included in its serialization\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    includeDefaultValues:     true,\r\n\r\n    /**\r\n     * Function that determines clipping of an object (context is passed as a first argument)\r\n     * Note that context origin is at the object's center point (not left/top corner)\r\n     * @type Function\r\n     */\r\n    clipTo:                   null,\r\n\r\n    /**\r\n     * When `true`, object horizontal movement is locked\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    lockMovementX:            false,\r\n\r\n    /**\r\n     * When `true`, object vertical movement is locked\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    lockMovementY:            false,\r\n\r\n    /**\r\n     * When `true`, object rotation is locked\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    lockRotation:             false,\r\n\r\n    /**\r\n     * When `true`, object horizontal scaling is locked\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    lockScalingX:             false,\r\n\r\n    /**\r\n     * When `true`, object vertical scaling is locked\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    lockScalingY:             false,\r\n\r\n    /**\r\n     * When `true`, object non-uniform scaling is locked\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    lockUniScaling:           false,\r\n\r\n    /**\r\n     * When `true`, object cannot be flipped by scaling into negative values\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n\r\n    lockScalingFlip:          false,\r\n    /**\r\n     * List of properties to consider when checking if state\r\n     * of an object is changed (fabric.Object#hasStateChanged)\r\n     * as well as for history (undo/redo) purposes\r\n     * @type Array\r\n     */\r\n    stateProperties:  (\r\n      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +\r\n      'stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit ' +\r\n      'angle opacity fill fillRule globalCompositeOperation shadow clipTo visible backgroundColor ' +\r\n      'alignX alignY meetOrSlice'\r\n    ).split(' '),\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} [options] Options object\r\n     */\r\n    initialize: function(options) {\r\n      if (options) {\r\n        this.setOptions(options);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initGradient: function(options) {\r\n      if (options.fill && options.fill.colorStops && !(options.fill instanceof fabric.Gradient)) {\r\n        this.set('fill', new fabric.Gradient(options.fill));\r\n      }\r\n      if (options.stroke && options.stroke.colorStops && !(options.stroke instanceof fabric.Gradient)) {\r\n        this.set('stroke', new fabric.Gradient(options.stroke));\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initPattern: function(options) {\r\n      if (options.fill && options.fill.source && !(options.fill instanceof fabric.Pattern)) {\r\n        this.set('fill', new fabric.Pattern(options.fill));\r\n      }\r\n      if (options.stroke && options.stroke.source && !(options.stroke instanceof fabric.Pattern)) {\r\n        this.set('stroke', new fabric.Pattern(options.stroke));\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initClipping: function(options) {\r\n      if (!options.clipTo || typeof options.clipTo !== 'string') {\r\n        return;\r\n      }\r\n\r\n      var functionBody = fabric.util.getFunctionBody(options.clipTo);\r\n      if (typeof functionBody !== 'undefined') {\r\n        this.clipTo = new Function('ctx', functionBody);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets object's properties from options\r\n     * @param {Object} [options] Options object\r\n     */\r\n    setOptions: function(options) {\r\n      for (var prop in options) {\r\n        this.set(prop, options[prop]);\r\n      }\r\n      this._initGradient(options);\r\n      this._initPattern(options);\r\n      this._initClipping(options);\r\n    },\r\n\r\n    /**\r\n     * Transforms context when rendering an object\r\n     * @param {CanvasRenderingContext2D} ctx Context\r\n     * @param {Boolean} fromLeft When true, context is transformed to object's top/left corner. This is used when rendering text on Node\r\n     */\r\n    transform: function(ctx, fromLeft) {\r\n      if (this.group && this.canvas.preserveObjectStacking && this.group === this.canvas._activeGroup) {\r\n        this.group.transform(ctx);\r\n      }\r\n      var center = fromLeft ? this._getLeftTopCoords() : this.getCenterPoint();\r\n      ctx.translate(center.x, center.y);\r\n      ctx.rotate(degreesToRadians(this.angle));\r\n      ctx.scale(\r\n        this.scaleX * (this.flipX ? -1 : 1),\r\n        this.scaleY * (this.flipY ? -1 : 1)\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Returns an object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,\r\n\r\n          object = {\r\n            type:                     this.type,\r\n            originX:                  this.originX,\r\n            originY:                  this.originY,\r\n            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),\r\n            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),\r\n            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),\r\n            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),\r\n            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,\r\n            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,\r\n            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),\r\n            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,\r\n            strokeLineCap:            this.strokeLineCap,\r\n            strokeLineJoin:           this.strokeLineJoin,\r\n            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),\r\n            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),\r\n            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),\r\n            angle:                    toFixed(this.getAngle(), NUM_FRACTION_DIGITS),\r\n            flipX:                    this.flipX,\r\n            flipY:                    this.flipY,\r\n            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),\r\n            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,\r\n            visible:                  this.visible,\r\n            clipTo:                   this.clipTo && String(this.clipTo),\r\n            backgroundColor:          this.backgroundColor,\r\n            fillRule:                 this.fillRule,\r\n            globalCompositeOperation: this.globalCompositeOperation,\r\n            transformMatrix:          this.transformMatrix ? this.transformMatrix.concat() : this.transformMatrix\r\n          };\r\n\r\n      if (!this.includeDefaultValues) {\r\n        object = this._removeDefaultValues(object);\r\n      }\r\n\r\n      fabric.util.populateWithProperties(this, object, propertiesToInclude);\r\n\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Returns (dataless) object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toDatalessObject: function(propertiesToInclude) {\r\n      // will be overwritten by subclasses\r\n      return this.toObject(propertiesToInclude);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} object\r\n     */\r\n    _removeDefaultValues: function(object) {\r\n      var prototype = fabric.util.getKlass(object.type).prototype,\r\n          stateProperties = prototype.stateProperties;\r\n\r\n      stateProperties.forEach(function(prop) {\r\n        if (object[prop] === prototype[prop]) {\r\n          delete object[prop];\r\n        }\r\n        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&\r\n                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';\r\n\r\n        // basically a check for [] === []\r\n        if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {\r\n          delete object[prop];\r\n        }\r\n      });\r\n\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Returns a string representation of an instance\r\n     * @return {String}\r\n     */\r\n    toString: function() {\r\n      return '#<fabric.' + capitalize(this.type) + '>';\r\n    },\r\n\r\n    /**\r\n     * Basic getter\r\n     * @param {String} property Property name\r\n     * @return {Any} value of a property\r\n     */\r\n    get: function(property) {\r\n      return this[property];\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setObject: function(obj) {\r\n      for (var prop in obj) {\r\n        this._set(prop, obj[prop]);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.\r\n     * @param {String|Object} key Property name or object (if object, iterate over the object properties)\r\n     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    set: function(key, value) {\r\n      if (typeof key === 'object') {\r\n        this._setObject(key);\r\n      }\r\n      else {\r\n        if (typeof value === 'function' && key !== 'clipTo') {\r\n          this._set(key, value(this.get(key)));\r\n        }\r\n        else {\r\n          this._set(key, value);\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} key\r\n     * @param {Any} value\r\n     * @return {fabric.Object} thisArg\r\n     */\r\n    _set: function(key, value) {\r\n      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY');\r\n\r\n      if (shouldConstrainValue) {\r\n        value = this._constrainScale(value);\r\n      }\r\n      if (key === 'scaleX' && value < 0) {\r\n        this.flipX = !this.flipX;\r\n        value *= -1;\r\n      }\r\n      else if (key === 'scaleY' && value < 0) {\r\n        this.flipY = !this.flipY;\r\n        value *= -1;\r\n      }\r\n      else if (key === 'width' || key === 'height') {\r\n        this.minScaleLimit = toFixed(Math.min(0.1, 1/Math.max(this.width, this.height)), 2);\r\n      }\r\n      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {\r\n        value = new fabric.Shadow(value);\r\n      }\r\n\r\n      this[key] = value;\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * This callback function is called by the parent group of an object every\r\n     * time a non-delegated property changes on the group. It is passed the key\r\n     * and value as parameters. Not adding in this function's signature to avoid\r\n     * Travis build error about unused variables.\r\n     */\r\n    setOnGroup: function() {\r\n      // implemented by sub-classes, as needed.\r\n    },\r\n\r\n    /**\r\n     * Toggles specified property from `true` to `false` or from `false` to `true`\r\n     * @param {String} property Property to toggle\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    toggle: function(property) {\r\n      var value = this.get(property);\r\n      if (typeof value === 'boolean') {\r\n        this.set(property, !value);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets sourcePath of an object\r\n     * @param {String} value Value to set sourcePath to\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    setSourcePath: function(value) {\r\n      this.sourcePath = value;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves viewportTransform from Object's canvas if possible\r\n     * @method getViewportTransform\r\n     * @memberOf fabric.Object.prototype\r\n     * @return {Boolean} flipY value // TODO\r\n     */\r\n    getViewportTransform: function() {\r\n      if (this.canvas && this.canvas.viewportTransform) {\r\n        return this.canvas.viewportTransform;\r\n      }\r\n      return [1, 0, 0, 1, 0, 0];\r\n    },\r\n\r\n    /**\r\n     * Renders an object on a specified context\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Boolean} [noTransform] When true, context is not transformed\r\n     */\r\n    render: function(ctx, noTransform) {\r\n      // do not render if width/height are zeros or object is not visible\r\n      if ((this.width === 0 && this.height === 0) || !this.visible) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n\r\n      //setup fill rule for current object\r\n      this._setupCompositeOperation(ctx);\r\n      if (!noTransform) {\r\n        this.transform(ctx);\r\n      }\r\n      this._setStrokeStyles(ctx);\r\n      this._setFillStyles(ctx);\r\n      if (this.transformMatrix) {\r\n        ctx.transform.apply(ctx, this.transformMatrix);\r\n      }\r\n      this._setOpacity(ctx);\r\n      this._setShadow(ctx);\r\n      this.clipTo && fabric.util.clipContext(this, ctx);\r\n      this._render(ctx, noTransform);\r\n      this.clipTo && ctx.restore();\r\n\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _setOpacity: function(ctx) {\r\n      if (this.group) {\r\n        this.group._setOpacity(ctx);\r\n      }\r\n      ctx.globalAlpha *= this.opacity;\r\n    },\r\n\r\n    _setStrokeStyles: function(ctx) {\r\n      if (this.stroke) {\r\n        ctx.lineWidth = this.strokeWidth;\r\n        ctx.lineCap = this.strokeLineCap;\r\n        ctx.lineJoin = this.strokeLineJoin;\r\n        ctx.miterLimit = this.strokeMiterLimit;\r\n        ctx.strokeStyle = this.stroke.toLive\r\n          ? this.stroke.toLive(ctx, this)\r\n          : this.stroke;\r\n      }\r\n    },\r\n\r\n    _setFillStyles: function(ctx) {\r\n      if (this.fill) {\r\n        ctx.fillStyle = this.fill.toLive\r\n          ? this.fill.toLive(ctx, this)\r\n          : this.fill;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Renders controls and borders for the object\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Boolean} [noTransform] When true, context is not transformed\r\n     */\r\n    _renderControls: function(ctx, noTransform) {\r\n      if (!this.active || noTransform) {\r\n        return;\r\n      }\r\n      var vpt = this.getViewportTransform();\r\n      ctx.save();\r\n      var center;\r\n      if (this.group) {\r\n        center = fabric.util.transformPoint(this.group.getCenterPoint(), vpt);\r\n        ctx.translate(center.x, center.y);\r\n        ctx.rotate(degreesToRadians(this.group.angle));\r\n      }\r\n      center = fabric.util.transformPoint(this.getCenterPoint(), vpt, null != this.group);\r\n      if (this.group) {\r\n        center.x *= this.group.scaleX;\r\n        center.y *= this.group.scaleY;\r\n      }\r\n      ctx.translate(center.x, center.y);\r\n      ctx.rotate(degreesToRadians(this.angle));\r\n      this.drawBorders(ctx);\r\n      this.drawControls(ctx);\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _setShadow: function(ctx) {\r\n      if (!this.shadow) {\r\n        return;\r\n      }\r\n\r\n      var multX = (this.canvas && this.canvas.viewportTransform[0]) || 1,\r\n          multY = (this.canvas && this.canvas.viewportTransform[3]) || 1;\r\n\r\n      ctx.shadowColor = this.shadow.color;\r\n      ctx.shadowBlur = this.shadow.blur * (multX + multY) * (this.scaleX + this.scaleY) / 4;\r\n      ctx.shadowOffsetX = this.shadow.offsetX * multX * this.scaleX;\r\n      ctx.shadowOffsetY = this.shadow.offsetY * multY * this.scaleY;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _removeShadow: function(ctx) {\r\n      if (!this.shadow) {\r\n        return;\r\n      }\r\n\r\n      ctx.shadowColor = '';\r\n      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderFill: function(ctx) {\r\n      if (!this.fill) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n      if (this.fill.gradientTransform) {\r\n        var g = this.fill.gradientTransform;\r\n        ctx.transform.apply(ctx, g);\r\n      }\r\n      if (this.fill.toLive) {\r\n        ctx.translate(\r\n          -this.width / 2 + this.fill.offsetX || 0,\r\n          -this.height / 2 + this.fill.offsetY || 0);\r\n      }\r\n      if (this.fillRule === 'evenodd') {\r\n        ctx.fill('evenodd');\r\n      }\r\n      else {\r\n        ctx.fill();\r\n      }\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderStroke: function(ctx) {\r\n      if (!this.stroke || this.strokeWidth === 0) {\r\n        return;\r\n      }\r\n\r\n      if (this.shadow && !this.shadow.affectStroke) {\r\n        this._removeShadow(ctx);\r\n      }\r\n\r\n      ctx.save();\r\n\r\n      if (this.strokeDashArray) {\r\n        // Spec requires the concatenation of two copies the dash list when the number of elements is odd\r\n        if (1 & this.strokeDashArray.length) {\r\n          this.strokeDashArray.push.apply(this.strokeDashArray, this.strokeDashArray);\r\n        }\r\n        if (supportsLineDash) {\r\n          ctx.setLineDash(this.strokeDashArray);\r\n          this._stroke && this._stroke(ctx);\r\n        }\r\n        else {\r\n          this._renderDashedStroke && this._renderDashedStroke(ctx);\r\n        }\r\n        ctx.stroke();\r\n      }\r\n      else {\r\n        if (this.stroke.gradientTransform) {\r\n          var g = this.stroke.gradientTransform;\r\n          ctx.transform.apply(ctx, g);\r\n        }\r\n        this._stroke ? this._stroke(ctx) : ctx.stroke();\r\n      }\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Clones an instance\r\n     * @param {Function} callback Callback is invoked with a clone as a first argument\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {fabric.Object} clone of an instance\r\n     */\r\n    clone: function(callback, propertiesToInclude) {\r\n      if (this.constructor.fromObject) {\r\n        return this.constructor.fromObject(this.toObject(propertiesToInclude), callback);\r\n      }\r\n      return new fabric.Object(this.toObject(propertiesToInclude));\r\n    },\r\n\r\n    /**\r\n     * Creates an instance of fabric.Image out of an object\r\n     * @param {Function} callback callback, invoked with an instance as a first argument\r\n     * @return {fabric.Object} thisArg\r\n     */\r\n    cloneAsImage: function(callback) {\r\n      var dataUrl = this.toDataURL();\r\n      fabric.util.loadImage(dataUrl, function(img) {\r\n        if (callback) {\r\n          callback(new fabric.Image(img));\r\n        }\r\n      });\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Converts an object into a data-url-like string\r\n     * @param {Object} options Options object\r\n     * @param {String} [options.format=png] The format of the output image. Either \"jpeg\" or \"png\"\r\n     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.\r\n     * @param {Number} [options.multiplier=1] Multiplier to scale by\r\n     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14\r\n     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14\r\n     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14\r\n     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14\r\n     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format\r\n     */\r\n    toDataURL: function(options) {\r\n      options || (options = { });\r\n\r\n      var el = fabric.util.createCanvasElement(),\r\n          boundingRect = this.getBoundingRect();\r\n\r\n      el.width = boundingRect.width;\r\n      el.height = boundingRect.height;\r\n\r\n      fabric.util.wrapElement(el, 'div');\r\n      var canvas = new fabric.StaticCanvas(el);\r\n\r\n      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806\r\n      if (options.format === 'jpg') {\r\n        options.format = 'jpeg';\r\n      }\r\n\r\n      if (options.format === 'jpeg') {\r\n        canvas.backgroundColor = '#fff';\r\n      }\r\n\r\n      var origParams = {\r\n        active: this.get('active'),\r\n        left: this.getLeft(),\r\n        top: this.getTop()\r\n      };\r\n\r\n      this.set('active', false);\r\n      this.setPositionByOrigin(new fabric.Point(el.width / 2, el.height / 2), 'center', 'center');\r\n\r\n      var originalCanvas = this.canvas;\r\n      canvas.add(this);\r\n      var data = canvas.toDataURL(options);\r\n\r\n      this.set(origParams).setCoords();\r\n      this.canvas = originalCanvas;\r\n\r\n      canvas.dispose();\r\n      canvas = null;\r\n\r\n      return data;\r\n    },\r\n\r\n    /**\r\n     * Returns true if specified type is identical to the type of an instance\r\n     * @param {String} type Type to check against\r\n     * @return {Boolean}\r\n     */\r\n    isType: function(type) {\r\n      return this.type === type;\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return 0;\r\n    },\r\n\r\n    /**\r\n     * Returns a JSON representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} JSON\r\n     */\r\n    toJSON: function(propertiesToInclude) {\r\n      // delegate, not alias\r\n      return this.toObject(propertiesToInclude);\r\n    },\r\n\r\n    /**\r\n     * Sets gradient (fill or stroke) of an object\r\n     * <b>Backwards incompatibility note:</b> This method was named \"setGradientFill\" until v1.1.0\r\n     * @param {String} property Property name 'stroke' or 'fill'\r\n     * @param {Object} [options] Options object\r\n     * @param {String} [options.type] Type of gradient 'radial' or 'linear'\r\n     * @param {Number} [options.x1=0] x-coordinate of start point\r\n     * @param {Number} [options.y1=0] y-coordinate of start point\r\n     * @param {Number} [options.x2=0] x-coordinate of end point\r\n     * @param {Number} [options.y2=0] y-coordinate of end point\r\n     * @param {Number} [options.r1=0] Radius of start point (only for radial gradients)\r\n     * @param {Number} [options.r2=0] Radius of end point (only for radial gradients)\r\n     * @param {Object} [options.colorStops] Color stops object eg. {0: 'ff0000', 1: '000000'}\r\n     * @param {Object} [options.gradientTransform] transforMatrix for gradient\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/58y8b/|jsFiddle demo}\r\n     * @example <caption>Set linear gradient</caption>\r\n     * object.setGradient('fill', {\r\n     *   type: 'linear',\r\n     *   x1: -object.width / 2,\r\n     *   y1: 0,\r\n     *   x2: object.width / 2,\r\n     *   y2: 0,\r\n     *   colorStops: {\r\n     *     0: 'red',\r\n     *     0.5: '#005555',\r\n     *     1: 'rgba(0,0,255,0.5)'\r\n     *   }\r\n     * });\r\n     * canvas.renderAll();\r\n     * @example <caption>Set radial gradient</caption>\r\n     * object.setGradient('fill', {\r\n     *   type: 'radial',\r\n     *   x1: 0,\r\n     *   y1: 0,\r\n     *   x2: 0,\r\n     *   y2: 0,\r\n     *   r1: object.width / 2,\r\n     *   r2: 10,\r\n     *   colorStops: {\r\n     *     0: 'red',\r\n     *     0.5: '#005555',\r\n     *     1: 'rgba(0,0,255,0.5)'\r\n     *   }\r\n     * });\r\n     * canvas.renderAll();\r\n     */\r\n    setGradient: function(property, options) {\r\n      options || (options = { });\r\n\r\n      var gradient = { colorStops: [] };\r\n\r\n      gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');\r\n      gradient.coords = {\r\n        x1: options.x1,\r\n        y1: options.y1,\r\n        x2: options.x2,\r\n        y2: options.y2\r\n      };\r\n\r\n      if (options.r1 || options.r2) {\r\n        gradient.coords.r1 = options.r1;\r\n        gradient.coords.r2 = options.r2;\r\n      }\r\n\r\n      options.gradientTransform && (gradient.gradientTransform = options.gradientTransform);\r\n\r\n      for (var position in options.colorStops) {\r\n        var color = new fabric.Color(options.colorStops[position]);\r\n        gradient.colorStops.push({\r\n          offset: position,\r\n          color: color.toRgb(),\r\n          opacity: color.getAlpha()\r\n        });\r\n      }\r\n\r\n      return this.set(property, fabric.Gradient.forObject(this, gradient));\r\n    },\r\n\r\n    /**\r\n     * Sets pattern fill of an object\r\n     * @param {Object} options Options object\r\n     * @param {(String|HTMLImageElement)} options.source Pattern source\r\n     * @param {String} [options.repeat=repeat] Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)\r\n     * @param {Number} [options.offsetX=0] Pattern horizontal offset from object's left/top corner\r\n     * @param {Number} [options.offsetY=0] Pattern vertical offset from object's left/top corner\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/QT3pa/|jsFiddle demo}\r\n     * @example <caption>Set pattern</caption>\r\n     * fabric.util.loadImage('http://fabricjs.com/assets/escheresque_ste.png', function(img) {\r\n     *   object.setPatternFill({\r\n     *     source: img,\r\n     *     repeat: 'repeat'\r\n     *   });\r\n     *   canvas.renderAll();\r\n     * });\r\n     */\r\n    setPatternFill: function(options) {\r\n      return this.set('fill', new fabric.Pattern(options));\r\n    },\r\n\r\n    /**\r\n     * Sets {@link fabric.Object#shadow|shadow} of an object\r\n     * @param {Object|String} [options] Options object or string (e.g. \"2px 2px 10px rgba(0,0,0,0.2)\")\r\n     * @param {String} [options.color=rgb(0,0,0)] Shadow color\r\n     * @param {Number} [options.blur=0] Shadow blur\r\n     * @param {Number} [options.offsetX=0] Shadow horizontal offset\r\n     * @param {Number} [options.offsetY=0] Shadow vertical offset\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     * @see {@link http://jsfiddle.net/fabricjs/7gvJG/|jsFiddle demo}\r\n     * @example <caption>Set shadow with string notation</caption>\r\n     * object.setShadow('2px 2px 10px rgba(0,0,0,0.2)');\r\n     * canvas.renderAll();\r\n     * @example <caption>Set shadow with object notation</caption>\r\n     * object.setShadow({\r\n     *   color: 'red',\r\n     *   blur: 10,\r\n     *   offsetX: 20,\r\n     *   offsetY: 20\r\n     * });\r\n     * canvas.renderAll();\r\n     */\r\n    setShadow: function(options) {\r\n      return this.set('shadow', options ? new fabric.Shadow(options) : null);\r\n    },\r\n\r\n    /**\r\n     * Sets \"color\" of an instance (alias of `set('fill', &hellip;)`)\r\n     * @param {String} color Color value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    setColor: function(color) {\r\n      this.set('fill', color);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets \"angle\" of an instance\r\n     * @param {Number} angle Angle value (in degrees)\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    setAngle: function(angle) {\r\n      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;\r\n\r\n      if (shouldCenterOrigin) {\r\n        this._setOriginToCenter();\r\n      }\r\n\r\n      this.set('angle', angle);\r\n\r\n      if (shouldCenterOrigin) {\r\n        this._resetOrigin();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Centers object horizontally on canvas to which it was added last.\r\n     * You might need to call `setCoords` on an object after centering, to update controls area.\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    centerH: function () {\r\n      this.canvas.centerObjectH(this);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Centers object vertically on canvas to which it was added last.\r\n     * You might need to call `setCoords` on an object after centering, to update controls area.\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    centerV: function () {\r\n      this.canvas.centerObjectV(this);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Centers object vertically and horizontally on canvas to which is was added last\r\n     * You might need to call `setCoords` on an object after centering, to update controls area.\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    center: function () {\r\n      this.canvas.centerObject(this);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Removes object from canvas to which it was added last\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    remove: function() {\r\n      this.canvas.remove(this);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns coordinates of a pointer relative to an object\r\n     * @param {Event} e Event to operate upon\r\n     * @param {Object} [pointer] Pointer to operate upon (instead of event)\r\n     * @return {Object} Coordinates of a pointer (x, y)\r\n     */\r\n    getLocalPointer: function(e, pointer) {\r\n      pointer = pointer || this.canvas.getPointer(e);\r\n      var pClicked = new fabric.Point(pointer.x, pointer.y),\r\n          objectLeftTop = this._getLeftTopCoords();\r\n      if (this.angle) {\r\n        pClicked = fabric.util.rotatePoint(\r\n          pClicked, objectLeftTop, fabric.util.degreesToRadians(-this.angle));\r\n      }\r\n      return {\r\n        x: pClicked.x - objectLeftTop.x,\r\n        y: pClicked.y - objectLeftTop.y\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Sets canvas globalCompositeOperation for specific object\r\n     * custom composition operation for the particular object can be specifed using globalCompositeOperation property\r\n     * @param {CanvasRenderingContext2D} ctx Rendering canvas context\r\n     */\r\n    _setupCompositeOperation: function (ctx) {\r\n      if (this.globalCompositeOperation) {\r\n        ctx.globalCompositeOperation = this.globalCompositeOperation;\r\n      }\r\n    }\r\n  });\r\n\r\n  fabric.util.createAccessors(fabric.Object);\r\n\r\n  /**\r\n   * Alias for {@link fabric.Object.prototype.setAngle}\r\n   * @alias rotate -> setAngle\r\n   * @memberOf fabric.Object\r\n   */\r\n  fabric.Object.prototype.rotate = fabric.Object.prototype.setAngle;\r\n\r\n  extend(fabric.Object.prototype, fabric.Observable);\r\n\r\n  /**\r\n   * Defines the number of fraction digits to use when serializing object values.\r\n   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.\r\n   * @static\r\n   * @memberOf fabric.Object\r\n   * @constant\r\n   * @type Number\r\n   */\r\n  fabric.Object.NUM_FRACTION_DIGITS = 2;\r\n\r\n  /**\r\n   * Unique id used internally when creating SVG elements\r\n   * @static\r\n   * @memberOf fabric.Object\r\n   * @type Number\r\n   */\r\n  fabric.Object.__uid = 0;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function() {\r\n\r\n  var degreesToRadians = fabric.util.degreesToRadians,\r\n      originXOffset = {\r\n        left: -0.5,\r\n        center: 0,\r\n        right: 0.5\r\n      },\r\n      originYOffset = {\r\n        top: -0.5,\r\n        center: 0,\r\n        bottom: 0.5\r\n      };\r\n\r\n  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n    /**\r\n     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\r\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\r\n     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @return {fabric.Point}\r\n     */\r\n    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {\r\n      var x = point.x,\r\n          y = point.y,\r\n          offsetX = originXOffset[toOriginX] - originXOffset[fromOriginX],\r\n          offsetY = originYOffset[toOriginY] - originYOffset[fromOriginY],\r\n          dim;\r\n      if (offsetX || offsetY) {\r\n        dim = this._getTransformedDimensions();\r\n        x = point.x + offsetX * dim.x;\r\n        y = point.y + offsetY * dim.y;\r\n      }\r\n      return new fabric.Point(x, y);\r\n    },\r\n\r\n    /**\r\n     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\r\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\r\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @return {fabric.Point}\r\n     */\r\n    translateToCenterPoint: function(point, originX, originY) {\r\n      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');\r\n      if (this.angle) {\r\n        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));\r\n      }\r\n      return p;\r\n    },\r\n\r\n    /**\r\n     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)\r\n     * @param {fabric.Point} center The point which corresponds to center of the object\r\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @return {fabric.Point}\r\n     */\r\n    translateToOriginPoint: function(center, originX, originY) {\r\n      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);\r\n      if (this.angle) {\r\n        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));\r\n      }\r\n      return p;\r\n    },\r\n\r\n    /**\r\n     * Returns the real center coordinates of the object\r\n     * @return {fabric.Point}\r\n     */\r\n    getCenterPoint: function() {\r\n      var leftTop = new fabric.Point(this.left, this.top);\r\n      return this.translateToCenterPoint(leftTop, this.originX, this.originY);\r\n    },\r\n\r\n    /**\r\n     * Returns the coordinates of the object based on center coordinates\r\n     * @param {fabric.Point} point The point which corresponds to the originX and originY params\r\n     * @return {fabric.Point}\r\n     */\r\n    // getOriginPoint: function(center) {\r\n    //   return this.translateToOriginPoint(center, this.originX, this.originY);\r\n    // },\r\n\r\n    /**\r\n     * Returns the coordinates of the object as if it has a different origin\r\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @return {fabric.Point}\r\n     */\r\n    getPointByOrigin: function(originX, originY) {\r\n      var center = this.getCenterPoint();\r\n      return this.translateToOriginPoint(center, originX, originY);\r\n    },\r\n\r\n    /**\r\n     * Returns the point in local coordinates\r\n     * @param {fabric.Point} point The point relative to the global coordinate system\r\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @return {fabric.Point}\r\n     */\r\n    toLocalPoint: function(point, originX, originY) {\r\n      var center = this.getCenterPoint(),\r\n          p, p2;\r\n\r\n      if (originX && originY) {\r\n        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);\r\n      }\r\n      else {\r\n        p = new fabric.Point(this.left, this.top);\r\n      }\r\n\r\n      p2 = new fabric.Point(point.x, point.y);\r\n      if (this.angle) {\r\n        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));\r\n      }\r\n      return p2.subtractEquals(p);\r\n    },\r\n\r\n    /**\r\n     * Returns the point in global coordinates\r\n     * @param {fabric.Point} The point relative to the local coordinate system\r\n     * @return {fabric.Point}\r\n     */\r\n    // toGlobalPoint: function(point) {\r\n    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));\r\n    // },\r\n\r\n    /**\r\n     * Sets the position of the object taking into consideration the object's origin\r\n     * @param {fabric.Point} pos The new position of the object\r\n     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'\r\n     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'\r\n     * @return {void}\r\n     */\r\n    setPositionByOrigin: function(pos, originX, originY) {\r\n      var center = this.translateToCenterPoint(pos, originX, originY),\r\n          position = this.translateToOriginPoint(center, this.originX, this.originY);\r\n\r\n      this.set('left', position.x);\r\n      this.set('top', position.y);\r\n    },\r\n\r\n    /**\r\n     * @param {String} to One of 'left', 'center', 'right'\r\n     */\r\n    adjustPosition: function(to) {\r\n      var angle = degreesToRadians(this.angle),\r\n          hypotFull = this.getWidth(),\r\n          xFull = Math.cos(angle) * hypotFull,\r\n          yFull = Math.sin(angle) * hypotFull;\r\n\r\n      //TODO: this function does not consider mixed situation like top, center.\r\n      this.left += xFull * (originXOffset[to] - originXOffset[this.originX]);\r\n      this.top += yFull * (originXOffset[to] - originXOffset[this.originX]);\r\n\r\n      this.setCoords();\r\n      this.originX = to;\r\n    },\r\n\r\n    /**\r\n     * Sets the origin/position of the object to it's center point\r\n     * @private\r\n     * @return {void}\r\n     */\r\n    _setOriginToCenter: function() {\r\n      this._originalOriginX = this.originX;\r\n      this._originalOriginY = this.originY;\r\n\r\n      var center = this.getCenterPoint();\r\n\r\n      this.originX = 'center';\r\n      this.originY = 'center';\r\n\r\n      this.left = center.x;\r\n      this.top = center.y;\r\n    },\r\n\r\n    /**\r\n     * Resets the origin/position of the object to it's original origin\r\n     * @private\r\n     * @return {void}\r\n     */\r\n    _resetOrigin: function() {\r\n      var originPoint = this.translateToOriginPoint(\r\n        this.getCenterPoint(),\r\n        this._originalOriginX,\r\n        this._originalOriginY);\r\n\r\n      this.originX = this._originalOriginX;\r\n      this.originY = this._originalOriginY;\r\n\r\n      this.left = originPoint.x;\r\n      this.top = originPoint.y;\r\n\r\n      this._originalOriginX = null;\r\n      this._originalOriginY = null;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getLeftTopCoords: function() {\r\n      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');\r\n    }\r\n  });\r\n\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  function getCoords(oCoords) {\r\n    return [\r\n      new fabric.Point(oCoords.tl.x, oCoords.tl.y),\r\n      new fabric.Point(oCoords.tr.x, oCoords.tr.y),\r\n      new fabric.Point(oCoords.br.x, oCoords.br.y),\r\n      new fabric.Point(oCoords.bl.x, oCoords.bl.y)\r\n    ];\r\n  }\r\n\r\n  var degreesToRadians = fabric.util.degreesToRadians;\r\n\r\n  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n    /**\r\n     * Object containing coordinates of object's controls\r\n     * @type Object\r\n     * @default\r\n     */\r\n    oCoords: null,\r\n\r\n    /**\r\n     * Checks if object intersects with an area formed by 2 points\r\n     * @param {Object} pointTL top-left point of area\r\n     * @param {Object} pointBR bottom-right point of area\r\n     * @return {Boolean} true if object intersects with an area formed by 2 points\r\n     */\r\n    intersectsWithRect: function(pointTL, pointBR) {\r\n      var oCoords = getCoords(this.oCoords),\r\n          intersection = fabric.Intersection.intersectPolygonRectangle(\r\n            oCoords,\r\n            pointTL,\r\n            pointBR\r\n          );\r\n      return intersection.status === 'Intersection';\r\n    },\r\n\r\n    /**\r\n     * Checks if object intersects with another object\r\n     * @param {Object} other Object to test\r\n     * @return {Boolean} true if object intersects with another object\r\n     */\r\n    intersectsWithObject: function(other) {\r\n      var intersection = fabric.Intersection.intersectPolygonPolygon(\r\n            getCoords(this.oCoords),\r\n            getCoords(other.oCoords)\r\n          );\r\n\r\n      return intersection.status === 'Intersection';\r\n    },\r\n\r\n    /**\r\n     * Checks if object is fully contained within area of another object\r\n     * @param {Object} other Object to test\r\n     * @return {Boolean} true if object is fully contained within area of another object\r\n     */\r\n    isContainedWithinObject: function(other) {\r\n      var boundingRect = other.getBoundingRect(),\r\n          point1 = new fabric.Point(boundingRect.left, boundingRect.top),\r\n          point2 = new fabric.Point(boundingRect.left + boundingRect.width, boundingRect.top + boundingRect.height);\r\n\r\n      return this.isContainedWithinRect(point1, point2);\r\n    },\r\n\r\n    /**\r\n     * Checks if object is fully contained within area formed by 2 points\r\n     * @param {Object} pointTL top-left point of area\r\n     * @param {Object} pointBR bottom-right point of area\r\n     * @return {Boolean} true if object is fully contained within area formed by 2 points\r\n     */\r\n    isContainedWithinRect: function(pointTL, pointBR) {\r\n      var boundingRect = this.getBoundingRect();\r\n\r\n      return (\r\n        boundingRect.left >= pointTL.x &&\r\n        boundingRect.left + boundingRect.width <= pointBR.x &&\r\n        boundingRect.top >= pointTL.y &&\r\n        boundingRect.top + boundingRect.height <= pointBR.y\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Checks if point is inside the object\r\n     * @param {fabric.Point} point Point to check against\r\n     * @return {Boolean} true if point is inside the object\r\n     */\r\n    containsPoint: function(point) {\r\n      var lines = this._getImageLines(this.oCoords),\r\n          xPoints = this._findCrossPoints(point, lines);\r\n\r\n      // if xPoints is odd then point is inside the object\r\n      return (xPoints !== 0 && xPoints % 2 === 1);\r\n    },\r\n\r\n    /**\r\n     * Method that returns an object with the object edges in it, given the coordinates of the corners\r\n     * @private\r\n     * @param {Object} oCoords Coordinates of the object corners\r\n     */\r\n    _getImageLines: function(oCoords) {\r\n      return {\r\n        topline: {\r\n          o: oCoords.tl,\r\n          d: oCoords.tr\r\n        },\r\n        rightline: {\r\n          o: oCoords.tr,\r\n          d: oCoords.br\r\n        },\r\n        bottomline: {\r\n          o: oCoords.br,\r\n          d: oCoords.bl\r\n        },\r\n        leftline: {\r\n          o: oCoords.bl,\r\n          d: oCoords.tl\r\n        }\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Helper method to determine how many cross points are between the 4 object edges\r\n     * and the horizontal line determined by a point on canvas\r\n     * @private\r\n     * @param {fabric.Point} point Point to check\r\n     * @param {Object} oCoords Coordinates of the object being evaluated\r\n     */\r\n    _findCrossPoints: function(point, oCoords) {\r\n      var b1, b2, a1, a2, xi, yi,\r\n          xcount = 0,\r\n          iLine;\r\n\r\n      for (var lineKey in oCoords) {\r\n        iLine = oCoords[lineKey];\r\n        // optimisation 1: line below point. no cross\r\n        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {\r\n          continue;\r\n        }\r\n        // optimisation 2: line above point. no cross\r\n        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {\r\n          continue;\r\n        }\r\n        // optimisation 3: vertical line case\r\n        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {\r\n          xi = iLine.o.x;\r\n          yi = point.y;\r\n        }\r\n        // calculate the intersection point\r\n        else {\r\n          b1 = 0;\r\n          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);\r\n          a1 = point.y - b1 * point.x;\r\n          a2 = iLine.o.y - b2 * iLine.o.x;\r\n\r\n          xi = - (a1 - a2) / (b1 - b2);\r\n          yi = a1 + b1 * xi;\r\n        }\r\n        // dont count xi < point.x cases\r\n        if (xi >= point.x) {\r\n          xcount += 1;\r\n        }\r\n        // optimisation 4: specific for square images\r\n        if (xcount === 2) {\r\n          break;\r\n        }\r\n      }\r\n      return xcount;\r\n    },\r\n\r\n    /**\r\n     * Returns width of an object's bounding rectangle\r\n     * @deprecated since 1.0.4\r\n     * @return {Number} width value\r\n     */\r\n    getBoundingRectWidth: function() {\r\n      return this.getBoundingRect().width;\r\n    },\r\n\r\n    /**\r\n     * Returns height of an object's bounding rectangle\r\n     * @deprecated since 1.0.4\r\n     * @return {Number} height value\r\n     */\r\n    getBoundingRectHeight: function() {\r\n      return this.getBoundingRect().height;\r\n    },\r\n\r\n    /**\r\n     * Returns coordinates of object's bounding rectangle (left, top, width, height)\r\n     * @return {Object} Object with left, top, width, height properties\r\n     */\r\n    getBoundingRect: function() {\r\n      this.oCoords || this.setCoords();\r\n\r\n      var xCoords = [this.oCoords.tl.x, this.oCoords.tr.x, this.oCoords.br.x, this.oCoords.bl.x],\r\n          minX = fabric.util.array.min(xCoords),\r\n          maxX = fabric.util.array.max(xCoords),\r\n          width = Math.abs(minX - maxX),\r\n\r\n          yCoords = [this.oCoords.tl.y, this.oCoords.tr.y, this.oCoords.br.y, this.oCoords.bl.y],\r\n          minY = fabric.util.array.min(yCoords),\r\n          maxY = fabric.util.array.max(yCoords),\r\n          height = Math.abs(minY - maxY);\r\n\r\n      return {\r\n        left: minX,\r\n        top: minY,\r\n        width: width,\r\n        height: height\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Returns width of an object\r\n     * @return {Number} width value\r\n     */\r\n    getWidth: function() {\r\n      //needs to be changed\r\n      return this.width * this.scaleX;\r\n    },\r\n\r\n    /**\r\n     * Returns height of an object\r\n     * @return {Number} height value\r\n     */\r\n    getHeight: function() {\r\n      //needs to be changed\r\n      return this.height * this.scaleY;\r\n    },\r\n\r\n    /**\r\n     * Makes sure the scale is valid and modifies it if necessary\r\n     * @private\r\n     * @param {Number} value\r\n     * @return {Number}\r\n     */\r\n    _constrainScale: function(value) {\r\n      if (Math.abs(value) < this.minScaleLimit) {\r\n        if (value < 0) {\r\n          return -this.minScaleLimit;\r\n        }\r\n        else {\r\n          return this.minScaleLimit;\r\n        }\r\n      }\r\n      return value;\r\n    },\r\n\r\n    /**\r\n     * Scales an object (equally by x and y)\r\n     * @param {Number} value Scale factor\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    scale: function(value) {\r\n      value = this._constrainScale(value);\r\n\r\n      if (value < 0) {\r\n        this.flipX = !this.flipX;\r\n        this.flipY = !this.flipY;\r\n        value *= -1;\r\n      }\r\n\r\n      this.scaleX = value;\r\n      this.scaleY = value;\r\n      this.setCoords();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)\r\n     * @param {Number} value New width value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    scaleToWidth: function(value) {\r\n      // adjust to bounding rect factor so that rotated shapes would fit as well\r\n      var boundingRectFactor = this.getBoundingRect().width / this.getWidth();\r\n      return this.scale(value / this.width / boundingRectFactor);\r\n    },\r\n\r\n    /**\r\n     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)\r\n     * @param {Number} value New height value\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    scaleToHeight: function(value) {\r\n      // adjust to bounding rect factor so that rotated shapes would fit as well\r\n      var boundingRectFactor = this.getBoundingRect().height / this.getHeight();\r\n      return this.scale(value / this.height / boundingRectFactor);\r\n    },\r\n\r\n    /**\r\n     * Sets corner position coordinates based on current angle, width and height\r\n     * See https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    setCoords: function() {\r\n      var theta = degreesToRadians(this.angle),\r\n          vpt = this.getViewportTransform(),\r\n          dim = this._calculateCurrentDimensions(),\r\n          currentWidth = dim.x, currentHeight = dim.y;\r\n\r\n      // If width is negative, make postive. Fixes path selection issue\r\n      if (currentWidth < 0) {\r\n        currentWidth = Math.abs(currentWidth);\r\n      }\r\n\r\n      var sinTh = Math.sin(theta),\r\n          cosTh = Math.cos(theta),\r\n          _angle = currentWidth > 0 ? Math.atan(currentHeight / currentWidth) : 0,\r\n          _hypotenuse = (currentWidth / Math.cos(_angle)) / 2,\r\n          offsetX = Math.cos(_angle + theta) * _hypotenuse,\r\n          offsetY = Math.sin(_angle + theta) * _hypotenuse,\r\n\r\n          // offset added for rotate and scale actions\r\n          coords = fabric.util.transformPoint(this.getCenterPoint(), vpt),\r\n          tl  = new fabric.Point(coords.x - offsetX, coords.y - offsetY),\r\n          tr  = new fabric.Point(tl.x + (currentWidth * cosTh), tl.y + (currentWidth * sinTh)),\r\n          bl  = new fabric.Point(tl.x - (currentHeight * sinTh), tl.y + (currentHeight * cosTh)),\r\n          br  = new fabric.Point(coords.x + offsetX, coords.y + offsetY),\r\n          ml  = new fabric.Point((tl.x + bl.x)/2, (tl.y + bl.y)/2),\r\n          mt  = new fabric.Point((tr.x + tl.x)/2, (tr.y + tl.y)/2),\r\n          mr  = new fabric.Point((br.x + tr.x)/2, (br.y + tr.y)/2),\r\n          mb  = new fabric.Point((br.x + bl.x)/2, (br.y + bl.y)/2),\r\n          mtr = new fabric.Point(mt.x + sinTh * this.rotatingPointOffset, mt.y - cosTh * this.rotatingPointOffset);\r\n      // debugging\r\n\r\n      /* setTimeout(function() {\r\n         canvas.contextTop.fillStyle = 'green';\r\n         canvas.contextTop.fillRect(mb.x, mb.y, 3, 3);\r\n         canvas.contextTop.fillRect(bl.x, bl.y, 3, 3);\r\n         canvas.contextTop.fillRect(br.x, br.y, 3, 3);\r\n         canvas.contextTop.fillRect(tl.x, tl.y, 3, 3);\r\n         canvas.contextTop.fillRect(tr.x, tr.y, 3, 3);\r\n         canvas.contextTop.fillRect(ml.x, ml.y, 3, 3);\r\n         canvas.contextTop.fillRect(mr.x, mr.y, 3, 3);\r\n         canvas.contextTop.fillRect(mt.x, mt.y, 3, 3);\r\n         canvas.contextTop.fillRect(mtr.x, mtr.y, 3, 3);\r\n       }, 50); */\r\n\r\n      this.oCoords = {\r\n        // corners\r\n        tl: tl, tr: tr, br: br, bl: bl,\r\n        // middle\r\n        ml: ml, mt: mt, mr: mr, mb: mb,\r\n        // rotating point\r\n        mtr: mtr\r\n      };\r\n\r\n      // set coordinates of the draggable boxes in the corners used to scale/rotate the image\r\n      this._setCornerCoords && this._setCornerCoords();\r\n\r\n      return this;\r\n    },\r\n\r\n    _calcDimensionsTransformMatrix: function() {\r\n      // introduce skew matrix here later\r\n      return [this.scaleX, 0, 0, this.scaleY, 0, 0];\r\n    }\r\n  });\r\n})();\r\n\r\n\r\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n  /**\r\n   * Moves an object to the bottom of the stack of drawn objects\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  sendToBack: function() {\r\n    if (this.group) {\r\n      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);\r\n    }\r\n    else {\r\n      this.canvas.sendToBack(this);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Moves an object to the top of the stack of drawn objects\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  bringToFront: function() {\r\n    if (this.group) {\r\n      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);\r\n    }\r\n    else {\r\n      this.canvas.bringToFront(this);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Moves an object down in stack of drawn objects\r\n   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  sendBackwards: function(intersecting) {\r\n    if (this.group) {\r\n      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);\r\n    }\r\n    else {\r\n      this.canvas.sendBackwards(this, intersecting);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Moves an object up in stack of drawn objects\r\n   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  bringForward: function(intersecting) {\r\n    if (this.group) {\r\n      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);\r\n    }\r\n    else {\r\n      this.canvas.bringForward(this, intersecting);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Moves an object to specified level in stack of drawn objects\r\n   * @param {Number} index New position of object\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  moveTo: function(index) {\r\n    if (this.group) {\r\n      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);\r\n    }\r\n    else {\r\n      this.canvas.moveTo(this, index);\r\n    }\r\n    return this;\r\n  }\r\n});\r\n\r\n\r\n/* _TO_SVG_START_ */\r\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n  /**\r\n   * Returns styles-string for svg-export\r\n   * @return {String}\r\n   */\r\n  getSvgStyles: function() {\r\n\r\n    var fill = this.fill\r\n          ? (this.fill.toLive ? 'url(#SVGID_' + this.fill.id + ')' : this.fill)\r\n          : 'none',\r\n        fillRule = this.fillRule,\r\n        stroke = this.stroke\r\n          ? (this.stroke.toLive ? 'url(#SVGID_' + this.stroke.id + ')' : this.stroke)\r\n          : 'none',\r\n\r\n        strokeWidth = this.strokeWidth ? this.strokeWidth : '0',\r\n        strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',\r\n        strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',\r\n        strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',\r\n        strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',\r\n        opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',\r\n\r\n        visibility = this.visible ? '' : ' visibility: hidden;',\r\n        filter = this.getSvgFilter();\r\n\r\n    return [\r\n      'stroke: ', stroke, '; ',\r\n      'stroke-width: ', strokeWidth, '; ',\r\n      'stroke-dasharray: ', strokeDashArray, '; ',\r\n      'stroke-linecap: ', strokeLineCap, '; ',\r\n      'stroke-linejoin: ', strokeLineJoin, '; ',\r\n      'stroke-miterlimit: ', strokeMiterLimit, '; ',\r\n      'fill: ', fill, '; ',\r\n      'fill-rule: ', fillRule, '; ',\r\n      'opacity: ', opacity, ';',\r\n      filter,\r\n      visibility\r\n    ].join('');\r\n  },\r\n\r\n  /**\r\n   * Returns filter for svg shadow\r\n   * @return {String}\r\n   */\r\n  getSvgFilter: function() {\r\n    return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';\r\n  },\r\n\r\n  /**\r\n   * Returns transform-string for svg-export\r\n   * @return {String}\r\n   */\r\n  getSvgTransform: function() {\r\n    if (this.group && this.group.type === 'path-group') {\r\n      return '';\r\n    }\r\n    var toFixed = fabric.util.toFixed,\r\n        angle = this.getAngle(),\r\n        vpt = !this.canvas || this.canvas.svgViewportTransformation ? this.getViewportTransform() : [1, 0, 0, 1, 0, 0],\r\n        center = fabric.util.transformPoint(this.getCenterPoint(), vpt),\r\n\r\n        NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,\r\n\r\n        translatePart = this.type === 'path-group' ? '' : 'translate(' +\r\n                          toFixed(center.x, NUM_FRACTION_DIGITS) +\r\n                          ' ' +\r\n                          toFixed(center.y, NUM_FRACTION_DIGITS) +\r\n                        ')',\r\n\r\n        anglePart = angle !== 0\r\n          ? (' rotate(' + toFixed(angle, NUM_FRACTION_DIGITS) + ')')\r\n          : '',\r\n\r\n        scalePart = (this.scaleX === 1 && this.scaleY === 1 && vpt[0] === 1 && vpt[3] === 1)\r\n          ? '' :\r\n          (' scale(' +\r\n            toFixed(this.scaleX * vpt[0], NUM_FRACTION_DIGITS) +\r\n            ' ' +\r\n            toFixed(this.scaleY * vpt[3], NUM_FRACTION_DIGITS) +\r\n          ')'),\r\n\r\n        addTranslateX = this.type === 'path-group' ? this.width * vpt[0] : 0,\r\n\r\n        flipXPart = this.flipX ? ' matrix(-1 0 0 1 ' + addTranslateX + ' 0) ' : '',\r\n\r\n        addTranslateY = this.type === 'path-group' ? this.height * vpt[3] : 0,\r\n\r\n        flipYPart = this.flipY ? ' matrix(1 0 0 -1 0 ' + addTranslateY + ')' : '';\r\n\r\n    return [\r\n      translatePart, anglePart, scalePart, flipXPart, flipYPart\r\n    ].join('');\r\n  },\r\n\r\n  /**\r\n   * Returns transform-string for svg-export from the transform matrix of single elements\r\n   * @return {String}\r\n   */\r\n  getSvgTransformMatrix: function() {\r\n    return this.transformMatrix ? ' matrix(' + this.transformMatrix.join(' ') + ') ' : '';\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _createBaseSVGMarkup: function() {\r\n    var markup = [ ];\r\n\r\n    if (this.fill && this.fill.toLive) {\r\n      markup.push(this.fill.toSVG(this, false));\r\n    }\r\n    if (this.stroke && this.stroke.toLive) {\r\n      markup.push(this.stroke.toSVG(this, false));\r\n    }\r\n    if (this.shadow) {\r\n      markup.push(this.shadow.toSVG(this));\r\n    }\r\n    return markup;\r\n  }\r\n});\r\n/* _TO_SVG_END_ */\r\n\r\n\r\n/*\r\n  Depends on `stateProperties`\r\n*/\r\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n  /**\r\n   * Returns true if object state (one of its state properties) was changed\r\n   * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called\r\n   */\r\n  hasStateChanged: function() {\r\n    return this.stateProperties.some(function(prop) {\r\n      return this.get(prop) !== this.originalState[prop];\r\n    }, this);\r\n  },\r\n\r\n  /**\r\n   * Saves state of an object\r\n   * @param {Object} [options] Object with additional `stateProperties` array to include when saving state\r\n   * @return {fabric.Object} thisArg\r\n   */\r\n  saveState: function(options) {\r\n    this.stateProperties.forEach(function(prop) {\r\n      this.originalState[prop] = this.get(prop);\r\n    }, this);\r\n\r\n    if (options && options.stateProperties) {\r\n      options.stateProperties.forEach(function(prop) {\r\n        this.originalState[prop] = this.get(prop);\r\n      }, this);\r\n    }\r\n\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Setups state of an object\r\n   * @return {fabric.Object} thisArg\r\n   */\r\n  setupState: function() {\r\n    this.originalState = { };\r\n    this.saveState();\r\n\r\n    return this;\r\n  }\r\n});\r\n\r\n\r\n(function() {\r\n\r\n  var degreesToRadians = fabric.util.degreesToRadians,\r\n      //jscs:disable requireCamelCaseOrUpperCaseIdentifiers\r\n      isVML = function() { return typeof G_vmlCanvasManager !== 'undefined'; };\r\n  //jscs:enable requireCamelCaseOrUpperCaseIdentifiers\r\n\r\n  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n    /**\r\n     * The object interactivity controls.\r\n     * @private\r\n     */\r\n    _controlsVisibility: null,\r\n\r\n    /**\r\n     * Determines which corner has been clicked\r\n     * @private\r\n     * @param {Object} pointer The pointer indicating the mouse position\r\n     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found\r\n     */\r\n    _findTargetCorner: function(pointer) {\r\n      if (!this.hasControls || !this.active) {\r\n        return false;\r\n      }\r\n\r\n      var ex = pointer.x,\r\n          ey = pointer.y,\r\n          xPoints,\r\n          lines;\r\n      this.__corner = 0;\r\n      for (var i in this.oCoords) {\r\n\r\n        if (!this.isControlVisible(i)) {\r\n          continue;\r\n        }\r\n\r\n        if (i === 'mtr' && !this.hasRotatingPoint) {\r\n          continue;\r\n        }\r\n\r\n        if (this.get('lockUniScaling') &&\r\n           (i === 'mt' || i === 'mr' || i === 'mb' || i === 'ml')) {\r\n          continue;\r\n        }\r\n\r\n        lines = this._getImageLines(this.oCoords[i].corner);\r\n\r\n        // debugging\r\n\r\n        // canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);\r\n        // canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);\r\n\r\n        // canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);\r\n        // canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);\r\n\r\n        // canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);\r\n        // canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);\r\n\r\n        // canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);\r\n        // canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);\r\n\r\n        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);\r\n        if (xPoints !== 0 && xPoints % 2 === 1) {\r\n          this.__corner = i;\r\n          return i;\r\n        }\r\n      }\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * Sets the coordinates of the draggable boxes in the corners of\r\n     * the image used to scale/rotate it.\r\n     * @private\r\n     */\r\n    _setCornerCoords: function() {\r\n      var coords = this.oCoords,\r\n          newTheta = degreesToRadians(45 - this.angle),\r\n          /* Math.sqrt(2 * Math.pow(this.cornerSize, 2)) / 2, */\r\n          /* 0.707106 stands for sqrt(2)/2 */\r\n          cornerHypotenuse = this.cornerSize * 0.707106,\r\n          cosHalfOffset = cornerHypotenuse * Math.cos(newTheta),\r\n          sinHalfOffset = cornerHypotenuse * Math.sin(newTheta),\r\n          x, y;\r\n\r\n      for (var point in coords) {\r\n        x = coords[point].x;\r\n        y = coords[point].y;\r\n        coords[point].corner = {\r\n          tl: {\r\n            x: x - sinHalfOffset,\r\n            y: y - cosHalfOffset\r\n          },\r\n          tr: {\r\n            x: x + cosHalfOffset,\r\n            y: y - sinHalfOffset\r\n          },\r\n          bl: {\r\n            x: x - cosHalfOffset,\r\n            y: y + sinHalfOffset\r\n          },\r\n          br: {\r\n            x: x + sinHalfOffset,\r\n            y: y + cosHalfOffset\r\n          }\r\n        };\r\n      }\r\n    },\r\n\r\n    /*\r\n     * Calculate object dimensions from its properties\r\n     * @private\r\n     */\r\n    _getNonTransformedDimensions: function() {\r\n      var strokeWidth = this.strokeWidth,\r\n          w = this.width,\r\n          h = this.height,\r\n          addStrokeToW = true,\r\n          addStrokeToH = true;\r\n\r\n      if (this.type === 'line' && this.strokeLineCap === 'butt') {\r\n        addStrokeToH = w;\r\n        addStrokeToW = h;\r\n      }\r\n\r\n      if (addStrokeToH) {\r\n        h += h < 0 ? -strokeWidth : strokeWidth;\r\n      }\r\n\r\n      if (addStrokeToW) {\r\n        w += w < 0 ? -strokeWidth : strokeWidth;\r\n      }\r\n\r\n      return { x: w, y: h };\r\n    },\r\n\r\n    /*\r\n     * @private\r\n     */\r\n    _getTransformedDimensions: function(dimensions) {\r\n      if (!dimensions) {\r\n        dimensions = this._getNonTransformedDimensions();\r\n      }\r\n      var transformMatrix = this._calcDimensionsTransformMatrix();\r\n      return fabric.util.transformPoint(dimensions, transformMatrix, true);\r\n    },\r\n\r\n    /*\r\n     * private\r\n     */\r\n    _calculateCurrentDimensions: function()  {\r\n      var vpt = this.getViewportTransform(),\r\n          dim = this._getTransformedDimensions(),\r\n          w = dim.x, h = dim.y;\r\n\r\n      w += 2 * this.padding;\r\n      h += 2 * this.padding;\r\n\r\n      return fabric.util.transformPoint(new fabric.Point(w, h), vpt, true);\r\n    },\r\n\r\n    /**\r\n     * Draws borders of an object's bounding box.\r\n     * Requires public properties: width, height\r\n     * Requires public options: padding, borderColor\r\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    drawBorders: function(ctx) {\r\n      if (!this.hasBorders) {\r\n        return this;\r\n      }\r\n\r\n      ctx.save();\r\n\r\n      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\r\n      ctx.strokeStyle = this.borderColor;\r\n      ctx.lineWidth = 1 / this.borderScaleFactor;\r\n\r\n      var wh = this._calculateCurrentDimensions(),\r\n          width = wh.x,\r\n          height = wh.y;\r\n      if (this.group) {\r\n        width = width * this.group.scaleX;\r\n        height = height * this.group.scaleY;\r\n      }\r\n\r\n      ctx.strokeRect(\r\n        ~~(-(width / 2)) - 0.5, // offset needed to make lines look sharper\r\n        ~~(-(height / 2)) - 0.5,\r\n        ~~(width) + 1, // double offset needed to make lines look sharper\r\n        ~~(height) + 1\r\n      );\r\n\r\n      if (this.hasRotatingPoint && this.isControlVisible('mtr') && !this.get('lockRotation') && this.hasControls) {\r\n\r\n        var rotateHeight = -height / 2;\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, rotateHeight);\r\n        ctx.lineTo(0, rotateHeight - this.rotatingPointOffset);\r\n        ctx.closePath();\r\n        ctx.stroke();\r\n      }\r\n\r\n      ctx.restore();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Draws corners of an object's bounding box.\r\n     * Requires public properties: width, height\r\n     * Requires public options: cornerSize, padding\r\n     * @param {CanvasRenderingContext2D} ctx Context to draw on\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    drawControls: function(ctx) {\r\n      if (!this.hasControls) {\r\n        return this;\r\n      }\r\n\r\n      var wh = this._calculateCurrentDimensions(),\r\n          width = wh.x,\r\n          height = wh.y,\r\n          scaleOffset = this.cornerSize / 2,\r\n          left = -(width / 2) - scaleOffset,\r\n          top = -(height / 2) - scaleOffset,\r\n          methodName = this.transparentCorners ? 'strokeRect' : 'fillRect';\r\n\r\n      ctx.save();\r\n\r\n      ctx.lineWidth = 1;\r\n\r\n      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\r\n      ctx.strokeStyle = ctx.fillStyle = this.cornerColor;\r\n\r\n      // top-left\r\n      this._drawControl('tl', ctx, methodName,\r\n        left,\r\n        top);\r\n\r\n      // top-right\r\n      this._drawControl('tr', ctx, methodName,\r\n        left + width,\r\n        top);\r\n\r\n      // bottom-left\r\n      this._drawControl('bl', ctx, methodName,\r\n        left,\r\n        top + height);\r\n\r\n      // bottom-right\r\n      this._drawControl('br', ctx, methodName,\r\n        left + width,\r\n        top + height);\r\n\r\n      if (!this.get('lockUniScaling')) {\r\n\r\n        // middle-top\r\n        this._drawControl('mt', ctx, methodName,\r\n          left + width/2,\r\n          top);\r\n\r\n        // middle-bottom\r\n        this._drawControl('mb', ctx, methodName,\r\n          left + width/2,\r\n          top + height);\r\n\r\n        // middle-right\r\n        this._drawControl('mr', ctx, methodName,\r\n          left + width,\r\n          top + height/2);\r\n\r\n        // middle-left\r\n        this._drawControl('ml', ctx, methodName,\r\n          left,\r\n          top + height/2);\r\n      }\r\n\r\n      // middle-top-rotate\r\n      if (this.hasRotatingPoint) {\r\n        this._drawControl('mtr', ctx, methodName,\r\n          left + width/2 ,\r\n          top - this.rotatingPointOffset);\r\n      }\r\n\r\n      ctx.restore();\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _drawControl: function(control, ctx, methodName, left, top) {\r\n      if (!this.isControlVisible(control)) {\r\n        return;\r\n      }\r\n      var size = this.cornerSize;\r\n      isVML() || this.transparentCorners || ctx.clearRect(left, top, size, size);\r\n      ctx[methodName](left, top, size, size);\r\n    },\r\n\r\n    /**\r\n     * Returns true if the specified control is visible, false otherwise.\r\n     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\r\n     * @returns {Boolean} true if the specified control is visible, false otherwise\r\n     */\r\n    isControlVisible: function(controlName) {\r\n      return this._getControlsVisibility()[controlName];\r\n    },\r\n\r\n    /**\r\n     * Sets the visibility of the specified control.\r\n     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.\r\n     * @param {Boolean} visible true to set the specified control visible, false otherwise\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    setControlVisible: function(controlName, visible) {\r\n      this._getControlsVisibility()[controlName] = visible;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the visibility state of object controls.\r\n     * @param {Object} [options] Options object\r\n     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it\r\n     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it\r\n     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it\r\n     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it\r\n     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it\r\n     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it\r\n     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it\r\n     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it\r\n     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it\r\n     * @return {fabric.Object} thisArg\r\n     * @chainable\r\n     */\r\n    setControlsVisibility: function(options) {\r\n      options || (options = { });\r\n\r\n      for (var p in options) {\r\n        this.setControlVisible(p, options[p]);\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the instance of the control visibility set for this object.\r\n     * @private\r\n     * @returns {Object}\r\n     */\r\n    _getControlsVisibility: function() {\r\n      if (!this._controlsVisibility) {\r\n        this._controlsVisibility = {\r\n          tl: true,\r\n          tr: true,\r\n          br: true,\r\n          bl: true,\r\n          ml: true,\r\n          mt: true,\r\n          mr: true,\r\n          mb: true,\r\n          mtr: true\r\n        };\r\n      }\r\n      return this._controlsVisibility;\r\n    }\r\n  });\r\n})();\r\n\r\n\r\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\r\n\r\n  /**\r\n   * Animation duration (in ms) for fx* methods\r\n   * @type Number\r\n   * @default\r\n   */\r\n  FX_DURATION: 500,\r\n\r\n  /**\r\n   * Centers object horizontally with animation.\r\n   * @param {fabric.Object} object Object to center\r\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\r\n   * @param {Function} [callbacks.onComplete] Invoked on completion\r\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\r\n   * @return {fabric.Canvas} thisArg\r\n   * @chainable\r\n   */\r\n  fxCenterObjectH: function (object, callbacks) {\r\n    callbacks = callbacks || { };\r\n\r\n    var empty = function() { },\r\n        onComplete = callbacks.onComplete || empty,\r\n        onChange = callbacks.onChange || empty,\r\n        _this = this;\r\n\r\n    fabric.util.animate({\r\n      startValue: object.get('left'),\r\n      endValue: this.getCenter().left,\r\n      duration: this.FX_DURATION,\r\n      onChange: function(value) {\r\n        object.set('left', value);\r\n        _this.renderAll();\r\n        onChange();\r\n      },\r\n      onComplete: function() {\r\n        object.setCoords();\r\n        onComplete();\r\n      }\r\n    });\r\n\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Centers object vertically with animation.\r\n   * @param {fabric.Object} object Object to center\r\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\r\n   * @param {Function} [callbacks.onComplete] Invoked on completion\r\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\r\n   * @return {fabric.Canvas} thisArg\r\n   * @chainable\r\n   */\r\n  fxCenterObjectV: function (object, callbacks) {\r\n    callbacks = callbacks || { };\r\n\r\n    var empty = function() { },\r\n        onComplete = callbacks.onComplete || empty,\r\n        onChange = callbacks.onChange || empty,\r\n        _this = this;\r\n\r\n    fabric.util.animate({\r\n      startValue: object.get('top'),\r\n      endValue: this.getCenter().top,\r\n      duration: this.FX_DURATION,\r\n      onChange: function(value) {\r\n        object.set('top', value);\r\n        _this.renderAll();\r\n        onChange();\r\n      },\r\n      onComplete: function() {\r\n        object.setCoords();\r\n        onComplete();\r\n      }\r\n    });\r\n\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Same as `fabric.Canvas#remove` but animated\r\n   * @param {fabric.Object} object Object to remove\r\n   * @param {Object} [callbacks] Callbacks object with optional \"onComplete\" and/or \"onChange\" properties\r\n   * @param {Function} [callbacks.onComplete] Invoked on completion\r\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\r\n   * @return {fabric.Canvas} thisArg\r\n   * @chainable\r\n   */\r\n  fxRemove: function (object, callbacks) {\r\n    callbacks = callbacks || { };\r\n\r\n    var empty = function() { },\r\n        onComplete = callbacks.onComplete || empty,\r\n        onChange = callbacks.onChange || empty,\r\n        _this = this;\r\n\r\n    fabric.util.animate({\r\n      startValue: object.get('opacity'),\r\n      endValue: 0,\r\n      duration: this.FX_DURATION,\r\n      onStart: function() {\r\n        object.set('active', false);\r\n      },\r\n      onChange: function(value) {\r\n        object.set('opacity', value);\r\n        _this.renderAll();\r\n        onChange();\r\n      },\r\n      onComplete: function () {\r\n        _this.remove(object);\r\n        onComplete();\r\n      }\r\n    });\r\n\r\n    return this;\r\n  }\r\n});\r\n\r\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n  /**\r\n   * Animates object's properties\r\n   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)\r\n   * @param {Number|Object} value Value to animate property to (if string was given first) or options object\r\n   * @return {fabric.Object} thisArg\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#animation}\r\n   * @chainable\r\n   *\r\n   * As object \u00e2\u0080\u0094 multiple properties\r\n   *\r\n   * object.animate({ left: ..., top: ... });\r\n   * object.animate({ left: ..., top: ... }, { duration: ... });\r\n   *\r\n   * As string \u00e2\u0080\u0094 one property\r\n   *\r\n   * object.animate('left', ...);\r\n   * object.animate('left', { duration: ... });\r\n   *\r\n   */\r\n  animate: function() {\r\n    if (arguments[0] && typeof arguments[0] === 'object') {\r\n      var propsToAnimate = [ ], prop, skipCallbacks;\r\n      for (prop in arguments[0]) {\r\n        propsToAnimate.push(prop);\r\n      }\r\n      for (var i = 0, len = propsToAnimate.length; i < len; i++) {\r\n        prop = propsToAnimate[i];\r\n        skipCallbacks = i !== len - 1;\r\n        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);\r\n      }\r\n    }\r\n    else {\r\n      this._animate.apply(this, arguments);\r\n    }\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {String} property Property to animate\r\n   * @param {String} to Value to animate to\r\n   * @param {Object} [options] Options object\r\n   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked\r\n   */\r\n  _animate: function(property, to, options, skipCallbacks) {\r\n    var _this = this, propPair;\r\n\r\n    to = to.toString();\r\n\r\n    if (!options) {\r\n      options = { };\r\n    }\r\n    else {\r\n      options = fabric.util.object.clone(options);\r\n    }\r\n\r\n    if (~property.indexOf('.')) {\r\n      propPair = property.split('.');\r\n    }\r\n\r\n    var currentValue = propPair\r\n      ? this.get(propPair[0])[propPair[1]]\r\n      : this.get(property);\r\n\r\n    if (!('from' in options)) {\r\n      options.from = currentValue;\r\n    }\r\n\r\n    if (~to.indexOf('=')) {\r\n      to = currentValue + parseFloat(to.replace('=', ''));\r\n    }\r\n    else {\r\n      to = parseFloat(to);\r\n    }\r\n\r\n    fabric.util.animate({\r\n      startValue: options.from,\r\n      endValue: to,\r\n      byValue: options.by,\r\n      easing: options.easing,\r\n      duration: options.duration,\r\n      abort: options.abort && function() {\r\n        return options.abort.call(_this);\r\n      },\r\n      onChange: function(value) {\r\n        if (propPair) {\r\n          _this[propPair[0]][propPair[1]] = value;\r\n        }\r\n        else {\r\n          _this.set(property, value);\r\n        }\r\n        if (skipCallbacks) {\r\n          return;\r\n        }\r\n        options.onChange && options.onChange();\r\n      },\r\n      onComplete: function() {\r\n        if (skipCallbacks) {\r\n          return;\r\n        }\r\n\r\n        _this.setCoords();\r\n        options.onComplete && options.onComplete();\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },\r\n      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');\r\n\r\n  if (fabric.Line) {\r\n    fabric.warn('fabric.Line is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Line class\r\n   * @class fabric.Line\r\n   * @extends fabric.Object\r\n   * @see {@link fabric.Line#initialize} for constructor definition\r\n   */\r\n  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'line',\r\n\r\n    /**\r\n     * x value or first line edge\r\n     * @type Number\r\n     * @default\r\n     */\r\n    x1: 0,\r\n\r\n    /**\r\n     * y value or first line edge\r\n     * @type Number\r\n     * @default\r\n     */\r\n    y1: 0,\r\n\r\n    /**\r\n     * x value or second line edge\r\n     * @type Number\r\n     * @default\r\n     */\r\n    x2: 0,\r\n\r\n    /**\r\n     * y value or second line edge\r\n     * @type Number\r\n     * @default\r\n     */\r\n    y2: 0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Array} [points] Array of points\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Line} thisArg\r\n     */\r\n    initialize: function(points, options) {\r\n      options = options || { };\r\n\r\n      if (!points) {\r\n        points = [0, 0, 0, 0];\r\n      }\r\n\r\n      this.callSuper('initialize', options);\r\n\r\n      this.set('x1', points[0]);\r\n      this.set('y1', points[1]);\r\n      this.set('x2', points[2]);\r\n      this.set('y2', points[3]);\r\n\r\n      this._setWidthHeight(options);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Options\r\n     */\r\n    _setWidthHeight: function(options) {\r\n      options || (options = { });\r\n\r\n      this.width = Math.abs(this.x2 - this.x1);\r\n      this.height = Math.abs(this.y2 - this.y1);\r\n\r\n      this.left = 'left' in options\r\n        ? options.left\r\n        : this._getLeftToOriginX();\r\n\r\n      this.top = 'top' in options\r\n        ? options.top\r\n        : this._getTopToOriginY();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} key\r\n     * @param {Any} value\r\n     */\r\n    _set: function(key, value) {\r\n      this.callSuper('_set', key, value);\r\n      if (typeof coordProps[key] !== 'undefined') {\r\n        this._setWidthHeight();\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.\r\n     */\r\n    _getLeftToOriginX: makeEdgeToOriginGetter(\r\n      { // property names\r\n        origin: 'originX',\r\n        axis1: 'x1',\r\n        axis2: 'x2',\r\n        dimension: 'width'\r\n      },\r\n      { // possible values of origin\r\n        nearest: 'left',\r\n        center: 'center',\r\n        farthest: 'right'\r\n      }\r\n    ),\r\n\r\n    /**\r\n     * @private\r\n     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.\r\n     */\r\n    _getTopToOriginY: makeEdgeToOriginGetter(\r\n      { // property names\r\n        origin: 'originY',\r\n        axis1: 'y1',\r\n        axis2: 'y2',\r\n        dimension: 'height'\r\n      },\r\n      { // possible values of origin\r\n        nearest: 'top',\r\n        center: 'center',\r\n        farthest: 'bottom'\r\n      }\r\n    ),\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx, noTransform) {\r\n      ctx.beginPath();\r\n\r\n      if (noTransform) {\r\n        //  Line coords are distances from left-top of canvas to origin of line.\r\n        //  To render line in a path-group, we need to translate them to\r\n        //  distances from center of path-group to center of line.\r\n        var cp = this.getCenterPoint();\r\n        ctx.translate(\r\n          cp.x - this.strokeWidth / 2,\r\n          cp.y - this.strokeWidth / 2\r\n        );\r\n      }\r\n\r\n      if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {\r\n        // move from center (of virtual box) to its left/top corner\r\n        // we can't assume x1, y1 is top left and x2, y2 is bottom right\r\n        var p = this.calcLinePoints();\r\n        ctx.moveTo(p.x1, p.y1);\r\n        ctx.lineTo(p.x2, p.y2);\r\n      }\r\n\r\n      ctx.lineWidth = this.strokeWidth;\r\n\r\n      // TODO: test this\r\n      // make sure setting \"fill\" changes color of a line\r\n      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)\r\n      var origStrokeStyle = ctx.strokeStyle;\r\n      ctx.strokeStyle = this.stroke || ctx.fillStyle;\r\n      this.stroke && this._renderStroke(ctx);\r\n      ctx.strokeStyle = origStrokeStyle;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderDashedStroke: function(ctx) {\r\n      var p = this.calcLinePoints();\r\n\r\n      ctx.beginPath();\r\n      fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);\r\n      ctx.closePath();\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @methd toObject\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());\r\n    },\r\n\r\n    /**\r\n     * Recalculates line points given width and height\r\n     * @private\r\n     */\r\n    calcLinePoints: function() {\r\n      var xMult = this.x1 <= this.x2 ? -1 : 1,\r\n          yMult = this.y1 <= this.y2 ? -1 : 1,\r\n          x1 = (xMult * this.width * 0.5),\r\n          y1 = (yMult * this.height * 0.5),\r\n          x2 = (xMult * this.width * -0.5),\r\n          y2 = (yMult * this.height * -0.5);\r\n\r\n      return {\r\n        x1: x1,\r\n        x2: x2,\r\n        y1: y1,\r\n        y2: y2\r\n      };\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(),\r\n          p = { x1: this.x1, x2: this.x2, y1: this.y1, y2: this.y2 };\r\n\r\n      if (!(this.group && this.group.type === 'path-group')) {\r\n        p = this.calcLinePoints();\r\n      }\r\n      markup.push(\r\n        '<line ',\r\n          'x1=\"', p.x1,\r\n          '\" y1=\"', p.y1,\r\n          '\" x2=\"', p.x2,\r\n          '\" y2=\"', p.y2,\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(),\r\n          this.getSvgTransformMatrix(),\r\n        '\"/>\\n'\r\n      );\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})\r\n   * @static\r\n   * @memberOf fabric.Line\r\n   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement\r\n   */\r\n  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));\r\n\r\n  /**\r\n   * Returns fabric.Line instance from an SVG element\r\n   * @static\r\n   * @memberOf fabric.Line\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Line} instance of fabric.Line\r\n   */\r\n  fabric.Line.fromElement = function(element, options) {\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),\r\n        points = [\r\n          parsedAttributes.x1 || 0,\r\n          parsedAttributes.y1 || 0,\r\n          parsedAttributes.x2 || 0,\r\n          parsedAttributes.y2 || 0\r\n        ];\r\n    return new fabric.Line(points, extend(parsedAttributes, options));\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns fabric.Line instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Line\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Line} instance of fabric.Line\r\n   */\r\n  fabric.Line.fromObject = function(object) {\r\n    var points = [object.x1, object.y1, object.x2, object.y2];\r\n    return new fabric.Line(points, object);\r\n  };\r\n\r\n  /**\r\n   * Produces a function that calculates distance from canvas edge to Line origin.\r\n   */\r\n  function makeEdgeToOriginGetter(propertyNames, originValues) {\r\n    var origin = propertyNames.origin,\r\n        axis1 = propertyNames.axis1,\r\n        axis2 = propertyNames.axis2,\r\n        dimension = propertyNames.dimension,\r\n        nearest = originValues.nearest,\r\n        center = originValues.center,\r\n        farthest = originValues.farthest;\r\n\r\n    return function() {\r\n      switch (this.get(origin)) {\r\n      case nearest:\r\n        return Math.min(this.get(axis1), this.get(axis2));\r\n      case center:\r\n        return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));\r\n      case farthest:\r\n        return Math.max(this.get(axis1), this.get(axis2));\r\n      }\r\n    };\r\n\r\n  }\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      pi = Math.PI,\r\n      extend = fabric.util.object.extend;\r\n\r\n  if (fabric.Circle) {\r\n    fabric.warn('fabric.Circle is already defined.');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Circle class\r\n   * @class fabric.Circle\r\n   * @extends fabric.Object\r\n   * @see {@link fabric.Circle#initialize} for constructor definition\r\n   */\r\n  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'circle',\r\n\r\n    /**\r\n     * Radius of this circle\r\n     * @type Number\r\n     * @default\r\n     */\r\n    radius: 0,\r\n\r\n    /**\r\n     * Start angle of the circle, moving clockwise\r\n     * @type Number\r\n     * @default 0\r\n     */\r\n    startAngle: 0,\r\n\r\n    /**\r\n     * End angle of the circle\r\n     * @type Number\r\n     * @default 2Pi\r\n     */\r\n    endAngle: pi * 2,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Circle} thisArg\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.callSuper('initialize', options);\r\n      this.set('radius', options.radius || 0);\r\n\r\n      this.startAngle = options.startAngle || this.startAngle;\r\n      this.endAngle = options.endAngle || this.endAngle;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} key\r\n     * @param {Any} value\r\n     * @return {fabric.Circle} thisArg\r\n     */\r\n    _set: function(key, value) {\r\n      this.callSuper('_set', key, value);\r\n\r\n      if (key === 'radius') {\r\n        this.setRadius(value);\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return extend(this.callSuper('toObject', propertiesToInclude), {\r\n        radius: this.get('radius'),\r\n        startAngle: this.startAngle,\r\n        endAngle: this.endAngle\r\n      });\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(), x = 0, y = 0,\r\n      angle = (this.endAngle - this.startAngle) % ( 2 * pi);\r\n\r\n      if (angle === 0) {\r\n        if (this.group && this.group.type === 'path-group') {\r\n          x = this.left + this.radius;\r\n          y = this.top + this.radius;\r\n        }\r\n        markup.push(\r\n          '<circle ',\r\n            'cx=\"' + x + '\" cy=\"' + y + '\" ',\r\n            'r=\"', this.radius,\r\n            '\" style=\"', this.getSvgStyles(),\r\n            '\" transform=\"', this.getSvgTransform(),\r\n            ' ', this.getSvgTransformMatrix(),\r\n          '\"/>\\n'\r\n        );\r\n      }\r\n      else {\r\n        var startX = Math.cos(this.startAngle) * this.radius,\r\n            startY = Math.sin(this.startAngle) * this.radius,\r\n            endX = Math.cos(this.endAngle) * this.radius,\r\n            endY = Math.sin(this.endAngle) * this.radius,\r\n            largeFlag = angle > pi ? '1' : '0';\r\n\r\n        markup.push(\r\n          '<path d=\"M ' + startX + ' ' + startY,\r\n          ' A ' + this.radius + ' ' + this.radius,\r\n          ' 0 ', + largeFlag + ' 1', ' ' + endX + ' ' + endY,\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(),\r\n          ' ', this.getSvgTransformMatrix(),\r\n          '\"/>\\n'\r\n        );\r\n      }\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx context to render on\r\n     * @param {Boolean} [noTransform] When true, context is not transformed\r\n     */\r\n    _render: function(ctx, noTransform) {\r\n      ctx.beginPath();\r\n      ctx.arc(noTransform ? this.left + this.radius : 0,\r\n              noTransform ? this.top + this.radius : 0,\r\n              this.radius,\r\n              this.startAngle,\r\n              this.endAngle, false);\r\n      this._renderFill(ctx);\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * Returns horizontal radius of an object (according to how an object is scaled)\r\n     * @return {Number}\r\n     */\r\n    getRadiusX: function() {\r\n      return this.get('radius') * this.get('scaleX');\r\n    },\r\n\r\n    /**\r\n     * Returns vertical radius of an object (according to how an object is scaled)\r\n     * @return {Number}\r\n     */\r\n    getRadiusY: function() {\r\n      return this.get('radius') * this.get('scaleY');\r\n    },\r\n\r\n    /**\r\n     * Sets radius of an object (and updates width accordingly)\r\n     * @return {fabric.Circle} thisArg\r\n     */\r\n    setRadius: function(value) {\r\n      this.radius = value;\r\n      return this.set('width', value * 2).set('height', value * 2);\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})\r\n   * @static\r\n   * @memberOf fabric.Circle\r\n   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement\r\n   */\r\n  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));\r\n\r\n  /**\r\n   * Returns {@link fabric.Circle} instance from an SVG element\r\n   * @static\r\n   * @memberOf fabric.Circle\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @throws {Error} If value of `r` attribute is missing or invalid\r\n   * @return {fabric.Circle} Instance of fabric.Circle\r\n   */\r\n  fabric.Circle.fromElement = function(element, options) {\r\n    options || (options = { });\r\n\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);\r\n\r\n    if (!isValidRadius(parsedAttributes)) {\r\n      throw new Error('value of `r` attribute is required and can not be negative');\r\n    }\r\n\r\n    parsedAttributes.left = parsedAttributes.left || 0;\r\n    parsedAttributes.top = parsedAttributes.top || 0;\r\n\r\n    var obj = new fabric.Circle(extend(parsedAttributes, options));\r\n\r\n    obj.left -= obj.radius;\r\n    obj.top -= obj.radius;\r\n    return obj;\r\n  };\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  function isValidRadius(attributes) {\r\n    return (('radius' in attributes) && (attributes.radius >= 0));\r\n  }\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns {@link fabric.Circle} instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Circle\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {Object} Instance of fabric.Circle\r\n   */\r\n  fabric.Circle.fromObject = function(object) {\r\n    return new fabric.Circle(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { });\r\n\r\n  if (fabric.Triangle) {\r\n    fabric.warn('fabric.Triangle is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Triangle class\r\n   * @class fabric.Triangle\r\n   * @extends fabric.Object\r\n   * @return {fabric.Triangle} thisArg\r\n   * @see {@link fabric.Triangle#initialize} for constructor definition\r\n   */\r\n  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'triangle',\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} [options] Options object\r\n     * @return {Object} thisArg\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.callSuper('initialize', options);\r\n\r\n      this.set('width', options.width || 100)\r\n          .set('height', options.height || 100);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx) {\r\n      var widthBy2 = this.width / 2,\r\n          heightBy2 = this.height / 2;\r\n\r\n      ctx.beginPath();\r\n      ctx.moveTo(-widthBy2, heightBy2);\r\n      ctx.lineTo(0, -heightBy2);\r\n      ctx.lineTo(widthBy2, heightBy2);\r\n      ctx.closePath();\r\n\r\n      this._renderFill(ctx);\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderDashedStroke: function(ctx) {\r\n      var widthBy2 = this.width / 2,\r\n          heightBy2 = this.height / 2;\r\n\r\n      ctx.beginPath();\r\n      fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);\r\n      ctx.closePath();\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(),\r\n          widthBy2 = this.width / 2,\r\n          heightBy2 = this.height / 2,\r\n          points = [\r\n            -widthBy2 + ' ' + heightBy2,\r\n            '0 ' + -heightBy2,\r\n            widthBy2 + ' ' + heightBy2\r\n          ]\r\n          .join(',');\r\n\r\n      markup.push(\r\n        '<polygon ',\r\n          'points=\"', points,\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(),\r\n        '\"/>'\r\n      );\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns fabric.Triangle instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Triangle\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {Object} instance of Canvas.Triangle\r\n   */\r\n  fabric.Triangle.fromObject = function(object) {\r\n    return new fabric.Triangle(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      piBy2   = Math.PI * 2,\r\n      extend = fabric.util.object.extend;\r\n\r\n  if (fabric.Ellipse) {\r\n    fabric.warn('fabric.Ellipse is already defined.');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Ellipse class\r\n   * @class fabric.Ellipse\r\n   * @extends fabric.Object\r\n   * @return {fabric.Ellipse} thisArg\r\n   * @see {@link fabric.Ellipse#initialize} for constructor definition\r\n   */\r\n  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'ellipse',\r\n\r\n    /**\r\n     * Horizontal radius\r\n     * @type Number\r\n     * @default\r\n     */\r\n    rx:   0,\r\n\r\n    /**\r\n     * Vertical radius\r\n     * @type Number\r\n     * @default\r\n     */\r\n    ry:   0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Ellipse} thisArg\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.callSuper('initialize', options);\r\n\r\n      this.set('rx', options.rx || 0);\r\n      this.set('ry', options.ry || 0);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} key\r\n     * @param {Any} value\r\n     * @return {fabric.Ellipse} thisArg\r\n     */\r\n    _set: function(key, value) {\r\n      this.callSuper('_set', key, value);\r\n      switch (key) {\r\n\r\n        case 'rx':\r\n          this.rx = value;\r\n          this.set('width', value * 2);\r\n          break;\r\n\r\n        case 'ry':\r\n          this.ry = value;\r\n          this.set('height', value * 2);\r\n          break;\r\n\r\n      }\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns horizontal radius of an object (according to how an object is scaled)\r\n     * @return {Number}\r\n     */\r\n    getRx: function() {\r\n      return this.get('rx') * this.get('scaleX');\r\n    },\r\n\r\n    /**\r\n     * Returns Vertical radius of an object (according to how an object is scaled)\r\n     * @return {Number}\r\n     */\r\n    getRy: function() {\r\n      return this.get('ry') * this.get('scaleY');\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return extend(this.callSuper('toObject', propertiesToInclude), {\r\n        rx: this.get('rx'),\r\n        ry: this.get('ry')\r\n      });\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(), x = 0, y = 0;\r\n      if (this.group && this.group.type === 'path-group') {\r\n        x = this.left + this.rx;\r\n        y = this.top + this.ry;\r\n      }\r\n      markup.push(\r\n        '<ellipse ',\r\n          'cx=\"', x, '\" cy=\"', y, '\" ',\r\n          'rx=\"', this.rx,\r\n          '\" ry=\"', this.ry,\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(),\r\n          this.getSvgTransformMatrix(),\r\n        '\"/>\\n'\r\n      );\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx context to render on\r\n     * @param {Boolean} [noTransform] When true, context is not transformed\r\n     */\r\n    _render: function(ctx, noTransform) {\r\n      ctx.beginPath();\r\n      ctx.save();\r\n      ctx.transform(1, 0, 0, this.ry/this.rx, 0, 0);\r\n      ctx.arc(\r\n        noTransform ? this.left + this.rx : 0,\r\n        noTransform ? (this.top + this.ry) * this.rx/this.ry : 0,\r\n        this.rx,\r\n        0,\r\n        piBy2,\r\n        false);\r\n      ctx.restore();\r\n      this._renderFill(ctx);\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})\r\n   * @static\r\n   * @memberOf fabric.Ellipse\r\n   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement\r\n   */\r\n  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));\r\n\r\n  /**\r\n   * Returns {@link fabric.Ellipse} instance from an SVG element\r\n   * @static\r\n   * @memberOf fabric.Ellipse\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Ellipse}\r\n   */\r\n  fabric.Ellipse.fromElement = function(element, options) {\r\n    options || (options = { });\r\n\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);\r\n\r\n    parsedAttributes.left = parsedAttributes.left || 0;\r\n    parsedAttributes.top = parsedAttributes.top || 0;\r\n\r\n    var ellipse = new fabric.Ellipse(extend(parsedAttributes, options));\r\n\r\n    ellipse.top -= ellipse.ry;\r\n    ellipse.left -= ellipse.rx;\r\n    return ellipse;\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns {@link fabric.Ellipse} instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Ellipse\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Ellipse}\r\n   */\r\n  fabric.Ellipse.fromObject = function(object) {\r\n    return new fabric.Ellipse(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  if (fabric.Rect) {\r\n    fabric.warn('fabric.Rect is already defined');\r\n    return;\r\n  }\r\n\r\n  var stateProperties = fabric.Object.prototype.stateProperties.concat();\r\n  stateProperties.push('rx', 'ry', 'x', 'y');\r\n\r\n  /**\r\n   * Rectangle class\r\n   * @class fabric.Rect\r\n   * @extends fabric.Object\r\n   * @return {fabric.Rect} thisArg\r\n   * @see {@link fabric.Rect#initialize} for constructor definition\r\n   */\r\n  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {\r\n\r\n    /**\r\n     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})\r\n     * as well as for history (undo/redo) purposes\r\n     * @type Array\r\n     */\r\n    stateProperties: stateProperties,\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'rect',\r\n\r\n    /**\r\n     * Horizontal border radius\r\n     * @type Number\r\n     * @default\r\n     */\r\n    rx:   0,\r\n\r\n    /**\r\n     * Vertical border radius\r\n     * @type Number\r\n     * @default\r\n     */\r\n    ry:   0,\r\n\r\n    /**\r\n     * Used to specify dash pattern for stroke on this object\r\n     * @type Array\r\n     */\r\n    strokeDashArray: null,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} [options] Options object\r\n     * @return {Object} thisArg\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.callSuper('initialize', options);\r\n      this._initRxRy();\r\n\r\n    },\r\n\r\n    /**\r\n     * Initializes rx/ry attributes\r\n     * @private\r\n     */\r\n    _initRxRy: function() {\r\n      if (this.rx && !this.ry) {\r\n        this.ry = this.rx;\r\n      }\r\n      else if (this.ry && !this.rx) {\r\n        this.rx = this.ry;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx, noTransform) {\r\n\r\n      // optimize 1x1 case (used in spray brush)\r\n      if (this.width === 1 && this.height === 1) {\r\n        ctx.fillRect(0, 0, 1, 1);\r\n        return;\r\n      }\r\n\r\n      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,\r\n          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,\r\n          w = this.width,\r\n          h = this.height,\r\n          x = noTransform ? this.left : -this.width / 2,\r\n          y = noTransform ? this.top : -this.height / 2,\r\n          isRounded = rx !== 0 || ry !== 0,\r\n          k = 1 - 0.5522847498 /* \"magic number\" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */;\r\n\r\n      ctx.beginPath();\r\n\r\n      ctx.moveTo(x + rx, y);\r\n\r\n      ctx.lineTo(x + w - rx, y);\r\n      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);\r\n\r\n      ctx.lineTo(x + w, y + h - ry);\r\n      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);\r\n\r\n      ctx.lineTo(x + rx, y + h);\r\n      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);\r\n\r\n      ctx.lineTo(x, y + ry);\r\n      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);\r\n\r\n      ctx.closePath();\r\n\r\n      this._renderFill(ctx);\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderDashedStroke: function(ctx) {\r\n      var x = -this.width / 2,\r\n          y = -this.height / 2,\r\n          w = this.width,\r\n          h = this.height;\r\n\r\n      ctx.beginPath();\r\n      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);\r\n      ctx.closePath();\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var object = extend(this.callSuper('toObject', propertiesToInclude), {\r\n        rx: this.get('rx') || 0,\r\n        ry: this.get('ry') || 0\r\n      });\r\n      if (!this.includeDefaultValues) {\r\n        this._removeDefaultValues(object);\r\n      }\r\n      return object;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(), x = this.left, y = this.top;\r\n      if (!(this.group && this.group.type === 'path-group')) {\r\n        x = -this.width / 2;\r\n        y = -this.height / 2;\r\n      }\r\n      markup.push(\r\n        '<rect ',\r\n          'x=\"', x, '\" y=\"', y,\r\n          '\" rx=\"', this.get('rx'), '\" ry=\"', this.get('ry'),\r\n          '\" width=\"', this.width, '\" height=\"', this.height,\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(),\r\n          this.getSvgTransformMatrix(),\r\n        '\"/>\\n');\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)\r\n   * @static\r\n   * @memberOf fabric.Rect\r\n   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement\r\n   */\r\n  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));\r\n\r\n  /**\r\n   * Returns {@link fabric.Rect} instance from an SVG element\r\n   * @static\r\n   * @memberOf fabric.Rect\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Rect} Instance of fabric.Rect\r\n   */\r\n  fabric.Rect.fromElement = function(element, options) {\r\n    if (!element) {\r\n      return null;\r\n    }\r\n    options = options || { };\r\n\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);\r\n\r\n    parsedAttributes.left = parsedAttributes.left || 0;\r\n    parsedAttributes.top  = parsedAttributes.top  || 0;\r\n    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));\r\n    rect.visible = rect.width > 0 && rect.height > 0;\r\n    return rect;\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns {@link fabric.Rect} instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Rect\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {Object} instance of fabric.Rect\r\n   */\r\n  fabric.Rect.fromObject = function(object) {\r\n    return new fabric.Rect(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { });\r\n\r\n  if (fabric.Polyline) {\r\n    fabric.warn('fabric.Polyline is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Polyline class\r\n   * @class fabric.Polyline\r\n   * @extends fabric.Object\r\n   * @see {@link fabric.Polyline#initialize} for constructor definition\r\n   */\r\n  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'polyline',\r\n\r\n    /**\r\n     * Points array\r\n     * @type Array\r\n     * @default\r\n     */\r\n    points: null,\r\n\r\n    /**\r\n     * Minimum X from points values, necessary to offset points\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minX: 0,\r\n\r\n    /**\r\n     * Minimum Y from points values, necessary to offset points\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minY: 0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Array} points Array of points (where each point is an object with x and y)\r\n     * @param {Object} [options] Options object\r\n     * @param {Boolean} [skipOffset] Whether points offsetting should be skipped\r\n     * @return {fabric.Polyline} thisArg\r\n     * @example\r\n     * var poly = new fabric.Polyline([\r\n     *     { x: 10, y: 10 },\r\n     *     { x: 50, y: 30 },\r\n     *     { x: 40, y: 70 },\r\n     *     { x: 60, y: 50 },\r\n     *     { x: 100, y: 150 },\r\n     *     { x: 40, y: 100 }\r\n     *   ], {\r\n     *   stroke: 'red',\r\n     *   left: 100,\r\n     *   top: 100\r\n     * });\r\n     */\r\n    initialize: function(points, options) {\r\n      return fabric.Polygon.prototype.initialize.call(this, points, options);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _calcDimensions: function() {\r\n      return fabric.Polygon.prototype._calcDimensions.call(this);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _applyPointOffset: function() {\r\n      return fabric.Polygon.prototype._applyPointOffset.call(this);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return fabric.Polygon.prototype.toObject.call(this, propertiesToInclude);\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      return fabric.Polygon.prototype.toSVG.call(this, reviver);\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx) {\r\n      if (!fabric.Polygon.prototype.commonRender.call(this, ctx)) {\r\n        return;\r\n      }\r\n      this._renderFill(ctx);\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderDashedStroke: function(ctx) {\r\n      var p1, p2;\r\n\r\n      ctx.beginPath();\r\n      for (var i = 0, len = this.points.length; i < len; i++) {\r\n        p1 = this.points[i];\r\n        p2 = this.points[i + 1] || p1;\r\n        fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return this.get('points').length;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})\r\n   * @static\r\n   * @memberOf fabric.Polyline\r\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement\r\n   */\r\n  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\r\n\r\n  /**\r\n   * Returns fabric.Polyline instance from an SVG element\r\n   * @static\r\n   * @memberOf fabric.Polyline\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Polyline} Instance of fabric.Polyline\r\n   */\r\n  fabric.Polyline.fromElement = function(element, options) {\r\n    if (!element) {\r\n      return null;\r\n    }\r\n    options || (options = { });\r\n\r\n    var points = fabric.parsePointsAttribute(element.getAttribute('points')),\r\n        parsedAttributes = fabric.parseAttributes(element, fabric.Polyline.ATTRIBUTE_NAMES);\r\n\r\n    return new fabric.Polyline(points, fabric.util.object.extend(parsedAttributes, options));\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns fabric.Polyline instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Polyline\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Polyline} Instance of fabric.Polyline\r\n   */\r\n  fabric.Polyline.fromObject = function(object) {\r\n    var points = object.points;\r\n    return new fabric.Polyline(points, object, true);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      min = fabric.util.array.min,\r\n      max = fabric.util.array.max,\r\n      toFixed = fabric.util.toFixed;\r\n\r\n  if (fabric.Polygon) {\r\n    fabric.warn('fabric.Polygon is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Polygon class\r\n   * @class fabric.Polygon\r\n   * @extends fabric.Object\r\n   * @see {@link fabric.Polygon#initialize} for constructor definition\r\n   */\r\n  fabric.Polygon = fabric.util.createClass(fabric.Object, /** @lends fabric.Polygon.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'polygon',\r\n\r\n    /**\r\n     * Points array\r\n     * @type Array\r\n     * @default\r\n     */\r\n    points: null,\r\n\r\n    /**\r\n     * Minimum X from points values, necessary to offset points\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minX: 0,\r\n\r\n    /**\r\n     * Minimum Y from points values, necessary to offset points\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minY: 0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Array} points Array of points\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Polygon} thisArg\r\n     */\r\n    initialize: function(points, options) {\r\n      options = options || { };\r\n      this.points = points || [ ];\r\n      this.callSuper('initialize', options);\r\n      this._calcDimensions();\r\n      if (!('top' in options)) {\r\n        this.top = this.minY;\r\n      }\r\n      if (!('left' in options)) {\r\n        this.left = this.minX;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _calcDimensions: function() {\r\n\r\n      var points = this.points,\r\n          minX = min(points, 'x'),\r\n          minY = min(points, 'y'),\r\n          maxX = max(points, 'x'),\r\n          maxY = max(points, 'y');\r\n\r\n      this.width = (maxX - minX) || 0;\r\n      this.height = (maxY - minY) || 0;\r\n\r\n      this.minX = minX || 0,\r\n      this.minY = minY || 0;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _applyPointOffset: function() {\r\n      // change points to offset polygon into a bounding box\r\n      // executed one time\r\n      this.points.forEach(function(p) {\r\n        p.x -= (this.minX + this.width / 2);\r\n        p.y -= (this.minY + this.height / 2);\r\n      }, this);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return extend(this.callSuper('toObject', propertiesToInclude), {\r\n        points: this.points.concat()\r\n      });\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var points = [],\r\n          markup = this._createBaseSVGMarkup();\r\n\r\n      for (var i = 0, len = this.points.length; i < len; i++) {\r\n        points.push(toFixed(this.points[i].x, 2), ',', toFixed(this.points[i].y, 2), ' ');\r\n      }\r\n\r\n      markup.push(\r\n        '<', this.type, ' ',\r\n          'points=\"', points.join(''),\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(),\r\n          ' ', this.getSvgTransformMatrix(),\r\n        '\"/>\\n'\r\n      );\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx) {\r\n      if (!this.commonRender(ctx)) {\r\n        return;\r\n      }\r\n      this._renderFill(ctx);\r\n      if (this.stroke || this.strokeDashArray) {\r\n        ctx.closePath();\r\n        this._renderStroke(ctx);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    commonRender: function(ctx) {\r\n      var point, len = this.points.length;\r\n\r\n      if (!len || isNaN(this.points[len - 1].y)) {\r\n        // do not draw if no points or odd points\r\n        // NaN comes from parseFloat of a empty string in parser\r\n        return false;\r\n      }\r\n\r\n      ctx.beginPath();\r\n\r\n      if (this._applyPointOffset) {\r\n        if (!(this.group && this.group.type === 'path-group')) {\r\n          this._applyPointOffset();\r\n        }\r\n        this._applyPointOffset = null;\r\n      }\r\n\r\n      ctx.moveTo(this.points[0].x, this.points[0].y);\r\n      for (var i = 0; i < len; i++) {\r\n        point = this.points[i];\r\n        ctx.lineTo(point.x, point.y);\r\n      }\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderDashedStroke: function(ctx) {\r\n      fabric.Polyline.prototype._renderDashedStroke.call(this, ctx);\r\n      ctx.closePath();\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return this.points.length;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)\r\n   * @static\r\n   * @memberOf fabric.Polygon\r\n   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement\r\n   */\r\n  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();\r\n\r\n  /**\r\n   * Returns {@link fabric.Polygon} instance from an SVG element\r\n   * @static\r\n   * @memberOf fabric.Polygon\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Polygon} Instance of fabric.Polygon\r\n   */\r\n  fabric.Polygon.fromElement = function(element, options) {\r\n    if (!element) {\r\n      return null;\r\n    }\r\n\r\n    options || (options = { });\r\n\r\n    var points = fabric.parsePointsAttribute(element.getAttribute('points')),\r\n        parsedAttributes = fabric.parseAttributes(element, fabric.Polygon.ATTRIBUTE_NAMES);\r\n\r\n    return new fabric.Polygon(points, extend(parsedAttributes, options));\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns fabric.Polygon instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Polygon\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Polygon} Instance of fabric.Polygon\r\n   */\r\n  fabric.Polygon.fromObject = function(object) {\r\n    return new fabric.Polygon(object.points, object, true);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      min = fabric.util.array.min,\r\n      max = fabric.util.array.max,\r\n      extend = fabric.util.object.extend,\r\n      _toString = Object.prototype.toString,\r\n      drawArc = fabric.util.drawArc,\r\n      commandLengths = {\r\n        m: 2,\r\n        l: 2,\r\n        h: 1,\r\n        v: 1,\r\n        c: 6,\r\n        s: 4,\r\n        q: 4,\r\n        t: 2,\r\n        a: 7\r\n      },\r\n      repeatedCommands = {\r\n        m: 'l',\r\n        M: 'L'\r\n      };\r\n\r\n  if (fabric.Path) {\r\n    fabric.warn('fabric.Path is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Path class\r\n   * @class fabric.Path\r\n   * @extends fabric.Object\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#path_and_pathgroup}\r\n   * @see {@link fabric.Path#initialize} for constructor definition\r\n   */\r\n  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'path',\r\n\r\n    /**\r\n     * Array of path points\r\n     * @type Array\r\n     * @default\r\n     */\r\n    path: null,\r\n\r\n    /**\r\n     * Minimum X from points values, necessary to offset points\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minX: 0,\r\n\r\n    /**\r\n     * Minimum Y from points values, necessary to offset points\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minY: 0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Array|String} path Path data (sequence of coordinates and corresponding \"command\" tokens)\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Path} thisArg\r\n     */\r\n    initialize: function(path, options) {\r\n      options = options || { };\r\n\r\n      this.setOptions(options);\r\n\r\n      if (!path) {\r\n        path = [ ];\r\n      }\r\n\r\n      var fromArray = _toString.call(path) === '[object Array]';\r\n\r\n      this.path = fromArray\r\n        ? path\r\n        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)\r\n        : path.match && path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);\r\n\r\n      if (!this.path) {\r\n        return;\r\n      }\r\n\r\n      if (!fromArray) {\r\n        this.path = this._parsePath();\r\n      }\r\n\r\n      this._setPositionDimensions(options);\r\n\r\n      if (options.sourcePath) {\r\n        this.setSourcePath(options.sourcePath);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} options Options object\r\n     */\r\n    _setPositionDimensions: function(options) {\r\n      var calcDim = this._parseDimensions();\r\n\r\n      this.minX = calcDim.left;\r\n      this.minY = calcDim.top;\r\n      this.width = calcDim.width;\r\n      this.height = calcDim.height;\r\n\r\n      if (typeof options.left === 'undefined') {\r\n        this.left = calcDim.left + (this.originX === 'center'\r\n          ? this.width / 2\r\n          : this.originX === 'right'\r\n            ? this.width\r\n            : 0);\r\n      }\r\n\r\n      if (typeof options.top === 'undefined') {\r\n        this.top = calcDim.top + (this.originY === 'center'\r\n          ? this.height / 2\r\n          : this.originY === 'bottom'\r\n            ? this.height\r\n            : 0);\r\n      }\r\n\r\n      this.pathOffset = this.pathOffset || {\r\n        x: this.minX + this.width / 2,\r\n        y: this.minY + this.height / 2\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx context to render path on\r\n     */\r\n    _render: function(ctx) {\r\n      var current, // current instruction\r\n          previous = null,\r\n          subpathStartX = 0,\r\n          subpathStartY = 0,\r\n          x = 0, // current x\r\n          y = 0, // current y\r\n          controlX = 0, // current control point x\r\n          controlY = 0, // current control point y\r\n          tempX,\r\n          tempY,\r\n          l = -this.pathOffset.x,\r\n          t = -this.pathOffset.y;\r\n\r\n      if (this.group && this.group.type === 'path-group') {\r\n        l = 0;\r\n        t = 0;\r\n      }\r\n\r\n      ctx.beginPath();\r\n\r\n      for (var i = 0, len = this.path.length; i < len; ++i) {\r\n\r\n        current = this.path[i];\r\n\r\n        switch (current[0]) { // first letter\r\n\r\n          case 'l': // lineto, relative\r\n            x += current[1];\r\n            y += current[2];\r\n            ctx.lineTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'L': // lineto, absolute\r\n            x = current[1];\r\n            y = current[2];\r\n            ctx.lineTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'h': // horizontal lineto, relative\r\n            x += current[1];\r\n            ctx.lineTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'H': // horizontal lineto, absolute\r\n            x = current[1];\r\n            ctx.lineTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'v': // vertical lineto, relative\r\n            y += current[1];\r\n            ctx.lineTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'V': // verical lineto, absolute\r\n            y = current[1];\r\n            ctx.lineTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'm': // moveTo, relative\r\n            x += current[1];\r\n            y += current[2];\r\n            subpathStartX = x;\r\n            subpathStartY = y;\r\n            ctx.moveTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'M': // moveTo, absolute\r\n            x = current[1];\r\n            y = current[2];\r\n            subpathStartX = x;\r\n            subpathStartY = y;\r\n            ctx.moveTo(x + l, y + t);\r\n            break;\r\n\r\n          case 'c': // bezierCurveTo, relative\r\n            tempX = x + current[5];\r\n            tempY = y + current[6];\r\n            controlX = x + current[3];\r\n            controlY = y + current[4];\r\n            ctx.bezierCurveTo(\r\n              x + current[1] + l, // x1\r\n              y + current[2] + t, // y1\r\n              controlX + l, // x2\r\n              controlY + t, // y2\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'C': // bezierCurveTo, absolute\r\n            x = current[5];\r\n            y = current[6];\r\n            controlX = current[3];\r\n            controlY = current[4];\r\n            ctx.bezierCurveTo(\r\n              current[1] + l,\r\n              current[2] + t,\r\n              controlX + l,\r\n              controlY + t,\r\n              x + l,\r\n              y + t\r\n            );\r\n            break;\r\n\r\n          case 's': // shorthand cubic bezierCurveTo, relative\r\n\r\n            // transform to absolute x,y\r\n            tempX = x + current[3];\r\n            tempY = y + current[4];\r\n\r\n            if (previous[0].match(/[CcSs]/) === null) {\r\n              // If there is no previous command or if the previous command was not a C, c, S, or s,\r\n              // the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control points\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n\r\n            ctx.bezierCurveTo(\r\n              controlX + l,\r\n              controlY + t,\r\n              x + current[1] + l,\r\n              y + current[2] + t,\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            // set control point to 2nd one of this command\r\n            // \"... the first control point is assumed to be\r\n            // the reflection of the second control point on\r\n            // the previous command relative to the current point.\"\r\n            controlX = x + current[1];\r\n            controlY = y + current[2];\r\n\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'S': // shorthand cubic bezierCurveTo, absolute\r\n            tempX = current[3];\r\n            tempY = current[4];\r\n            if (previous[0].match(/[CcSs]/) === null) {\r\n              // If there is no previous command or if the previous command was not a C, c, S, or s,\r\n              // the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control points\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n            ctx.bezierCurveTo(\r\n              controlX + l,\r\n              controlY + t,\r\n              current[1] + l,\r\n              current[2] + t,\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n\r\n            // set control point to 2nd one of this command\r\n            // \"... the first control point is assumed to be\r\n            // the reflection of the second control point on\r\n            // the previous command relative to the current point.\"\r\n            controlX = current[1];\r\n            controlY = current[2];\r\n\r\n            break;\r\n\r\n          case 'q': // quadraticCurveTo, relative\r\n            // transform to absolute x,y\r\n            tempX = x + current[3];\r\n            tempY = y + current[4];\r\n\r\n            controlX = x + current[1];\r\n            controlY = y + current[2];\r\n\r\n            ctx.quadraticCurveTo(\r\n              controlX + l,\r\n              controlY + t,\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'Q': // quadraticCurveTo, absolute\r\n            tempX = current[3];\r\n            tempY = current[4];\r\n\r\n            ctx.quadraticCurveTo(\r\n              current[1] + l,\r\n              current[2] + t,\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            controlX = current[1];\r\n            controlY = current[2];\r\n            break;\r\n\r\n          case 't': // shorthand quadraticCurveTo, relative\r\n\r\n            // transform to absolute x,y\r\n            tempX = x + current[1];\r\n            tempY = y + current[2];\r\n\r\n            if (previous[0].match(/[QqTt]/) === null) {\r\n              // If there is no previous command or if the previous command was not a Q, q, T or t,\r\n              // assume the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control point\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n\r\n            ctx.quadraticCurveTo(\r\n              controlX + l,\r\n              controlY + t,\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n\r\n            break;\r\n\r\n          case 'T':\r\n            tempX = current[1];\r\n            tempY = current[2];\r\n\r\n            if (previous[0].match(/[QqTt]/) === null) {\r\n              // If there is no previous command or if the previous command was not a Q, q, T or t,\r\n              // assume the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control point\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n            ctx.quadraticCurveTo(\r\n              controlX + l,\r\n              controlY + t,\r\n              tempX + l,\r\n              tempY + t\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'a':\r\n            // TODO: optimize this\r\n            drawArc(ctx, x + l, y + t, [\r\n              current[1],\r\n              current[2],\r\n              current[3],\r\n              current[4],\r\n              current[5],\r\n              current[6] + x + l,\r\n              current[7] + y + t\r\n            ]);\r\n            x += current[6];\r\n            y += current[7];\r\n            break;\r\n\r\n          case 'A':\r\n            // TODO: optimize this\r\n            drawArc(ctx, x + l, y + t, [\r\n              current[1],\r\n              current[2],\r\n              current[3],\r\n              current[4],\r\n              current[5],\r\n              current[6] + l,\r\n              current[7] + t\r\n            ]);\r\n            x = current[6];\r\n            y = current[7];\r\n            break;\r\n\r\n          case 'z':\r\n          case 'Z':\r\n            x = subpathStartX;\r\n            y = subpathStartY;\r\n            ctx.closePath();\r\n            break;\r\n        }\r\n        previous = current;\r\n      }\r\n      this._renderFill(ctx);\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * Returns string representation of an instance\r\n     * @return {String} string representation of an instance\r\n     */\r\n    toString: function() {\r\n      return '#<fabric.Path (' + this.complexity() +\r\n        '): { \"top\": ' + this.top + ', \"left\": ' + this.left + ' }>';\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var o = extend(this.callSuper('toObject', propertiesToInclude), {\r\n        path: this.path.map(function(item) { return item.slice() }),\r\n        pathOffset: this.pathOffset\r\n      });\r\n      if (this.sourcePath) {\r\n        o.sourcePath = this.sourcePath;\r\n      }\r\n      if (this.transformMatrix) {\r\n        o.transformMatrix = this.transformMatrix;\r\n      }\r\n      return o;\r\n    },\r\n\r\n    /**\r\n     * Returns dataless object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toDatalessObject: function(propertiesToInclude) {\r\n      var o = this.toObject(propertiesToInclude);\r\n      if (this.sourcePath) {\r\n        o.path = this.sourcePath;\r\n      }\r\n      delete o.sourcePath;\r\n      return o;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var chunks = [],\r\n          markup = this._createBaseSVGMarkup(), addTransform = '';\r\n\r\n      for (var i = 0, len = this.path.length; i < len; i++) {\r\n        chunks.push(this.path[i].join(' '));\r\n      }\r\n      var path = chunks.join(' ');\r\n      if (!(this.group && this.group.type === 'path-group')) {\r\n        addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';\r\n      }\r\n      markup.push(\r\n        //jscs:disable validateIndentation\r\n        '<path ',\r\n          'd=\"', path,\r\n          '\" style=\"', this.getSvgStyles(),\r\n          '\" transform=\"', this.getSvgTransform(), addTransform,\r\n          this.getSvgTransformMatrix(), '\" stroke-linecap=\"round\" ',\r\n        '/>\\n'\r\n        //jscs:enable validateIndentation\r\n      );\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns number representation of an instance complexity\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return this.path.length;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _parsePath: function() {\r\n      var result = [ ],\r\n          coords = [ ],\r\n          currentPath,\r\n          parsed,\r\n          re = /([-+]?((\\d+\\.\\d+)|((\\d+)|(\\.\\d+)))(?:e[-+]?\\d+)?)/ig,\r\n          match,\r\n          coordsStr;\r\n\r\n      for (var i = 0, coordsParsed, len = this.path.length; i < len; i++) {\r\n        currentPath = this.path[i];\r\n\r\n        coordsStr = currentPath.slice(1).trim();\r\n        coords.length = 0;\r\n\r\n        while ((match = re.exec(coordsStr))) {\r\n          coords.push(match[0]);\r\n        }\r\n\r\n        coordsParsed = [ currentPath.charAt(0) ];\r\n\r\n        for (var j = 0, jlen = coords.length; j < jlen; j++) {\r\n          parsed = parseFloat(coords[j]);\r\n          if (!isNaN(parsed)) {\r\n            coordsParsed.push(parsed);\r\n          }\r\n        }\r\n\r\n        var command = coordsParsed[0],\r\n            commandLength = commandLengths[command.toLowerCase()],\r\n            repeatedCommand = repeatedCommands[command] || command;\r\n\r\n        if (coordsParsed.length - 1 > commandLength) {\r\n          for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {\r\n            result.push([ command ].concat(coordsParsed.slice(k, k + commandLength)));\r\n            command = repeatedCommand;\r\n          }\r\n        }\r\n        else {\r\n          result.push(coordsParsed);\r\n        }\r\n      }\r\n\r\n      return result;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _parseDimensions: function() {\r\n\r\n      var aX = [],\r\n          aY = [],\r\n          current, // current instruction\r\n          previous = null,\r\n          subpathStartX = 0,\r\n          subpathStartY = 0,\r\n          x = 0, // current x\r\n          y = 0, // current y\r\n          controlX = 0, // current control point x\r\n          controlY = 0, // current control point y\r\n          tempX,\r\n          tempY,\r\n          bounds;\r\n\r\n      for (var i = 0, len = this.path.length; i < len; ++i) {\r\n\r\n        current = this.path[i];\r\n\r\n        switch (current[0]) { // first letter\r\n\r\n          case 'l': // lineto, relative\r\n            x += current[1];\r\n            y += current[2];\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'L': // lineto, absolute\r\n            x = current[1];\r\n            y = current[2];\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'h': // horizontal lineto, relative\r\n            x += current[1];\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'H': // horizontal lineto, absolute\r\n            x = current[1];\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'v': // vertical lineto, relative\r\n            y += current[1];\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'V': // verical lineto, absolute\r\n            y = current[1];\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'm': // moveTo, relative\r\n            x += current[1];\r\n            y += current[2];\r\n            subpathStartX = x;\r\n            subpathStartY = y;\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'M': // moveTo, absolute\r\n            x = current[1];\r\n            y = current[2];\r\n            subpathStartX = x;\r\n            subpathStartY = y;\r\n            bounds = [ ];\r\n            break;\r\n\r\n          case 'c': // bezierCurveTo, relative\r\n            tempX = x + current[5];\r\n            tempY = y + current[6];\r\n            controlX = x + current[3];\r\n            controlY = y + current[4];\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              x + current[1], // x1\r\n              y + current[2], // y1\r\n              controlX, // x2\r\n              controlY, // y2\r\n              tempX,\r\n              tempY\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'C': // bezierCurveTo, absolute\r\n            x = current[5];\r\n            y = current[6];\r\n            controlX = current[3];\r\n            controlY = current[4];\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              current[1],\r\n              current[2],\r\n              controlX,\r\n              controlY,\r\n              x,\r\n              y\r\n            );\r\n            break;\r\n\r\n          case 's': // shorthand cubic bezierCurveTo, relative\r\n\r\n            // transform to absolute x,y\r\n            tempX = x + current[3];\r\n            tempY = y + current[4];\r\n\r\n            if (previous[0].match(/[CcSs]/) === null) {\r\n              // If there is no previous command or if the previous command was not a C, c, S, or s,\r\n              // the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control points\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              controlX,\r\n              controlY,\r\n              x + current[1],\r\n              y + current[2],\r\n              tempX,\r\n              tempY\r\n            );\r\n            // set control point to 2nd one of this command\r\n            // \"... the first control point is assumed to be\r\n            // the reflection of the second control point on\r\n            // the previous command relative to the current point.\"\r\n            controlX = x + current[1];\r\n            controlY = y + current[2];\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'S': // shorthand cubic bezierCurveTo, absolute\r\n            tempX = current[3];\r\n            tempY = current[4];\r\n            if (previous[0].match(/[CcSs]/) === null) {\r\n              // If there is no previous command or if the previous command was not a C, c, S, or s,\r\n              // the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control points\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              controlX,\r\n              controlY,\r\n              current[1],\r\n              current[2],\r\n              tempX,\r\n              tempY\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            // set control point to 2nd one of this command\r\n            // \"... the first control point is assumed to be\r\n            // the reflection of the second control point on\r\n            // the previous command relative to the current point.\"\r\n            controlX = current[1];\r\n            controlY = current[2];\r\n            break;\r\n\r\n          case 'q': // quadraticCurveTo, relative\r\n            // transform to absolute x,y\r\n            tempX = x + current[3];\r\n            tempY = y + current[4];\r\n            controlX = x + current[1];\r\n            controlY = y + current[2];\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              controlX,\r\n              controlY,\r\n              controlX,\r\n              controlY,\r\n              tempX,\r\n              tempY\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'Q': // quadraticCurveTo, absolute\r\n            controlX = current[1];\r\n            controlY = current[2];\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              controlX,\r\n              controlY,\r\n              controlX,\r\n              controlY,\r\n              current[3],\r\n              current[4]\r\n            );\r\n            x = current[3];\r\n            y = current[4];\r\n            break;\r\n\r\n          case 't': // shorthand quadraticCurveTo, relative\r\n            // transform to absolute x,y\r\n            tempX = x + current[1];\r\n            tempY = y + current[2];\r\n            if (previous[0].match(/[QqTt]/) === null) {\r\n              // If there is no previous command or if the previous command was not a Q, q, T or t,\r\n              // assume the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control point\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              controlX,\r\n              controlY,\r\n              controlX,\r\n              controlY,\r\n              tempX,\r\n              tempY\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n\r\n            break;\r\n\r\n          case 'T':\r\n            tempX = current[1];\r\n            tempY = current[2];\r\n\r\n            if (previous[0].match(/[QqTt]/) === null) {\r\n              // If there is no previous command or if the previous command was not a Q, q, T or t,\r\n              // assume the control point is coincident with the current point\r\n              controlX = x;\r\n              controlY = y;\r\n            }\r\n            else {\r\n              // calculate reflection of previous control point\r\n              controlX = 2 * x - controlX;\r\n              controlY = 2 * y - controlY;\r\n            }\r\n            bounds = fabric.util.getBoundsOfCurve(x, y,\r\n              controlX,\r\n              controlY,\r\n              controlX,\r\n              controlY,\r\n              tempX,\r\n              tempY\r\n            );\r\n            x = tempX;\r\n            y = tempY;\r\n            break;\r\n\r\n          case 'a':\r\n            // TODO: optimize this\r\n            bounds = fabric.util.getBoundsOfArc(x, y,\r\n              current[1],\r\n              current[2],\r\n              current[3],\r\n              current[4],\r\n              current[5],\r\n              current[6] + x,\r\n              current[7] + y\r\n            );\r\n            x += current[6];\r\n            y += current[7];\r\n            break;\r\n\r\n          case 'A':\r\n            // TODO: optimize this\r\n            bounds = fabric.util.getBoundsOfArc(x, y,\r\n              current[1],\r\n              current[2],\r\n              current[3],\r\n              current[4],\r\n              current[5],\r\n              current[6],\r\n              current[7]\r\n            );\r\n            x = current[6];\r\n            y = current[7];\r\n            break;\r\n\r\n          case 'z':\r\n          case 'Z':\r\n            x = subpathStartX;\r\n            y = subpathStartY;\r\n            break;\r\n        }\r\n        previous = current;\r\n        bounds.forEach(function (point) {\r\n          aX.push(point.x);\r\n          aY.push(point.y);\r\n        });\r\n        aX.push(x);\r\n        aY.push(y);\r\n      }\r\n\r\n      var minX = min(aX) || 0,\r\n          minY = min(aY) || 0,\r\n          maxX = max(aX) || 0,\r\n          maxY = max(aY) || 0,\r\n          deltaX = maxX - minX,\r\n          deltaY = maxY - minY,\r\n\r\n          o = {\r\n            left: minX,\r\n            top: minY,\r\n            width: deltaX,\r\n            height: deltaY\r\n          };\r\n\r\n      return o;\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Creates an instance of fabric.Path from an object\r\n   * @static\r\n   * @memberOf fabric.Path\r\n   * @param {Object} object\r\n   * @param {Function} callback Callback to invoke when an fabric.Path instance is created\r\n   */\r\n  fabric.Path.fromObject = function(object, callback) {\r\n    if (typeof object.path === 'string') {\r\n      fabric.loadSVGFromURL(object.path, function (elements) {\r\n        var path = elements[0],\r\n            pathUrl = object.path;\r\n\r\n        delete object.path;\r\n\r\n        fabric.util.object.extend(path, object);\r\n        path.setSourcePath(pathUrl);\r\n\r\n        callback(path);\r\n      });\r\n    }\r\n    else {\r\n      callback(new fabric.Path(object.path, object));\r\n    }\r\n  };\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)\r\n   * @static\r\n   * @memberOf fabric.Path\r\n   * @see http://www.w3.org/TR/SVG/paths.html#PathElement\r\n   */\r\n  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);\r\n\r\n  /**\r\n   * Creates an instance of fabric.Path from an SVG <path> element\r\n   * @static\r\n   * @memberOf fabric.Path\r\n   * @param {SVGElement} element to parse\r\n   * @param {Function} callback Callback to invoke when an fabric.Path instance is created\r\n   * @param {Object} [options] Options object\r\n   */\r\n  fabric.Path.fromElement = function(element, callback, options) {\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);\r\n    callback && callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Indicates that instances of this type are async\r\n   * @static\r\n   * @memberOf fabric.Path\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  fabric.Path.async = true;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      invoke = fabric.util.array.invoke,\r\n      parentToObject = fabric.Object.prototype.toObject;\r\n\r\n  if (fabric.PathGroup) {\r\n    fabric.warn('fabric.PathGroup is already defined');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Path group class\r\n   * @class fabric.PathGroup\r\n   * @extends fabric.Path\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#path_and_pathgroup}\r\n   * @see {@link fabric.PathGroup#initialize} for constructor definition\r\n   */\r\n  fabric.PathGroup = fabric.util.createClass(fabric.Path, /** @lends fabric.PathGroup.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'path-group',\r\n\r\n    /**\r\n     * Fill value\r\n     * @type String\r\n     * @default\r\n     */\r\n    fill: '',\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Array} paths\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.PathGroup} thisArg\r\n     */\r\n    initialize: function(paths, options) {\r\n\r\n      options = options || { };\r\n      this.paths = paths || [ ];\r\n\r\n      for (var i = this.paths.length; i--;) {\r\n        this.paths[i].group = this;\r\n      }\r\n\r\n      if (options.toBeParsed) {\r\n        this.parseDimensionsFromPaths(options);\r\n        delete options.toBeParsed;\r\n      }\r\n      this.setOptions(options);\r\n      this.setCoords();\r\n\r\n      if (options.sourcePath) {\r\n        this.setSourcePath(options.sourcePath);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Calculate width and height based on paths contained\r\n     */\r\n    parseDimensionsFromPaths: function(options) {\r\n      var points, p, xC = [ ], yC = [ ], path, height, width,\r\n          m;\r\n      for (var j = this.paths.length; j--;) {\r\n        path = this.paths[j];\r\n        height = path.height + path.strokeWidth;\r\n        width = path.width + path.strokeWidth;\r\n        points = [\r\n          { x: path.left, y: path.top },\r\n          { x: path.left + width, y: path.top },\r\n          { x: path.left, y: path.top + height },\r\n          { x: path.left + width, y: path.top + height }\r\n        ];\r\n        m = this.paths[j].transformMatrix;\r\n        for (var i = 0; i < points.length; i++) {\r\n          p = points[i];\r\n          if (m) {\r\n            p = fabric.util.transformPoint(p, m, false);\r\n          }\r\n          xC.push(p.x);\r\n          yC.push(p.y);\r\n        }\r\n      }\r\n      options.width = Math.max.apply(null, xC);\r\n      options.height = Math.max.apply(null, yC);\r\n    },\r\n\r\n    /**\r\n     * Renders this group on a specified context\r\n     * @param {CanvasRenderingContext2D} ctx Context to render this instance on\r\n     */\r\n    render: function(ctx) {\r\n      // do not render if object is not visible\r\n      if (!this.visible) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n\r\n      if (this.transformMatrix) {\r\n        ctx.transform.apply(ctx, this.transformMatrix);\r\n      }\r\n      this.transform(ctx);\r\n\r\n      this._setShadow(ctx);\r\n      this.clipTo && fabric.util.clipContext(this, ctx);\r\n      ctx.translate(-this.width/2, -this.height/2);\r\n      for (var i = 0, l = this.paths.length; i < l; ++i) {\r\n        this.paths[i].render(ctx, true);\r\n      }\r\n      this.clipTo && ctx.restore();\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Sets certain property to a certain value\r\n     * @param {String} prop\r\n     * @param {Any} value\r\n     * @return {fabric.PathGroup} thisArg\r\n     */\r\n    _set: function(prop, value) {\r\n\r\n      if (prop === 'fill' && value && this.isSameColor()) {\r\n        var i = this.paths.length;\r\n        while (i--) {\r\n          this.paths[i]._set(prop, value);\r\n        }\r\n      }\r\n\r\n      return this.callSuper('_set', prop, value);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of this path group\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var o = extend(parentToObject.call(this, propertiesToInclude), {\r\n        paths: invoke(this.getObjects(), 'toObject', propertiesToInclude)\r\n      });\r\n      if (this.sourcePath) {\r\n        o.sourcePath = this.sourcePath;\r\n      }\r\n      return o;\r\n    },\r\n\r\n    /**\r\n     * Returns dataless object representation of this path group\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} dataless object representation of an instance\r\n     */\r\n    toDatalessObject: function(propertiesToInclude) {\r\n      var o = this.toObject(propertiesToInclude);\r\n      if (this.sourcePath) {\r\n        o.paths = this.sourcePath;\r\n      }\r\n      return o;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var objects = this.getObjects(),\r\n          p = this.getPointByOrigin('left', 'top'),\r\n          translatePart = 'translate(' + p.x + ' ' + p.y + ')',\r\n          markup = this._createBaseSVGMarkup();\r\n      markup.push(\r\n        '<g ',\r\n        'style=\"', this.getSvgStyles(), '\" ',\r\n        'transform=\"', this.getSvgTransformMatrix(), translatePart, this.getSvgTransform(), '\" ',\r\n        '>\\n'\r\n      );\r\n\r\n      for (var i = 0, len = objects.length; i < len; i++) {\r\n        markup.push('\\t', objects[i].toSVG(reviver));\r\n      }\r\n      markup.push('</g>\\n');\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns a string representation of this path group\r\n     * @return {String} string representation of an object\r\n     */\r\n    toString: function() {\r\n      return '#<fabric.PathGroup (' + this.complexity() +\r\n        '): { top: ' + this.top + ', left: ' + this.left + ' }>';\r\n    },\r\n\r\n    /**\r\n     * Returns true if all paths in this group are of same color\r\n     * @return {Boolean} true if all paths are of the same color (`fill`)\r\n     */\r\n    isSameColor: function() {\r\n      var firstPathFill = this.getObjects()[0].get('fill') || '';\r\n      if (typeof firstPathFill !== 'string') {\r\n        return false;\r\n      }\r\n      firstPathFill = firstPathFill.toLowerCase();\r\n      return this.getObjects().every(function(path) {\r\n        var pathFill = path.get('fill') || '';\r\n        return typeof pathFill === 'string' && (pathFill).toLowerCase() === firstPathFill;\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Returns number representation of object's complexity\r\n     * @return {Number} complexity\r\n     */\r\n    complexity: function() {\r\n      return this.paths.reduce(function(total, path) {\r\n        return total + ((path && path.complexity) ? path.complexity() : 0);\r\n      }, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns all paths in this path group\r\n     * @return {Array} array of path objects included in this path group\r\n     */\r\n    getObjects: function() {\r\n      return this.paths;\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Creates fabric.PathGroup instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.PathGroup\r\n   * @param {Object} object Object to create an instance from\r\n   * @param {Function} callback Callback to invoke when an fabric.PathGroup instance is created\r\n   */\r\n  fabric.PathGroup.fromObject = function(object, callback) {\r\n    if (typeof object.paths === 'string') {\r\n      fabric.loadSVGFromURL(object.paths, function (elements) {\r\n\r\n        var pathUrl = object.paths;\r\n        delete object.paths;\r\n\r\n        var pathGroup = fabric.util.groupSVGElements(elements, object, pathUrl);\r\n\r\n        callback(pathGroup);\r\n      });\r\n    }\r\n    else {\r\n      fabric.util.enlivenObjects(object.paths, function(enlivenedObjects) {\r\n        delete object.paths;\r\n        callback(new fabric.PathGroup(enlivenedObjects, object));\r\n      });\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Indicates that instances of this type are async\r\n   * @static\r\n   * @memberOf fabric.PathGroup\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  fabric.PathGroup.async = true;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      min = fabric.util.array.min,\r\n      max = fabric.util.array.max,\r\n      invoke = fabric.util.array.invoke;\r\n\r\n  if (fabric.Group) {\r\n    return;\r\n  }\r\n\r\n  // lock-related properties, for use in fabric.Group#get\r\n  // to enable locking behavior on group\r\n  // when one of its objects has lock-related properties set\r\n  var _lockProperties = {\r\n    lockMovementX:  true,\r\n    lockMovementY:  true,\r\n    lockRotation:   true,\r\n    lockScalingX:   true,\r\n    lockScalingY:   true,\r\n    lockUniScaling: true\r\n  };\r\n\r\n  /**\r\n   * Group class\r\n   * @class fabric.Group\r\n   * @extends fabric.Object\r\n   * @mixes fabric.Collection\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#groups}\r\n   * @see {@link fabric.Group#initialize} for constructor definition\r\n   */\r\n  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'group',\r\n\r\n    /**\r\n     * Width of stroke\r\n     * @type Number\r\n     * @default\r\n     */\r\n    strokeWidth: 0,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {Object} objects Group objects\r\n     * @param {Object} [options] Options object\r\n     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.\r\n     * @return {Object} thisArg\r\n     */\r\n    initialize: function(objects, options, isAlreadyGrouped) {\r\n      options = options || { };\r\n\r\n      this._objects = [];\r\n      // if objects enclosed in a group have been grouped already,\r\n      // we cannot change properties of objects.\r\n      // Thus we need to set options to group without objects,\r\n      // because delegatedProperties propagate to objects.\r\n      isAlreadyGrouped && this.callSuper('initialize', options);\r\n\r\n      this._objects = objects || [];\r\n      for (var i = this._objects.length; i--; ) {\r\n        this._objects[i].group = this;\r\n      }\r\n\r\n      this.originalState = { };\r\n\r\n      if (options.originX) {\r\n        this.originX = options.originX;\r\n      }\r\n      if (options.originY) {\r\n        this.originY = options.originY;\r\n      }\r\n\r\n      if (isAlreadyGrouped) {\r\n        // do not change coordinate of objects enclosed in a group,\r\n        // because objects coordinate system have been group coodinate system already.\r\n        this._updateObjectsCoords(true);\r\n      }\r\n      else {\r\n        this._calcBounds();\r\n        this._updateObjectsCoords();\r\n        this.callSuper('initialize', options);\r\n      }\r\n\r\n      this.setCoords();\r\n      this.saveCoords();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change\r\n     */\r\n    _updateObjectsCoords: function(skipCoordsChange) {\r\n      for (var i = this._objects.length; i--; ){\r\n        this._updateObjectCoords(this._objects[i], skipCoordsChange);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} object\r\n     * @param {Boolean} [skipCoordsChange] if true, coordinates of object dose not change\r\n     */\r\n    _updateObjectCoords: function(object, skipCoordsChange) {\r\n      // do not display corners of objects enclosed in a group\r\n      object.__origHasControls = object.hasControls;\r\n      object.hasControls = false;\r\n\r\n      if (skipCoordsChange) {\r\n        return;\r\n      }\r\n\r\n      var objectLeft = object.getLeft(),\r\n          objectTop = object.getTop(),\r\n          center = this.getCenterPoint();\r\n\r\n      object.set({\r\n        originalLeft: objectLeft,\r\n        originalTop: objectTop,\r\n        left: objectLeft - center.x,\r\n        top: objectTop - center.y\r\n      });\r\n      object.setCoords();\r\n    },\r\n\r\n    /**\r\n     * Returns string represenation of a group\r\n     * @return {String}\r\n     */\r\n    toString: function() {\r\n      return '#<fabric.Group: (' + this.complexity() + ')>';\r\n    },\r\n\r\n    /**\r\n     * Adds an object to a group; Then recalculates group's dimension, position.\r\n     * @param {Object} object\r\n     * @return {fabric.Group} thisArg\r\n     * @chainable\r\n     */\r\n    addWithUpdate: function(object) {\r\n      this._restoreObjectsState();\r\n      if (object) {\r\n        this._objects.push(object);\r\n        object.group = this;\r\n        object._set('canvas', this.canvas);\r\n      }\r\n      // since _restoreObjectsState set objects inactive\r\n      this.forEachObject(this._setObjectActive, this);\r\n      this._calcBounds();\r\n      this._updateObjectsCoords();\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setObjectActive: function(object) {\r\n      object.set('active', true);\r\n      object.group = this;\r\n    },\r\n\r\n    /**\r\n     * Removes an object from a group; Then recalculates group's dimension, position.\r\n     * @param {Object} object\r\n     * @return {fabric.Group} thisArg\r\n     * @chainable\r\n     */\r\n    removeWithUpdate: function(object) {\r\n      this._moveFlippedObject(object);\r\n      this._restoreObjectsState();\r\n\r\n      // since _restoreObjectsState set objects inactive\r\n      this.forEachObject(this._setObjectActive, this);\r\n\r\n      this.remove(object);\r\n      this._calcBounds();\r\n      this._updateObjectsCoords();\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _onObjectAdded: function(object) {\r\n      object.group = this;\r\n      object._set('canvas', this.canvas);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _onObjectRemoved: function(object) {\r\n      delete object.group;\r\n      object.set('active', false);\r\n    },\r\n\r\n    /**\r\n     * Properties that are delegated to group objects when reading/writing\r\n     * @param {Object} delegatedProperties\r\n     */\r\n    delegatedProperties: {\r\n      fill:             true,\r\n      opacity:          true,\r\n      fontFamily:       true,\r\n      fontWeight:       true,\r\n      fontSize:         true,\r\n      fontStyle:        true,\r\n      lineHeight:       true,\r\n      textDecoration:   true,\r\n      textAlign:        true,\r\n      backgroundColor:  true\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _set: function(key, value) {\r\n      var i = this._objects.length;\r\n\r\n      if (this.delegatedProperties[key] || key === 'canvas') {\r\n        while (i--) {\r\n          this._objects[i].set(key, value);\r\n        }\r\n      }\r\n      else {\r\n        while (i--) {\r\n          this._objects[i].setOnGroup(key, value);\r\n        }\r\n      }\r\n\r\n      this.callSuper('_set', key, value);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return extend(this.callSuper('toObject', propertiesToInclude), {\r\n        objects: invoke(this._objects, 'toObject', propertiesToInclude)\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Renders instance on a given context\r\n     * @param {CanvasRenderingContext2D} ctx context to render instance on\r\n     */\r\n    render: function(ctx) {\r\n      // do not render if object is not visible\r\n      if (!this.visible) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n      if (this.transformMatrix) {\r\n        ctx.transform.apply(ctx, this.transformMatrix);\r\n      }\r\n      this.transform(ctx);\r\n      this._setShadow(ctx);\r\n      this.clipTo && fabric.util.clipContext(this, ctx);\r\n      // the array is now sorted in order of highest first, so start from end\r\n      for (var i = 0, len = this._objects.length; i < len; i++) {\r\n        this._renderObject(this._objects[i], ctx);\r\n      }\r\n\r\n      this.clipTo && ctx.restore();\r\n\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Renders controls and borders for the object\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Boolean} [noTransform] When true, context is not transformed\r\n     */\r\n    _renderControls: function(ctx, noTransform) {\r\n      this.callSuper('_renderControls', ctx, noTransform);\r\n      for (var i = 0, len = this._objects.length; i < len; i++) {\r\n        this._objects[i]._renderControls(ctx);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _renderObject: function(object, ctx) {\r\n      // do not render if object is not visible\r\n      if (!object.visible) {\r\n        return;\r\n      }\r\n\r\n      var originalHasRotatingPoint = object.hasRotatingPoint;\r\n      object.hasRotatingPoint = false;\r\n      object.render(ctx);\r\n      object.hasRotatingPoint = originalHasRotatingPoint;\r\n    },\r\n\r\n    /**\r\n     * Retores original state of each of group objects (original state is that which was before group was created).\r\n     * @private\r\n     * @return {fabric.Group} thisArg\r\n     * @chainable\r\n     */\r\n    _restoreObjectsState: function() {\r\n      this._objects.forEach(this._restoreObjectState, this);\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Realises the transform from this group onto the supplied object\r\n     * i.e. it tells you what would happen if the supplied object was in\r\n     * the group, and then the group was destroyed. It mutates the supplied\r\n     * object.\r\n     * @param {fabric.Object} object\r\n     * @return {fabric.Object} transformedObject\r\n     */\r\n    realizeTransform: function(object) {\r\n      this._moveFlippedObject(object);\r\n      this._setObjectPosition(object);\r\n      return object;\r\n    },\r\n\r\n    /**\r\n     * Moves a flipped object to the position where it's displayed\r\n     * @private\r\n     * @param {fabric.Object} object\r\n     * @return {fabric.Group} thisArg\r\n     */\r\n    _moveFlippedObject: function(object) {\r\n      var oldOriginX = object.get('originX'),\r\n          oldOriginY = object.get('originY'),\r\n          center = object.getCenterPoint();\r\n\r\n      object.set({\r\n        originX: 'center',\r\n        originY: 'center',\r\n        left: center.x,\r\n        top: center.y\r\n      });\r\n\r\n      this._toggleFlipping(object);\r\n\r\n      var newOrigin = object.getPointByOrigin(oldOriginX, oldOriginY);\r\n\r\n      object.set({\r\n        originX: oldOriginX,\r\n        originY: oldOriginY,\r\n        left: newOrigin.x,\r\n        top: newOrigin.y\r\n      });\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _toggleFlipping: function(object) {\r\n      if (this.flipX) {\r\n        object.toggle('flipX');\r\n        object.set('left', -object.get('left'));\r\n        object.setAngle(-object.getAngle());\r\n      }\r\n      if (this.flipY) {\r\n        object.toggle('flipY');\r\n        object.set('top', -object.get('top'));\r\n        object.setAngle(-object.getAngle());\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Restores original state of a specified object in group\r\n     * @private\r\n     * @param {fabric.Object} object\r\n     * @return {fabric.Group} thisArg\r\n     */\r\n    _restoreObjectState: function(object) {\r\n      this._setObjectPosition(object);\r\n\r\n      object.setCoords();\r\n      object.hasControls = object.__origHasControls;\r\n      delete object.__origHasControls;\r\n      object.set('active', false);\r\n      object.setCoords();\r\n      delete object.group;\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setObjectPosition: function(object) {\r\n      var center = this.getCenterPoint(),\r\n          rotated = this._getRotatedLeftTop(object);\r\n\r\n      object.set({\r\n        angle: object.getAngle() + this.getAngle(),\r\n        left: center.x + rotated.left,\r\n        top: center.y + rotated.top,\r\n        scaleX: object.get('scaleX') * this.get('scaleX'),\r\n        scaleY: object.get('scaleY') * this.get('scaleY')\r\n      });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getRotatedLeftTop: function(object) {\r\n      var groupAngle = this.getAngle() * (Math.PI / 180);\r\n      return {\r\n        left: (-Math.sin(groupAngle) * object.getTop() * this.get('scaleY') +\r\n                Math.cos(groupAngle) * object.getLeft() * this.get('scaleX')),\r\n\r\n        top:  (Math.cos(groupAngle) * object.getTop() * this.get('scaleY') +\r\n               Math.sin(groupAngle) * object.getLeft() * this.get('scaleX'))\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Destroys a group (restoring state of its objects)\r\n     * @return {fabric.Group} thisArg\r\n     * @chainable\r\n     */\r\n    destroy: function() {\r\n      this._objects.forEach(this._moveFlippedObject, this);\r\n      return this._restoreObjectsState();\r\n    },\r\n\r\n    /**\r\n     * Saves coordinates of this instance (to be used together with `hasMoved`)\r\n     * @saveCoords\r\n     * @return {fabric.Group} thisArg\r\n     * @chainable\r\n     */\r\n    saveCoords: function() {\r\n      this._originalLeft = this.get('left');\r\n      this._originalTop = this.get('top');\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Checks whether this group was moved (since `saveCoords` was called last)\r\n     * @return {Boolean} true if an object was moved (since fabric.Group#saveCoords was called)\r\n     */\r\n    hasMoved: function() {\r\n      return this._originalLeft !== this.get('left') ||\r\n             this._originalTop !== this.get('top');\r\n    },\r\n\r\n    /**\r\n     * Sets coordinates of all group objects\r\n     * @return {fabric.Group} thisArg\r\n     * @chainable\r\n     */\r\n    setObjectsCoords: function() {\r\n      this.forEachObject(function(object) {\r\n        object.setCoords();\r\n      });\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _calcBounds: function(onlyWidthHeight) {\r\n      var aX = [],\r\n          aY = [],\r\n          o, prop,\r\n          props = ['tr', 'br', 'bl', 'tl'],\r\n          i = 0, iLen = this._objects.length,\r\n          j, jLen = props.length;\r\n\r\n      for ( ; i < iLen; ++i) {\r\n        o = this._objects[i];\r\n        o.setCoords();\r\n        for (j = 0; j < jLen; j++) {\r\n          prop = props[j];\r\n          aX.push(o.oCoords[prop].x);\r\n          aY.push(o.oCoords[prop].y);\r\n        }\r\n      }\r\n\r\n      this.set(this._getBounds(aX, aY, onlyWidthHeight));\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getBounds: function(aX, aY, onlyWidthHeight) {\r\n      var ivt = fabric.util.invertTransform(this.getViewportTransform()),\r\n          minXY = fabric.util.transformPoint(new fabric.Point(min(aX), min(aY)), ivt),\r\n          maxXY = fabric.util.transformPoint(new fabric.Point(max(aX), max(aY)), ivt),\r\n          obj = {\r\n            width: (maxXY.x - minXY.x) || 0,\r\n            height: (maxXY.y - minXY.y) || 0\r\n          };\r\n\r\n      if (!onlyWidthHeight) {\r\n        obj.left = minXY.x || 0;\r\n        obj.top = minXY.y || 0;\r\n        if (this.originX === 'center') {\r\n          obj.left += obj.width / 2;\r\n        }\r\n        if (this.originX === 'right') {\r\n          obj.left += obj.width;\r\n        }\r\n        if (this.originY === 'center') {\r\n          obj.top += obj.height / 2;\r\n        }\r\n        if (this.originY === 'bottom') {\r\n          obj.top += obj.height;\r\n        }\r\n      }\r\n      return obj;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns svg representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup();\r\n      markup.push(\r\n        '<g transform=\"',\r\n        /* avoiding styles intentionally */\r\n        this.getSvgTransform(),\r\n        this.getSvgTransformMatrix(),\r\n        '\" style=\"',\r\n        this.getSvgFilter(),\r\n        '\">\\n'\r\n      );\r\n\r\n      for (var i = 0, len = this._objects.length; i < len; i++) {\r\n        markup.push('\\t', this._objects[i].toSVG(reviver));\r\n      }\r\n\r\n      markup.push('</g>\\n');\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns requested property\r\n     * @param {String} prop Property to get\r\n     * @return {Any}\r\n     */\r\n    get: function(prop) {\r\n      if (prop in _lockProperties) {\r\n        if (this[prop]) {\r\n          return this[prop];\r\n        }\r\n        else {\r\n          for (var i = 0, len = this._objects.length; i < len; i++) {\r\n            if (this._objects[i][prop]) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        }\r\n      }\r\n      else {\r\n        if (prop in this.delegatedProperties) {\r\n          return this._objects[0] && this._objects[0].get(prop);\r\n        }\r\n        return this[prop];\r\n      }\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns {@link fabric.Group} instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Group\r\n   * @param {Object} object Object to create a group from\r\n   * @param {Function} [callback] Callback to invoke when an group instance is created\r\n   * @return {fabric.Group} An instance of fabric.Group\r\n   */\r\n  fabric.Group.fromObject = function(object, callback) {\r\n    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {\r\n      delete object.objects;\r\n      callback && callback(new fabric.Group(enlivenedObjects, object, true));\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Indicates that instances of this type are async\r\n   * @static\r\n   * @memberOf fabric.Group\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  fabric.Group.async = true;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var extend = fabric.util.object.extend;\r\n\r\n  if (!global.fabric) {\r\n    global.fabric = { };\r\n  }\r\n\r\n  if (global.fabric.Image) {\r\n    fabric.warn('fabric.Image is already defined.');\r\n    return;\r\n  }\r\n\r\n  /**\r\n   * Image class\r\n   * @class fabric.Image\r\n   * @extends fabric.Object\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#images}\r\n   * @see {@link fabric.Image#initialize} for constructor definition\r\n   */\r\n  fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'image',\r\n\r\n    /**\r\n     * crossOrigin value (one of \"\", \"anonymous\", \"allow-credentials\")\r\n     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes\r\n     * @type String\r\n     * @default\r\n     */\r\n    crossOrigin: '',\r\n\r\n    /**\r\n     * AlignX value, part of preserveAspectRatio (one of \"none\", \"mid\", \"min\", \"max\")\r\n     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\r\n     * This parameter defines how the picture is aligned to its viewport when image element width differs from image width.\r\n     * @type String\r\n     * @default\r\n     */\r\n    alignX: 'none',\r\n\r\n    /**\r\n     * AlignY value, part of preserveAspectRatio (one of \"none\", \"mid\", \"min\", \"max\")\r\n     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\r\n     * This parameter defines how the picture is aligned to its viewport when image element height differs from image height.\r\n     * @type String\r\n     * @default\r\n     */\r\n    alignY: 'none',\r\n\r\n    /**\r\n     * meetOrSlice value, part of preserveAspectRatio  (one of \"meet\", \"slice\").\r\n     * if meet the image is always fully visibile, if slice the viewport is always filled with image.\r\n     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\r\n     * @type String\r\n     * @default\r\n     */\r\n    meetOrSlice: 'meet',\r\n\r\n    /**\r\n     * private\r\n     * contains last value of scaleX to detect\r\n     * if the Image got resized after the last Render\r\n     * @type Number\r\n     */\r\n    _lastScaleX: 1,\r\n\r\n    /**\r\n     * private\r\n     * contains last value of scaleY to detect\r\n     * if the Image got resized after the last Render\r\n     * @type Number\r\n     */\r\n    _lastScaleY: 1,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {HTMLImageElement | String} element Image element\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Image} thisArg\r\n     */\r\n    initialize: function(element, options) {\r\n      options || (options = { });\r\n      this.filters = [ ];\r\n      this.resizeFilters = [ ];\r\n      this.callSuper('initialize', options);\r\n      this._initElement(element, options);\r\n    },\r\n\r\n    /**\r\n     * Returns image element which this instance if based on\r\n     * @return {HTMLImageElement} Image element\r\n     */\r\n    getElement: function() {\r\n      return this._element;\r\n    },\r\n\r\n    /**\r\n     * Sets image element for this instance to a specified one.\r\n     * If filters defined they are applied to new image.\r\n     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.\r\n     * @param {HTMLImageElement} element\r\n     * @param {Function} [callback] Callback is invoked when all filters have been applied and new image is generated\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Image} thisArg\r\n     * @chainable\r\n     */\r\n    setElement: function(element, callback, options) {\r\n      this._element = element;\r\n      this._originalElement = element;\r\n      this._initConfig(options);\r\n\r\n      if (this.filters.length !== 0) {\r\n        this.applyFilters(callback);\r\n      }\r\n      else if (callback) {\r\n        callback();\r\n      }\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Sets crossOrigin value (on an instance and corresponding image element)\r\n     * @return {fabric.Image} thisArg\r\n     * @chainable\r\n     */\r\n    setCrossOrigin: function(value) {\r\n      this.crossOrigin = value;\r\n      this._element.crossOrigin = value;\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * Returns original size of an image\r\n     * @return {Object} Object with \"width\" and \"height\" properties\r\n     */\r\n    getOriginalSize: function() {\r\n      var element = this.getElement();\r\n      return {\r\n        width: element.width,\r\n        height: element.height\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _stroke: function(ctx) {\r\n      ctx.save();\r\n      this._setStrokeStyles(ctx);\r\n      ctx.beginPath();\r\n      ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);\r\n      ctx.closePath();\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderDashedStroke: function(ctx) {\r\n      var x = -this.width / 2,\r\n          y = -this.height / 2,\r\n          w = this.width,\r\n          h = this.height;\r\n\r\n      ctx.save();\r\n      this._setStrokeStyles(ctx);\r\n\r\n      ctx.beginPath();\r\n      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);\r\n      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);\r\n      ctx.closePath();\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var filters = [ ];\r\n      this.filters.forEach(function(filterObj) {\r\n        if (filterObj) {\r\n          filters.push(filterObj.toObject());\r\n        }\r\n      });\r\n      var object = extend(this.callSuper('toObject', propertiesToInclude), {\r\n        src: this._originalElement.src || this._originalElement._src,\r\n        filters: filters,\r\n        crossOrigin: this.crossOrigin,\r\n        alignX: this.alignX,\r\n        alignY: this.alignY,\r\n        meetOrSlice: this.meetOrSlice\r\n      });\r\n\r\n      if (this.resizeFilters.length > 0) {\r\n        object.resizeFilters = this.resizeFilters.map(function(filterObj) {\r\n          return filterObj && filterObj.toObject();\r\n        });\r\n      }\r\n\r\n      if (!this.includeDefaultValues) {\r\n        this._removeDefaultValues(object);\r\n      }\r\n\r\n      return object;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2,\r\n          preserveAspectRatio = 'none';\r\n      if (this.group && this.group.type === 'path-group') {\r\n        x = this.left;\r\n        y = this.top;\r\n      }\r\n      if (this.alignX !== 'none' && this.alignY !== 'none') {\r\n        preserveAspectRatio = 'x' + this.alignX + 'Y' + this.alignY + ' ' + this.meetOrSlice;\r\n      }\r\n      markup.push(\r\n        '<g transform=\"', this.getSvgTransform(), this.getSvgTransformMatrix(), '\">\\n',\r\n          '<image xlink:href=\"', this.getSvgSrc(),\r\n            '\" x=\"', x, '\" y=\"', y,\r\n            '\" style=\"', this.getSvgStyles(),\r\n            // we're essentially moving origin of transformation from top/left corner to the center of the shape\r\n            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left\r\n            // so that object's center aligns with container's left/top\r\n            '\" width=\"', this.width,\r\n            '\" height=\"', this.height,\r\n            '\" preserveAspectRatio=\"', preserveAspectRatio, '\"',\r\n          '></image>\\n'\r\n      );\r\n\r\n      if (this.stroke || this.strokeDashArray) {\r\n        var origFill = this.fill;\r\n        this.fill = null;\r\n        markup.push(\r\n          '<rect ',\r\n            'x=\"', x, '\" y=\"', y,\r\n            '\" width=\"', this.width, '\" height=\"', this.height,\r\n            '\" style=\"', this.getSvgStyles(),\r\n          '\"/>\\n'\r\n        );\r\n        this.fill = origFill;\r\n      }\r\n\r\n      markup.push('</g>\\n');\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Returns source of an image\r\n     * @return {String} Source of an image\r\n     */\r\n    getSrc: function() {\r\n      if (this.getElement()) {\r\n        return this.getElement().src || this.getElement()._src;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Sets source of an image\r\n     * @param {String} src Source string (URL)\r\n     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Image} thisArg\r\n     * @chainable\r\n     */\r\n    setSrc: function(src, callback, options) {\r\n      fabric.util.loadImage(src, function(img) {\r\n        return this.setElement(img, callback, options);\r\n      }, this, options && options.crossOrigin);\r\n    },\r\n\r\n    /**\r\n     * Returns string representation of an instance\r\n     * @return {String} String representation of an instance\r\n     */\r\n    toString: function() {\r\n      return '#<fabric.Image: { src: \"' + this.getSrc() + '\" }>';\r\n    },\r\n\r\n    /**\r\n     * Returns a clone of an instance\r\n     * @param {Function} callback Callback is invoked with a clone as a first argument\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     */\r\n    clone: function(callback, propertiesToInclude) {\r\n      this.constructor.fromObject(this.toObject(propertiesToInclude), callback);\r\n    },\r\n\r\n    /**\r\n     * Applies filters assigned to this image (from \"filters\" array)\r\n     * @method applyFilters\r\n     * @param {Function} callback Callback is invoked when all filters have been applied and new image is generated\r\n     * @return {fabric.Image} thisArg\r\n     * @chainable\r\n     */\r\n    applyFilters: function(callback, filters, imgElement, forResizing) {\r\n\r\n      filters = filters || this.filters;\r\n      imgElement = imgElement || this._originalElement;\r\n\r\n      if (!imgElement) {\r\n        return;\r\n      }\r\n\r\n      var imgEl = imgElement,\r\n          canvasEl = fabric.util.createCanvasElement(),\r\n          replacement = fabric.util.createImage(),\r\n          _this = this;\r\n\r\n      canvasEl.width = imgEl.width;\r\n      canvasEl.height = imgEl.height;\r\n      canvasEl.getContext('2d').drawImage(imgEl, 0, 0, imgEl.width, imgEl.height);\r\n\r\n      if (filters.length === 0) {\r\n        this._element = imgElement;\r\n        callback && callback();\r\n        return canvasEl;\r\n      }\r\n      filters.forEach(function(filter) {\r\n        filter && filter.applyTo(canvasEl, filter.scaleX || _this.scaleX, filter.scaleY || _this.scaleY);\r\n        if (!forResizing && filter && filter.type === 'Resize') {\r\n          _this.width *= filter.scaleX;\r\n          _this.height *= filter.scaleY;\r\n        }\r\n      });\r\n\r\n      /** @ignore */\r\n      replacement.width = canvasEl.width;\r\n      replacement.height = canvasEl.height;\r\n\r\n      if (fabric.isLikelyNode) {\r\n        replacement.src = canvasEl.toBuffer(undefined, fabric.Image.pngCompression);\r\n        // onload doesn't fire in some node versions, so we invoke callback manually\r\n        _this._element = replacement;\r\n        !forResizing && (_this._filteredEl = replacement);\r\n        callback && callback();\r\n      }\r\n      else {\r\n        replacement.onload = function() {\r\n          _this._element = replacement;\r\n          !forResizing && (_this._filteredEl = replacement);\r\n          callback && callback();\r\n          replacement.onload = canvasEl = imgEl = null;\r\n        };\r\n        replacement.src = canvasEl.toDataURL('image/png');\r\n      }\r\n      return canvasEl;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx, noTransform) {\r\n      var x, y, imageMargins = this._findMargins(), elementToDraw;\r\n\r\n      x = (noTransform ? this.left : -this.width / 2);\r\n      y = (noTransform ? this.top : -this.height / 2);\r\n\r\n      if (this.meetOrSlice === 'slice') {\r\n        ctx.beginPath();\r\n        ctx.rect(x, y, this.width, this.height);\r\n        ctx.clip();\r\n      }\r\n\r\n      if (this.isMoving === false && this.resizeFilters.length && this._needsResize()) {\r\n        this._lastScaleX = this.scaleX;\r\n        this._lastScaleY = this.scaleY;\r\n        elementToDraw = this.applyFilters(null, this.resizeFilters, this._filteredEl || this._originalElement, true);\r\n      }\r\n      else {\r\n        elementToDraw = this._element;\r\n      }\r\n      elementToDraw && ctx.drawImage(elementToDraw,\r\n                                     x + imageMargins.marginX,\r\n                                     y + imageMargins.marginY,\r\n                                     imageMargins.width,\r\n                                     imageMargins.height\r\n                                    );\r\n\r\n      this._renderStroke(ctx);\r\n    },\r\n\r\n    /**\r\n     * @private, needed to check if image needs resize\r\n     */\r\n    _needsResize: function() {\r\n      return (this.scaleX !== this._lastScaleX || this.scaleY !== this._lastScaleY);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _findMargins: function() {\r\n      var width = this.width, height = this.height, scales,\r\n          scale, marginX = 0, marginY = 0;\r\n\r\n      if (this.alignX !== 'none' || this.alignY !== 'none') {\r\n        scales = [this.width / this._element.width, this.height / this._element.height];\r\n        scale = this.meetOrSlice === 'meet'\r\n                ? Math.min.apply(null, scales) : Math.max.apply(null, scales);\r\n        width = this._element.width * scale;\r\n        height = this._element.height * scale;\r\n        if (this.alignX === 'Mid') {\r\n          marginX = (this.width - width) / 2;\r\n        }\r\n        if (this.alignX === 'Max') {\r\n          marginX = this.width - width;\r\n        }\r\n        if (this.alignY === 'Mid') {\r\n          marginY = (this.height - height) / 2;\r\n        }\r\n        if (this.alignY === 'Max') {\r\n          marginY = this.height - height;\r\n        }\r\n      }\r\n      return {\r\n        width:  width,\r\n        height: height,\r\n        marginX: marginX,\r\n        marginY: marginY\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _resetWidthHeight: function() {\r\n      var element = this.getElement();\r\n\r\n      this.set('width', element.width);\r\n      this.set('height', element.height);\r\n    },\r\n\r\n    /**\r\n     * The Image class's initialization method. This method is automatically\r\n     * called by the constructor.\r\n     * @private\r\n     * @param {HTMLImageElement|String} element The element representing the image\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initElement: function(element, options) {\r\n      this.setElement(fabric.util.getById(element), null, options);\r\n      fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Options object\r\n     */\r\n    _initConfig: function(options) {\r\n      options || (options = { });\r\n      this.setOptions(options);\r\n      this._setWidthHeight(options);\r\n      if (this._element && this.crossOrigin) {\r\n        this._element.crossOrigin = this.crossOrigin;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Array} filters to be initialized\r\n     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created\r\n     */\r\n    _initFilters: function(filters, callback) {\r\n      if (filters && filters.length) {\r\n        fabric.util.enlivenObjects(filters, function(enlivenedObjects) {\r\n          callback && callback(enlivenedObjects);\r\n        }, 'fabric.Image.filters');\r\n      }\r\n      else {\r\n        callback && callback();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} [options] Object with width/height properties\r\n     */\r\n    _setWidthHeight: function(options) {\r\n      this.width = 'width' in options\r\n        ? options.width\r\n        : (this.getElement()\r\n            ? this.getElement().width || 0\r\n            : 0);\r\n\r\n      this.height = 'height' in options\r\n        ? options.height\r\n        : (this.getElement()\r\n            ? this.getElement().height || 0\r\n            : 0);\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity of this instance\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Default CSS class name for canvas\r\n   * @static\r\n   * @type String\r\n   * @default\r\n   */\r\n  fabric.Image.CSS_CANVAS = 'canvas-img';\r\n\r\n  /**\r\n   * Alias for getSrc\r\n   * @static\r\n   */\r\n  fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;\r\n\r\n  /**\r\n   * Creates an instance of fabric.Image from its object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @param {Function} [callback] Callback to invoke when an image instance is created\r\n   */\r\n  fabric.Image.fromObject = function(object, callback) {\r\n    fabric.util.loadImage(object.src, function(img) {\r\n      fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {\r\n        object.filters = filters || [ ];\r\n        fabric.Image.prototype._initFilters.call(object, object.resizeFilters, function(resizeFilters) {\r\n          object.resizeFilters = resizeFilters || [ ];\r\n          var instance = new fabric.Image(img, object);\r\n          callback && callback(instance);\r\n        });\r\n      });\r\n    }, null, object.crossOrigin);\r\n  };\r\n\r\n  /**\r\n   * Creates an instance of fabric.Image from an URL string\r\n   * @static\r\n   * @param {String} url URL to create an image from\r\n   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument)\r\n   * @param {Object} [imgOptions] Options object\r\n   */\r\n  fabric.Image.fromURL = function(url, callback, imgOptions) {\r\n    fabric.util.loadImage(url, function(img) {\r\n      callback && callback(new fabric.Image(img, imgOptions));\r\n    }, null, imgOptions && imgOptions.crossOrigin);\r\n  };\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})\r\n   * @static\r\n   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}\r\n   */\r\n  fabric.Image.ATTRIBUTE_NAMES =\r\n    fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href'.split(' '));\r\n\r\n  /**\r\n   * Returns {@link fabric.Image} instance from an SVG element\r\n   * @static\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Function} callback Callback to execute when fabric.Image object is created\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Image} Instance of fabric.Image\r\n   */\r\n  fabric.Image.fromElement = function(element, callback, options) {\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES),\r\n        preserveAR;\r\n\r\n    if (parsedAttributes.preserveAspectRatio) {\r\n      preserveAR = fabric.util.parsePreserveAspectRatioAttribute(parsedAttributes.preserveAspectRatio);\r\n      extend(parsedAttributes, preserveAR);\r\n    }\r\n\r\n    fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,\r\n      extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Indicates that instances of this type are async\r\n   * @static\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  fabric.Image.async = true;\r\n\r\n  /**\r\n   * Indicates compression level used when generating PNG under Node (in applyFilters). Any of 0-9\r\n   * @static\r\n   * @type Number\r\n   * @default\r\n   */\r\n  fabric.Image.pngCompression = 1;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\nfabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {\r\n\r\n  /**\r\n   * @private\r\n   * @return {Number} angle value\r\n   */\r\n  _getAngleValueForStraighten: function() {\r\n    var angle = this.getAngle() % 360;\r\n    if (angle > 0) {\r\n      return Math.round((angle - 1) / 90) * 90;\r\n    }\r\n    return Math.round(angle / 90) * 90;\r\n  },\r\n\r\n  /**\r\n   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  straighten: function() {\r\n    this.setAngle(this._getAngleValueForStraighten());\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Same as {@link fabric.Object.prototype.straighten} but with animation\r\n   * @param {Object} callbacks Object with callback functions\r\n   * @param {Function} [callbacks.onComplete] Invoked on completion\r\n   * @param {Function} [callbacks.onChange] Invoked on every step of animation\r\n   * @return {fabric.Object} thisArg\r\n   * @chainable\r\n   */\r\n  fxStraighten: function(callbacks) {\r\n    callbacks = callbacks || { };\r\n\r\n    var empty = function() { },\r\n        onComplete = callbacks.onComplete || empty,\r\n        onChange = callbacks.onChange || empty,\r\n        _this = this;\r\n\r\n    fabric.util.animate({\r\n      startValue: this.get('angle'),\r\n      endValue: this._getAngleValueForStraighten(),\r\n      duration: this.FX_DURATION,\r\n      onChange: function(value) {\r\n        _this.setAngle(value);\r\n        onChange();\r\n      },\r\n      onComplete: function() {\r\n        _this.setCoords();\r\n        onComplete();\r\n      },\r\n      onStart: function() {\r\n        _this.set('active', false);\r\n      }\r\n    });\r\n\r\n    return this;\r\n  }\r\n});\r\n\r\nfabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {\r\n\r\n  /**\r\n   * Straightens object, then rerenders canvas\r\n   * @param {fabric.Object} object Object to straighten\r\n   * @return {fabric.Canvas} thisArg\r\n   * @chainable\r\n   */\r\n  straightenObject: function (object) {\r\n    object.straighten();\r\n    this.renderAll();\r\n    return this;\r\n  },\r\n\r\n  /**\r\n   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated\r\n   * @param {fabric.Object} object Object to straighten\r\n   * @return {fabric.Canvas} thisArg\r\n   * @chainable\r\n   */\r\n  fxStraightenObject: function (object) {\r\n    object.fxStraighten({\r\n      onChange: this.renderAll.bind(this)\r\n    });\r\n    return this;\r\n  }\r\n});\r\n\r\n\r\n/**\r\n * @namespace fabric.Image.filters\r\n * @memberOf fabric.Image\r\n * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#image_filters}\r\n * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n */\r\nfabric.Image.filters = fabric.Image.filters || { };\r\n\r\n/**\r\n * Root filter class from which all filter classes inherit from\r\n * @class fabric.Image.filters.BaseFilter\r\n * @memberOf fabric.Image.filters\r\n */\r\nfabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {\r\n\r\n  /**\r\n   * Filter type\r\n   * @param {String} type\r\n   * @default\r\n   */\r\n  type: 'BaseFilter',\r\n\r\n  /**\r\n   * Constructor\r\n   * @param {Object} [options] Options object\r\n   */\r\n  initialize: function(options) {\r\n    if (options) {\r\n      this.setOptions(options);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Sets filter's properties from options\r\n   * @param {Object} [options] Options object\r\n   */\r\n  setOptions: function(options) {\r\n    for (var prop in options) {\r\n      this[prop] = options[prop];\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns object representation of an instance\r\n   * @return {Object} Object representation of an instance\r\n   */\r\n  toObject: function() {\r\n    return { type: this.type };\r\n  },\r\n\r\n  /**\r\n   * Returns a JSON representation of an instance\r\n   * @return {Object} JSON\r\n   */\r\n  toJSON: function() {\r\n    // delegate, not alias\r\n    return this.toObject();\r\n  }\r\n});\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Brightness filter class\r\n   * @class fabric.Image.filters.Brightness\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Brightness({\r\n   *   brightness: 200\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Brightness = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Brightness',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Brightness.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {Number} [options.brightness=0] Value to brighten the image up (0..255)\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n      this.brightness = options.brightness || 0;\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          brightness = this.brightness;\r\n\r\n      for (var i = 0, len = data.length; i < len; i += 4) {\r\n        data[i] += brightness;\r\n        data[i + 1] += brightness;\r\n        data[i + 2] += brightness;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        brightness: this.brightness\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness\r\n   */\r\n  fabric.Image.filters.Brightness.fromObject = function(object) {\r\n    return new fabric.Image.filters.Brightness(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Adapted from <a href=\"http://www.html5rocks.com/en/tutorials/canvas/imagefilters/\">html5rocks article</a>\r\n   * @class fabric.Image.filters.Convolute\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example <caption>Sharpen filter</caption>\r\n   * var filter = new fabric.Image.filters.Convolute({\r\n   *   matrix: [ 0, -1,  0,\r\n   *            -1,  5, -1,\r\n   *             0, -1,  0 ]\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   * @example <caption>Blur filter</caption>\r\n   * var filter = new fabric.Image.filters.Convolute({\r\n   *   matrix: [ 1/9, 1/9, 1/9,\r\n   *             1/9, 1/9, 1/9,\r\n   *             1/9, 1/9, 1/9 ]\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   * @example <caption>Emboss filter</caption>\r\n   * var filter = new fabric.Image.filters.Convolute({\r\n   *   matrix: [ 1,   1,  1,\r\n   *             1, 0.7, -1,\r\n   *            -1,  -1, -1 ]\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   * @example <caption>Emboss filter with opaqueness</caption>\r\n   * var filter = new fabric.Image.filters.Convolute({\r\n   *   opaque: true,\r\n   *   matrix: [ 1,   1,  1,\r\n   *             1, 0.7, -1,\r\n   *            -1,  -1, -1 ]\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Convolute = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Convolute',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Convolute.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {Boolean} [options.opaque=false] Opaque value (true/false)\r\n     * @param {Array} [options.matrix] Filter matrix\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.opaque = options.opaque;\r\n      this.matrix = options.matrix || [\r\n        0, 0, 0,\r\n        0, 1, 0,\r\n        0, 0, 0\r\n      ];\r\n\r\n      var canvasEl = fabric.util.createCanvasElement();\r\n      this.tmpCtx = canvasEl.getContext('2d');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _createImageData: function(w, h) {\r\n      return this.tmpCtx.createImageData(w, h);\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n\r\n      var weights = this.matrix,\r\n          context = canvasEl.getContext('2d'),\r\n          pixels = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n\r\n          side = Math.round(Math.sqrt(weights.length)),\r\n          halfSide = Math.floor(side/2),\r\n          src = pixels.data,\r\n          sw = pixels.width,\r\n          sh = pixels.height,\r\n\r\n          // pad output by the convolution matrix\r\n          w = sw,\r\n          h = sh,\r\n          output = this._createImageData(w, h),\r\n\r\n          dst = output.data,\r\n\r\n          // go through the destination image pixels\r\n          alphaFac = this.opaque ? 1 : 0;\r\n\r\n      for (var y = 0; y < h; y++) {\r\n        for (var x = 0; x < w; x++) {\r\n          var sy = y,\r\n              sx = x,\r\n              dstOff = (y * w + x) * 4,\r\n              // calculate the weighed sum of the source image pixels that\r\n              // fall under the convolution matrix\r\n              r = 0, g = 0, b = 0, a = 0;\r\n\r\n          for (var cy = 0; cy < side; cy++) {\r\n            for (var cx = 0; cx < side; cx++) {\r\n\r\n              var scy = sy + cy - halfSide,\r\n                  scx = sx + cx - halfSide;\r\n\r\n              /* jshint maxdepth:5 */\r\n              if (scy < 0 || scy > sh || scx < 0 || scx > sw) {\r\n                continue;\r\n              }\r\n\r\n              var srcOff = (scy * sw + scx) * 4,\r\n                  wt = weights[cy * side + cx];\r\n\r\n              r += src[srcOff] * wt;\r\n              g += src[srcOff + 1] * wt;\r\n              b += src[srcOff + 2] * wt;\r\n              a += src[srcOff + 3] * wt;\r\n            }\r\n          }\r\n          dst[dstOff] = r;\r\n          dst[dstOff + 1] = g;\r\n          dst[dstOff + 2] = b;\r\n          dst[dstOff + 3] = a + alphaFac * (255 - a);\r\n        }\r\n      }\r\n\r\n      context.putImageData(output, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        opaque: this.opaque,\r\n        matrix: this.matrix\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute\r\n   */\r\n  fabric.Image.filters.Convolute.fromObject = function(object) {\r\n    return new fabric.Image.filters.Convolute(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * GradientTransparency filter class\r\n   * @class fabric.Image.filters.GradientTransparency\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.GradientTransparency#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.GradientTransparency({\r\n   *   threshold: 200\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.GradientTransparency = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.GradientTransparency.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'GradientTransparency',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.GradientTransparency.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {Number} [options.threshold=100] Threshold value\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n      this.threshold = options.threshold || 100;\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          threshold = this.threshold,\r\n          total = data.length;\r\n\r\n      for (var i = 0, len = data.length; i < len; i += 4) {\r\n        data[i + 3] = threshold + 255 * (total - i) / total;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        threshold: this.threshold\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.GradientTransparency} Instance of fabric.Image.filters.GradientTransparency\r\n   */\r\n  fabric.Image.filters.GradientTransparency.fromObject = function(object) {\r\n    return new fabric.Image.filters.GradientTransparency(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { });\r\n\r\n  /**\r\n   * Grayscale image filter class\r\n   * @class fabric.Image.filters.Grayscale\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Grayscale();\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Grayscale = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Grayscale',\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @memberOf fabric.Image.filters.Grayscale.prototype\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          len = imageData.width * imageData.height * 4,\r\n          index = 0,\r\n          average;\r\n\r\n      while (index < len) {\r\n        average = (data[index] + data[index + 1] + data[index + 2]) / 3;\r\n        data[index]     = average;\r\n        data[index + 1] = average;\r\n        data[index + 2] = average;\r\n        index += 4;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale\r\n   */\r\n  fabric.Image.filters.Grayscale.fromObject = function() {\r\n    return new fabric.Image.filters.Grayscale();\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { });\r\n\r\n  /**\r\n   * Invert filter class\r\n   * @class fabric.Image.filters.Invert\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Invert();\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Invert = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Invert',\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @memberOf fabric.Image.filters.Invert.prototype\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          iLen = data.length, i;\r\n\r\n      for (i = 0; i < iLen; i+=4) {\r\n        data[i] = 255 - data[i];\r\n        data[i + 1] = 255 - data[i + 1];\r\n        data[i + 2] = 255 - data[i + 2];\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert\r\n   */\r\n  fabric.Image.filters.Invert.fromObject = function() {\r\n    return new fabric.Image.filters.Invert();\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Mask filter class\r\n   * See http://resources.aleph-1.com/mask/\r\n   * @class fabric.Image.filters.Mask\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.Mask#initialize} for constructor definition\r\n   */\r\n  fabric.Image.filters.Mask = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Mask.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Mask',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Mask.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {fabric.Image} [options.mask] Mask image object\r\n     * @param {Number} [options.channel=0] Rgb channel (0, 1, 2 or 3)\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.mask = options.mask;\r\n      this.channel = [ 0, 1, 2, 3 ].indexOf(options.channel) > -1 ? options.channel : 0;\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      if (!this.mask) {\r\n        return;\r\n      }\r\n\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          maskEl = this.mask.getElement(),\r\n          maskCanvasEl = fabric.util.createCanvasElement(),\r\n          channel = this.channel,\r\n          i,\r\n          iLen = imageData.width * imageData.height * 4;\r\n\r\n      maskCanvasEl.width = maskEl.width;\r\n      maskCanvasEl.height = maskEl.height;\r\n\r\n      maskCanvasEl.getContext('2d').drawImage(maskEl, 0, 0, maskEl.width, maskEl.height);\r\n\r\n      var maskImageData = maskCanvasEl.getContext('2d').getImageData(0, 0, maskEl.width, maskEl.height),\r\n          maskData = maskImageData.data;\r\n\r\n      for (i = 0; i < iLen; i += 4) {\r\n        data[i + 3] = maskData[i + channel];\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        mask: this.mask.toObject(),\r\n        channel: this.channel\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @param {Function} [callback] Callback to invoke when a mask filter instance is created\r\n   */\r\n  fabric.Image.filters.Mask.fromObject = function(object, callback) {\r\n    fabric.util.loadImage(object.mask.src, function(img) {\r\n      object.mask = new fabric.Image(img, object.mask);\r\n      callback && callback(new fabric.Image.filters.Mask(object));\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Indicates that instances of this type are async\r\n   * @static\r\n   * @type Boolean\r\n   * @default\r\n   */\r\n  fabric.Image.filters.Mask.async = true;\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Noise filter class\r\n   * @class fabric.Image.filters.Noise\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Noise({\r\n   *   noise: 700\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Noise = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Noise',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Noise.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {Number} [options.noise=0] Noise value\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n      this.noise = options.noise || 0;\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          noise = this.noise, rand;\r\n\r\n      for (var i = 0, len = data.length; i < len; i += 4) {\r\n\r\n        rand = (0.5 - Math.random()) * noise;\r\n\r\n        data[i] += rand;\r\n        data[i + 1] += rand;\r\n        data[i + 2] += rand;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        noise: this.noise\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise\r\n   */\r\n  fabric.Image.filters.Noise.fromObject = function(object) {\r\n    return new fabric.Image.filters.Noise(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Pixelate filter class\r\n   * @class fabric.Image.filters.Pixelate\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Pixelate({\r\n   *   blocksize: 8\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Pixelate = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Pixelate',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Pixelate.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {Number} [options.blocksize=4] Blocksize for pixelate\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n      this.blocksize = options.blocksize || 4;\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          iLen = imageData.height,\r\n          jLen = imageData.width,\r\n          index, i, j, r, g, b, a;\r\n\r\n      for (i = 0; i < iLen; i += this.blocksize) {\r\n        for (j = 0; j < jLen; j += this.blocksize) {\r\n\r\n          index = (i * 4) * jLen + (j * 4);\r\n\r\n          r = data[index];\r\n          g = data[index + 1];\r\n          b = data[index + 2];\r\n          a = data[index + 3];\r\n\r\n          /*\r\n           blocksize: 4\r\n\r\n           [1,x,x,x,1]\r\n           [x,x,x,x,1]\r\n           [x,x,x,x,1]\r\n           [x,x,x,x,1]\r\n           [1,1,1,1,1]\r\n           */\r\n\r\n          for (var _i = i, _ilen = i + this.blocksize; _i < _ilen; _i++) {\r\n            for (var _j = j, _jlen = j + this.blocksize; _j < _jlen; _j++) {\r\n              index = (_i * 4) * jLen + (_j * 4);\r\n              data[index] = r;\r\n              data[index + 1] = g;\r\n              data[index + 2] = b;\r\n              data[index + 3] = a;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        blocksize: this.blocksize\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate\r\n   */\r\n  fabric.Image.filters.Pixelate.fromObject = function(object) {\r\n    return new fabric.Image.filters.Pixelate(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Remove white filter class\r\n   * @class fabric.Image.filters.RemoveWhite\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.RemoveWhite#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.RemoveWhite({\r\n   *   threshold: 40,\r\n   *   distance: 140\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.RemoveWhite = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.RemoveWhite.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'RemoveWhite',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.RemoveWhite.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {Number} [options.threshold=30] Threshold value\r\n     * @param {Number} [options.distance=20] Distance value\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n      this.threshold = options.threshold || 30;\r\n      this.distance = options.distance || 20;\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          threshold = this.threshold,\r\n          distance = this.distance,\r\n          limit = 255 - threshold,\r\n          abs = Math.abs,\r\n          r, g, b;\r\n\r\n      for (var i = 0, len = data.length; i < len; i += 4) {\r\n        r = data[i];\r\n        g = data[i + 1];\r\n        b = data[i + 2];\r\n\r\n        if (r > limit &&\r\n            g > limit &&\r\n            b > limit &&\r\n            abs(r - g) < distance &&\r\n            abs(r - b) < distance &&\r\n            abs(g - b) < distance\r\n        ) {\r\n          data[i + 3] = 1;\r\n        }\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        threshold: this.threshold,\r\n        distance: this.distance\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.RemoveWhite} Instance of fabric.Image.filters.RemoveWhite\r\n   */\r\n  fabric.Image.filters.RemoveWhite.fromObject = function(object) {\r\n    return new fabric.Image.filters.RemoveWhite(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { });\r\n\r\n  /**\r\n   * Sepia filter class\r\n   * @class fabric.Image.filters.Sepia\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Sepia();\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Sepia = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Sepia.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Sepia',\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @memberOf fabric.Image.filters.Sepia.prototype\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          iLen = data.length, i, avg;\r\n\r\n      for (i = 0; i < iLen; i+=4) {\r\n        avg = 0.3  * data[i] + 0.59 * data[i + 1] + 0.11 * data[i + 2];\r\n        data[i] = avg + 100;\r\n        data[i + 1] = avg + 50;\r\n        data[i + 2] = avg + 255;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @return {fabric.Image.filters.Sepia} Instance of fabric.Image.filters.Sepia\r\n   */\r\n  fabric.Image.filters.Sepia.fromObject = function() {\r\n    return new fabric.Image.filters.Sepia();\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { });\r\n\r\n  /**\r\n   * Sepia2 filter class\r\n   * @class fabric.Image.filters.Sepia2\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Sepia2();\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Sepia2 = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Sepia2.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Sepia2',\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @memberOf fabric.Image.filters.Sepia.prototype\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          iLen = data.length, i, r, g, b;\r\n\r\n      for (i = 0; i < iLen; i+=4) {\r\n        r = data[i];\r\n        g = data[i + 1];\r\n        b = data[i + 2];\r\n\r\n        data[i] = (r * 0.393 + g * 0.769 + b * 0.189 ) / 1.351;\r\n        data[i + 1] = (r * 0.349 + g * 0.686 + b * 0.168 ) / 1.203;\r\n        data[i + 2] = (r * 0.272 + g * 0.534 + b * 0.131 ) / 2.140;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @return {fabric.Image.filters.Sepia2} Instance of fabric.Image.filters.Sepia2\r\n   */\r\n  fabric.Image.filters.Sepia2.fromObject = function() {\r\n    return new fabric.Image.filters.Sepia2();\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Tint filter class\r\n   * Adapted from <a href=\"https://github.com/mezzoblue/PaintbrushJS\">https://github.com/mezzoblue/PaintbrushJS</a>\r\n   * @class fabric.Image.filters.Tint\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link fabric.Image.filters.Tint#initialize} for constructor definition\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example <caption>Tint filter with hex color and opacity</caption>\r\n   * var filter = new fabric.Image.filters.Tint({\r\n   *   color: '#3513B0',\r\n   *   opacity: 0.5\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   * @example <caption>Tint filter with rgba color</caption>\r\n   * var filter = new fabric.Image.filters.Tint({\r\n   *   color: 'rgba(53, 21, 176, 0.5)'\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Tint = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Tint.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Tint',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Tint.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {String} [options.color=#000000] Color to tint the image with\r\n     * @param {Number} [options.opacity] Opacity value that controls the tint effect's transparency (0..1)\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.color = options.color || '#000000';\r\n      this.opacity = typeof options.opacity !== 'undefined'\r\n                      ? options.opacity\r\n                      : new fabric.Color(this.color).getAlpha();\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          iLen = data.length, i,\r\n          tintR, tintG, tintB,\r\n          r, g, b, alpha1,\r\n          source;\r\n\r\n      source = new fabric.Color(this.color).getSource();\r\n\r\n      tintR = source[0] * this.opacity;\r\n      tintG = source[1] * this.opacity;\r\n      tintB = source[2] * this.opacity;\r\n\r\n      alpha1 = 1 - this.opacity;\r\n\r\n      for (i = 0; i < iLen; i+=4) {\r\n        r = data[i];\r\n        g = data[i + 1];\r\n        b = data[i + 2];\r\n\r\n        // alpha compositing\r\n        data[i] = tintR + r * alpha1;\r\n        data[i + 1] = tintG + g * alpha1;\r\n        data[i + 2] = tintB + b * alpha1;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        color: this.color,\r\n        opacity: this.opacity\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.Tint} Instance of fabric.Image.filters.Tint\r\n   */\r\n  fabric.Image.filters.Tint.fromObject = function(object) {\r\n    return new fabric.Image.filters.Tint(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend;\r\n\r\n  /**\r\n   * Multiply filter class\r\n   * Adapted from <a href=\"http://www.laurenscorijn.com/articles/colormath-basics\">http://www.laurenscorijn.com/articles/colormath-basics</a>\r\n   * @class fabric.Image.filters.Multiply\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @example <caption>Multiply filter with hex color</caption>\r\n   * var filter = new fabric.Image.filters.Multiply({\r\n   *   color: '#F0F'\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   * @example <caption>Multiply filter with rgb color</caption>\r\n   * var filter = new fabric.Image.filters.Multiply({\r\n   *   color: 'rgb(53, 21, 176)'\r\n   * });\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Multiply = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Multiply.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Multiply',\r\n\r\n    /**\r\n     * Constructor\r\n     * @memberOf fabric.Image.filters.Multiply.prototype\r\n     * @param {Object} [options] Options object\r\n     * @param {String} [options.color=#000000] Color to multiply the image pixels with\r\n     */\r\n    initialize: function(options) {\r\n      options = options || { };\r\n\r\n      this.color = options.color || '#000000';\r\n    },\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          iLen = data.length, i,\r\n          source;\r\n\r\n      source = new fabric.Color(this.color).getSource();\r\n\r\n      for (i = 0; i < iLen; i+=4) {\r\n        data[i] *= source[0] / 255;\r\n        data[i + 1] *= source[1] / 255;\r\n        data[i + 2] *= source[2] / 255;\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return extend(this.callSuper('toObject'), {\r\n        color: this.color\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Image.filters.Multiply} Instance of fabric.Image.filters.Multiply\r\n   */\r\n  fabric.Image.filters.Multiply.fromObject = function(object) {\r\n    return new fabric.Image.filters.Multiply(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n  'use strict';\r\n\r\n  var fabric = global.fabric;\r\n\r\n  /**\r\n   * Color Blend filter class\r\n   * @class fabric.Image.filter.Blend\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Blend({\r\n   *  color: '#000',\r\n   *  mode: 'multiply'\r\n   * });\r\n   *\r\n   * var filter = new fabric.Image.filters.Blend({\r\n   *  image: fabricImageObject,\r\n   *  mode: 'multiply',\r\n   *  alpha: 0.5\r\n   * });\r\n\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Blend = fabric.util.createClass({\r\n    type: 'Blend',\r\n\r\n    initialize: function(options) {\r\n      options = options || {};\r\n      this.color = options.color || '#000';\r\n      this.image = options.image || false;\r\n      this.mode = options.mode || 'multiply';\r\n      this.alpha = options.alpha || 1;\r\n    },\r\n\r\n    applyTo: function(canvasEl) {\r\n      var context = canvasEl.getContext('2d'),\r\n          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),\r\n          data = imageData.data,\r\n          tr, tg, tb,\r\n          r, g, b,\r\n          _r, _g, _b,\r\n          source,\r\n          isImage = false;\r\n\r\n      if (this.image) {\r\n        // Blend images\r\n        isImage = true;\r\n\r\n        var _el = fabric.util.createCanvasElement();\r\n        _el.width = this.image.width;\r\n        _el.height = this.image.height;\r\n\r\n        var tmpCanvas = new fabric.StaticCanvas(_el);\r\n        tmpCanvas.add(this.image);\r\n        var context2 =  tmpCanvas.getContext('2d');\r\n        source = context2.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height).data;\r\n      }\r\n      else {\r\n        // Blend color\r\n        source = new fabric.Color(this.color).getSource();\r\n\r\n        tr = source[0] * this.alpha;\r\n        tg = source[1] * this.alpha;\r\n        tb = source[2] * this.alpha;\r\n      }\r\n\r\n      for (var i = 0, len = data.length; i < len; i += 4) {\r\n\r\n        r = data[i];\r\n        g = data[i + 1];\r\n        b = data[i + 2];\r\n\r\n        if (isImage) {\r\n          tr = source[i] * this.alpha;\r\n          tg = source[i + 1] * this.alpha;\r\n          tb = source[i + 2] * this.alpha;\r\n        }\r\n\r\n        switch (this.mode) {\r\n          case 'multiply':\r\n            data[i] = r * tr / 255;\r\n            data[i + 1] = g * tg / 255;\r\n            data[i + 2] = b * tb / 255;\r\n            break;\r\n          case 'screen':\r\n            data[i] = 1 - (1 - r) * (1 - tr);\r\n            data[i + 1] = 1 - (1 - g) * (1 - tg);\r\n            data[i + 2] = 1 - (1 - b) * (1 - tb);\r\n            break;\r\n          case 'add':\r\n            data[i] = Math.min(255, r + tr);\r\n            data[i + 1] = Math.min(255, g + tg);\r\n            data[i + 2] = Math.min(255, b + tb);\r\n            break;\r\n          case 'diff':\r\n          case 'difference':\r\n            data[i] = Math.abs(r - tr);\r\n            data[i + 1] = Math.abs(g - tg);\r\n            data[i + 2] = Math.abs(b - tb);\r\n            break;\r\n          case 'subtract':\r\n            _r = r - tr;\r\n            _g = g - tg;\r\n            _b = b - tb;\r\n\r\n            data[i] = (_r < 0) ? 0 : _r;\r\n            data[i + 1] = (_g < 0) ? 0 : _g;\r\n            data[i + 2] = (_b < 0) ? 0 : _b;\r\n            break;\r\n          case 'darken':\r\n            data[i] = Math.min(r, tr);\r\n            data[i + 1] = Math.min(g, tg);\r\n            data[i + 2] = Math.min(b, tb);\r\n            break;\r\n          case 'lighten':\r\n            data[i] = Math.max(r, tr);\r\n            data[i + 1] = Math.max(g, tg);\r\n            data[i + 2] = Math.max(b, tb);\r\n            break;\r\n        }\r\n      }\r\n\r\n      context.putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return {\r\n        color: this.color,\r\n        image: this.image,\r\n        mode: this.mode,\r\n        alpha: this.alpha\r\n      };\r\n    }\r\n  });\r\n\r\n  fabric.Image.filters.Blend.fromObject = function(object) {\r\n    return new fabric.Image.filters.Blend(object);\r\n  };\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,\r\n      sqrt = Math.sqrt, abs = Math.abs, max = Math.max, round = Math.round, sin = Math.sin,\r\n      ceil = Math.ceil;\r\n\r\n  /**\r\n   * Resize image filter class\r\n   * @class fabric.Image.filters.Resize\r\n   * @memberOf fabric.Image.filters\r\n   * @extends fabric.Image.filters.BaseFilter\r\n   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}\r\n   * @example\r\n   * var filter = new fabric.Image.filters.Resize();\r\n   * object.filters.push(filter);\r\n   * object.applyFilters(canvas.renderAll.bind(canvas));\r\n   */\r\n  fabric.Image.filters.Resize = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {\r\n\r\n    /**\r\n     * Filter type\r\n     * @param {String} type\r\n     * @default\r\n     */\r\n    type: 'Resize',\r\n\r\n    /**\r\n     * Resize type\r\n     * @param {String} resizeType\r\n     * @default\r\n     */\r\n    resizeType: 'hermite',\r\n\r\n    /**\r\n     * Scale factor for resizing, x axis\r\n     * @param {Number} scaleX\r\n     * @default\r\n     */\r\n    scaleX: 0,\r\n\r\n    /**\r\n     * Scale factor for resizing, y axis\r\n     * @param {Number} scaleY\r\n     * @default\r\n     */\r\n    scaleY: 0,\r\n\r\n    /**\r\n     * LanczosLobes parameter for lanczos filter\r\n     * @param {Number} lanczosLobes\r\n     * @default\r\n     */\r\n    lanczosLobes: 3,\r\n\r\n    /**\r\n     * Applies filter to canvas element\r\n     * @memberOf fabric.Image.filters.Resize.prototype\r\n     * @param {Object} canvasEl Canvas element to apply filter to\r\n     */\r\n    applyTo: function(canvasEl, scaleX, scaleY) {\r\n\r\n      this.rcpScaleX = 1 / scaleX;\r\n      this.rcpScaleY = 1 / scaleY;\r\n\r\n      var oW = canvasEl.width, oH = canvasEl.height,\r\n          dW = round(oW * scaleX), dH = round(oH * scaleY),\r\n          imageData;\r\n\r\n      if (this.resizeType === 'sliceHack') {\r\n        imageData = this.sliceByTwo(canvasEl, oW, oH, dW, dH);\r\n      }\r\n      if (this.resizeType === 'hermite') {\r\n        imageData = this.hermiteFastResize(canvasEl, oW, oH, dW, dH);\r\n      }\r\n      if (this.resizeType === 'bilinear') {\r\n        imageData = this.bilinearFiltering(canvasEl, oW, oH, dW, dH);\r\n      }\r\n      if (this.resizeType === 'lanczos') {\r\n        imageData = this.lanczosResize(canvasEl, oW, oH, dW, dH);\r\n      }\r\n      canvasEl.width = dW;\r\n      canvasEl.height = dH;\r\n      canvasEl.getContext('2d').putImageData(imageData, 0, 0);\r\n    },\r\n\r\n    sliceByTwo: function(canvasEl, width, height, newWidth, newHeight) {\r\n      var context = canvasEl.getContext('2d'), imageData,\r\n          multW = 0.5, multH = 0.5, signW = 1, signH = 1,\r\n          doneW = false, doneH = false, stepW = width, stepH = height,\r\n          tmpCanvas = fabric.util.createCanvasElement(),\r\n          tmpCtx = tmpCanvas.getContext('2d');\r\n      newWidth = floor(newWidth);\r\n      newHeight = floor(newHeight);\r\n      tmpCanvas.width = max(newWidth, width);\r\n      tmpCanvas.height = max(newHeight, height);\r\n\r\n      if (newWidth > width) {\r\n        multW = 2;\r\n        signW = -1;\r\n      }\r\n      if (newHeight > height) {\r\n        multH = 2;\r\n        signH = -1;\r\n      }\r\n      imageData = context.getImageData(0, 0, width, height);\r\n      canvasEl.width = max(newWidth, width);\r\n      canvasEl.height = max(newHeight, height);\r\n      context.putImageData(imageData, 0, 0);\r\n\r\n      while (!doneW || !doneH) {\r\n        width = stepW;\r\n        height = stepH;\r\n        if (newWidth * signW < floor(stepW * multW * signW)) {\r\n          stepW = floor(stepW * multW);\r\n        }\r\n        else {\r\n          stepW = newWidth;\r\n          doneW = true;\r\n        }\r\n        if (newHeight * signH < floor(stepH * multH * signH)) {\r\n          stepH = floor(stepH * multH);\r\n        }\r\n        else {\r\n          stepH = newHeight;\r\n          doneH = true;\r\n        }\r\n        imageData = context.getImageData(0, 0, width, height);\r\n        tmpCtx.putImageData(imageData, 0, 0);\r\n        context.clearRect(0, 0, stepW, stepH);\r\n        context.drawImage(tmpCanvas, 0, 0, width, height, 0, 0, stepW, stepH);\r\n      }\r\n      return context.getImageData(0, 0, newWidth, newHeight);\r\n    },\r\n\r\n    lanczosResize: function(canvasEl, oW, oH, dW, dH) {\r\n\r\n      function lanczosCreate(lobes) {\r\n        return function(x) {\r\n          if (x > lobes) {\r\n            return 0;\r\n          }\r\n          x *= Math.PI;\r\n          if (abs(x) < 1e-16) {\r\n            return 1;\r\n          }\r\n          var xx = x / lobes;\r\n          return sin(x) * sin(xx) / x / xx;\r\n        };\r\n      }\r\n\r\n      function process(u) {\r\n        var v, i, weight, idx, a, red, green,\r\n            blue, alpha, fX, fY;\r\n        center.x = (u + 0.5) * ratioX;\r\n        icenter.x = floor(center.x);\r\n        for (v = 0; v < dH; v++) {\r\n          center.y = (v + 0.5) * ratioY;\r\n          icenter.y = floor(center.y);\r\n          a = 0, red = 0, green = 0, blue = 0, alpha = 0;\r\n          for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {\r\n            if (i < 0 || i >= oW) {\r\n              continue;\r\n            }\r\n            fX = floor(1000 * abs(i - center.x));\r\n            if (!cacheLanc[fX]) {\r\n              cacheLanc[fX] = { };\r\n            }\r\n            for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {\r\n              if (j < 0 || j >= oH) {\r\n                continue;\r\n              }\r\n              fY = floor(1000 * abs(j - center.y));\r\n              if (!cacheLanc[fX][fY]) {\r\n                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);\r\n              }\r\n              weight = cacheLanc[fX][fY];\r\n              if (weight > 0) {\r\n                idx = (j * oW + i) * 4;\r\n                a += weight;\r\n                red += weight * srcData[idx];\r\n                green += weight * srcData[idx + 1];\r\n                blue += weight * srcData[idx + 2];\r\n                alpha += weight * srcData[idx + 3];\r\n              }\r\n            }\r\n          }\r\n          idx = (v * dW + u) * 4;\r\n          destData[idx] = red / a;\r\n          destData[idx + 1] = green / a;\r\n          destData[idx + 2] = blue / a;\r\n          destData[idx + 3] = alpha / a;\r\n        }\r\n\r\n        if (++u < dW) {\r\n          return process(u);\r\n        }\r\n        else {\r\n          return destImg;\r\n        }\r\n      }\r\n\r\n      var context = canvasEl.getContext('2d'),\r\n          srcImg = context.getImageData(0, 0, oW, oH),\r\n          destImg = context.getImageData(0, 0, dW, dH),\r\n          srcData = srcImg.data, destData = destImg.data,\r\n          lanczos = lanczosCreate(this.lanczosLobes),\r\n          ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,\r\n          rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,\r\n          range2X = ceil(ratioX * this.lanczosLobes / 2),\r\n          range2Y = ceil(ratioY * this.lanczosLobes / 2),\r\n          cacheLanc = { }, center = { }, icenter = { };\r\n\r\n      return process(0);\r\n    },\r\n\r\n    bilinearFiltering: function(canvasEl, w, h, w2, h2) {\r\n      var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,\r\n          color, offset = 0, origPix, ratioX = this.rcpScaleX,\r\n          ratioY = this.rcpScaleY, context = canvasEl.getContext('2d'),\r\n          w4 = 4 * (w - 1), img = context.getImageData(0, 0, w, h),\r\n          pixels = img.data, destImage = context.getImageData(0, 0, w2, h2),\r\n          destPixels = destImage.data;\r\n      for (i = 0; i < h2; i++) {\r\n        for (j = 0; j < w2; j++) {\r\n          x = floor(ratioX * j);\r\n          y = floor(ratioY * i);\r\n          xDiff = ratioX * j - x;\r\n          yDiff = ratioY * i - y;\r\n          origPix = 4 * (y * w + x);\r\n\r\n          for (chnl = 0; chnl < 4; chnl++) {\r\n            a = pixels[origPix + chnl];\r\n            b = pixels[origPix + 4 + chnl];\r\n            c = pixels[origPix + w4 + chnl];\r\n            d = pixels[origPix + w4 + 4 + chnl];\r\n            color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +\r\n                    c * yDiff * (1 - xDiff) + d * xDiff * yDiff;\r\n            destPixels[offset++] = color;\r\n          }\r\n        }\r\n      }\r\n      return destImage;\r\n    },\r\n\r\n    hermiteFastResize: function(canvasEl, oW, oH, dW, dH) {\r\n      var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,\r\n          ratioWHalf = ceil(ratioW / 2),\r\n          ratioHHalf = ceil(ratioH / 2),\r\n          context = canvasEl.getContext('2d'),\r\n          img = context.getImageData(0, 0, oW, oH), data = img.data,\r\n          img2 = context.getImageData(0, 0, dW, dH), data2 = img2.data;\r\n      for (var j = 0; j < dH; j++) {\r\n        for (var i = 0; i < dW; i++) {\r\n          var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,\r\n              gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;\r\n          for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {\r\n            var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,\r\n                centerX = (i + 0.5) * ratioW, w0 = dy * dy;\r\n            for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {\r\n              var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,\r\n                  w = sqrt(w0 + dx * dx);\r\n              /*jshint maxdepth:5 */\r\n              if (w > 1 && w < -1) {\r\n                continue;\r\n              }\r\n              //hermite filter\r\n              weight = 2 * w * w * w - 3 * w * w + 1;\r\n              if (weight > 0) {\r\n                dx = 4 * (xx + yy * oW);\r\n                //alpha\r\n                gxA += weight * data[dx + 3];\r\n                weightsAlpha += weight;\r\n                //colors\r\n                /*jshint maxdepth:6 */\r\n                if (data[dx + 3] < 255) {\r\n                  weight = weight * data[dx + 3] / 250;\r\n                }\r\n                /*jshint maxdepth:5 */\r\n                gxR += weight * data[dx];\r\n                gxG += weight * data[dx + 1];\r\n                gxB += weight * data[dx + 2];\r\n                weights += weight;\r\n              }\r\n              /*jshint maxdepth:4 */\r\n            }\r\n          }\r\n          data2[x2] = gxR / weights;\r\n          data2[x2 + 1] = gxG / weights;\r\n          data2[x2 + 2] = gxB / weights;\r\n          data2[x2 + 3] = gxA / weightsAlpha;\r\n        }\r\n      }\r\n      return img2;\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function() {\r\n      return {\r\n        type: this.type,\r\n        scaleX: this.scaleX,\r\n        scaleY: this.scaleY,\r\n        resizeType: this.resizeType,\r\n        lanczosLobes: this.lanczosLobes\r\n      };\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns filter instance from an object representation\r\n   * @static\r\n   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize\r\n   */\r\n  fabric.Image.filters.Resize.fromObject = function(object) {\r\n    return new fabric.Image.filters.Resize(object);\r\n  };\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = { }),\r\n      extend = fabric.util.object.extend,\r\n      clone = fabric.util.object.clone,\r\n      toFixed = fabric.util.toFixed,\r\n      supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),\r\n      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\r\n\r\n  if (fabric.Text) {\r\n    fabric.warn('fabric.Text is already defined');\r\n    return;\r\n  }\r\n\r\n  var stateProperties = fabric.Object.prototype.stateProperties.concat();\r\n  stateProperties.push(\r\n    'fontFamily',\r\n    'fontWeight',\r\n    'fontSize',\r\n    'text',\r\n    'textDecoration',\r\n    'textAlign',\r\n    'fontStyle',\r\n    'lineHeight',\r\n    'textBackgroundColor'\r\n  );\r\n\r\n  /**\r\n   * Text class\r\n   * @class fabric.Text\r\n   * @extends fabric.Object\r\n   * @return {fabric.Text} thisArg\r\n   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#text}\r\n   * @see {@link fabric.Text#initialize} for constructor definition\r\n   */\r\n  fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {\r\n\r\n    /**\r\n     * Properties which when set cause object to change dimensions\r\n     * @type Object\r\n     * @private\r\n     */\r\n    _dimensionAffectingProps: {\r\n      fontSize: true,\r\n      fontWeight: true,\r\n      fontFamily: true,\r\n      fontStyle: true,\r\n      lineHeight: true,\r\n      stroke: true,\r\n      strokeWidth: true,\r\n      text: true,\r\n      textAlign: true\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _reNewline: /\\r?\\n/,\r\n\r\n    /**\r\n     * Use this regular expression to filter for whitespace that is not a new line.\r\n     * Mostly used when text is 'justify' aligned.\r\n     * @private\r\n     */\r\n    _reSpacesAndTabs: /[ \\t\\r]+/g,\r\n\r\n    /**\r\n     * Retrieves object's fontSize\r\n     * @method getFontSize\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} Font size (in pixels)\r\n     */\r\n\r\n    /**\r\n     * Sets object's fontSize\r\n     * @method setFontSize\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {Number} fontSize Font size (in pixels)\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's fontWeight\r\n     * @method getFontWeight\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {(String|Number)} Font weight\r\n     */\r\n\r\n    /**\r\n     * Sets object's fontWeight\r\n     * @method setFontWeight\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {(Number|String)} fontWeight Font weight\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's fontFamily\r\n     * @method getFontFamily\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} Font family\r\n     */\r\n\r\n    /**\r\n     * Sets object's fontFamily\r\n     * @method setFontFamily\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {String} fontFamily Font family\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's text\r\n     * @method getText\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} text\r\n     */\r\n\r\n    /**\r\n     * Sets object's text\r\n     * @method setText\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {String} text Text\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's textDecoration\r\n     * @method getTextDecoration\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} Text decoration\r\n     */\r\n\r\n    /**\r\n     * Sets object's textDecoration\r\n     * @method setTextDecoration\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {String} textDecoration Text decoration\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's fontStyle\r\n     * @method getFontStyle\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} Font style\r\n     */\r\n\r\n    /**\r\n     * Sets object's fontStyle\r\n     * @method setFontStyle\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {String} fontStyle Font style\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's lineHeight\r\n     * @method getLineHeight\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {Number} Line height\r\n     */\r\n\r\n    /**\r\n     * Sets object's lineHeight\r\n     * @method setLineHeight\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {Number} lineHeight Line height\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's textAlign\r\n     * @method getTextAlign\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} Text alignment\r\n     */\r\n\r\n    /**\r\n     * Sets object's textAlign\r\n     * @method setTextAlign\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {String} textAlign Text alignment\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Retrieves object's textBackgroundColor\r\n     * @method getTextBackgroundColor\r\n     * @memberOf fabric.Text.prototype\r\n     * @return {String} Text background color\r\n     */\r\n\r\n    /**\r\n     * Sets object's textBackgroundColor\r\n     * @method setTextBackgroundColor\r\n     * @memberOf fabric.Text.prototype\r\n     * @param {String} textBackgroundColor Text background color\r\n     * @return {fabric.Text}\r\n     * @chainable\r\n     */\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type:                 'text',\r\n\r\n    /**\r\n     * Font size (in pixels)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    fontSize:             40,\r\n\r\n    /**\r\n     * Font weight (e.g. bold, normal, 400, 600, 800)\r\n     * @type {(Number|String)}\r\n     * @default\r\n     */\r\n    fontWeight:           'normal',\r\n\r\n    /**\r\n     * Font family\r\n     * @type String\r\n     * @default\r\n     */\r\n    fontFamily:           'Times New Roman',\r\n\r\n    /**\r\n     * Text decoration Possible values: \"\", \"underline\", \"overline\" or \"line-through\".\r\n     * @type String\r\n     * @default\r\n     */\r\n    textDecoration:       '',\r\n\r\n    /**\r\n     * Text alignment. Possible values: \"left\", \"center\", or \"right\".\r\n     * @type String\r\n     * @default\r\n     */\r\n    textAlign:            'left',\r\n\r\n    /**\r\n     * Font style . Possible values: \"\", \"normal\", \"italic\" or \"oblique\".\r\n     * @type String\r\n     * @default\r\n     */\r\n    fontStyle:            '',\r\n\r\n    /**\r\n     * Line height\r\n     * @type Number\r\n     * @default\r\n     */\r\n    lineHeight:           1.16,\r\n\r\n    /**\r\n     * Background color of text lines\r\n     * @type String\r\n     * @default\r\n     */\r\n    textBackgroundColor:  '',\r\n\r\n    /**\r\n     * List of properties to consider when checking if\r\n     * state of an object is changed ({@link fabric.Object#hasStateChanged})\r\n     * as well as for history (undo/redo) purposes\r\n     * @type Array\r\n     */\r\n    stateProperties:      stateProperties,\r\n\r\n    /**\r\n     * When defined, an object is rendered via stroke and this property specifies its color.\r\n     * <b>Backwards incompatibility note:</b> This property was named \"strokeStyle\" until v1.1.6\r\n     * @type String\r\n     * @default\r\n     */\r\n    stroke:               null,\r\n\r\n    /**\r\n     * Shadow object representing shadow of this shape.\r\n     * <b>Backwards incompatibility note:</b> This property was named \"textShadow\" (String) until v1.2.11\r\n     * @type fabric.Shadow\r\n     * @default\r\n     */\r\n    shadow:               null,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _fontSizeFraction: 0.25,\r\n\r\n    /**\r\n     * Text Line proportion to font Size (in pixels)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    _fontSizeMult:             1.13,\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {String} text Text string\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Text} thisArg\r\n     */\r\n    initialize: function(text, options) {\r\n      options = options || { };\r\n      this.text = text;\r\n      this.__skipDimension = true;\r\n      this.setOptions(options);\r\n      this.__skipDimension = false;\r\n      this._initDimensions();\r\n    },\r\n\r\n    /**\r\n     * Renders text object on offscreen canvas, so that it would get dimensions\r\n     * @private\r\n     */\r\n    _initDimensions: function(ctx) {\r\n      if (this.__skipDimension) {\r\n        return;\r\n      }\r\n      if (!ctx) {\r\n        ctx = fabric.util.createCanvasElement().getContext('2d');\r\n        this._setTextStyles(ctx);\r\n      }\r\n      this._textLines = this._splitTextIntoLines();\r\n      this._clearCache();\r\n      //if textAlign is 'justify' i have to disable caching\r\n      //when calculating width of text and widths of line.\r\n      this._cacheLinesWidth = (this.textAlign !== 'justify');\r\n      this.width = this._getTextWidth(ctx);\r\n      this._cacheLinesWidth = true;\r\n      this.height = this._getTextHeight(ctx);\r\n    },\r\n\r\n    /**\r\n     * Returns string representation of an instance\r\n     * @return {String} String representation of text object\r\n     */\r\n    toString: function() {\r\n      return '#<fabric.Text (' + this.complexity() +\r\n        '): { \"text\": \"' + this.text + '\", \"fontFamily\": \"' + this.fontFamily + '\" }>';\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx) {\r\n      this.clipTo && fabric.util.clipContext(this, ctx);\r\n      this._setOpacity(ctx);\r\n      this._setShadow(ctx);\r\n      this._setupCompositeOperation(ctx);\r\n      this._renderTextBackground(ctx);\r\n      this._setStrokeStyles(ctx);\r\n      this._setFillStyles(ctx);\r\n      this._renderText(ctx);\r\n      this._renderTextDecoration(ctx);\r\n      this.clipTo && ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderText: function(ctx) {\r\n\r\n      this._translateForTextAlign(ctx);\r\n      this._renderTextFill(ctx);\r\n      this._renderTextStroke(ctx);\r\n      this._translateForTextAlign(ctx, true);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Boolean} back Indicates if translate back or forward\r\n     */\r\n    _translateForTextAlign: function(ctx, back) {\r\n      if (this.textAlign !== 'left' && this.textAlign !== 'justify') {\r\n        var sign = back ? -1 : 1;\r\n        ctx.translate(this.textAlign === 'center' ? (sign * this.width / 2) : sign * this.width, 0);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _setTextStyles: function(ctx) {\r\n      ctx.textBaseline = 'alphabetic';\r\n      if (!this.skipTextAlign) {\r\n        ctx.textAlign = this.textAlign;\r\n      }\r\n      ctx.font = this._getFontDeclaration();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @return {Number} Height of fabric.Text object\r\n     */\r\n    _getTextHeight: function() {\r\n      return this._textLines.length * this._getHeightOfLine();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @return {Number} Maximum width of fabric.Text object\r\n     */\r\n    _getTextWidth: function(ctx) {\r\n      var maxWidth = this._getLineWidth(ctx, 0);\r\n\r\n      for (var i = 1, len = this._textLines.length; i < len; i++) {\r\n        var currentLineWidth = this._getLineWidth(ctx, i);\r\n        if (currentLineWidth > maxWidth) {\r\n          maxWidth = currentLineWidth;\r\n        }\r\n      }\r\n      return maxWidth;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {String} chars Chars to render\r\n     * @param {Number} left Left position of text\r\n     * @param {Number} top Top position of text\r\n     */\r\n    _renderChars: function(method, ctx, chars, left, top) {\r\n      // remove Text word from method var\r\n      var shortM = method.slice(0, -4);\r\n      if (this[shortM].toLive) {\r\n        var offsetX = -this.width / 2 + this[shortM].offsetX || 0,\r\n            offsetY = -this.height / 2 + this[shortM].offsetY || 0;\r\n        ctx.save();\r\n        ctx.translate(offsetX, offsetY);\r\n        left -= offsetX;\r\n        top -= offsetY;\r\n      }\r\n      ctx[method](chars, left, top);\r\n      this[shortM].toLive && ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} method Method name (\"fillText\" or \"strokeText\")\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {String} line Text to render\r\n     * @param {Number} left Left position of text\r\n     * @param {Number} top Top position of text\r\n     * @param {Number} lineIndex Index of a line in a text\r\n     */\r\n    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {\r\n      // lift the line by quarter of fontSize\r\n      top -= this.fontSize * this._fontSizeFraction;\r\n\r\n      // short-circuit\r\n      var lineWidth = this._getLineWidth(ctx, lineIndex);\r\n      if (this.textAlign !== 'justify' || this.width < lineWidth) {\r\n        this._renderChars(method, ctx, line, left, top, lineIndex);\r\n        return;\r\n      }\r\n\r\n      // stretch the line\r\n      var words = line.split(/\\s+/),\r\n          wordsWidth = this._getWidthOfWords(ctx, line, lineIndex),\r\n          widthDiff = this.width - wordsWidth,\r\n          numSpaces = words.length - 1,\r\n          spaceWidth = numSpaces > 0 ? widthDiff / numSpaces : 0,\r\n          leftOffset = 0, charOffset = 0, word;\r\n\r\n      for (var i = 0, len = words.length; i < len; i++) {\r\n        while (line[charOffset] === ' ' && charOffset < line.length) {\r\n          charOffset++;\r\n        }\r\n        word = words[i];\r\n        this._renderChars(method, ctx, word, left + leftOffset, top, lineIndex, charOffset);\r\n        leftOffset += ctx.measureText(word).width + spaceWidth;\r\n        charOffset += word.length;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Number} line\r\n     */\r\n    _getWidthOfWords: function (ctx, line) {\r\n      return ctx.measureText(line.replace(/\\s+/g, '')).width;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @return {Number} Left offset\r\n     */\r\n    _getLeftOffset: function() {\r\n      return -this.width / 2;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @return {Number} Top offset\r\n     */\r\n    _getTopOffset: function() {\r\n      return -this.height / 2;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextFill: function(ctx) {\r\n      if (!this.fill && !this._skipFillStrokeCheck) {\r\n        return;\r\n      }\r\n\r\n      var lineHeights = 0;\r\n\r\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n        var heightOfLine = this._getHeightOfLine(ctx, i),\r\n            maxHeight = heightOfLine / this.lineHeight;\r\n\r\n        this._renderTextLine(\r\n          'fillText',\r\n          ctx,\r\n          this._textLines[i],\r\n          this._getLeftOffset(),\r\n          this._getTopOffset() + lineHeights + maxHeight,\r\n          i\r\n        );\r\n        lineHeights += heightOfLine;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextStroke: function(ctx) {\r\n      if ((!this.stroke || this.strokeWidth === 0) && !this._skipFillStrokeCheck) {\r\n        return;\r\n      }\r\n\r\n      var lineHeights = 0;\r\n\r\n      if (this.shadow && !this.shadow.affectStroke) {\r\n        this._removeShadow(ctx);\r\n      }\r\n\r\n      ctx.save();\r\n\r\n      if (this.strokeDashArray) {\r\n        // Spec requires the concatenation of two copies the dash list when the number of elements is odd\r\n        if (1 & this.strokeDashArray.length) {\r\n          this.strokeDashArray.push.apply(this.strokeDashArray, this.strokeDashArray);\r\n        }\r\n        supportsLineDash && ctx.setLineDash(this.strokeDashArray);\r\n      }\r\n\r\n      ctx.beginPath();\r\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n        var heightOfLine = this._getHeightOfLine(ctx, i),\r\n            maxHeight = heightOfLine / this.lineHeight;\r\n\r\n        this._renderTextLine(\r\n          'strokeText',\r\n          ctx,\r\n          this._textLines[i],\r\n          this._getLeftOffset(),\r\n          this._getTopOffset() + lineHeights + maxHeight,\r\n          i\r\n        );\r\n        lineHeights += heightOfLine;\r\n      }\r\n      ctx.closePath();\r\n      ctx.restore();\r\n    },\r\n\r\n    _getHeightOfLine: function() {\r\n      return this.fontSize * this._fontSizeMult * this.lineHeight;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Array} textLines Array of all text lines\r\n     */\r\n    _renderTextBackground: function(ctx) {\r\n      this._renderTextBoxBackground(ctx);\r\n      this._renderTextLinesBackground(ctx);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextBoxBackground: function(ctx) {\r\n      if (!this.backgroundColor) {\r\n        return;\r\n      }\r\n\r\n      ctx.fillStyle = this.backgroundColor;\r\n\r\n      ctx.fillRect(\r\n        this._getLeftOffset(),\r\n        this._getTopOffset(),\r\n        this.width,\r\n        this.height\r\n      );\r\n\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextLinesBackground: function(ctx) {\r\n      if (!this.textBackgroundColor) {\r\n        return;\r\n      }\r\n      var lineTopOffset = 0, heightOfLine = this._getHeightOfLine(),\r\n          lineWidth, lineLeftOffset;\r\n\r\n      ctx.fillStyle = this.textBackgroundColor;\r\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n        if (this._textLines[i] !== '') {\r\n          lineWidth = this._getLineWidth(ctx, i);\r\n          lineLeftOffset = this._getLineLeftOffset(lineWidth);\r\n          ctx.fillRect(\r\n            this._getLeftOffset() + lineLeftOffset,\r\n            this._getTopOffset() + lineTopOffset,\r\n            lineWidth,\r\n            this.fontSize * this._fontSizeMult\r\n          );\r\n        }\r\n        lineTopOffset += heightOfLine;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Number} lineWidth Width of text line\r\n     * @return {Number} Line left offset\r\n     */\r\n    _getLineLeftOffset: function(lineWidth) {\r\n      if (this.textAlign === 'center') {\r\n        return (this.width - lineWidth) / 2;\r\n      }\r\n      if (this.textAlign === 'right') {\r\n        return this.width - lineWidth;\r\n      }\r\n      return 0;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _clearCache: function() {\r\n      this.__lineWidths = [ ];\r\n      this.__lineHeights = [ ];\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _shouldClearCache: function() {\r\n      var shouldClear = false;\r\n      if (this._forceClearCache) {\r\n        this._forceClearCache = false;\r\n        return true;\r\n      }\r\n      for (var prop in this._dimensionAffectingProps) {\r\n        if (this['__' + prop] !== this[prop]) {\r\n          this['__' + prop] = this[prop];\r\n          shouldClear = true;\r\n        }\r\n      }\r\n      return shouldClear;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Number} lineIndex line number\r\n     * @return {Number} Line width\r\n     */\r\n    _getLineWidth: function(ctx, lineIndex) {\r\n      if (this.__lineWidths[lineIndex]) {\r\n        return this.__lineWidths[lineIndex];\r\n      }\r\n      var width, wordCount, line = this._textLines[lineIndex];\r\n      if (line === '') {\r\n        width = 0;\r\n      }\r\n      else if (this.textAlign === 'justify' && this._cacheLinesWidth) {\r\n        wordCount = line.split(' ');\r\n        //consider not justify last line, not for now.\r\n        if (wordCount.length > 1) {\r\n          width = this.width;\r\n        }\r\n        else {\r\n          width = ctx.measureText(line).width;\r\n        }\r\n      }\r\n      else {\r\n        width = ctx.measureText(line).width;\r\n      }\r\n      this._cacheLinesWidth && (this.__lineWidths[lineIndex] = width);\r\n      return width;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextDecoration: function(ctx) {\r\n      if (!this.textDecoration) {\r\n        return;\r\n      }\r\n\r\n      var halfOfVerticalBox = this.height / 2,\r\n          _this = this, offsets = [];\r\n\r\n      /** @ignore */\r\n      function renderLinesAtOffset(offsets) {\r\n        var i, lineHeight = 0, len, j, oLen, lineWidth,\r\n            lineLeftOffset, heightOfLine;\r\n\r\n        for (i = 0, len = _this._textLines.length; i < len; i++) {\r\n\r\n          lineWidth = _this._getLineWidth(ctx, i),\r\n          lineLeftOffset = _this._getLineLeftOffset(lineWidth),\r\n          heightOfLine = _this._getHeightOfLine(ctx, i);\r\n\r\n          for (j = 0, oLen = offsets.length; j < oLen; j++) {\r\n            ctx.fillRect(\r\n              _this._getLeftOffset() + lineLeftOffset,\r\n              lineHeight + (_this._fontSizeMult - 1 + offsets[j] ) * _this.fontSize - halfOfVerticalBox,\r\n              lineWidth,\r\n              _this.fontSize / 15);\r\n          }\r\n          lineHeight += heightOfLine;\r\n        }\r\n      }\r\n\r\n      if (this.textDecoration.indexOf('underline') > -1) {\r\n        offsets.push(0.85); // 1 - 3/16\r\n      }\r\n      if (this.textDecoration.indexOf('line-through') > -1) {\r\n        offsets.push(0.43);\r\n      }\r\n      if (this.textDecoration.indexOf('overline') > -1) {\r\n        offsets.push(-0.12);\r\n      }\r\n      if (offsets.length > 0) {\r\n        renderLinesAtOffset(offsets);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getFontDeclaration: function() {\r\n      return [\r\n        // node-canvas needs \"weight style\", while browsers need \"style weight\"\r\n        (fabric.isLikelyNode ? this.fontWeight : this.fontStyle),\r\n        (fabric.isLikelyNode ? this.fontStyle : this.fontWeight),\r\n        this.fontSize + 'px',\r\n        (fabric.isLikelyNode ? ('\"' + this.fontFamily + '\"') : this.fontFamily)\r\n      ].join(' ');\r\n    },\r\n\r\n    /**\r\n     * Renders text instance on a specified context\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    render: function(ctx, noTransform) {\r\n      // do not render if object is not visible\r\n      if (!this.visible) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n      this._setTextStyles(ctx);\r\n\r\n      if (this._shouldClearCache()) {\r\n        this._initDimensions(ctx);\r\n      }\r\n      if (!noTransform) {\r\n        this.transform(ctx);\r\n      }\r\n      if (this.transformMatrix) {\r\n        ctx.transform.apply(ctx, this.transformMatrix);\r\n      }\r\n      if (this.group && this.group.type === 'path-group') {\r\n        ctx.translate(this.left, this.top);\r\n      }\r\n      this._render(ctx);\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Returns the text as an array of lines.\r\n     * @returns {Array} Lines in the text\r\n     */\r\n    _splitTextIntoLines: function() {\r\n      return this.text.split(this._reNewline);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} Object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var object = extend(this.callSuper('toObject', propertiesToInclude), {\r\n        text:                 this.text,\r\n        fontSize:             this.fontSize,\r\n        fontWeight:           this.fontWeight,\r\n        fontFamily:           this.fontFamily,\r\n        fontStyle:            this.fontStyle,\r\n        lineHeight:           this.lineHeight,\r\n        textDecoration:       this.textDecoration,\r\n        textAlign:            this.textAlign,\r\n        textBackgroundColor:  this.textBackgroundColor\r\n      });\r\n      if (!this.includeDefaultValues) {\r\n        this._removeDefaultValues(object);\r\n      }\r\n      return object;\r\n    },\r\n\r\n    /* _TO_SVG_START_ */\r\n    /**\r\n     * Returns SVG representation of an instance\r\n     * @param {Function} [reviver] Method for further parsing of svg representation.\r\n     * @return {String} svg representation of an instance\r\n     */\r\n    toSVG: function(reviver) {\r\n      var markup = this._createBaseSVGMarkup(),\r\n          offsets = this._getSVGLeftTopOffsets(this.ctx),\r\n          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);\r\n      this._wrapSVGTextAndBg(markup, textAndBg);\r\n\r\n      return reviver ? reviver(markup.join('')) : markup.join('');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getSVGLeftTopOffsets: function(ctx) {\r\n      var lineTop = this._getHeightOfLine(ctx, 0),\r\n          textLeft = -this.width / 2,\r\n          textTop = 0;\r\n\r\n      return {\r\n        textLeft: textLeft + (this.group && this.group.type === 'path-group' ? this.left : 0),\r\n        textTop: textTop + (this.group && this.group.type === 'path-group' ? -this.top : 0),\r\n        lineTop: lineTop\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _wrapSVGTextAndBg: function(markup, textAndBg) {\r\n      markup.push(\r\n        '\\t<g transform=\"', this.getSvgTransform(), this.getSvgTransformMatrix(), '\">\\n',\r\n          textAndBg.textBgRects.join(''),\r\n          '\\t\\t<text ',\r\n            (this.fontFamily ? 'font-family=\"' + this.fontFamily.replace(/\"/g, '\\'') + '\" ': ''),\r\n            (this.fontSize ? 'font-size=\"' + this.fontSize + '\" ': ''),\r\n            (this.fontStyle ? 'font-style=\"' + this.fontStyle + '\" ': ''),\r\n            (this.fontWeight ? 'font-weight=\"' + this.fontWeight + '\" ': ''),\r\n            (this.textDecoration ? 'text-decoration=\"' + this.textDecoration + '\" ': ''),\r\n            'style=\"', this.getSvgStyles(), '\" >',\r\n            textAndBg.textSpans.join(''),\r\n          '</text>\\n',\r\n        '\\t</g>\\n'\r\n      );\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Number} textTopOffset Text top offset\r\n     * @param {Number} textLeftOffset Text left offset\r\n     * @return {Object}\r\n     */\r\n    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {\r\n      var textSpans = [ ],\r\n          textBgRects = [ ],\r\n          height = 0;\r\n      // bounding-box background\r\n      this._setSVGBg(textBgRects);\r\n\r\n      // text and text-background\r\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n        if (this.textBackgroundColor) {\r\n          this._setSVGTextLineBg(textBgRects, i, textLeftOffset, textTopOffset, height);\r\n        }\r\n        this._setSVGTextLineText(i, textSpans, height, textLeftOffset, textTopOffset, textBgRects);\r\n        height += this._getHeightOfLine(this.ctx, i);\r\n      }\r\n\r\n      return {\r\n        textSpans: textSpans,\r\n        textBgRects: textBgRects\r\n      };\r\n    },\r\n\r\n    _setSVGTextLineText: function(i, textSpans, height, textLeftOffset, textTopOffset) {\r\n      var yPos = this.fontSize * (this._fontSizeMult - this._fontSizeFraction)\r\n        - textTopOffset + height - this.height / 2;\r\n      textSpans.push(\r\n        '<tspan x=\"',\r\n          toFixed(textLeftOffset + this._getLineLeftOffset(this._getLineWidth(this.ctx, i)), NUM_FRACTION_DIGITS), '\" ',\r\n          'y=\"',\r\n          toFixed(yPos, NUM_FRACTION_DIGITS),\r\n          '\" ',\r\n          // doing this on <tspan> elements since setting opacity\r\n          // on containing <text> one doesn't work in Illustrator\r\n          this._getFillAttributes(this.fill), '>',\r\n          fabric.util.string.escapeXml(this._textLines[i]),\r\n        '</tspan>'\r\n      );\r\n    },\r\n\r\n    _setSVGTextLineBg: function(textBgRects, i, textLeftOffset, textTopOffset, height) {\r\n      textBgRects.push(\r\n        '\\t\\t<rect ',\r\n          this._getFillAttributes(this.textBackgroundColor),\r\n          ' x=\"',\r\n          toFixed(textLeftOffset + this._getLineLeftOffset(this._getLineWidth(this.ctx, i)), NUM_FRACTION_DIGITS),\r\n          '\" y=\"',\r\n          toFixed(height - this.height / 2, NUM_FRACTION_DIGITS),\r\n          '\" width=\"',\r\n          toFixed(this._getLineWidth(this.ctx, i), NUM_FRACTION_DIGITS),\r\n          '\" height=\"',\r\n          toFixed(this._getHeightOfLine(this.ctx, i) / this.lineHeight, NUM_FRACTION_DIGITS),\r\n        '\"></rect>\\n');\r\n    },\r\n\r\n    _setSVGBg: function(textBgRects) {\r\n      if (this.backgroundColor) {\r\n        textBgRects.push(\r\n          '\\t\\t<rect ',\r\n            this._getFillAttributes(this.backgroundColor),\r\n            ' x=\"',\r\n            toFixed(-this.width / 2, NUM_FRACTION_DIGITS),\r\n            '\" y=\"',\r\n            toFixed(-this.height / 2, NUM_FRACTION_DIGITS),\r\n            '\" width=\"',\r\n            toFixed(this.width, NUM_FRACTION_DIGITS),\r\n            '\" height=\"',\r\n            toFixed(this.height, NUM_FRACTION_DIGITS),\r\n          '\"></rect>\\n');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values\r\n     * we work around it by \"moving\" alpha channel into opacity attribute and setting fill's alpha to 1\r\n     *\r\n     * @private\r\n     * @param {Any} value\r\n     * @return {String}\r\n     */\r\n    _getFillAttributes: function(value) {\r\n      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';\r\n      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {\r\n        return 'fill=\"' + value + '\"';\r\n      }\r\n      return 'opacity=\"' + fillColor.getAlpha() + '\" fill=\"' + fillColor.setAlpha(1).toRgb() + '\"';\r\n    },\r\n    /* _TO_SVG_END_ */\r\n\r\n    /**\r\n     * Sets specified property to a specified value\r\n     * @param {String} key\r\n     * @param {Any} value\r\n     * @return {fabric.Text} thisArg\r\n     * @chainable\r\n     */\r\n    _set: function(key, value) {\r\n      this.callSuper('_set', key, value);\r\n\r\n      if (key in this._dimensionAffectingProps) {\r\n        this._initDimensions();\r\n        this.setCoords();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns complexity of an instance\r\n     * @return {Number} complexity\r\n     */\r\n    complexity: function() {\r\n      return 1;\r\n    }\r\n  });\r\n\r\n  /* _FROM_SVG_START_ */\r\n  /**\r\n   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})\r\n   * @static\r\n   * @memberOf fabric.Text\r\n   * @see: http://www.w3.org/TR/SVG/text.html#TextElement\r\n   */\r\n  fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(\r\n    'x y dx dy font-family font-style font-weight font-size text-decoration text-anchor'.split(' '));\r\n\r\n  /**\r\n   * Default SVG font size\r\n   * @static\r\n   * @memberOf fabric.Text\r\n   */\r\n  fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;\r\n\r\n  /**\r\n   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)\r\n   * @static\r\n   * @memberOf fabric.Text\r\n   * @param {SVGElement} element Element to parse\r\n   * @param {Object} [options] Options object\r\n   * @return {fabric.Text} Instance of fabric.Text\r\n   */\r\n  fabric.Text.fromElement = function(element, options) {\r\n    if (!element) {\r\n      return null;\r\n    }\r\n\r\n    var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES);\r\n    options = fabric.util.object.extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes);\r\n\r\n    options.top = options.top || 0;\r\n    options.left = options.left || 0;\r\n    if ('dx' in parsedAttributes) {\r\n      options.left += parsedAttributes.dx;\r\n    }\r\n    if ('dy' in parsedAttributes) {\r\n      options.top += parsedAttributes.dy;\r\n    }\r\n    if (!('fontSize' in options)) {\r\n      options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;\r\n    }\r\n\r\n    if (!options.originX) {\r\n      options.originX = 'left';\r\n    }\r\n    var textContent = element.textContent.replace(/^\\s+|\\s+$|\\n+/g, '').replace(/\\s+/g, ' '),\r\n        text = new fabric.Text(textContent, options),\r\n        /*\r\n          Adjust positioning:\r\n            x/y attributes in SVG correspond to the bottom-left corner of text bounding box\r\n            top/left properties in Fabric correspond to center point of text bounding box\r\n        */\r\n        offX = 0;\r\n\r\n    if (text.originX === 'left') {\r\n      offX = text.getWidth() / 2;\r\n    }\r\n    if (text.originX === 'right') {\r\n      offX = -text.getWidth() / 2;\r\n    }\r\n    text.set({\r\n      left: text.getLeft() + offX,\r\n      top: text.getTop() - text.getHeight() / 2 + text.fontSize * (0.18 + text._fontSizeFraction) /* 0.3 is the old lineHeight */\r\n    });\r\n\r\n    return text;\r\n  };\r\n  /* _FROM_SVG_END_ */\r\n\r\n  /**\r\n   * Returns fabric.Text instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Text\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Text} Instance of fabric.Text\r\n   */\r\n  fabric.Text.fromObject = function(object) {\r\n    return new fabric.Text(object.text, clone(object));\r\n  };\r\n\r\n  fabric.util.createAccessors(fabric.Text);\r\n\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function() {\r\n\r\n  var clone = fabric.util.object.clone;\r\n\r\n  /**\r\n   * IText class (introduced in <b>v1.4</b>) Events are also fired with \"text:\"\r\n   * prefix when observing canvas.\r\n   * @class fabric.IText\r\n   * @extends fabric.Text\r\n   * @mixes fabric.Observable\r\n   *\r\n   * @fires changed\r\n   * @fires selection:changed\r\n   * @fires editing:entered\r\n   * @fires editing:exited\r\n   *\r\n   * @return {fabric.IText} thisArg\r\n   * @see {@link fabric.IText#initialize} for constructor definition\r\n   *\r\n   * <p>Supported key combinations:</p>\r\n   * <pre>\r\n   *   Move cursor:                    left, right, up, down\r\n   *   Select character:               shift + left, shift + right\r\n   *   Select text vertically:         shift + up, shift + down\r\n   *   Move cursor by word:            alt + left, alt + right\r\n   *   Select words:                   shift + alt + left, shift + alt + right\r\n   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end\r\n   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end\r\n   *   Jump to start/end of text:      cmd + up, cmd + down\r\n   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown\r\n   *   Delete character:               backspace\r\n   *   Delete word:                    alt + backspace\r\n   *   Delete line:                    cmd + backspace\r\n   *   Forward delete:                 delete\r\n   *   Copy text:                      ctrl/cmd + c\r\n   *   Paste text:                     ctrl/cmd + v\r\n   *   Cut text:                       ctrl/cmd + x\r\n   *   Select entire text:             ctrl/cmd + a\r\n   *   Quit editing                    tab or esc\r\n   * </pre>\r\n   *\r\n   * <p>Supported mouse/touch combination</p>\r\n   * <pre>\r\n   *   Position cursor:                click/touch\r\n   *   Create selection:               click/touch & drag\r\n   *   Create selection:               click & shift + click\r\n   *   Select word:                    double click\r\n   *   Select line:                    triple click\r\n   * </pre>\r\n   */\r\n  fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {\r\n\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'i-text',\r\n\r\n    /**\r\n     * Index where text selection starts (or where cursor is when there is no selection)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    selectionStart: 0,\r\n\r\n    /**\r\n     * Index where text selection ends\r\n     * @type Number\r\n     * @default\r\n     */\r\n    selectionEnd: 0,\r\n\r\n    /**\r\n     * Color of text selection\r\n     * @type String\r\n     * @default\r\n     */\r\n    selectionColor: 'rgba(17,119,255,0.3)',\r\n\r\n    /**\r\n     * Indicates whether text is in editing mode\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    isEditing: false,\r\n\r\n    /**\r\n     * Indicates whether a text can be edited\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    editable: true,\r\n\r\n    /**\r\n     * Border color of text object while it's in editing mode\r\n     * @type String\r\n     * @default\r\n     */\r\n    editingBorderColor: 'rgba(102,153,255,0.25)',\r\n\r\n    /**\r\n     * Width of cursor (in px)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    cursorWidth: 2,\r\n\r\n    /**\r\n     * Color of default cursor (when not overwritten by character style)\r\n     * @type String\r\n     * @default\r\n     */\r\n    cursorColor: '#333',\r\n\r\n    /**\r\n     * Delay between cursor blink (in ms)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    cursorDelay: 1000,\r\n\r\n    /**\r\n     * Duration of cursor fadein (in ms)\r\n     * @type Number\r\n     * @default\r\n     */\r\n    cursorDuration: 600,\r\n\r\n    /**\r\n     * Object containing character styles\r\n     * (where top-level properties corresponds to line number and 2nd-level properties -- to char number in a line)\r\n     * @type Object\r\n     * @default\r\n     */\r\n    styles: null,\r\n\r\n    /**\r\n     * Indicates whether internal text char widths can be cached\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    caching: true,\r\n\r\n    /**\r\n     * @private\r\n     * @type Boolean\r\n     * @default\r\n     */\r\n    _skipFillStrokeCheck: false,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _reSpace: /\\s|\\n/,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _currentCursorOpacity: 0,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _selectionDirection: null,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _abortCursorAnimation: false,\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _charWidthsCache: { },\r\n\r\n    /**\r\n     * Constructor\r\n     * @param {String} text Text string\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.IText} thisArg\r\n     */\r\n    initialize: function(text, options) {\r\n      this.styles = options ? (options.styles || { }) : { };\r\n      this.callSuper('initialize', text, options);\r\n      this.initBehavior();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _clearCache: function() {\r\n      this.callSuper('_clearCache');\r\n      this.__maxFontHeights = [ ];\r\n      this.__widthOfSpace = [ ];\r\n    },\r\n\r\n    /**\r\n     * Returns true if object has no styling\r\n     */\r\n    isEmptyStyles: function() {\r\n      if (!this.styles) {\r\n        return true;\r\n      }\r\n      var obj = this.styles;\r\n\r\n      for (var p1 in obj) {\r\n        for (var p2 in obj[p1]) {\r\n          /*jshint unused:false */\r\n          for (var p3 in obj[p1][p2]) {\r\n            return false;\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Sets selection start (left boundary of a selection)\r\n     * @param {Number} index Index to set selection start to\r\n     */\r\n    setSelectionStart: function(index) {\r\n      index = Math.max(index, 0);\r\n      if (this.selectionStart !== index) {\r\n        this.fire('selection:changed');\r\n        this.canvas && this.canvas.fire('text:selection:changed', { target: this });\r\n        this.selectionStart = index;\r\n      }\r\n      this._updateTextarea();\r\n    },\r\n\r\n    /**\r\n     * Sets selection end (right boundary of a selection)\r\n     * @param {Number} index Index to set selection end to\r\n     */\r\n    setSelectionEnd: function(index) {\r\n      index = Math.min(index, this.text.length);\r\n      if (this.selectionEnd !== index) {\r\n        this.fire('selection:changed');\r\n        this.canvas && this.canvas.fire('text:selection:changed', { target: this });\r\n        this.selectionEnd = index;\r\n      }\r\n      this._updateTextarea();\r\n    },\r\n\r\n    /**\r\n     * Gets style of a current selection/cursor (at the start position)\r\n     * @param {Number} [startIndex] Start index to get styles at\r\n     * @param {Number} [endIndex] End index to get styles at\r\n     * @return {Object} styles Style object at a specified (or current) index\r\n     */\r\n    getSelectionStyles: function(startIndex, endIndex) {\r\n\r\n      if (arguments.length === 2) {\r\n        var styles = [ ];\r\n        for (var i = startIndex; i < endIndex; i++) {\r\n          styles.push(this.getSelectionStyles(i));\r\n        }\r\n        return styles;\r\n      }\r\n\r\n      var loc = this.get2DCursorLocation(startIndex),\r\n          style = this._getStyleDeclaration(loc.lineIndex, loc.charIndex);\r\n\r\n      return style || {};\r\n    },\r\n\r\n    /**\r\n     * Sets style of a current selection\r\n     * @param {Object} [styles] Styles object\r\n     * @return {fabric.IText} thisArg\r\n     * @chainable\r\n     */\r\n    setSelectionStyles: function(styles) {\r\n      if (this.selectionStart === this.selectionEnd) {\r\n        this._extendStyles(this.selectionStart, styles);\r\n      }\r\n      else {\r\n        for (var i = this.selectionStart; i < this.selectionEnd; i++) {\r\n          this._extendStyles(i, styles);\r\n        }\r\n      }\r\n      /* not included in _extendStyles to avoid clearing cache more than once */\r\n      this._forceClearCache = true;\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _extendStyles: function(index, styles) {\r\n      var loc = this.get2DCursorLocation(index);\r\n\r\n      if (!this._getLineStyle(loc.lineIndex)) {\r\n        this._setLineStyle(loc.lineIndex, {});\r\n      }\r\n\r\n      if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {\r\n        this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});\r\n      }\r\n\r\n      fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _render: function(ctx) {\r\n      this.callSuper('_render', ctx);\r\n      this.ctx = ctx;\r\n      this.isEditing && this.renderCursorOrSelection();\r\n    },\r\n\r\n    /**\r\n     * Renders cursor or selection (depending on what exists)\r\n     */\r\n    renderCursorOrSelection: function() {\r\n      if (!this.active) {\r\n        return;\r\n      }\r\n\r\n      var chars = this.text.split(''),\r\n          boundaries, ctx;\r\n\r\n      if (this.canvas.contextTop) {\r\n        ctx = this.canvas.contextTop;\r\n        ctx.save();\r\n        ctx.transform.apply(ctx, this.canvas.viewportTransform);\r\n        this.transform(ctx);\r\n        this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);\r\n      }\r\n      else {\r\n        ctx = this.ctx;\r\n        ctx.save();\r\n      }\r\n\r\n      if (this.selectionStart === this.selectionEnd) {\r\n        boundaries = this._getCursorBoundaries(chars, 'cursor');\r\n        this.renderCursor(boundaries, ctx);\r\n      }\r\n      else {\r\n        boundaries = this._getCursorBoundaries(chars, 'selection');\r\n        this.renderSelection(chars, boundaries, ctx);\r\n      }\r\n\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)\r\n     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.\r\n     */\r\n    get2DCursorLocation: function(selectionStart) {\r\n      if (typeof selectionStart === 'undefined') {\r\n        selectionStart = this.selectionStart;\r\n      }\r\n      var len = this._textLines.length;\r\n      for (var i = 0; i < len; i++) {\r\n        if (selectionStart <= this._textLines[i].length) {\r\n          return {\r\n            lineIndex: i,\r\n            charIndex: selectionStart\r\n          };\r\n        }\r\n        selectionStart -= this._textLines[i].length + 1;\r\n      }\r\n      return {\r\n        lineIndex: i - 1,\r\n        charIndex: this._textLines[i - 1].length < selectionStart ? this._textLines[i - 1].length : selectionStart\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Returns complete style of char at the current cursor\r\n     * @param {Number} lineIndex Line index\r\n     * @param {Number} charIndex Char index\r\n     * @return {Object} Character style\r\n     */\r\n    getCurrentCharStyle: function(lineIndex, charIndex) {\r\n      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);\r\n\r\n      return {\r\n        fontSize: style && style.fontSize || this.fontSize,\r\n        fill: style && style.fill || this.fill,\r\n        textBackgroundColor: style && style.textBackgroundColor || this.textBackgroundColor,\r\n        textDecoration: style && style.textDecoration || this.textDecoration,\r\n        fontFamily: style && style.fontFamily || this.fontFamily,\r\n        fontWeight: style && style.fontWeight || this.fontWeight,\r\n        fontStyle: style && style.fontStyle || this.fontStyle,\r\n        stroke: style && style.stroke || this.stroke,\r\n        strokeWidth: style && style.strokeWidth || this.strokeWidth\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Returns fontSize of char at the current cursor\r\n     * @param {Number} lineIndex Line index\r\n     * @param {Number} charIndex Char index\r\n     * @return {Number} Character font size\r\n     */\r\n    getCurrentCharFontSize: function(lineIndex, charIndex) {\r\n      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);\r\n      return style && style.fontSize ? style.fontSize : this.fontSize;\r\n    },\r\n\r\n    /**\r\n     * Returns color (fill) of char at the current cursor\r\n     * @param {Number} lineIndex Line index\r\n     * @param {Number} charIndex Char index\r\n     * @return {String} Character color (fill)\r\n     */\r\n    getCurrentCharColor: function(lineIndex, charIndex) {\r\n      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);\r\n      return style && style.fill ? style.fill : this.cursorColor;\r\n    },\r\n\r\n    /**\r\n     * Returns cursor boundaries (left, top, leftOffset, topOffset)\r\n     * @private\r\n     * @param {Array} chars Array of characters\r\n     * @param {String} typeOfBoundaries\r\n     */\r\n    _getCursorBoundaries: function(chars, typeOfBoundaries) {\r\n\r\n      // left/top are left/top of entire text box\r\n      // leftOffset/topOffset are offset from that left/top point of a text box\r\n\r\n      var left = Math.round(this._getLeftOffset()),\r\n          top = this._getTopOffset(),\r\n\r\n          offsets = this._getCursorBoundariesOffsets(\r\n                      chars, typeOfBoundaries);\r\n\r\n      return {\r\n        left: left,\r\n        top: top,\r\n        leftOffset: offsets.left + offsets.lineLeft,\r\n        topOffset: offsets.top\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getCursorBoundariesOffsets: function(chars, typeOfBoundaries) {\r\n\r\n      var lineLeftOffset = 0,\r\n\r\n          lineIndex = 0,\r\n          charIndex = 0,\r\n          topOffset = 0,\r\n          leftOffset = 0;\r\n\r\n      for (var i = 0; i < this.selectionStart; i++) {\r\n        if (chars[i] === '\\n') {\r\n          leftOffset = 0;\r\n          topOffset += this._getHeightOfLine(this.ctx, lineIndex);\r\n\r\n          lineIndex++;\r\n          charIndex = 0;\r\n        }\r\n        else {\r\n          leftOffset += this._getWidthOfChar(this.ctx, chars[i], lineIndex, charIndex);\r\n          charIndex++;\r\n        }\r\n\r\n        lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex));\r\n      }\r\n      if (typeOfBoundaries === 'cursor') {\r\n        topOffset += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, lineIndex) / this.lineHeight\r\n          - this.getCurrentCharFontSize(lineIndex, charIndex) * (1 - this._fontSizeFraction);\r\n      }\r\n\r\n      return {\r\n        top: topOffset,\r\n        left: leftOffset,\r\n        lineLeft: lineLeftOffset\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Renders cursor\r\n     * @param {Object} boundaries\r\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\r\n     */\r\n    renderCursor: function(boundaries, ctx) {\r\n\r\n      var cursorLocation = this.get2DCursorLocation(),\r\n          lineIndex = cursorLocation.lineIndex,\r\n          charIndex = cursorLocation.charIndex,\r\n          charHeight = this.getCurrentCharFontSize(lineIndex, charIndex),\r\n          leftOffset = (lineIndex === 0 && charIndex === 0)\r\n                    ? this._getLineLeftOffset(this._getLineWidth(ctx, lineIndex))\r\n                    : boundaries.leftOffset;\r\n\r\n      ctx.fillStyle = this.getCurrentCharColor(lineIndex, charIndex);\r\n      ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;\r\n\r\n      ctx.fillRect(\r\n        boundaries.left + leftOffset,\r\n        boundaries.top + boundaries.topOffset,\r\n        this.cursorWidth / this.scaleX,\r\n        charHeight);\r\n\r\n    },\r\n\r\n    /**\r\n     * Renders text selection\r\n     * @param {Array} chars Array of characters\r\n     * @param {Object} boundaries Object with left/top/leftOffset/topOffset\r\n     * @param {CanvasRenderingContext2D} ctx transformed context to draw on\r\n     */\r\n    renderSelection: function(chars, boundaries, ctx) {\r\n\r\n      ctx.fillStyle = this.selectionColor;\r\n\r\n      var start = this.get2DCursorLocation(this.selectionStart),\r\n          end = this.get2DCursorLocation(this.selectionEnd),\r\n          startLine = start.lineIndex,\r\n          endLine = end.lineIndex;\r\n\r\n      for (var i = startLine; i <= endLine; i++) {\r\n        var lineOffset = this._getLineLeftOffset(this._getLineWidth(ctx, i)) || 0,\r\n            lineHeight = this._getHeightOfLine(this.ctx, i),\r\n            boxWidth = 0, line = this._textLines[i];\r\n\r\n        if (i === startLine) {\r\n          for (var j = 0, len = line.length; j < len; j++) {\r\n            if (j >= start.charIndex && (i !== endLine || j < end.charIndex)) {\r\n              boxWidth += this._getWidthOfChar(ctx, line[j], i, j);\r\n            }\r\n            if (j < start.charIndex) {\r\n              lineOffset += this._getWidthOfChar(ctx, line[j], i, j);\r\n            }\r\n          }\r\n        }\r\n        else if (i > startLine && i < endLine) {\r\n          boxWidth += this._getLineWidth(ctx, i) || 5;\r\n        }\r\n        else if (i === endLine) {\r\n          for (var j2 = 0, j2len = end.charIndex; j2 < j2len; j2++) {\r\n            boxWidth += this._getWidthOfChar(ctx, line[j2], i, j2);\r\n          }\r\n        }\r\n\r\n        ctx.fillRect(\r\n          boundaries.left + lineOffset,\r\n          boundaries.top + boundaries.topOffset,\r\n          boxWidth,\r\n          lineHeight);\r\n\r\n        boundaries.topOffset += lineHeight;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} method\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderChars: function(method, ctx, line, left, top, lineIndex, charOffset) {\r\n\r\n      if (this.isEmptyStyles()) {\r\n        return this._renderCharsFast(method, ctx, line, left, top);\r\n      }\r\n\r\n      charOffset = charOffset || 0;\r\n      this.skipTextAlign = true;\r\n\r\n      // set proper box offset\r\n      left -= this.textAlign === 'center'\r\n        ? (this.width / 2)\r\n        : (this.textAlign === 'right')\r\n          ? this.width\r\n          : 0;\r\n\r\n      // set proper line offset\r\n      var lineHeight = this._getHeightOfLine(ctx, lineIndex),\r\n          lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(ctx, lineIndex)),\r\n          prevStyle,\r\n          thisStyle,\r\n          charsToRender = '';\r\n\r\n      left += lineLeftOffset || 0;\r\n\r\n      ctx.save();\r\n      top -= lineHeight / this.lineHeight * this._fontSizeFraction;\r\n      for (var i = charOffset, len = line.length + charOffset; i <= len; i++) {\r\n        prevStyle = prevStyle || this.getCurrentCharStyle(lineIndex, i);\r\n        thisStyle = this.getCurrentCharStyle(lineIndex, i + 1);\r\n\r\n        if (this._hasStyleChanged(prevStyle, thisStyle) || i === len) {\r\n          this._renderChar(method, ctx, lineIndex, i - 1, charsToRender, left, top, lineHeight);\r\n          charsToRender = '';\r\n          prevStyle = thisStyle;\r\n        }\r\n        charsToRender += line[i - charOffset];\r\n      }\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} method\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {String} line Content of the line\r\n     * @param {Number} left Left coordinate\r\n     * @param {Number} top Top coordinate\r\n     */\r\n    _renderCharsFast: function(method, ctx, line, left, top) {\r\n      this.skipTextAlign = false;\r\n\r\n      if (method === 'fillText' && this.fill) {\r\n        this.callSuper('_renderChars', method, ctx, line, left, top);\r\n      }\r\n      if (method === 'strokeText' && ((this.stroke && this.strokeWidth > 0) || this.skipFillStrokeCheck)) {\r\n        this.callSuper('_renderChars', method, ctx, line, left, top);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} method\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Number} lineIndex\r\n     * @param {Number} i\r\n     * @param {String} _char\r\n     * @param {Number} left Left coordinate\r\n     * @param {Number} top Top coordinate\r\n     * @param {Number} lineHeight Height of the line\r\n     */\r\n    _renderChar: function(method, ctx, lineIndex, i, _char, left, top, lineHeight) {\r\n      var charWidth, charHeight,\r\n          decl = this._getStyleDeclaration(lineIndex, i),\r\n          offset = this._fontSizeFraction * lineHeight / this.lineHeight;\r\n\r\n      if (decl) {\r\n        var shouldStroke = decl.stroke || this.stroke,\r\n            shouldFill = decl.fill || this.fill;\r\n\r\n        ctx.save();\r\n        charWidth = this._applyCharStylesGetWidth(ctx, _char, lineIndex, i, decl);\r\n        charHeight = this._getHeightOfChar(ctx, _char, lineIndex, i);\r\n\r\n        if (shouldFill) {\r\n          ctx.fillText(_char, left, top);\r\n        }\r\n        if (shouldStroke) {\r\n          ctx.strokeText(_char, left, top);\r\n        }\r\n\r\n        this._renderCharDecoration(ctx, decl, left, top, offset, charWidth, charHeight);\r\n        ctx.restore();\r\n      }\r\n      else {\r\n        if (method === 'strokeText' && this.stroke) {\r\n          ctx[method](_char, left, top);\r\n        }\r\n        if (method === 'fillText' && this.fill) {\r\n          ctx[method](_char, left, top);\r\n        }\r\n        charWidth = this._applyCharStylesGetWidth(ctx, _char, lineIndex, i);\r\n        this._renderCharDecoration(ctx, null, left, top, offset, charWidth, this.fontSize);\r\n      }\r\n      ctx.translate(charWidth, 0);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} prevStyle\r\n     * @param {Object} thisStyle\r\n     */\r\n    _hasStyleChanged: function(prevStyle, thisStyle) {\r\n      return (prevStyle.fill !== thisStyle.fill ||\r\n              prevStyle.fontSize !== thisStyle.fontSize ||\r\n              prevStyle.textBackgroundColor !== thisStyle.textBackgroundColor ||\r\n              prevStyle.textDecoration !== thisStyle.textDecoration ||\r\n              prevStyle.fontFamily !== thisStyle.fontFamily ||\r\n              prevStyle.fontWeight !== thisStyle.fontWeight ||\r\n              prevStyle.fontStyle !== thisStyle.fontStyle ||\r\n              prevStyle.stroke !== thisStyle.stroke ||\r\n              prevStyle.strokeWidth !== thisStyle.strokeWidth\r\n      );\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderCharDecoration: function(ctx, styleDeclaration, left, top, offset, charWidth, charHeight) {\r\n\r\n      var textDecoration = styleDeclaration\r\n            ? (styleDeclaration.textDecoration || this.textDecoration)\r\n            : this.textDecoration;\r\n\r\n      if (!textDecoration) {\r\n        return;\r\n      }\r\n\r\n      if (textDecoration.indexOf('underline') > -1) {\r\n        ctx.fillRect(\r\n          left,\r\n          top + charHeight / 10,\r\n          charWidth ,\r\n          charHeight / 15\r\n        );\r\n      }\r\n      if (textDecoration.indexOf('line-through') > -1) {\r\n        ctx.fillRect(\r\n          left,\r\n          top - charHeight * (this._fontSizeFraction + this._fontSizeMult - 1) + charHeight / 15,\r\n          charWidth,\r\n          charHeight / 15\r\n        );\r\n      }\r\n      if (textDecoration.indexOf('overline') > -1) {\r\n        ctx.fillRect(\r\n          left,\r\n          top - (this._fontSizeMult - this._fontSizeFraction) * charHeight,\r\n          charWidth,\r\n          charHeight / 15\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {String} method\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {String} line\r\n     */\r\n    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {\r\n      // to \"cancel\" this.fontSize subtraction in fabric.Text#_renderTextLine\r\n      // the adding 0.03 is just to align text with itext by overlap test\r\n      if (!this.isEmptyStyles()) {\r\n        top += this.fontSize * (this._fontSizeFraction + 0.03);\r\n      }\r\n      this.callSuper('_renderTextLine', method, ctx, line, left, top, lineIndex);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextDecoration: function(ctx) {\r\n      if (this.isEmptyStyles()) {\r\n        return this.callSuper('_renderTextDecoration', ctx);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _renderTextLinesBackground: function(ctx) {\r\n      if (!this.textBackgroundColor && !this.styles) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n\r\n      if (this.textBackgroundColor) {\r\n        ctx.fillStyle = this.textBackgroundColor;\r\n      }\r\n\r\n      var lineHeights = 0;\r\n\r\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n\r\n        var heightOfLine = this._getHeightOfLine(ctx, i);\r\n        if (this._textLines[i] === '') {\r\n          lineHeights += heightOfLine;\r\n          continue;\r\n        }\r\n\r\n        var lineWidth = this._getLineWidth(ctx, i),\r\n            lineLeftOffset = this._getLineLeftOffset(lineWidth);\r\n\r\n        if (this.textBackgroundColor) {\r\n          ctx.fillStyle = this.textBackgroundColor;\r\n\r\n          ctx.fillRect(\r\n            this._getLeftOffset() + lineLeftOffset,\r\n            this._getTopOffset() + lineHeights,\r\n            lineWidth,\r\n            heightOfLine / this.lineHeight\r\n          );\r\n        }\r\n        if (this._getLineStyle(i)) {\r\n          for (var j = 0, jlen = this._textLines[i].length; j < jlen; j++) {\r\n            var style = this._getStyleDeclaration(i, j);\r\n            if (style && style.textBackgroundColor) {\r\n\r\n              var _char = this._textLines[i][j];\r\n\r\n              ctx.fillStyle = style.textBackgroundColor;\r\n\r\n              ctx.fillRect(\r\n                this._getLeftOffset() + lineLeftOffset + this._getWidthOfCharsAt(ctx, i, j),\r\n                this._getTopOffset() + lineHeights,\r\n                this._getWidthOfChar(ctx, _char, i, j) + 1,\r\n                heightOfLine / this.lineHeight\r\n              );\r\n            }\r\n          }\r\n        }\r\n        lineHeights += heightOfLine;\r\n      }\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getCacheProp: function(_char, styleDeclaration) {\r\n      return _char +\r\n             styleDeclaration.fontFamily +\r\n             styleDeclaration.fontSize +\r\n             styleDeclaration.fontWeight +\r\n             styleDeclaration.fontStyle +\r\n             styleDeclaration.shadow;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {String} _char\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @param {Object} [decl]\r\n     */\r\n    _applyCharStylesGetWidth: function(ctx, _char, lineIndex, charIndex, decl) {\r\n      var styleDeclaration = decl || this._getStyleDeclaration(lineIndex, charIndex, true);\r\n\r\n      this._applyFontStyles(styleDeclaration);\r\n\r\n      var cacheProp = this._getCacheProp(_char, styleDeclaration);\r\n\r\n      // short-circuit if no styles\r\n      if (this.isEmptyStyles() && this._charWidthsCache[cacheProp] && this.caching) {\r\n        return this._charWidthsCache[cacheProp];\r\n      }\r\n\r\n      if (typeof styleDeclaration.shadow === 'string') {\r\n        styleDeclaration.shadow = new fabric.Shadow(styleDeclaration.shadow);\r\n      }\r\n\r\n      var fill = styleDeclaration.fill || this.fill;\r\n      ctx.fillStyle = fill.toLive\r\n        ? fill.toLive(ctx, this)\r\n        : fill;\r\n\r\n      if (styleDeclaration.stroke) {\r\n        ctx.strokeStyle = (styleDeclaration.stroke && styleDeclaration.stroke.toLive)\r\n          ? styleDeclaration.stroke.toLive(ctx, this)\r\n          : styleDeclaration.stroke;\r\n      }\r\n\r\n      ctx.lineWidth = styleDeclaration.strokeWidth || this.strokeWidth;\r\n      ctx.font = this._getFontDeclaration.call(styleDeclaration);\r\n      this._setShadow.call(styleDeclaration, ctx);\r\n\r\n      if (!this.caching) {\r\n        return ctx.measureText(_char).width;\r\n      }\r\n\r\n      if (!this._charWidthsCache[cacheProp]) {\r\n        this._charWidthsCache[cacheProp] = ctx.measureText(_char).width;\r\n      }\r\n\r\n      return this._charWidthsCache[cacheProp];\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {Object} styleDeclaration\r\n     */\r\n    _applyFontStyles: function(styleDeclaration) {\r\n      if (!styleDeclaration.fontFamily) {\r\n        styleDeclaration.fontFamily = this.fontFamily;\r\n      }\r\n      if (!styleDeclaration.fontSize) {\r\n        styleDeclaration.fontSize = this.fontSize;\r\n      }\r\n      if (!styleDeclaration.fontWeight) {\r\n        styleDeclaration.fontWeight = this.fontWeight;\r\n      }\r\n      if (!styleDeclaration.fontStyle) {\r\n        styleDeclaration.fontStyle = this.fontStyle;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @param {Boolean} [returnCloneOrEmpty=false]\r\n     * @private\r\n     */\r\n    _getStyleDeclaration: function(lineIndex, charIndex, returnCloneOrEmpty) {\r\n      if (returnCloneOrEmpty) {\r\n        return (this.styles[lineIndex] && this.styles[lineIndex][charIndex])\r\n          ? clone(this.styles[lineIndex][charIndex])\r\n          : { };\r\n      }\r\n\r\n      return this.styles[lineIndex] && this.styles[lineIndex][charIndex] ? this.styles[lineIndex][charIndex] : null;\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @param {Object} style\r\n     * @private\r\n     */\r\n    _setStyleDeclaration: function(lineIndex, charIndex, style) {\r\n      this.styles[lineIndex][charIndex] = style;\r\n    },\r\n\r\n    /**\r\n     *\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @private\r\n     */\r\n    _deleteStyleDeclaration: function(lineIndex, charIndex) {\r\n      delete this.styles[lineIndex][charIndex];\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @private\r\n     */\r\n    _getLineStyle: function(lineIndex) {\r\n      return this.styles[lineIndex];\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Object} style\r\n     * @private\r\n     */\r\n    _setLineStyle: function(lineIndex, style) {\r\n      this.styles[lineIndex] = style;\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @private\r\n     */\r\n    _deleteLineStyle: function(lineIndex) {\r\n      delete this.styles[lineIndex];\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getWidthOfChar: function(ctx, _char, lineIndex, charIndex) {\r\n      if (this.textAlign === 'justify' && this._reSpacesAndTabs.test(_char)) {\r\n        return this._getWidthOfSpace(ctx, lineIndex);\r\n      }\r\n\r\n      var styleDeclaration = this._getStyleDeclaration(lineIndex, charIndex, true);\r\n      this._applyFontStyles(styleDeclaration);\r\n      var cacheProp = this._getCacheProp(_char, styleDeclaration);\r\n\r\n      if (this._charWidthsCache[cacheProp] && this.caching) {\r\n        return this._charWidthsCache[cacheProp];\r\n      }\r\n      else if (ctx) {\r\n        ctx.save();\r\n        var width = this._applyCharStylesGetWidth(ctx, _char, lineIndex, charIndex);\r\n        ctx.restore();\r\n        return width;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getHeightOfChar: function(ctx, _char, lineIndex, charIndex) {\r\n      var style = this._getStyleDeclaration(lineIndex, charIndex);\r\n      return style && style.fontSize ? style.fontSize : this.fontSize;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getHeightOfCharAt: function(ctx, lineIndex, charIndex) {\r\n      var _char = this._textLines[lineIndex][charIndex];\r\n      return this._getHeightOfChar(ctx, _char, lineIndex, charIndex);\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getWidthOfCharsAt: function(ctx, lineIndex, charIndex) {\r\n      var width = 0, i, _char;\r\n      for (i = 0; i < charIndex; i++) {\r\n        _char = this._textLines[lineIndex][i];\r\n        width += this._getWidthOfChar(ctx, _char, lineIndex, i);\r\n      }\r\n      return width;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getLineWidth: function(ctx, lineIndex) {\r\n      if (this.__lineWidths[lineIndex]) {\r\n        return this.__lineWidths[lineIndex];\r\n      }\r\n      this.__lineWidths[lineIndex] = this._getWidthOfCharsAt(ctx, lineIndex, this._textLines[lineIndex].length);\r\n      return this.__lineWidths[lineIndex];\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Number} lineIndex\r\n     */\r\n    _getWidthOfSpace: function (ctx, lineIndex) {\r\n      if (this.__widthOfSpace[lineIndex]) {\r\n        return this.__widthOfSpace[lineIndex];\r\n      }\r\n      var line = this._textLines[lineIndex],\r\n          wordsWidth = this._getWidthOfWords(ctx, line, lineIndex),\r\n          widthDiff = this.width - wordsWidth,\r\n          numSpaces = line.length - line.replace(this._reSpacesAndTabs, '').length,\r\n          width = widthDiff / numSpaces;\r\n      this.__widthOfSpace[lineIndex] = width;\r\n      return width;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     * @param {Number} line\r\n     * @param {Number} lineIndex\r\n     */\r\n    _getWidthOfWords: function (ctx, line, lineIndex) {\r\n      var width = 0;\r\n\r\n      for (var charIndex = 0; charIndex < line.length; charIndex++) {\r\n        var _char = line[charIndex];\r\n\r\n        if (!_char.match(/\\s/)) {\r\n          width += this._getWidthOfChar(ctx, _char, lineIndex, charIndex);\r\n        }\r\n      }\r\n\r\n      return width;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getHeightOfLine: function(ctx, lineIndex) {\r\n      if (this.__lineHeights[lineIndex]) {\r\n        return this.__lineHeights[lineIndex];\r\n      }\r\n\r\n      var line = this._textLines[lineIndex],\r\n          maxHeight = this._getHeightOfChar(ctx, line[0], lineIndex, 0);\r\n\r\n      for (var i = 1, len = line.length; i < len; i++) {\r\n        var currentCharHeight = this._getHeightOfChar(ctx, line[i], lineIndex, i);\r\n        if (currentCharHeight > maxHeight) {\r\n          maxHeight = currentCharHeight;\r\n        }\r\n      }\r\n      this.__maxFontHeights[lineIndex] = maxHeight;\r\n      this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;\r\n      return this.__lineHeights[lineIndex];\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     * @param {CanvasRenderingContext2D} ctx Context to render on\r\n     */\r\n    _getTextHeight: function(ctx) {\r\n      var height = 0;\r\n      for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n        height += this._getHeightOfLine(ctx, i);\r\n      }\r\n      return height;\r\n    },\r\n\r\n    /**\r\n     * This method is overwritten to account for different top offset\r\n     * @private\r\n     */\r\n    _renderTextBoxBackground: function(ctx) {\r\n      if (!this.backgroundColor) {\r\n        return;\r\n      }\r\n\r\n      ctx.save();\r\n      ctx.fillStyle = this.backgroundColor;\r\n\r\n      ctx.fillRect(\r\n        this._getLeftOffset(),\r\n        this._getTopOffset(),\r\n        this.width,\r\n        this.height\r\n      );\r\n\r\n      ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @method toObject\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      var clonedStyles = { }, i, j, row;\r\n      for (i in this.styles) {\r\n        row = this.styles[i];\r\n        clonedStyles[i] = { };\r\n        for (j in row) {\r\n          clonedStyles[i][j] = clone(row[j]);\r\n        }\r\n      }\r\n      return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {\r\n        styles: clonedStyles\r\n      });\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Returns fabric.IText instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.IText\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.IText} instance of fabric.IText\r\n   */\r\n  fabric.IText.fromObject = function(object) {\r\n    return new fabric.IText(object.text, clone(object));\r\n  };\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  var clone = fabric.util.object.clone;\r\n\r\n  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\r\n\r\n    /**\r\n     * Initializes all the interactive behavior of IText\r\n     */\r\n    initBehavior: function() {\r\n      this.initAddedHandler();\r\n      this.initRemovedHandler();\r\n      this.initCursorSelectionHandlers();\r\n      this.initDoubleClickSimulation();\r\n    },\r\n\r\n    /**\r\n     * Initializes \"selected\" event handler\r\n     */\r\n    initSelectedHandler: function() {\r\n      this.on('selected', function() {\r\n\r\n        var _this = this;\r\n        setTimeout(function() {\r\n          _this.selected = true;\r\n        }, 100);\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Initializes \"added\" event handler\r\n     */\r\n    initAddedHandler: function() {\r\n      var _this = this;\r\n      this.on('added', function() {\r\n        if (this.canvas && !this.canvas._hasITextHandlers) {\r\n          this.canvas._hasITextHandlers = true;\r\n          this._initCanvasHandlers();\r\n        }\r\n\r\n        // Track IText instances per-canvas. Only register in this array once added\r\n        // to a canvas; we don't want to leak a reference to the instance forever\r\n        // simply because it existed at some point.\r\n        // (Might be added to a collection, but not on a canvas.)\r\n        if (_this.canvas) {\r\n          _this.canvas._iTextInstances = _this.canvas._iTextInstances || [];\r\n          _this.canvas._iTextInstances.push(_this);\r\n        }\r\n      });\r\n    },\r\n\r\n    initRemovedHandler: function() {\r\n      var _this = this;\r\n      this.on('removed', function() {\r\n        // (Might be removed from a collection, but not on a canvas.)\r\n        if (_this.canvas) {\r\n          _this.canvas._iTextInstances = _this.canvas._iTextInstances || [];\r\n          fabric.util.removeFromArray(_this.canvas._iTextInstances, _this);\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _initCanvasHandlers: function() {\r\n      var _this = this;\r\n\r\n      this.canvas.on('selection:cleared', function() {\r\n        fabric.IText.prototype.exitEditingOnOthers(_this.canvas);\r\n      });\r\n\r\n      this.canvas.on('mouse:up', function() {\r\n        if (_this.canvas._iTextInstances) {\r\n          _this.canvas._iTextInstances.forEach(function(obj) {\r\n            obj.__isMousedown = false;\r\n          });\r\n        }\r\n      });\r\n\r\n      this.canvas.on('object:selected', function() {\r\n        fabric.IText.prototype.exitEditingOnOthers(_this.canvas);\r\n      });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _tick: function() {\r\n      this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _animateCursor: function(obj, targetOpacity, duration, completeMethod) {\r\n\r\n      var tickState;\r\n\r\n      tickState = {\r\n        isAborted: false,\r\n        abort: function() {\r\n          this.isAborted = true;\r\n        },\r\n      };\r\n\r\n      obj.animate('_currentCursorOpacity', targetOpacity, {\r\n        duration: duration,\r\n        onComplete: function() {\r\n          if (!tickState.isAborted) {\r\n            obj[completeMethod]();\r\n          }\r\n        },\r\n        onChange: function() {\r\n          if (obj.canvas) {\r\n            obj.canvas.clearContext(obj.canvas.contextTop || obj.ctx);\r\n            obj.renderCursorOrSelection();\r\n          }\r\n        },\r\n        abort: function() {\r\n          return tickState.isAborted;\r\n        }\r\n      });\r\n      return tickState;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _onTickComplete: function() {\r\n\r\n      var _this = this;\r\n\r\n      if (this._cursorTimeout1) {\r\n        clearTimeout(this._cursorTimeout1);\r\n      }\r\n      this._cursorTimeout1 = setTimeout(function() {\r\n        _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');\r\n      }, 100);\r\n    },\r\n\r\n    /**\r\n     * Initializes delayed cursor\r\n     */\r\n    initDelayedCursor: function(restart) {\r\n      var _this = this,\r\n          delay = restart ? 0 : this.cursorDelay;\r\n\r\n      this._currentTickState && this._currentTickState.abort();\r\n      this._currentTickCompleteState && this._currentTickCompleteState.abort();\r\n      clearTimeout(this._cursorTimeout1);\r\n      this._currentCursorOpacity = 1;\r\n      if (this.canvas) {\r\n        this.canvas.clearContext(this.canvas.contextTop || this.ctx);\r\n        this.renderCursorOrSelection();\r\n      }\r\n      if (this._cursorTimeout2) {\r\n        clearTimeout(this._cursorTimeout2);\r\n      }\r\n      this._cursorTimeout2 = setTimeout(function() {\r\n        _this._tick();\r\n      }, delay);\r\n    },\r\n\r\n    /**\r\n     * Aborts cursor animation and clears all timeouts\r\n     */\r\n    abortCursorAnimation: function() {\r\n      this._currentTickState && this._currentTickState.abort();\r\n      this._currentTickCompleteState && this._currentTickCompleteState.abort();\r\n\r\n      clearTimeout(this._cursorTimeout1);\r\n      clearTimeout(this._cursorTimeout2);\r\n\r\n      this._currentCursorOpacity = 0;\r\n      this.canvas && this.canvas.clearContext(this.canvas.contextTop || this.ctx);\r\n    },\r\n\r\n    /**\r\n     * Selects entire text\r\n     */\r\n    selectAll: function() {\r\n      this.setSelectionStart(0);\r\n      this.setSelectionEnd(this.text.length);\r\n    },\r\n\r\n    /**\r\n     * Returns selected text\r\n     * @return {String}\r\n     */\r\n    getSelectedText: function() {\r\n      return this.text.slice(this.selectionStart, this.selectionEnd);\r\n    },\r\n\r\n    /**\r\n     * Find new selection index representing start of current word according to current selection index\r\n     * @param {Number} startFrom Surrent selection index\r\n     * @return {Number} New selection index\r\n     */\r\n    findWordBoundaryLeft: function(startFrom) {\r\n      var offset = 0, index = startFrom - 1;\r\n\r\n      // remove space before cursor first\r\n      if (this._reSpace.test(this.text.charAt(index))) {\r\n        while (this._reSpace.test(this.text.charAt(index))) {\r\n          offset++;\r\n          index--;\r\n        }\r\n      }\r\n      while (/\\S/.test(this.text.charAt(index)) && index > -1) {\r\n        offset++;\r\n        index--;\r\n      }\r\n\r\n      return startFrom - offset;\r\n    },\r\n\r\n    /**\r\n     * Find new selection index representing end of current word according to current selection index\r\n     * @param {Number} startFrom Current selection index\r\n     * @return {Number} New selection index\r\n     */\r\n    findWordBoundaryRight: function(startFrom) {\r\n      var offset = 0, index = startFrom;\r\n\r\n      // remove space after cursor first\r\n      if (this._reSpace.test(this.text.charAt(index))) {\r\n        while (this._reSpace.test(this.text.charAt(index))) {\r\n          offset++;\r\n          index++;\r\n        }\r\n      }\r\n      while (/\\S/.test(this.text.charAt(index)) && index < this.text.length) {\r\n        offset++;\r\n        index++;\r\n      }\r\n\r\n      return startFrom + offset;\r\n    },\r\n\r\n    /**\r\n     * Find new selection index representing start of current line according to current selection index\r\n     * @param {Number} startFrom Current selection index\r\n     * @return {Number} New selection index\r\n     */\r\n    findLineBoundaryLeft: function(startFrom) {\r\n      var offset = 0, index = startFrom - 1;\r\n\r\n      while (!/\\n/.test(this.text.charAt(index)) && index > -1) {\r\n        offset++;\r\n        index--;\r\n      }\r\n\r\n      return startFrom - offset;\r\n    },\r\n\r\n    /**\r\n     * Find new selection index representing end of current line according to current selection index\r\n     * @param {Number} startFrom Current selection index\r\n     * @return {Number} New selection index\r\n     */\r\n    findLineBoundaryRight: function(startFrom) {\r\n      var offset = 0, index = startFrom;\r\n\r\n      while (!/\\n/.test(this.text.charAt(index)) && index < this.text.length) {\r\n        offset++;\r\n        index++;\r\n      }\r\n\r\n      return startFrom + offset;\r\n    },\r\n\r\n    /**\r\n     * Returns number of newlines in selected text\r\n     * @return {Number} Number of newlines in selected text\r\n     */\r\n    getNumNewLinesInSelectedText: function() {\r\n      var selectedText = this.getSelectedText(),\r\n          numNewLines  = 0;\r\n\r\n      for (var i = 0, len = selectedText.length; i < len; i++) {\r\n        if (selectedText[i] === '\\n') {\r\n          numNewLines++;\r\n        }\r\n      }\r\n      return numNewLines;\r\n    },\r\n\r\n    /**\r\n     * Finds index corresponding to beginning or end of a word\r\n     * @param {Number} selectionStart Index of a character\r\n     * @param {Number} direction 1 or -1\r\n     * @return {Number} Index of the beginning or end of a word\r\n     */\r\n    searchWordBoundary: function(selectionStart, direction) {\r\n      var index     = this._reSpace.test(this.text.charAt(selectionStart)) ? selectionStart - 1 : selectionStart,\r\n          _char     = this.text.charAt(index),\r\n          reNonWord = /[ \\n\\.,;!\\?\\-]/;\r\n\r\n      while (!reNonWord.test(_char) && index > 0 && index < this.text.length) {\r\n        index += direction;\r\n        _char = this.text.charAt(index);\r\n      }\r\n      if (reNonWord.test(_char) && _char !== '\\n') {\r\n        index += direction === 1 ? 0 : 1;\r\n      }\r\n      return index;\r\n    },\r\n\r\n    /**\r\n     * Selects a word based on the index\r\n     * @param {Number} selectionStart Index of a character\r\n     */\r\n    selectWord: function(selectionStart) {\r\n      var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */\r\n          newSelectionEnd   = this.searchWordBoundary(selectionStart, 1);\r\n      /* search forward */\r\n\r\n      this.setSelectionStart(newSelectionStart);\r\n      this.setSelectionEnd(newSelectionEnd);\r\n    },\r\n\r\n    /**\r\n     * Selects a line based on the index\r\n     * @param {Number} selectionStart Index of a character\r\n     */\r\n    selectLine: function(selectionStart) {\r\n      var newSelectionStart = this.findLineBoundaryLeft(selectionStart),\r\n          newSelectionEnd   = this.findLineBoundaryRight(selectionStart);\r\n\r\n      this.setSelectionStart(newSelectionStart);\r\n      this.setSelectionEnd(newSelectionEnd);\r\n    },\r\n\r\n    /**\r\n     * Enters editing state\r\n     * @return {fabric.IText} thisArg\r\n     * @chainable\r\n     */\r\n    enterEditing: function() {\r\n      if (this.isEditing || !this.editable) {\r\n        return;\r\n      }\r\n\r\n      if (this.canvas) {\r\n        this.exitEditingOnOthers(this.canvas);\r\n      }\r\n\r\n      this.isEditing = true;\r\n\r\n      this.initHiddenTextarea();\r\n      this.hiddenTextarea.focus();\r\n      this._updateTextarea();\r\n      this._saveEditingProps();\r\n      this._setEditingProps();\r\n\r\n      this._tick();\r\n      this.fire('editing:entered');\r\n\r\n      if (!this.canvas) {\r\n        return this;\r\n      }\r\n\r\n      this.canvas.renderAll();\r\n      this.canvas.fire('text:editing:entered', { target: this });\r\n      this.initMouseMoveHandler();\r\n      return this;\r\n    },\r\n\r\n    exitEditingOnOthers: function(canvas) {\r\n      if (canvas._iTextInstances) {\r\n        canvas._iTextInstances.forEach(function(obj) {\r\n          obj.selected = false;\r\n          if (obj.isEditing) {\r\n            obj.exitEditing();\r\n          }\r\n        });\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Initializes \"mousemove\" event handler\r\n     */\r\n    initMouseMoveHandler: function() {\r\n      var _this = this;\r\n      this.canvas.on('mouse:move', function(options) {\r\n        if (!_this.__isMousedown || !_this.isEditing) {\r\n          return;\r\n        }\r\n\r\n        var newSelectionStart = _this.getSelectionStartFromPointer(options.e);\r\n        if (newSelectionStart >= _this.__selectionStartOnMouseDown) {\r\n          _this.setSelectionStart(_this.__selectionStartOnMouseDown);\r\n          _this.setSelectionEnd(newSelectionStart);\r\n        }\r\n        else {\r\n          _this.setSelectionStart(newSelectionStart);\r\n          _this.setSelectionEnd(_this.__selectionStartOnMouseDown);\r\n        }\r\n      });\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setEditingProps: function() {\r\n      this.hoverCursor = 'text';\r\n\r\n      if (this.canvas) {\r\n        this.canvas.defaultCursor = this.canvas.moveCursor = 'text';\r\n      }\r\n\r\n      this.borderColor = this.editingBorderColor;\r\n\r\n      this.hasControls = this.selectable = false;\r\n      this.lockMovementX = this.lockMovementY = true;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _updateTextarea: function() {\r\n      if (!this.hiddenTextarea) {\r\n        return;\r\n      }\r\n\r\n      this.hiddenTextarea.value = this.text;\r\n      this.hiddenTextarea.selectionStart = this.selectionStart;\r\n      this.hiddenTextarea.selectionEnd = this.selectionEnd;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _saveEditingProps: function() {\r\n      this._savedProps = {\r\n        hasControls: this.hasControls,\r\n        borderColor: this.borderColor,\r\n        lockMovementX: this.lockMovementX,\r\n        lockMovementY: this.lockMovementY,\r\n        hoverCursor: this.hoverCursor,\r\n        defaultCursor: this.canvas && this.canvas.defaultCursor,\r\n        moveCursor: this.canvas && this.canvas.moveCursor\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _restoreEditingProps: function() {\r\n      if (!this._savedProps) {\r\n        return;\r\n      }\r\n\r\n      this.hoverCursor = this._savedProps.overCursor;\r\n      this.hasControls = this._savedProps.hasControls;\r\n      this.borderColor = this._savedProps.borderColor;\r\n      this.lockMovementX = this._savedProps.lockMovementX;\r\n      this.lockMovementY = this._savedProps.lockMovementY;\r\n\r\n      if (this.canvas) {\r\n        this.canvas.defaultCursor = this._savedProps.defaultCursor;\r\n        this.canvas.moveCursor = this._savedProps.moveCursor;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Exits from editing state\r\n     * @return {fabric.IText} thisArg\r\n     * @chainable\r\n     */\r\n    exitEditing: function() {\r\n\r\n      this.selected = false;\r\n      this.isEditing = false;\r\n      this.selectable = true;\r\n\r\n      this.selectionEnd = this.selectionStart;\r\n      this.hiddenTextarea && this.canvas && this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea);\r\n      this.hiddenTextarea = null;\r\n\r\n      this.abortCursorAnimation();\r\n      this._restoreEditingProps();\r\n      this._currentCursorOpacity = 0;\r\n\r\n      this.fire('editing:exited');\r\n      this.canvas && this.canvas.fire('text:editing:exited', { target: this });\r\n\r\n      return this;\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _removeExtraneousStyles: function() {\r\n      for (var prop in this.styles) {\r\n        if (!this._textLines[prop]) {\r\n          delete this.styles[prop];\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _removeCharsFromTo: function(start, end) {\r\n      while (end !== start) {\r\n        this._removeSingleCharAndStyle(start + 1);\r\n        end--;\r\n      }\r\n      this.setSelectionStart(start);\r\n    },\r\n\r\n    _removeSingleCharAndStyle: function(index) {\r\n      var isBeginningOfLine = this.text[index - 1] === '\\n',\r\n          indexStyle        = isBeginningOfLine ? index : index - 1;\r\n      this.removeStyleObject(isBeginningOfLine, indexStyle);\r\n      this.text = this.text.slice(0, index - 1) +\r\n        this.text.slice(index);\r\n\r\n      this._textLines = this._splitTextIntoLines();\r\n    },\r\n\r\n    /**\r\n     * Inserts characters where cursor is (replacing selection if one exists)\r\n     * @param {String} _chars Characters to insert\r\n     * @param {Boolean} useCopiedStyle use fabric.copiedTextStyle\r\n     */\r\n    insertChars: function(_chars, useCopiedStyle) {\r\n      var style;\r\n\r\n      if (this.selectionEnd - this.selectionStart > 1) {\r\n        this._removeCharsFromTo(this.selectionStart, this.selectionEnd);\r\n        this.setSelectionEnd(this.selectionStart);\r\n      }\r\n\r\n      for (var i = 0, len = _chars.length; i < len; i++) {\r\n        if (useCopiedStyle) {\r\n          style = fabric.copiedTextStyle[i];\r\n        }\r\n        this.insertChar(_chars[i], i < len - 1, style);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Inserts a character where cursor is\r\n     * @param {String} _char Characters to insert\r\n     * @param {Boolean} skipUpdate trigger rendering and updates at the end of text insert\r\n     * @param {Object} styleObject Style to be inserted for the new char\r\n     */\r\n    insertChar: function(_char, skipUpdate, styleObject) {\r\n      var isEndOfLine = this.text[this.selectionStart] === '\\n';\r\n      this.text = this.text.slice(0, this.selectionStart) +\r\n        _char + this.text.slice(this.selectionEnd);\r\n      this._textLines = this._splitTextIntoLines();\r\n      this.insertStyleObjects(_char, isEndOfLine, styleObject);\r\n      this.selectionStart += 1;\r\n      this.selectionEnd = this.selectionStart;\r\n      if (skipUpdate) {\r\n        return;\r\n      }\r\n      this._updateTextarea();\r\n      this.canvas && this.canvas.renderAll();\r\n      this.setCoords();\r\n      this.fire('changed');\r\n      this.canvas && this.canvas.fire('text:changed', { target: this });\r\n    },\r\n\r\n    /**\r\n     * Inserts new style object\r\n     * @param {Number} lineIndex Index of a line\r\n     * @param {Number} charIndex Index of a char\r\n     * @param {Boolean} isEndOfLine True if it's end of line\r\n     */\r\n    insertNewlineStyleObject: function(lineIndex, charIndex, isEndOfLine) {\r\n\r\n      this.shiftLineStyles(lineIndex, +1);\r\n\r\n      if (!this.styles[lineIndex + 1]) {\r\n        this.styles[lineIndex + 1] = {};\r\n      }\r\n\r\n      var currentCharStyle = {},\r\n          newLineStyles    = {};\r\n\r\n      if (this.styles[lineIndex] && this.styles[lineIndex][charIndex - 1]) {\r\n        currentCharStyle = this.styles[lineIndex][charIndex - 1];\r\n      }\r\n\r\n      // if there's nothing after cursor,\r\n      // we clone current char style onto the next (otherwise empty) line\r\n      if (isEndOfLine) {\r\n        newLineStyles[0] = clone(currentCharStyle);\r\n        this.styles[lineIndex + 1] = newLineStyles;\r\n      }\r\n      // otherwise we clone styles of all chars\r\n      // after cursor onto the next line, from the beginning\r\n      else {\r\n        for (var index in this.styles[lineIndex]) {\r\n          if (parseInt(index, 10) >= charIndex) {\r\n            newLineStyles[parseInt(index, 10) - charIndex] = this.styles[lineIndex][index];\r\n            // remove lines from the previous line since they're on a new line now\r\n            delete this.styles[lineIndex][index];\r\n          }\r\n        }\r\n        this.styles[lineIndex + 1] = newLineStyles;\r\n      }\r\n      this._forceClearCache = true;\r\n    },\r\n\r\n    /**\r\n     * Inserts style object for a given line/char index\r\n     * @param {Number} lineIndex Index of a line\r\n     * @param {Number} charIndex Index of a char\r\n     * @param {Object} [style] Style object to insert, if given\r\n     */\r\n    insertCharStyleObject: function(lineIndex, charIndex, style) {\r\n\r\n      var currentLineStyles       = this.styles[lineIndex],\r\n          currentLineStylesCloned = clone(currentLineStyles);\r\n\r\n      if (charIndex === 0 && !style) {\r\n        charIndex = 1;\r\n      }\r\n\r\n      // shift all char styles by 1 forward\r\n      // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4\r\n      for (var index in currentLineStylesCloned) {\r\n        var numericIndex = parseInt(index, 10);\r\n\r\n        if (numericIndex >= charIndex) {\r\n          currentLineStyles[numericIndex + 1] = currentLineStylesCloned[numericIndex];\r\n\r\n          // only delete the style if there was nothing moved there\r\n          if (!currentLineStylesCloned[numericIndex - 1]) {\r\n            delete currentLineStyles[numericIndex];\r\n          }\r\n        }\r\n      }\r\n\r\n      this.styles[lineIndex][charIndex] =\r\n        style || clone(currentLineStyles[charIndex - 1]);\r\n      this._forceClearCache = true;\r\n    },\r\n\r\n    /**\r\n     * Inserts style object(s)\r\n     * @param {String} _chars Characters at the location where style is inserted\r\n     * @param {Boolean} isEndOfLine True if it's end of line\r\n     * @param {Object} [styleObject] Style to insert\r\n     */\r\n    insertStyleObjects: function(_chars, isEndOfLine, styleObject) {\r\n      // removed shortcircuit over isEmptyStyles\r\n\r\n      var cursorLocation = this.get2DCursorLocation(),\r\n          lineIndex      = cursorLocation.lineIndex,\r\n          charIndex      = cursorLocation.charIndex;\r\n\r\n      if (!this._getLineStyle(lineIndex)) {\r\n        this._setLineStyle(lineIndex, {});\r\n      }\r\n\r\n      if (_chars === '\\n') {\r\n        this.insertNewlineStyleObject(lineIndex, charIndex, isEndOfLine);\r\n      }\r\n      else {\r\n        this.insertCharStyleObject(lineIndex, charIndex, styleObject);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Shifts line styles up or down\r\n     * @param {Number} lineIndex Index of a line\r\n     * @param {Number} offset Can be -1 or +1\r\n     */\r\n    shiftLineStyles: function(lineIndex, offset) {\r\n      // shift all line styles by 1 upward\r\n      var clonedStyles = clone(this.styles);\r\n      for (var line in this.styles) {\r\n        var numericLine = parseInt(line, 10);\r\n        if (numericLine > lineIndex) {\r\n          this.styles[numericLine + offset] = clonedStyles[numericLine];\r\n          if (!clonedStyles[numericLine - offset]) {\r\n            delete this.styles[numericLine];\r\n          }\r\n        }\r\n      }\r\n      //TODO: evaluate if delete old style lines with offset -1\r\n    },\r\n\r\n    /**\r\n     * Removes style object\r\n     * @param {Boolean} isBeginningOfLine True if cursor is at the beginning of line\r\n     * @param {Number} [index] Optional index. When not given, current selectionStart is used.\r\n     */\r\n    removeStyleObject: function(isBeginningOfLine, index) {\r\n\r\n      var cursorLocation = this.get2DCursorLocation(index),\r\n          lineIndex      = cursorLocation.lineIndex,\r\n          charIndex      = cursorLocation.charIndex;\r\n\r\n      if (isBeginningOfLine) {\r\n\r\n        var textOnPreviousLine     = this._textLines[lineIndex - 1],\r\n            newCharIndexOnPrevLine = textOnPreviousLine\r\n              ? textOnPreviousLine.length\r\n              : 0;\r\n\r\n        if (!this.styles[lineIndex - 1]) {\r\n          this.styles[lineIndex - 1] = {};\r\n        }\r\n\r\n        for (charIndex in this.styles[lineIndex]) {\r\n          this.styles[lineIndex - 1][parseInt(charIndex, 10) + newCharIndexOnPrevLine]\r\n            = this.styles[lineIndex][charIndex];\r\n        }\r\n\r\n        this.shiftLineStyles(lineIndex, -1);\r\n\r\n      }\r\n      else {\r\n        var currentLineStyles = this.styles[lineIndex];\r\n\r\n        if (currentLineStyles) {\r\n          delete currentLineStyles[charIndex];\r\n          //console.log('deleting', lineIndex, charIndex + offset);\r\n        }\r\n\r\n        var currentLineStylesCloned = clone(currentLineStyles);\r\n\r\n        // shift all styles by 1 backwards\r\n        for (var i in currentLineStylesCloned) {\r\n          var numericIndex = parseInt(i, 10);\r\n          if (numericIndex >= charIndex && numericIndex !== 0) {\r\n            currentLineStyles[numericIndex - 1] = currentLineStylesCloned[numericIndex];\r\n            delete currentLineStyles[numericIndex];\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Inserts new line\r\n     */\r\n    insertNewline: function() {\r\n      this.insertChars('\\n');\r\n    }\r\n  });\r\n})();\r\n\r\n\r\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\r\n  /**\r\n   * Initializes \"dbclick\" event handler\r\n   */\r\n  initDoubleClickSimulation: function() {\r\n\r\n    // for double click\r\n    this.__lastClickTime = +new Date();\r\n\r\n    // for triple click\r\n    this.__lastLastClickTime = +new Date();\r\n\r\n    this.__lastPointer = { };\r\n\r\n    this.on('mousedown', this.onMouseDown.bind(this));\r\n  },\r\n\r\n  onMouseDown: function(options) {\r\n\r\n    this.__newClickTime = +new Date();\r\n    var newPointer = this.canvas.getPointer(options.e);\r\n\r\n    if (this.isTripleClick(newPointer)) {\r\n      this.fire('tripleclick', options);\r\n      this._stopEvent(options.e);\r\n    }\r\n    else if (this.isDoubleClick(newPointer)) {\r\n      this.fire('dblclick', options);\r\n      this._stopEvent(options.e);\r\n    }\r\n\r\n    this.__lastLastClickTime = this.__lastClickTime;\r\n    this.__lastClickTime = this.__newClickTime;\r\n    this.__lastPointer = newPointer;\r\n    this.__lastIsEditing = this.isEditing;\r\n    this.__lastSelected = this.selected;\r\n  },\r\n\r\n  isDoubleClick: function(newPointer) {\r\n    return this.__newClickTime - this.__lastClickTime < 500 &&\r\n        this.__lastPointer.x === newPointer.x &&\r\n        this.__lastPointer.y === newPointer.y && this.__lastIsEditing;\r\n  },\r\n\r\n  isTripleClick: function(newPointer) {\r\n    return this.__newClickTime - this.__lastClickTime < 500 &&\r\n        this.__lastClickTime - this.__lastLastClickTime < 500 &&\r\n        this.__lastPointer.x === newPointer.x &&\r\n        this.__lastPointer.y === newPointer.y;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _stopEvent: function(e) {\r\n    e.preventDefault && e.preventDefault();\r\n    e.stopPropagation && e.stopPropagation();\r\n  },\r\n\r\n  /**\r\n   * Initializes event handlers related to cursor or selection\r\n   */\r\n  initCursorSelectionHandlers: function() {\r\n    this.initSelectedHandler();\r\n    this.initMousedownHandler();\r\n    this.initMouseupHandler();\r\n    this.initClicks();\r\n  },\r\n\r\n  /**\r\n   * Initializes double and triple click event handlers\r\n   */\r\n  initClicks: function() {\r\n    this.on('dblclick', function(options) {\r\n      this.selectWord(this.getSelectionStartFromPointer(options.e));\r\n    });\r\n    this.on('tripleclick', function(options) {\r\n      this.selectLine(this.getSelectionStartFromPointer(options.e));\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Initializes \"mousedown\" event handler\r\n   */\r\n  initMousedownHandler: function() {\r\n    this.on('mousedown', function(options) {\r\n\r\n      var pointer = this.canvas.getPointer(options.e);\r\n\r\n      this.__mousedownX = pointer.x;\r\n      this.__mousedownY = pointer.y;\r\n      this.__isMousedown = true;\r\n\r\n      if (this.hiddenTextarea && this.canvas) {\r\n        this.canvas.wrapperEl.appendChild(this.hiddenTextarea);\r\n      }\r\n\r\n      if (this.selected) {\r\n        this.setCursorByClick(options.e);\r\n      }\r\n\r\n      if (this.isEditing) {\r\n        this.__selectionStartOnMouseDown = this.selectionStart;\r\n        this.initDelayedCursor(true);\r\n      }\r\n    });\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _isObjectMoved: function(e) {\r\n    var pointer = this.canvas.getPointer(e);\r\n\r\n    return this.__mousedownX !== pointer.x ||\r\n           this.__mousedownY !== pointer.y;\r\n  },\r\n\r\n  /**\r\n   * Initializes \"mouseup\" event handler\r\n   */\r\n  initMouseupHandler: function() {\r\n    this.on('mouseup', function(options) {\r\n      this.__isMousedown = false;\r\n      if (this._isObjectMoved(options.e)) {\r\n        return;\r\n      }\r\n\r\n      if (this.__lastSelected && !this.__corner) {\r\n        this.enterEditing();\r\n        this.initDelayedCursor(true);\r\n      }\r\n      this.selected = true;\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Changes cursor location in a text depending on passed pointer (x/y) object\r\n   * @param {Event} e Event object\r\n   */\r\n  setCursorByClick: function(e) {\r\n    var newSelectionStart = this.getSelectionStartFromPointer(e);\r\n\r\n    if (e.shiftKey) {\r\n      if (newSelectionStart < this.selectionStart) {\r\n        this.setSelectionEnd(this.selectionStart);\r\n        this.setSelectionStart(newSelectionStart);\r\n      }\r\n      else {\r\n        this.setSelectionEnd(newSelectionStart);\r\n      }\r\n    }\r\n    else {\r\n      this.setSelectionStart(newSelectionStart);\r\n      this.setSelectionEnd(newSelectionStart);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Returns index of a character corresponding to where an object was clicked\r\n   * @param {Event} e Event object\r\n   * @return {Number} Index of a character\r\n   */\r\n  getSelectionStartFromPointer: function(e) {\r\n    var mouseOffset = this.getLocalPointer(e),\r\n        prevWidth = 0,\r\n        width = 0,\r\n        height = 0,\r\n        charIndex = 0,\r\n        newSelectionStart,\r\n        line;\r\n\r\n    for (var i = 0, len = this._textLines.length; i < len; i++) {\r\n      line = this._textLines[i];\r\n      height += this._getHeightOfLine(this.ctx, i) * this.scaleY;\r\n\r\n      var widthOfLine = this._getLineWidth(this.ctx, i),\r\n          lineLeftOffset = this._getLineLeftOffset(widthOfLine);\r\n\r\n      width = lineLeftOffset * this.scaleX;\r\n\r\n      if (this.flipX) {\r\n        // when oject is horizontally flipped we reverse chars\r\n        // we should reverse also style or do not revers at all.\r\n        this._textLines[i] = line.reverse().join('');\r\n      }\r\n\r\n      for (var j = 0, jlen = line.length; j < jlen; j++) {\r\n\r\n        prevWidth = width;\r\n\r\n        width += this._getWidthOfChar(this.ctx, line[j], i, this.flipX ? jlen - j : j) *\r\n                 this.scaleX;\r\n\r\n        if (height <= mouseOffset.y || width <= mouseOffset.x) {\r\n          charIndex++;\r\n          continue;\r\n        }\r\n\r\n        return this._getNewSelectionStartFromOffset(\r\n          mouseOffset, prevWidth, width, charIndex + i, jlen);\r\n      }\r\n\r\n      if (mouseOffset.y < height) {\r\n        //this happens just on end of lines.\r\n        return this._getNewSelectionStartFromOffset(\r\n          mouseOffset, prevWidth, width, charIndex + i - 1, jlen);\r\n      }\r\n    }\r\n\r\n    // clicked somewhere after all chars, so set at the end\r\n    if (typeof newSelectionStart === 'undefined') {\r\n      return this.text.length;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {\r\n\r\n    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,\r\n        distanceBtwNextCharAndCursor = width - mouseOffset.x,\r\n        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ? 0 : 1,\r\n        newSelectionStart = index + offset;\r\n\r\n    // if object is horizontally flipped, mirror cursor location from the end\r\n    if (this.flipX) {\r\n      newSelectionStart = jlen - newSelectionStart;\r\n    }\r\n\r\n    if (newSelectionStart > this.text.length) {\r\n      newSelectionStart = this.text.length;\r\n    }\r\n\r\n    return newSelectionStart;\r\n  }\r\n});\r\n\r\n\r\nfabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\r\n\r\n  /**\r\n   * Initializes hidden textarea (needed to bring up keyboard in iOS)\r\n   */\r\n  initHiddenTextarea: function() {\r\n    this.hiddenTextarea = fabric.document.createElement('textarea');\r\n\r\n    this.hiddenTextarea.setAttribute('autocapitalize', 'off');\r\n    this.hiddenTextarea.style.cssText = 'position: fixed; bottom: 20px; left: 0px; opacity: 0;'\r\n                                        + ' width: 0px; height: 0px; z-index: -999;';\r\n    fabric.document.body.appendChild(this.hiddenTextarea);\r\n\r\n    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));\r\n    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));\r\n    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));\r\n    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));\r\n\r\n    if (!this._clickHandlerInitialized && this.canvas) {\r\n      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));\r\n      this._clickHandlerInitialized = true;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _keysMap: {\r\n    8:  'removeChars',\r\n    9:  'exitEditing',\r\n    27: 'exitEditing',\r\n    13: 'insertNewline',\r\n    33: 'moveCursorUp',\r\n    34: 'moveCursorDown',\r\n    35: 'moveCursorRight',\r\n    36: 'moveCursorLeft',\r\n    37: 'moveCursorLeft',\r\n    38: 'moveCursorUp',\r\n    39: 'moveCursorRight',\r\n    40: 'moveCursorDown',\r\n    46: 'forwardDelete'\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _ctrlKeysMap: {\r\n    65: 'selectAll',\r\n    88: 'cut'\r\n  },\r\n\r\n  onClick: function() {\r\n    // No need to trigger click event here, focus is enough to have the keyboard appear on Android\r\n    this.hiddenTextarea && this.hiddenTextarea.focus();\r\n  },\r\n\r\n  /**\r\n   * Handles keyup event\r\n   * @param {Event} e Event object\r\n   */\r\n  onKeyDown: function(e) {\r\n    if (!this.isEditing) {\r\n      return;\r\n    }\r\n    if (e.keyCode in this._keysMap) {\r\n      this[this._keysMap[e.keyCode]](e);\r\n    }\r\n    else if ((e.keyCode in this._ctrlKeysMap) && (e.ctrlKey || e.metaKey)) {\r\n      this[this._ctrlKeysMap[e.keyCode]](e);\r\n    }\r\n    else {\r\n      return;\r\n    }\r\n    e.stopImmediatePropagation();\r\n    e.preventDefault();\r\n    this.canvas && this.canvas.renderAll();\r\n  },\r\n\r\n  /**\r\n   * Handles onInput event\r\n   * @param {Event} e Event object\r\n   */\r\n  onInput: function(e) {\r\n    if (!this.isEditing || this._cancelOnInput) {\r\n      this._cancelOnInput = false;\r\n      return;\r\n    }\r\n    var offset = this.selectionStart || 0,\r\n        textLength = this.text.length,\r\n        newTextLength = this.hiddenTextarea.value.length,\r\n        diff = newTextLength - textLength,\r\n        charsToInsert = this.hiddenTextarea.value.slice(offset, offset + diff);\r\n    this.insertChars(charsToInsert);\r\n    e.stopPropagation();\r\n  },\r\n\r\n  /**\r\n   * Forward delete\r\n   */\r\n  forwardDelete: function(e) {\r\n    if (this.selectionStart === this.selectionEnd) {\r\n      if (this.selectionStart === this.text.length) {\r\n        return;\r\n      }\r\n      this.moveCursorRight(e);\r\n    }\r\n    this.removeChars(e);\r\n  },\r\n\r\n  /**\r\n   * Copies selected text\r\n   * @param {Event} e Event object\r\n   */\r\n  copy: function(e) {\r\n    var selectedText = this.getSelectedText(),\r\n        clipboardData = this._getClipboardData(e);\r\n\r\n    // Check for backward compatibility with old browsers\r\n    if (clipboardData) {\r\n      clipboardData.setData('text', selectedText);\r\n    }\r\n\r\n    fabric.copiedText = selectedText;\r\n    fabric.copiedTextStyle = this.getSelectionStyles(\r\n                          this.selectionStart,\r\n                          this.selectionEnd);\r\n  },\r\n\r\n  /**\r\n   * Pastes text\r\n   * @param {Event} e Event object\r\n   */\r\n  paste: function(e) {\r\n    var copiedText = null,\r\n        clipboardData = this._getClipboardData(e),\r\n        useCopiedStyle = true;\r\n\r\n    // Check for backward compatibility with old browsers\r\n    if (clipboardData) {\r\n      copiedText = clipboardData.getData('text').replace(/\\r/g, '');\r\n      if (!fabric.copiedTextStyle || fabric.copiedText !== copiedText) {\r\n        useCopiedStyle = false;\r\n      }\r\n    }\r\n    else {\r\n      copiedText = fabric.copiedText;\r\n    }\r\n\r\n    if (copiedText) {\r\n      this.insertChars(copiedText, useCopiedStyle);\r\n    }\r\n    this._cancelOnInput = true;\r\n  },\r\n\r\n  /**\r\n   * Cuts text\r\n   * @param {Event} e Event object\r\n   */\r\n  cut: function(e) {\r\n    if (this.selectionStart === this.selectionEnd) {\r\n      return;\r\n    }\r\n\r\n    this.copy();\r\n    this.removeChars(e);\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} e Event object\r\n   * @return {Object} Clipboard data object\r\n   */\r\n  _getClipboardData: function(e) {\r\n    return e && (e.clipboardData || fabric.window.clipboardData);\r\n  },\r\n\r\n  /**\r\n   * Gets start offset of a selection\r\n   * @param {Event} e Event object\r\n   * @param {Boolean} isRight\r\n   * @return {Number}\r\n   */\r\n  getDownCursorOffset: function(e, isRight) {\r\n    var selectionProp = isRight ? this.selectionEnd : this.selectionStart,\r\n        cursorLocation = this.get2DCursorLocation(selectionProp),\r\n        _char, lineLeftOffset, lineIndex = cursorLocation.lineIndex,\r\n        textOnSameLineBeforeCursor = this._textLines[lineIndex].slice(0, cursorLocation.charIndex),\r\n        textOnSameLineAfterCursor = this._textLines[lineIndex].slice(cursorLocation.charIndex),\r\n        textOnNextLine = this._textLines[lineIndex + 1] || '';\r\n\r\n    // if on last line, down cursor goes to end of line\r\n    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {\r\n\r\n      // move to the end of a text\r\n      return this.text.length - selectionProp;\r\n    }\r\n\r\n    var widthOfSameLineBeforeCursor = this._getLineWidth(this.ctx, lineIndex);\r\n    lineLeftOffset = this._getLineLeftOffset(widthOfSameLineBeforeCursor);\r\n\r\n    var widthOfCharsOnSameLineBeforeCursor = lineLeftOffset;\r\n\r\n    for (var i = 0, len = textOnSameLineBeforeCursor.length; i < len; i++) {\r\n      _char = textOnSameLineBeforeCursor[i];\r\n      widthOfCharsOnSameLineBeforeCursor += this._getWidthOfChar(this.ctx, _char, lineIndex, i);\r\n    }\r\n\r\n    var indexOnNextLine = this._getIndexOnNextLine(\r\n      cursorLocation, textOnNextLine, widthOfCharsOnSameLineBeforeCursor);\r\n\r\n    return textOnSameLineAfterCursor.length + 1 + indexOnNextLine;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _getIndexOnNextLine: function(cursorLocation, textOnNextLine, widthOfCharsOnSameLineBeforeCursor) {\r\n    var lineIndex = cursorLocation.lineIndex + 1,\r\n        widthOfNextLine = this._getLineWidth(this.ctx, lineIndex),\r\n        lineLeftOffset = this._getLineLeftOffset(widthOfNextLine),\r\n        widthOfCharsOnNextLine = lineLeftOffset,\r\n        indexOnNextLine = 0,\r\n        foundMatch;\r\n\r\n    for (var j = 0, jlen = textOnNextLine.length; j < jlen; j++) {\r\n\r\n      var _char = textOnNextLine[j],\r\n          widthOfChar = this._getWidthOfChar(this.ctx, _char, lineIndex, j);\r\n\r\n      widthOfCharsOnNextLine += widthOfChar;\r\n\r\n      if (widthOfCharsOnNextLine > widthOfCharsOnSameLineBeforeCursor) {\r\n\r\n        foundMatch = true;\r\n\r\n        var leftEdge = widthOfCharsOnNextLine - widthOfChar,\r\n            rightEdge = widthOfCharsOnNextLine,\r\n            offsetFromLeftEdge = Math.abs(leftEdge - widthOfCharsOnSameLineBeforeCursor),\r\n            offsetFromRightEdge = Math.abs(rightEdge - widthOfCharsOnSameLineBeforeCursor);\r\n\r\n        indexOnNextLine = offsetFromRightEdge < offsetFromLeftEdge ? j + 1 : j;\r\n\r\n        break;\r\n      }\r\n    }\r\n\r\n    // reached end\r\n    if (!foundMatch) {\r\n      indexOnNextLine = textOnNextLine.length;\r\n    }\r\n\r\n    return indexOnNextLine;\r\n  },\r\n\r\n  /**\r\n   * Moves cursor down\r\n   * @param {Event} e Event object\r\n   */\r\n  moveCursorDown: function(e) {\r\n    this.abortCursorAnimation();\r\n    this._currentCursorOpacity = 1;\r\n\r\n    var offset = this.getDownCursorOffset(e, this._selectionDirection === 'right');\r\n\r\n    if (e.shiftKey) {\r\n      this.moveCursorDownWithShift(offset);\r\n    }\r\n    else {\r\n      this.moveCursorDownWithoutShift(offset);\r\n    }\r\n\r\n    this.initDelayedCursor();\r\n  },\r\n\r\n  /**\r\n   * Moves cursor down without keeping selection\r\n   * @param {Number} offset\r\n   */\r\n  moveCursorDownWithoutShift: function(offset) {\r\n    this._selectionDirection = 'right';\r\n    this.setSelectionStart(this.selectionStart + offset);\r\n    this.setSelectionEnd(this.selectionStart);\r\n  },\r\n\r\n  /**\r\n   * private\r\n   */\r\n  swapSelectionPoints: function() {\r\n    var swapSel = this.selectionEnd;\r\n    this.setSelectionEnd(this.selectionStart);\r\n    this.setSelectionStart(swapSel);\r\n  },\r\n\r\n  /**\r\n   * Moves cursor down while keeping selection\r\n   * @param {Number} offset\r\n   */\r\n  moveCursorDownWithShift: function(offset) {\r\n    if (this.selectionEnd === this.selectionStart) {\r\n      this._selectionDirection = 'right';\r\n    }\r\n    if (this._selectionDirection === 'right') {\r\n      this.setSelectionEnd(this.selectionEnd + offset);\r\n    }\r\n    else {\r\n      this.setSelectionStart(this.selectionStart + offset);\r\n    }\r\n    if (this.selectionEnd < this.selectionStart  && this._selectionDirection === 'left') {\r\n      this.swapSelectionPoints();\r\n      this._selectionDirection = 'right';\r\n    }\r\n    if (this.selectionEnd > this.text.length) {\r\n      this.setSelectionEnd(this.text.length);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @param {Event} e Event object\r\n   * @param {Boolean} isRight\r\n   * @return {Number}\r\n   */\r\n  getUpCursorOffset: function(e, isRight) {\r\n    var selectionProp = isRight ? this.selectionEnd : this.selectionStart,\r\n        cursorLocation = this.get2DCursorLocation(selectionProp),\r\n        lineIndex = cursorLocation.lineIndex;\r\n    // if on first line, up cursor goes to start of line\r\n    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {\r\n      return selectionProp;\r\n    }\r\n\r\n    var textOnSameLineBeforeCursor = this._textLines[lineIndex].slice(0, cursorLocation.charIndex),\r\n        textOnPreviousLine = this._textLines[lineIndex - 1] || '',\r\n        _char,\r\n        widthOfSameLineBeforeCursor = this._getLineWidth(this.ctx, cursorLocation.lineIndex),\r\n        lineLeftOffset = this._getLineLeftOffset(widthOfSameLineBeforeCursor),\r\n        widthOfCharsOnSameLineBeforeCursor = lineLeftOffset;\r\n\r\n    for (var i = 0, len = textOnSameLineBeforeCursor.length; i < len; i++) {\r\n      _char = textOnSameLineBeforeCursor[i];\r\n      widthOfCharsOnSameLineBeforeCursor += this._getWidthOfChar(this.ctx, _char, lineIndex, i);\r\n    }\r\n\r\n    var indexOnPrevLine = this._getIndexOnPrevLine(\r\n      cursorLocation, textOnPreviousLine, widthOfCharsOnSameLineBeforeCursor);\r\n\r\n    return textOnPreviousLine.length - indexOnPrevLine + textOnSameLineBeforeCursor.length;\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _getIndexOnPrevLine: function(cursorLocation, textOnPreviousLine, widthOfCharsOnSameLineBeforeCursor) {\r\n\r\n    var lineIndex = cursorLocation.lineIndex - 1,\r\n        widthOfPreviousLine = this._getLineWidth(this.ctx, lineIndex),\r\n        lineLeftOffset = this._getLineLeftOffset(widthOfPreviousLine),\r\n        widthOfCharsOnPreviousLine = lineLeftOffset,\r\n        indexOnPrevLine = 0,\r\n        foundMatch;\r\n\r\n    for (var j = 0, jlen = textOnPreviousLine.length; j < jlen; j++) {\r\n\r\n      var _char = textOnPreviousLine[j],\r\n          widthOfChar = this._getWidthOfChar(this.ctx, _char, lineIndex, j);\r\n\r\n      widthOfCharsOnPreviousLine += widthOfChar;\r\n\r\n      if (widthOfCharsOnPreviousLine > widthOfCharsOnSameLineBeforeCursor) {\r\n\r\n        foundMatch = true;\r\n\r\n        var leftEdge = widthOfCharsOnPreviousLine - widthOfChar,\r\n            rightEdge = widthOfCharsOnPreviousLine,\r\n            offsetFromLeftEdge = Math.abs(leftEdge - widthOfCharsOnSameLineBeforeCursor),\r\n            offsetFromRightEdge = Math.abs(rightEdge - widthOfCharsOnSameLineBeforeCursor);\r\n\r\n        indexOnPrevLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);\r\n\r\n        break;\r\n      }\r\n    }\r\n\r\n    // reached end\r\n    if (!foundMatch) {\r\n      indexOnPrevLine = textOnPreviousLine.length - 1;\r\n    }\r\n\r\n    return indexOnPrevLine;\r\n  },\r\n\r\n  /**\r\n   * Moves cursor up\r\n   * @param {Event} e Event object\r\n   */\r\n  moveCursorUp: function(e) {\r\n\r\n    this.abortCursorAnimation();\r\n    this._currentCursorOpacity = 1;\r\n\r\n    var offset = this.getUpCursorOffset(e, this._selectionDirection === 'right');\r\n    if (e.shiftKey) {\r\n      this.moveCursorUpWithShift(offset);\r\n    }\r\n    else {\r\n      this.moveCursorUpWithoutShift(offset);\r\n    }\r\n\r\n    this.initDelayedCursor();\r\n  },\r\n\r\n  /**\r\n   * Moves cursor up with shift\r\n   * @param {Number} offset\r\n   */\r\n  moveCursorUpWithShift: function(offset) {\r\n    if (this.selectionEnd === this.selectionStart) {\r\n      this._selectionDirection = 'left';\r\n    }\r\n    if (this._selectionDirection === 'right') {\r\n      this.setSelectionEnd(this.selectionEnd - offset);\r\n    }\r\n    else {\r\n      this.setSelectionStart(this.selectionStart - offset);\r\n    }\r\n    if (this.selectionEnd < this.selectionStart && this._selectionDirection === 'right') {\r\n      this.swapSelectionPoints();\r\n      this._selectionDirection = 'left';\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Moves cursor up without shift\r\n   * @param {Number} offset\r\n   */\r\n  moveCursorUpWithoutShift: function(offset) {\r\n    if (this.selectionStart === this.selectionEnd) {\r\n      this.setSelectionStart(this.selectionStart - offset);\r\n    }\r\n    this.setSelectionEnd(this.selectionStart);\r\n\r\n    this._selectionDirection = 'left';\r\n  },\r\n\r\n  /**\r\n   * Moves cursor left\r\n   * @param {Event} e Event object\r\n   */\r\n  moveCursorLeft: function(e) {\r\n    if (this.selectionStart === 0 && this.selectionEnd === 0) {\r\n      return;\r\n    }\r\n\r\n    this.abortCursorAnimation();\r\n    this._currentCursorOpacity = 1;\r\n\r\n    if (e.shiftKey) {\r\n      this.moveCursorLeftWithShift(e);\r\n    }\r\n    else {\r\n      this.moveCursorLeftWithoutShift(e);\r\n    }\r\n\r\n    this.initDelayedCursor();\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _move: function(e, prop, direction) {\r\n    var propMethod = (prop === 'selectionStart' ? 'setSelectionStart' : 'setSelectionEnd');\r\n    if (e.altKey) {\r\n      this[propMethod](this['findWordBoundary' + direction](this[prop]));\r\n    }\r\n    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {\r\n      this[propMethod](this['findLineBoundary' + direction](this[prop]));\r\n    }\r\n    else {\r\n      this[propMethod](this[prop] + (direction === 'Left' ? -1 : 1));\r\n    }\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _moveLeft: function(e, prop) {\r\n    this._move(e, prop, 'Left');\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  _moveRight: function(e, prop) {\r\n    this._move(e, prop, 'Right');\r\n  },\r\n\r\n  /**\r\n   * Moves cursor left without keeping selection\r\n   * @param {Event} e\r\n   */\r\n  moveCursorLeftWithoutShift: function(e) {\r\n    this._selectionDirection = 'left';\r\n\r\n    // only move cursor when there is no selection,\r\n    // otherwise we discard it, and leave cursor on same place\r\n    if (this.selectionEnd === this.selectionStart) {\r\n      this._moveLeft(e, 'selectionStart');\r\n    }\r\n    this.setSelectionEnd(this.selectionStart);\r\n  },\r\n\r\n  /**\r\n   * Moves cursor left while keeping selection\r\n   * @param {Event} e\r\n   */\r\n  moveCursorLeftWithShift: function(e) {\r\n    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {\r\n      this._moveLeft(e, 'selectionEnd');\r\n    }\r\n    else {\r\n      this._selectionDirection = 'left';\r\n      this._moveLeft(e, 'selectionStart');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Moves cursor right\r\n   * @param {Event} e Event object\r\n   */\r\n  moveCursorRight: function(e) {\r\n    if (this.selectionStart >= this.text.length && this.selectionEnd >= this.text.length) {\r\n      return;\r\n    }\r\n\r\n    this.abortCursorAnimation();\r\n    this._currentCursorOpacity = 1;\r\n\r\n    if (e.shiftKey) {\r\n      this.moveCursorRightWithShift(e);\r\n    }\r\n    else {\r\n      this.moveCursorRightWithoutShift(e);\r\n    }\r\n\r\n    this.initDelayedCursor();\r\n  },\r\n\r\n  /**\r\n   * Moves cursor right while keeping selection\r\n   * @param {Event} e\r\n   */\r\n  moveCursorRightWithShift: function(e) {\r\n    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {\r\n      this._moveRight(e, 'selectionStart');\r\n    }\r\n    else {\r\n      this._selectionDirection = 'right';\r\n      this._moveRight(e, 'selectionEnd');\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Moves cursor right without keeping selection\r\n   * @param {Event} e Event object\r\n   */\r\n  moveCursorRightWithoutShift: function(e) {\r\n    this._selectionDirection = 'right';\r\n\r\n    if (this.selectionStart === this.selectionEnd) {\r\n      this._moveRight(e, 'selectionStart');\r\n      this.setSelectionEnd(this.selectionStart);\r\n    }\r\n    else {\r\n      this.setSelectionEnd(this.selectionEnd + this.getNumNewLinesInSelectedText());\r\n      this.setSelectionStart(this.selectionEnd);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Removes characters selected by selection\r\n   * @param {Event} e Event object\r\n   */\r\n  removeChars: function(e) {\r\n    if (this.selectionStart === this.selectionEnd) {\r\n      this._removeCharsNearCursor(e);\r\n    }\r\n    else {\r\n      this._removeCharsFromTo(this.selectionStart, this.selectionEnd);\r\n    }\r\n\r\n    this.setSelectionEnd(this.selectionStart);\r\n\r\n    this._removeExtraneousStyles();\r\n\r\n    this.canvas && this.canvas.renderAll();\r\n\r\n    this.setCoords();\r\n    this.fire('changed');\r\n    this.canvas && this.canvas.fire('text:changed', { target: this });\r\n  },\r\n\r\n  /**\r\n   * @private\r\n   * @param {Event} e Event object\r\n   */\r\n  _removeCharsNearCursor: function(e) {\r\n    if (this.selectionStart === 0) {\r\n      return;\r\n    }\r\n    if (e.metaKey) {\r\n      // remove all till the start of current line\r\n      var leftLineBoundary = this.findLineBoundaryLeft(this.selectionStart);\r\n\r\n      this._removeCharsFromTo(leftLineBoundary, this.selectionStart);\r\n      this.setSelectionStart(leftLineBoundary);\r\n    }\r\n    else if (e.altKey) {\r\n      // remove all till the start of current word\r\n      var leftWordBoundary = this.findWordBoundaryLeft(this.selectionStart);\r\n\r\n      this._removeCharsFromTo(leftWordBoundary, this.selectionStart);\r\n      this.setSelectionStart(leftWordBoundary);\r\n    }\r\n    else {\r\n      this._removeSingleCharAndStyle(this.selectionStart);\r\n      this.setSelectionStart(this.selectionStart - 1);\r\n    }\r\n  }\r\n});\r\n\r\n\r\n/* _TO_SVG_START_ */\r\n(function() {\r\n  var toFixed = fabric.util.toFixed,\r\n      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;\r\n\r\n  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGTextLineText: function(lineIndex, textSpans, height, textLeftOffset, textTopOffset, textBgRects) {\r\n      if (!this.styles[lineIndex]) {\r\n        fabric.Text.prototype._setSVGTextLineText.call(this,\r\n          lineIndex, textSpans, height, textLeftOffset, textTopOffset);\r\n      }\r\n      else {\r\n        this._setSVGTextLineChars(\r\n          lineIndex, textSpans, height, textLeftOffset, textBgRects);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _setSVGTextLineChars: function(lineIndex, textSpans, height, textLeftOffset, textBgRects) {\r\n\r\n      var chars = this._textLines[lineIndex],\r\n          charOffset = 0,\r\n          lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, lineIndex)) - this.width / 2,\r\n          lineOffset = this._getSVGLineTopOffset(lineIndex),\r\n          heightOfLine = this._getHeightOfLine(this.ctx, lineIndex);\r\n\r\n      for (var i = 0, len = chars.length; i < len; i++) {\r\n        var styleDecl = this.styles[lineIndex][i] || { };\r\n\r\n        textSpans.push(\r\n          this._createTextCharSpan(\r\n            chars[i], styleDecl, lineLeftOffset, lineOffset.lineTop + lineOffset.offset, charOffset));\r\n\r\n        var charWidth = this._getWidthOfChar(this.ctx, chars[i], lineIndex, i);\r\n\r\n        if (styleDecl.textBackgroundColor) {\r\n          textBgRects.push(\r\n            this._createTextCharBg(\r\n              styleDecl, lineLeftOffset, lineOffset.lineTop, heightOfLine, charWidth, charOffset));\r\n        }\r\n\r\n        charOffset += charWidth;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _getSVGLineTopOffset: function(lineIndex) {\r\n      var lineTopOffset = 0, lastHeight = 0;\r\n      for (var j = 0; j < lineIndex; j++) {\r\n        lineTopOffset += this._getHeightOfLine(this.ctx, j);\r\n      }\r\n      lastHeight = this._getHeightOfLine(this.ctx, j);\r\n      return {\r\n        lineTop: lineTopOffset,\r\n        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)\r\n      };\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _createTextCharBg: function(styleDecl, lineLeftOffset, lineTopOffset, heightOfLine, charWidth, charOffset) {\r\n      return [\r\n        //jscs:disable validateIndentation\r\n        '<rect fill=\"', styleDecl.textBackgroundColor,\r\n        '\" x=\"', toFixed(lineLeftOffset + charOffset, NUM_FRACTION_DIGITS),\r\n        '\" y=\"', toFixed(lineTopOffset - this.height/2, NUM_FRACTION_DIGITS),\r\n        '\" width=\"', toFixed(charWidth, NUM_FRACTION_DIGITS),\r\n        '\" height=\"', toFixed(heightOfLine / this.lineHeight, NUM_FRACTION_DIGITS),\r\n        '\"></rect>'\r\n        //jscs:enable validateIndentation\r\n      ].join('');\r\n    },\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _createTextCharSpan: function(_char, styleDecl, lineLeftOffset, lineTopOffset, charOffset) {\r\n\r\n      var fillStyles = this.getSvgStyles.call(fabric.util.object.extend({\r\n        visible: true,\r\n        fill: this.fill,\r\n        stroke: this.stroke,\r\n        type: 'text'\r\n      }, styleDecl));\r\n\r\n      return [\r\n        //jscs:disable validateIndentation\r\n        '<tspan x=\"', toFixed(lineLeftOffset + charOffset, NUM_FRACTION_DIGITS), '\" y=\"',\r\n          toFixed(lineTopOffset - this.height/2, NUM_FRACTION_DIGITS), '\" ',\r\n          (styleDecl.fontFamily ? 'font-family=\"' + styleDecl.fontFamily.replace(/\"/g, '\\'') + '\" ': ''),\r\n          (styleDecl.fontSize ? 'font-size=\"' + styleDecl.fontSize + '\" ': ''),\r\n          (styleDecl.fontStyle ? 'font-style=\"' + styleDecl.fontStyle + '\" ': ''),\r\n          (styleDecl.fontWeight ? 'font-weight=\"' + styleDecl.fontWeight + '\" ': ''),\r\n          (styleDecl.textDecoration ? 'text-decoration=\"' + styleDecl.textDecoration + '\" ': ''),\r\n          'style=\"', fillStyles, '\">',\r\n          fabric.util.string.escapeXml(_char),\r\n        '</tspan>'\r\n        //jscs:enable validateIndentation\r\n      ].join('');\r\n    }\r\n  });\r\n})();\r\n/* _TO_SVG_END_ */\r\n\r\n\r\n(function(global) {\r\n\r\n  'use strict';\r\n\r\n  var fabric = global.fabric || (global.fabric = {}),\r\n      clone  = fabric.util.object.clone;\r\n\r\n  /**\r\n   * Textbox class, based on IText, allows the user to resize the text rectangle\r\n   * and wraps lines automatically. Textboxes have their Y scaling locked, the\r\n   * user can only change width. Height is adjusted automatically based on the\r\n   * wrapping of lines.\r\n   * @class fabric.Textbox\r\n   * @extends fabric.IText\r\n   * @mixes fabric.Observable\r\n   * @return {fabric.Textbox} thisArg\r\n   * @see {@link fabric.Textbox#initialize} for constructor definition\r\n   */\r\n  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {\r\n    /**\r\n     * Type of an object\r\n     * @type String\r\n     * @default\r\n     */\r\n    type: 'textbox',\r\n    /**\r\n     * Minimum width of textbox, in pixels.\r\n     * @type Number\r\n     * @default\r\n     */\r\n    minWidth: 20,\r\n    /**\r\n     * Minimum calculated width of a textbox, in pixels.\r\n     * @type Number\r\n     * @default\r\n     */\r\n    dynamicMinWidth: 0,\r\n    /**\r\n     * Cached array of text wrapping.\r\n     * @type Array\r\n     */\r\n    __cachedLines: null,\r\n    /**\r\n     * Constructor. Some scaling related property values are forced. Visibility\r\n     * of controls is also fixed; only the rotation and width controls are\r\n     * made available.\r\n     * @param {String} text Text string\r\n     * @param {Object} [options] Options object\r\n     * @return {fabric.Textbox} thisArg\r\n     */\r\n    initialize: function(text, options) {\r\n      this.ctx = fabric.util.createCanvasElement().getContext('2d');\r\n\r\n      this.callSuper('initialize', text, options);\r\n      this.set({\r\n        lockUniScaling: false,\r\n        lockScalingY: true,\r\n        lockScalingFlip: true,\r\n        hasBorders: true\r\n      });\r\n      this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility());\r\n\r\n      // add width to this list of props that effect line wrapping.\r\n      this._dimensionAffectingProps.width = true;\r\n    },\r\n\r\n    /**\r\n     * Unlike superclass's version of this function, Textbox does not update\r\n     * its width.\r\n     * @param {CanvasRenderingContext2D} ctx Context to use for measurements\r\n     * @private\r\n     * @override\r\n     */\r\n    _initDimensions: function(ctx) {\r\n      if (this.__skipDimension) {\r\n        return;\r\n      }\r\n\r\n      if (!ctx) {\r\n        ctx = fabric.util.createCanvasElement().getContext('2d');\r\n        this._setTextStyles(ctx);\r\n      }\r\n\r\n      // clear dynamicMinWidth as it will be different after we re-wrap line\r\n      this.dynamicMinWidth = 0;\r\n\r\n      // wrap lines\r\n      this._textLines = this._splitTextIntoLines();\r\n\r\n      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap\r\n      if (this.dynamicMinWidth > this.width) {\r\n        this._set('width', this.dynamicMinWidth);\r\n      }\r\n\r\n      // clear cache and re-calculate height\r\n      this._clearCache();\r\n      this.height = this._getTextHeight(ctx);\r\n    },\r\n\r\n    /**\r\n     * Generate an object that translates the style object so that it is\r\n     * broken up by visual lines (new lines and automatic wrapping).\r\n     * The original text styles object is broken up by actual lines (new lines only),\r\n     * which is only sufficient for Text / IText\r\n     * @private\r\n     */\r\n    _generateStyleMap: function() {\r\n      var realLineCount     = 0,\r\n          realLineCharCount = 0,\r\n          charCount         = 0,\r\n          map               = {};\r\n\r\n      for (var i = 0; i < this._textLines.length; i++) {\r\n        if (this.text[charCount] === '\\n') {\r\n          realLineCharCount = 0;\r\n          charCount++;\r\n          realLineCount++;\r\n        }\r\n        else if (this.text[charCount] === ' ') {\r\n          // this case deals with space's that are removed from end of lines when wrapping\r\n          realLineCharCount++;\r\n          charCount++;\r\n        }\r\n\r\n        map[i] = { line: realLineCount, offset: realLineCharCount };\r\n\r\n        charCount += this._textLines[i].length;\r\n        realLineCharCount += this._textLines[i].length;\r\n      }\r\n\r\n      return map;\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @param {Boolean} [returnCloneOrEmpty=false]\r\n     * @private\r\n     */\r\n    _getStyleDeclaration: function(lineIndex, charIndex, returnCloneOrEmpty) {\r\n      if (this._styleMap) {\r\n        var map = this._styleMap[lineIndex];\r\n        lineIndex = map.line;\r\n        charIndex = map.offset + charIndex;\r\n      }\r\n      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex, returnCloneOrEmpty);\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @param {Object} style\r\n     * @private\r\n     */\r\n    _setStyleDeclaration: function(lineIndex, charIndex, style) {\r\n      var map = this._styleMap[lineIndex];\r\n      lineIndex = map.line;\r\n      charIndex = map.offset + charIndex;\r\n\r\n      this.styles[lineIndex][charIndex] = style;\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Number} charIndex\r\n     * @private\r\n     */\r\n    _deleteStyleDeclaration: function(lineIndex, charIndex) {\r\n      var map = this._styleMap[lineIndex];\r\n      lineIndex = map.line;\r\n      charIndex = map.offset + charIndex;\r\n\r\n      delete this.styles[lineIndex][charIndex];\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @private\r\n     */\r\n    _getLineStyle: function(lineIndex) {\r\n      var map = this._styleMap[lineIndex];\r\n      return this.styles[map.line];\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @param {Object} style\r\n     * @private\r\n     */\r\n    _setLineStyle: function(lineIndex, style) {\r\n      var map = this._styleMap[lineIndex];\r\n      this.styles[map.line] = style;\r\n    },\r\n\r\n    /**\r\n     * @param {Number} lineIndex\r\n     * @private\r\n     */\r\n    _deleteLineStyle: function(lineIndex) {\r\n      var map = this._styleMap[lineIndex];\r\n      delete this.styles[map.line];\r\n    },\r\n\r\n    /**\r\n     * Wraps text using the 'width' property of Textbox. First this function\r\n     * splits text on newlines, so we preserve newlines entered by the user.\r\n     * Then it wraps each line using the width of the Textbox by calling\r\n     * _wrapLine().\r\n     * @param {CanvasRenderingContext2D} ctx Context to use for measurements\r\n     * @param {String} text The string of text that is split into lines\r\n     * @returns {Array} Array of lines\r\n     */\r\n    _wrapText: function(ctx, text) {\r\n      var lines = text.split(this._reNewline), wrapped = [], i;\r\n\r\n      for (i = 0; i < lines.length; i++) {\r\n        wrapped = wrapped.concat(this._wrapLine(ctx, lines[i], i));\r\n      }\r\n\r\n      return wrapped;\r\n    },\r\n\r\n    /**\r\n     * Helper function to measure a string of text, given its lineIndex and charIndex offset\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {String} text\r\n     * @param {number} lineIndex\r\n     * @param {number} charOffset\r\n     * @returns {number}\r\n     * @private\r\n     */\r\n    _measureText: function(ctx, text, lineIndex, charOffset) {\r\n      var width = 0, decl;\r\n      charOffset = charOffset || 0;\r\n\r\n      for (var i = 0; i < text.length; i++) {\r\n        if (this.styles && this.styles[lineIndex] && (decl = this.styles[lineIndex][i + charOffset])) {\r\n          ctx.save();\r\n          width += this._applyCharStylesGetWidth(ctx, text[i], lineIndex, i, decl);\r\n          ctx.restore();\r\n        }\r\n        else {\r\n          // @note: we intentionally pass in an empty style declaration, because if we pass in nothing, it will\r\n          // retry fetching style declaration\r\n          width += this._applyCharStylesGetWidth(ctx, text[i], lineIndex, i, {});\r\n        }\r\n      }\r\n\r\n      return width;\r\n    },\r\n\r\n    /**\r\n     * Wraps a line of text using the width of the Textbox and a context.\r\n     * @param {CanvasRenderingContext2D} ctx Context to use for measurements\r\n     * @param {String} text The string of text to split into lines\r\n     * @param {Number} lineIndex\r\n     * @returns {Array} Array of line(s) into which the given text is wrapped\r\n     * to.\r\n     */\r\n    _wrapLine: function(ctx, text, lineIndex) {\r\n      var maxWidth  = this.width,\r\n          lineWidth = this._measureText(ctx, text, lineIndex, 0);\r\n\r\n      // first case: does the whole line fit?\r\n      if (lineWidth < maxWidth) {\r\n        // if the current line is only one word, we need to keep track of it if it's a large word\r\n        if (text.indexOf(' ') === -1 && lineWidth > this.dynamicMinWidth) {\r\n          this.dynamicMinWidth = lineWidth;\r\n        }\r\n\r\n        return [text];\r\n      }\r\n\r\n      // if the whole line doesn't fit, we break it up into words\r\n      var lines            = [],\r\n          line             = '',\r\n          words            = text.split(' '),\r\n          offset           = 0,\r\n          infix            = '',\r\n          wordWidth        = 0,\r\n          largestWordWidth = 0;\r\n\r\n      while (words.length > 0) {\r\n        infix = line === '' ? '' : ' ';\r\n        wordWidth = this._measureText(ctx, words[0], lineIndex, line.length + infix.length + offset);\r\n        lineWidth = line === '' ? wordWidth : this._measureText(ctx, line + infix + words[0], lineIndex, offset);\r\n\r\n        if (lineWidth < maxWidth || (line === '' && wordWidth >= maxWidth)) {\r\n          line += infix + words.shift();\r\n        }\r\n        else {\r\n          offset += line.length + 1; // add 1 because each word is separated by a space\r\n          lines.push(line);\r\n          line = '';\r\n        }\r\n\r\n        if (words.length === 0) {\r\n          lines.push(line);\r\n        }\r\n\r\n        // keep track of largest word\r\n        if (wordWidth > largestWordWidth) {\r\n          largestWordWidth = wordWidth;\r\n        }\r\n      }\r\n\r\n      if (largestWordWidth > this.dynamicMinWidth) {\r\n        this.dynamicMinWidth = largestWordWidth;\r\n      }\r\n\r\n      return lines;\r\n    },\r\n\r\n    /**\r\n     * Gets lines of text to render in the Textbox. This function calculates\r\n     * text wrapping on the fly everytime it is called.\r\n     * @returns {Array} Array of lines in the Textbox.\r\n     * @override\r\n     */\r\n    _splitTextIntoLines: function() {\r\n      this.ctx.save();\r\n      this._setTextStyles(this.ctx);\r\n\r\n      var lines = this._wrapText(this.ctx, this.text);\r\n\r\n      this.ctx.restore();\r\n      this._textLines = lines;\r\n      this._styleMap = this._generateStyleMap();\r\n      return lines;\r\n    },\r\n\r\n    /**\r\n     * When part of a group, we don't want the Textbox's scale to increase if\r\n     * the group's increases. That's why we reduce the scale of the Textbox by\r\n     * the amount that the group's increases. This is to maintain the effective\r\n     * scale of the Textbox at 1, so that font-size values make sense. Otherwise\r\n     * the same font-size value would result in different actual size depending\r\n     * on the value of the scale.\r\n     * @param {String} key\r\n     * @param {Any} value\r\n     */\r\n    setOnGroup: function(key, value) {\r\n      if (key === 'scaleX') {\r\n        this.set('scaleX', Math.abs(1 / value));\r\n        this.set('width', (this.get('width') * value) /\r\n          (typeof this.__oldScaleX === 'undefined' ? 1 : this.__oldScaleX));\r\n        this.__oldScaleX = value;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start).\r\n     * Overrides the superclass function to take into account text wrapping.\r\n     *\r\n     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.\r\n     */\r\n    get2DCursorLocation: function(selectionStart) {\r\n      if (typeof selectionStart === 'undefined') {\r\n        selectionStart = this.selectionStart;\r\n      }\r\n\r\n      var numLines = this._textLines.length,\r\n          removed  = 0;\r\n\r\n      for (var i = 0; i < numLines; i++) {\r\n        var line    = this._textLines[i],\r\n            lineLen = line.length;\r\n\r\n        if (selectionStart <= removed + lineLen) {\r\n          return {\r\n            lineIndex: i,\r\n            charIndex: selectionStart - removed\r\n          };\r\n        }\r\n\r\n        removed += lineLen;\r\n\r\n        if (this.text[removed] === '\\n' || this.text[removed] === ' ') {\r\n          removed++;\r\n        }\r\n      }\r\n\r\n      return {\r\n        lineIndex: numLines - 1,\r\n        charIndex: this._textLines[numLines - 1].length\r\n      };\r\n    },\r\n\r\n    /**\r\n     * Overrides superclass function and uses text wrapping data to get cursor\r\n     * boundary offsets instead of the array of chars.\r\n     * @param {Array} chars Unused\r\n     * @param {String} typeOfBoundaries Can be 'cursor' or 'selection'\r\n     * @returns {Object} Object with 'top', 'left', and 'lineLeft' properties set.\r\n     */\r\n    _getCursorBoundariesOffsets: function(chars, typeOfBoundaries) {\r\n      var topOffset      = 0,\r\n          leftOffset     = 0,\r\n          cursorLocation = this.get2DCursorLocation(),\r\n          lineChars      = this._textLines[cursorLocation.lineIndex].split(''),\r\n          lineLeftOffset = this._getLineLeftOffset(this._getLineWidth(this.ctx, cursorLocation.lineIndex));\r\n\r\n      for (var i = 0; i < cursorLocation.charIndex; i++) {\r\n        leftOffset += this._getWidthOfChar(this.ctx, lineChars[i], cursorLocation.lineIndex, i);\r\n      }\r\n\r\n      for (i = 0; i < cursorLocation.lineIndex; i++) {\r\n        topOffset += this._getHeightOfLine(this.ctx, i);\r\n      }\r\n\r\n      if (typeOfBoundaries === 'cursor') {\r\n        topOffset += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, cursorLocation.lineIndex)\r\n          / this.lineHeight - this.getCurrentCharFontSize(cursorLocation.lineIndex, cursorLocation.charIndex)\r\n          * (1 - this._fontSizeFraction);\r\n      }\r\n\r\n      return {\r\n        top: topOffset,\r\n        left: leftOffset,\r\n        lineLeft: lineLeftOffset\r\n      };\r\n    },\r\n\r\n    getMinWidth: function() {\r\n      return Math.max(this.minWidth, this.dynamicMinWidth);\r\n    },\r\n\r\n    /**\r\n     * Returns object representation of an instance\r\n     * @method toObject\r\n     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\r\n     * @return {Object} object representation of an instance\r\n     */\r\n    toObject: function(propertiesToInclude) {\r\n      return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {\r\n        minWidth: this.minWidth\r\n      });\r\n    }\r\n  });\r\n  /**\r\n   * Returns fabric.Textbox instance from an object representation\r\n   * @static\r\n   * @memberOf fabric.Textbox\r\n   * @param {Object} object Object to create an instance from\r\n   * @return {fabric.Textbox} instance of fabric.Textbox\r\n   */\r\n  fabric.Textbox.fromObject = function(object) {\r\n    return new fabric.Textbox(object.text, clone(object));\r\n  };\r\n  /**\r\n   * Returns the default controls visibility required for Textboxes.\r\n   * @returns {Object}\r\n   */\r\n  fabric.Textbox.getTextboxControlVisibility = function() {\r\n    return {\r\n      tl: false,\r\n      tr: false,\r\n      br: false,\r\n      bl: false,\r\n      ml: true,\r\n      mt: false,\r\n      mr: true,\r\n      mb: false,\r\n      mtr: true\r\n    };\r\n  };\r\n  /**\r\n   * Contains all fabric.Textbox objects that have been created\r\n   * @static\r\n   * @memberOf fabric.Textbox\r\n   * @type Array\r\n   */\r\n  fabric.Textbox.instances = [];\r\n})(typeof exports !== 'undefined' ? exports : this);\r\n\r\n\r\n(function() {\r\n\r\n  /**\r\n   * Override _setObjectScale and add Textbox specific resizing behavior. Resizing\r\n   * a Textbox doesn't scale text, it only changes width and makes text wrap automatically.\r\n   */\r\n  var setObjectScaleOverridden = fabric.Canvas.prototype._setObjectScale;\r\n\r\n  fabric.Canvas.prototype._setObjectScale = function(localMouse, transform,\r\n                                                     lockScalingX, lockScalingY, by, lockScalingFlip) {\r\n\r\n    var t = transform.target;\r\n    if (t instanceof fabric.Textbox) {\r\n      var w = t.width * ((localMouse.x / transform.scaleX) / (t.width + t.strokeWidth));\r\n      if (w >= t.getMinWidth()) {\r\n        t.set('width', w);\r\n      }\r\n    }\r\n    else {\r\n      setObjectScaleOverridden.call(fabric.Canvas.prototype, localMouse, transform,\r\n        lockScalingX, lockScalingY, by, lockScalingFlip);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Sets controls of this group to the Textbox's special configuration if\r\n   * one is present in the group. Deletes _controlsVisibility otherwise, so that\r\n   * it gets initialized to default value at runtime.\r\n   */\r\n  fabric.Group.prototype._refreshControlsVisibility = function() {\r\n    if (typeof fabric.Textbox === 'undefined') {\r\n      return;\r\n    }\r\n    for (var i = this._objects.length; i--;) {\r\n      if (this._objects[i] instanceof fabric.Textbox) {\r\n        this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility());\r\n        return;\r\n      }\r\n    }\r\n  };\r\n\r\n  var clone = fabric.util.object.clone;\r\n\r\n  fabric.util.object.extend(fabric.Textbox.prototype, /** @lends fabric.IText.prototype */ {\r\n    /**\r\n     * @private\r\n     */\r\n    _removeExtraneousStyles: function() {\r\n      for (var prop in this._styleMap) {\r\n        if (!this._textLines[prop]) {\r\n          delete this.styles[this._styleMap[prop].line];\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Inserts style object for a given line/char index\r\n     * @param {Number} lineIndex Index of a line\r\n     * @param {Number} charIndex Index of a char\r\n     * @param {Object} [style] Style object to insert, if given\r\n     */\r\n    insertCharStyleObject: function(lineIndex, charIndex, style) {\r\n      // adjust lineIndex and charIndex\r\n      var map = this._styleMap[lineIndex];\r\n      lineIndex = map.line;\r\n      charIndex = map.offset + charIndex;\r\n\r\n      fabric.IText.prototype.insertCharStyleObject.apply(this, [lineIndex, charIndex, style]);\r\n    },\r\n\r\n    /**\r\n     * Inserts new style object\r\n     * @param {Number} lineIndex Index of a line\r\n     * @param {Number} charIndex Index of a char\r\n     * @param {Boolean} isEndOfLine True if it's end of line\r\n     */\r\n    insertNewlineStyleObject: function(lineIndex, charIndex, isEndOfLine) {\r\n      // adjust lineIndex and charIndex\r\n      var map = this._styleMap[lineIndex];\r\n      lineIndex = map.line;\r\n      charIndex = map.offset + charIndex;\r\n\r\n      fabric.IText.prototype.insertNewlineStyleObject.apply(this, [lineIndex, charIndex, isEndOfLine]);\r\n    },\r\n\r\n    /**\r\n     * Shifts line styles up or down. This function is slightly different than the one in\r\n     * itext_behaviour as it takes into account the styleMap.\r\n     *\r\n     * @param {Number} lineIndex Index of a line\r\n     * @param {Number} offset Can be -1 or +1\r\n     */\r\n    shiftLineStyles: function(lineIndex, offset) {\r\n      // shift all line styles by 1 upward\r\n      var clonedStyles = clone(this.styles),\r\n          map          = this._styleMap[lineIndex];\r\n\r\n      // adjust line index\r\n      lineIndex = map.line;\r\n\r\n      for (var line in this.styles) {\r\n        var numericLine = parseInt(line, 10);\r\n\r\n        if (numericLine > lineIndex) {\r\n          this.styles[numericLine + offset] = clonedStyles[numericLine];\r\n\r\n          if (!clonedStyles[numericLine - offset]) {\r\n            delete this.styles[numericLine];\r\n          }\r\n        }\r\n      }\r\n      //TODO: evaluate if delete old style lines with offset -1\r\n    },\r\n\r\n    /**\r\n     * Figure out programatically the text on previous actual line (actual = separated by \\n);\r\n     *\r\n     * @param {Number} lIndex\r\n     * @returns {String}\r\n     * @private\r\n     */\r\n    _getTextOnPreviousLine: function(lIndex) {\r\n      var textOnPreviousLine = this._textLines[lIndex - 1];\r\n\r\n      while (this._styleMap[lIndex - 2] && this._styleMap[lIndex - 2].line === this._styleMap[lIndex - 1].line) {\r\n        textOnPreviousLine = this._textLines[lIndex - 2] + textOnPreviousLine;\r\n\r\n        lIndex--;\r\n      }\r\n\r\n      return textOnPreviousLine;\r\n    },\r\n\r\n    /**\r\n     * Removes style object\r\n     * @param {Boolean} isBeginningOfLine True if cursor is at the beginning of line\r\n     * @param {Number} [index] Optional index. When not given, current selectionStart is used.\r\n     */\r\n    removeStyleObject: function(isBeginningOfLine, index) {\r\n\r\n      var cursorLocation = this.get2DCursorLocation(index),\r\n          map            = this._styleMap[cursorLocation.lineIndex],\r\n          lineIndex      = map.line,\r\n          charIndex      = map.offset + cursorLocation.charIndex;\r\n\r\n      if (isBeginningOfLine) {\r\n        var textOnPreviousLine     = this._getTextOnPreviousLine(cursorLocation.lineIndex),\r\n            newCharIndexOnPrevLine = textOnPreviousLine ? textOnPreviousLine.length : 0;\r\n\r\n        if (!this.styles[lineIndex - 1]) {\r\n          this.styles[lineIndex - 1] = {};\r\n        }\r\n\r\n        for (charIndex in this.styles[lineIndex]) {\r\n          this.styles[lineIndex - 1][parseInt(charIndex, 10) + newCharIndexOnPrevLine]\r\n            = this.styles[lineIndex][charIndex];\r\n        }\r\n\r\n        this.shiftLineStyles(cursorLocation.lineIndex, -1);\r\n\r\n      }\r\n      else {\r\n        var currentLineStyles = this.styles[lineIndex];\r\n\r\n        if (currentLineStyles) {\r\n          delete currentLineStyles[charIndex];\r\n          //console.log('deleting', lineIndex, charIndex + offset);\r\n        }\r\n\r\n        var currentLineStylesCloned = clone(currentLineStyles);\r\n\r\n        // shift all styles by 1 backwards\r\n        for (var i in currentLineStylesCloned) {\r\n          var numericIndex = parseInt(i, 10);\r\n          if (numericIndex >= charIndex && numericIndex !== 0) {\r\n            currentLineStyles[numericIndex - 1] = currentLineStylesCloned[numericIndex];\r\n            delete currentLineStyles[numericIndex];\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n})();\r\n\r\n\r\n(function() {\r\n  var override = fabric.IText.prototype._getNewSelectionStartFromOffset;\r\n  /**\r\n   * Overrides the IText implementation and adjusts character index as there is not always a linebreak\r\n   *\r\n   * @param {Number} mouseOffset\r\n   * @param {Number} prevWidth\r\n   * @param {Number} width\r\n   * @param {Number} index\r\n   * @param {Number} jlen\r\n   * @returns {Number}\r\n   */\r\n  fabric.IText.prototype._getNewSelectionStartFromOffset = function(mouseOffset, prevWidth, width, index, jlen) {\r\n    index = override.call(this, mouseOffset, prevWidth, width, index, jlen);\r\n\r\n    // the index passed into the function is padded by the amount of lines from _textLines (to account for \\n)\r\n    // we need to remove this padding, and pad it by actual lines, and / or spaces that are meant to be there\r\n    var tmp     = 0,\r\n        removed = 0;\r\n\r\n    // account for removed characters\r\n    for (var i = 0; i < this._textLines.length; i++) {\r\n      tmp += this._textLines[i].length;\r\n\r\n      if (tmp + removed >= index) {\r\n        break;\r\n      }\r\n\r\n      if (this.text[tmp + removed] === '\\n' || this.text[tmp + removed] === ' ') {\r\n        removed++;\r\n      }\r\n    }\r\n\r\n    return index - i + removed;\r\n  };\r\n})();\r\n\r\n\r\n(function() {\r\n\r\n  if (typeof document !== 'undefined' && typeof window !== 'undefined') {\r\n    return;\r\n  }\r\n\r\n  var DOMParser = require('xmldom').DOMParser,\r\n      URL = require('url'),\r\n      HTTP = require('http'),\r\n      HTTPS = require('https'),\r\n\r\n      Canvas = require('canvas'),\r\n      Image = require('canvas').Image;\r\n\r\n  /** @private */\r\n  function request(url, encoding, callback) {\r\n    var oURL = URL.parse(url);\r\n\r\n    // detect if http or https is used\r\n    if ( !oURL.port ) {\r\n      oURL.port = ( oURL.protocol.indexOf('https:') === 0 ) ? 443 : 80;\r\n    }\r\n\r\n    // assign request handler based on protocol\r\n    var reqHandler = (oURL.protocol.indexOf('https:') === 0 ) ? HTTPS : HTTP,\r\n        req = reqHandler.request({\r\n          hostname: oURL.hostname,\r\n          port: oURL.port,\r\n          path: oURL.path,\r\n          method: 'GET'\r\n        }, function(response) {\r\n          var body = '';\r\n          if (encoding) {\r\n            response.setEncoding(encoding);\r\n          }\r\n          response.on('end', function () {\r\n            callback(body);\r\n          });\r\n          response.on('data', function (chunk) {\r\n            if (response.statusCode === 200) {\r\n              body += chunk;\r\n            }\r\n          });\r\n        });\r\n\r\n    req.on('error', function(err) {\r\n      if (err.errno === process.ECONNREFUSED) {\r\n        fabric.log('ECONNREFUSED: connection refused to ' + oURL.hostname + ':' + oURL.port);\r\n      }\r\n      else {\r\n        fabric.log(err.message);\r\n      }\r\n      callback(null);\r\n    });\r\n\r\n    req.end();\r\n  }\r\n\r\n  /** @private */\r\n  function requestFs(path, callback) {\r\n    var fs = require('fs');\r\n    fs.readFile(path, function (err, data) {\r\n      if (err) {\r\n        fabric.log(err);\r\n        throw err;\r\n      }\r\n      else {\r\n        callback(data);\r\n      }\r\n    });\r\n  }\r\n\r\n  fabric.util.loadImage = function(url, callback, context) {\r\n    function createImageAndCallBack(data) {\r\n      if (data) {\r\n        img.src = new Buffer(data, 'binary');\r\n        // preserving original url, which seems to be lost in node-canvas\r\n        img._src = url;\r\n        callback && callback.call(context, img);\r\n      }\r\n      else {\r\n        img = null;\r\n        callback && callback.call(context, null, true);\r\n      }\r\n    }\r\n    var img = new Image();\r\n    if (url && (url instanceof Buffer || url.indexOf('data') === 0)) {\r\n      img.src = img._src = url;\r\n      callback && callback.call(context, img);\r\n    }\r\n    else if (url && url.indexOf('http') !== 0) {\r\n      requestFs(url, createImageAndCallBack);\r\n    }\r\n    else if (url) {\r\n      request(url, 'binary', createImageAndCallBack);\r\n    }\r\n    else {\r\n      callback && callback.call(context, url);\r\n    }\r\n  };\r\n\r\n  fabric.loadSVGFromURL = function(url, callback, reviver) {\r\n    url = url.replace(/^\\n\\s*/, '').replace(/\\?.*$/, '').trim();\r\n    if (url.indexOf('http') !== 0) {\r\n      requestFs(url, function(body) {\r\n        fabric.loadSVGFromString(body.toString(), callback, reviver);\r\n      });\r\n    }\r\n    else {\r\n      request(url, '', function(body) {\r\n        fabric.loadSVGFromString(body, callback, reviver);\r\n      });\r\n    }\r\n  };\r\n\r\n  fabric.loadSVGFromString = function(string, callback, reviver) {\r\n    var doc = new DOMParser().parseFromString(string);\r\n    fabric.parseSVGDocument(doc.documentElement, function(results, options) {\r\n      callback && callback(results, options);\r\n    }, reviver);\r\n  };\r\n\r\n  fabric.util.getScript = function(url, callback) {\r\n    request(url, '', function(body) {\r\n      eval(body);\r\n      callback && callback();\r\n    });\r\n  };\r\n\r\n  fabric.Image.fromObject = function(object, callback) {\r\n    fabric.util.loadImage(object.src, function(img) {\r\n      var oImg = new fabric.Image(img);\r\n\r\n      oImg._initConfig(object);\r\n      oImg._initFilters(object.filters, function(filters) {\r\n        oImg.filters = filters || [ ];\r\n        oImg._initFilters(object.resizeFilters, function(resizeFilters) {\r\n          oImg.resizeFilters = resizeFilters || [ ];\r\n          callback && callback(oImg);\r\n        });\r\n      });\r\n    });\r\n  };\r\n  /**\r\n   * Only available when running fabric on node.js\r\n   * @param {Number} width Canvas width\r\n   * @param {Number} height Canvas height\r\n   * @param {Object} [options] Options to pass to FabricCanvas.\r\n   * @param {Object} [nodeCanvasOptions] Options to pass to NodeCanvas.\r\n   * @return {Object} wrapped canvas instance\r\n   */\r\n  fabric.createCanvasForNode = function(width, height, options, nodeCanvasOptions) {\r\n    nodeCanvasOptions = nodeCanvasOptions || options;\r\n\r\n    var canvasEl = fabric.document.createElement('canvas'),\r\n        nodeCanvas = new Canvas(width || 600, height || 600, nodeCanvasOptions);\r\n\r\n    // jsdom doesn't create style on canvas element, so here be temp. workaround\r\n    canvasEl.style = { };\r\n\r\n    canvasEl.width = nodeCanvas.width;\r\n    canvasEl.height = nodeCanvas.height;\r\n\r\n    var FabricCanvas = fabric.Canvas || fabric.StaticCanvas,\r\n        fabricCanvas = new FabricCanvas(canvasEl, options);\r\n\r\n    fabricCanvas.contextContainer = nodeCanvas.getContext('2d');\r\n    fabricCanvas.nodeCanvas = nodeCanvas;\r\n    fabricCanvas.Font = Canvas.Font;\r\n\r\n    return fabricCanvas;\r\n  };\r\n\r\n  /** @ignore */\r\n  fabric.StaticCanvas.prototype.createPNGStream = function() {\r\n    return this.nodeCanvas.createPNGStream();\r\n  };\r\n\r\n  fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {\r\n    return this.nodeCanvas.createJPEGStream(opts);\r\n  };\r\n\r\n  var origSetWidth = fabric.StaticCanvas.prototype.setWidth;\r\n  fabric.StaticCanvas.prototype.setWidth = function(width, options) {\r\n    origSetWidth.call(this, width, options);\r\n    this.nodeCanvas.width = width;\r\n    return this;\r\n  };\r\n  if (fabric.Canvas) {\r\n    fabric.Canvas.prototype.setWidth = fabric.StaticCanvas.prototype.setWidth;\r\n  }\r\n\r\n  var origSetHeight = fabric.StaticCanvas.prototype.setHeight;\r\n  fabric.StaticCanvas.prototype.setHeight = function(height, options) {\r\n    origSetHeight.call(this, height, options);\r\n    this.nodeCanvas.height = height;\r\n    return this;\r\n  };\r\n  if (fabric.Canvas) {\r\n    fabric.Canvas.prototype.setHeight = fabric.StaticCanvas.prototype.setHeight;\r\n  }\r\n\r\n})();\r\n\r\n","Milople_Personalizedcool/js/piklor.js":"(function (root) {\n\n    /**\n     * Piklor\n     * Creates a new `Piklor` instance.\n     *\n     * @name Piklor\n     * @function\n     * @param {String|Element} sel The element where the color picker will live.\n     * @param {Array} colors An array of strings representing colors.\n     * @param {Object} options An object containing the following fields:\n     *\n     *  - `open` (String|Element): The HTML element or query selector which will open the picker.\n     *  - `openEvent` (String): The open event (default: `\"click\"`).\n     *  - `style` (Object): Some style options:\n     *    - `display` (String): The display value when the picker is opened (default: `\"block\"`).\n     *  - `template` (String): The color item template. The `{color}` snippet will be replaced\n     *    with the color value (default: `\"<div data-col=\\\"{color}\\\" style=\\\"background-color: {color}\\\"></div>\"`).\n     *  - `autoclose` (Boolean): If `false`, the color picker will not be hided by default (default: `true`).\n     *  - `closeOnBlur` (Boolean): If `true`, the color picker will be closed when clicked outside of it (default: `false`).\n     *\n     * @return {Piklor} The `Piklor` instance.\n     */\n    function Piklor(sel, colors, options) {\n        var self = this;\n        options = options || {};\n        options.open = self.getElm(options.open);\n        options.openEvent = options.openEvent || \"click\";\n        options.style = Object(options.style);\n        options.style.display = options.style.display || \"block\";\n        options.closeOnBlur = options.closeOnBlur || false;\n        options.template = options.template || \"<div data-col=\\\"{color}\\\" style=\\\"background-color: {color}\\\"></div>\";\n        self.elm = self.getElm(sel);\n        self.cbs = [];\n        self.isOpen = true;\n        self.colors = colors;\n        self.options = options;\n        self.render();\n\n        // Handle the open element and event.\n        if (options.open) {\n            options.open.addEventListener(options.openEvent, function (ev) {\n                self.isOpen ? self.close() : self.open();\n            });\n        }\n\n        // Click on colors\n        self.elm.addEventListener(\"click\", function (ev) {\n            var col = ev.target.getAttribute(\"data-col\");\n            if (!col) { return; }\n            self.set(col);\n            self.close();\n        });\n        \n        if (options.closeOnBlur) {\n          window.addEventListener(\"click\", function (ev) {\n              // check if we didn't click 'open' and 'color pallete' elements\n              if (ev.target != options.open && ev.target != self.elm && self.isOpen) {\n                self.close();\n              }\n          });\n        }\n\n        if (options.autoclose !== false) {\n            self.close();\n        }\n    }\n\n    /**\n     * getElm\n     * Finds the HTML element.\n     *\n     * @name getElm\n     * @function\n     * @param {String|Element} el The HTML element or query selector.\n     * @return {HTMLElement} The selected HTML element.\n     */\n    Piklor.prototype.getElm = function (el) {\n        if (typeof el === \"string\") {\n            return document.querySelector(el);\n        }\n        return el;\n    };\n\n    /**\n     * render\n     * Renders the colors.\n     *\n     * @name render\n     * @function\n     */\n    Piklor.prototype.render = function () {\n        var self = this\n          , html = \"\"\n          ;\n\n        self.colors.forEach(function (c) {\n            html += self.options.template.replace(/\\{color\\}/g, c);\n        });\n\n        self.elm.innerHTML = html;\n    };\n\n    /**\n     * close\n     * Closes the color picker.\n     *\n     * @name close\n     * @function\n     */\n    Piklor.prototype.close = function () {\n        this.elm.style.display = \"none\";\n        this.isOpen = false;\n    };\n\n    /**\n     * open\n     * Opens the color picker.\n     *\n     * @name open\n     * @function\n     */\n    Piklor.prototype.open = function () {\n        this.elm.style.display = this.options.style.display;\n        this.isOpen = true;\n    };\n\n    /**\n     * colorChosen\n     * Adds a new callback in the colorChosen callback buffer.\n     *\n     * @name colorChosen\n     * @function\n     * @param {Function} cb The callback function called with the selected color.\n     */\n    Piklor.prototype.colorChosen = function (cb) {\n        this.cbs.push(cb);\n    };\n\n    /**\n     * set\n     * Sets the color picker color.\n     *\n     * @name set\n     * @function\n     * @param {String} c The color to set.\n     * @param {Boolean} p If `false`, the `colorChosen` callbacks will not be called.\n     */\n    Piklor.prototype.set = function (c, p) {\n        var self = this;\n        self.color = c;\n        if (p === false) { return; }\n        self.cbs.forEach(function (cb) {\n            cb.call(self, c);\n        });\n    };\n\n    root.Piklor = Piklor;\n})(this);\n","Milople_Personalizedcool/js/fabric.curvedText.js":"(function (global){\r\n\r\n\t\"use strict\";\r\n\r\n\tvar fabric=global.fabric||(global.fabric={}),\r\n\t\t\textend=fabric.util.object.extend,\r\n\t\t\tclone=fabric.util.object.clone;\r\n\r\n\tif(fabric.CurvedText){\r\n\t\tfabric.warn('fabric.CurvedText is already defined');\r\n\t\treturn;\r\n\t}\r\n\tvar stateProperties=fabric.Text.prototype.stateProperties.concat();\r\n\tstateProperties.push(\r\n\t\t\t'radius',\r\n\t\t\t'spacing',\r\n\t\t\t'reverse',\r\n\t\t\t'effect',\r\n\t\t\t'range',\r\n\t\t\t'largeFont',\r\n\t\t\t'smallFont'\r\n\t\t\t);\r\n\tvar _dimensionAffectingProps=fabric.Text.prototype._dimensionAffectingProps;\r\n\t_dimensionAffectingProps['radius']=true;\r\n\t_dimensionAffectingProps['spacing']=true;\r\n\t_dimensionAffectingProps['reverse']=true;\r\n\t_dimensionAffectingProps['fill']=true;\r\n\t_dimensionAffectingProps['effect']=true;\r\n\t_dimensionAffectingProps['width']=true;\r\n\t_dimensionAffectingProps['height']=true;\r\n\t_dimensionAffectingProps['range']=true;\r\n\t_dimensionAffectingProps['fontSize']=true;\r\n\t_dimensionAffectingProps['shadow']=true;\r\n\t_dimensionAffectingProps['largeFont']=true;\r\n\t_dimensionAffectingProps['smallFont']=true;\r\n\r\n\r\n\tvar delegatedProperties=fabric.Group.prototype.delegatedProperties;\r\n\tdelegatedProperties['backgroundColor']=true;\r\n\tdelegatedProperties['textBackgroundColor']=true;\r\n\tdelegatedProperties['textDecoration']=true;\r\n\tdelegatedProperties['stroke']=true;\r\n\tdelegatedProperties['strokeWidth']=true;\r\n\tdelegatedProperties['shadow']=true;\r\n\tdelegatedProperties['fontWeight']=true;\r\n\tdelegatedProperties['fontStyle']=true;\r\n\tdelegatedProperties['strokeWidth']=true;\r\n\tdelegatedProperties['textAlign']=true;\r\n\r\n\t/**\r\n\t * Group class\r\n\t * @class fabric.CurvedText\r\n\t * @extends fabric.Text\r\n\t * @mixes fabric.Collection\r\n\t */\r\n\tfabric.CurvedText=fabric.util.createClass(fabric.Text, fabric.Collection, /** @lends fabric.CurvedText.prototype */ {\r\n\t\t/**\r\n\t\t * Type of an object\r\n\t\t * @type String\r\n\t\t * @default\r\n\t\t */\r\n\t\ttype: 'curvedText',\r\n\t\t/**\r\n\t\t * The radius of the curved Text\r\n\t\t * @type Number\r\n\t\t * @default 50\r\n\t\t */\r\n\t\tradius: 50,\r\n\t\t/**\r\n\t\t * Special Effects, Thanks to fahadnabbasi\r\n\t\t * https://github.com/EffEPi/fabric.curvedText/issues/9\r\n\t\t */\r\n\t\trange: 5,\r\n\t\tsmallFont: 10,\r\n\t\tlargeFont: 30,\r\n\t\teffect: 'curved',\r\n\t\t/**\r\n\t\t * Spacing between the letters\r\n\t\t * @type fabricNumber\r\n\t\t * @default 20\r\n\t\t */\r\n\t\tspacing: 20,\r\n//\t\tletters: null,\r\n\r\n\t\t/**\r\n\t\t * Reversing the radius (position of the original point)\r\n\t\t * @type Boolean\r\n\t\t * @default false\r\n\t\t */\r\n\t\treverse: false,\r\n\t\t/**\r\n\t\t * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})\r\n\t\t * as well as for history (undo/redo) purposes\r\n\t\t * @type Array\r\n\t\t */\r\n\t\tstateProperties: stateProperties,\r\n\t\t/**\r\n\t\t * Properties that are delegated to group objects when reading/writing\r\n\t\t * @param {Object} delegatedProperties\r\n\t\t */\r\n\t\tdelegatedProperties: delegatedProperties,\r\n\t\t/**\r\n\t\t * Properties which when set cause object to change dimensions\r\n\t\t * @type Object\r\n\t\t * @private\r\n\t\t */\r\n\t\t_dimensionAffectingProps: _dimensionAffectingProps,\r\n\t\t/**\r\n\t\t *\r\n\t\t * Rendering, is we are rendering and another rendering call is passed, then stop rendering the old and\r\n\t\t * rendering the new (trying to speed things up)\r\n\t\t */\r\n\t\t_isRendering: 0,\r\n\t\t/**\r\n\t\t * Added complexity\r\n\t\t */\r\n\t\tcomplexity: function (){\r\n\t\t\tthis.callSuper('complexity');\r\n\t\t},\r\n\t\tinitialize: function (text, options){\r\n\t\t\toptions||(options={});\r\n\t\t\tthis.letters=new fabric.Group([], {\r\n\t\t\t\tselectable: false,\r\n\t\t\t\tpadding: 0\r\n\t\t\t});\r\n\t\t\tthis.__skipDimension=true;\r\n\t\t\tthis.setOptions(options);\r\n\t\t\tthis.__skipDimension=false;\r\n//\t\t\tthis.callSuper('initialize', options);\r\n\t\t\tthis.setText(text);\r\n\t\t},\r\n\t\tsetText: function (text){\r\n\t\t\tif(this.letters){\r\n\t\t\t\twhile(text.length!==0&&this.letters.size()>=text.length){\r\n\t\t\t\t\tthis.letters.remove(this.letters.item(this.letters.size()-1));\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i=0; i<text.length; i++){\r\n\t\t\t\t\t//I need to pass the options from the main options\r\n\t\t\t\t\tif(this.letters.item(i)===undefined){\r\n\t\t\t\t\t\tthis.letters.add(new fabric.Text(text[i]));\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthis.letters.item(i).setText(text[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.callSuper('setText', text);\r\n\t\t},\r\n\t\t_initDimensions: function (ctx){\r\n\t\t\t// from fabric.Text.prototype._initDimensions\r\n\t\t\t// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\r\n\t\t\tif(this.__skipDimension){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif(!ctx){\r\n\t\t\t\tctx=fabric.util.createCanvasElement().getContext('2d');\r\n\t\t\t\tthis._setTextStyles(ctx);\r\n\t\t\t}\r\n\t\t\tthis._textLines=this.text.split(this._reNewline);\r\n\t\t\tthis._clearCache();\r\n\t\t\tvar currentTextAlign=this.textAlign;\r\n\t\t\tthis.textAlign='left';\r\n\t\t\tthis.width=this._getTextWidth(ctx);\r\n\t\t\tthis.textAlign=currentTextAlign;\r\n\t\t\tthis.height=this._getTextHeight(ctx);\r\n\t\t\t// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\r\n\t\t\tthis._render(ctx);\r\n\t\t},\r\n\t\t_render: function (ctx){\r\n\t\t\tvar renderingCode=fabric.util.getRandomInt(100, 999);\r\n\t\t\tthis._isRendering=renderingCode;\r\n\t\t\tif(this.letters){\r\n\t\t\t\tvar curAngle=0,\r\n\t\t\t\t\t\tcurAngleRotation=0,\r\n\t\t\t\t\t\tangleRadians=0,\r\n\t\t\t\t\t\talign=0,\r\n\t\t\t\t\t\ttextWidth=0,\r\n\t\t\t\t\t\tspace=parseInt(this.spacing),\r\n\t\t\t\t\t\tfixedLetterAngle=0;\r\n\r\n\t\t\t\t//get text width\r\n\t\t\t\tif(this.effect==='curved'){\r\n\t\t\t\t\tfor(var i=0, len=this.text.length; i<len; i++){\r\n\t\t\t\t\t\ttextWidth+=this.letters.item(i).width+space;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttextWidth-=space;\r\n\t\t\t\t}else if(this.effect==='arc'){\r\n\t\t\t\t\tfixedLetterAngle=((this.letters.item(0).fontSize+space)/this.radius)/(Math.PI/180);\r\n\t\t\t\t\ttextWidth=((this.text.length+1)*(this.letters.item(0).fontSize+space));\r\n\t\t\t\t}\r\n\t\t\t\t// Text align\r\n\t\t\t\tif(this.get('textAlign')==='right'){\r\n\t\t\t\t\tcurAngle=90-(((textWidth/2)/this.radius)/(Math.PI/180));\r\n\t\t\t\t}else if(this.get('textAlign')==='left'){\r\n\t\t\t\t\tcurAngle=-90-(((textWidth/2)/this.radius)/(Math.PI/180));\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcurAngle=-(((textWidth/2)/this.radius)/(Math.PI/180));\r\n\t\t\t\t}\r\n\t\t\t\tif(this.reverse)\r\n\t\t\t\t\tcurAngle=-curAngle;\r\n\r\n\t\t\t\tvar width=0,\r\n\t\t\t\t\t\tmultiplier=this.reverse?-1:1,\r\n\t\t\t\t\t\tthisLetterAngle=0,\r\n\t\t\t\t\t\tlastLetterAngle=0;\r\n\r\n\t\t\t\tfor(var i=0, len=this.text.length; i<len; i++){\r\n\t\t\t\t\tif(renderingCode!==this._isRendering)\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\tfor(var key in this.delegatedProperties){\r\n\t\t\t\t\t\tthis.letters.item(i).set(key, this.get(key));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.letters.item(i).set('left', (width));\r\n\t\t\t\t\tthis.letters.item(i).set('top', (0));\r\n\t\t\t\t\tthis.letters.item(i).setAngle(0);\r\n\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\r\n\t\t\t\t\tif(this.effect==='curved'){\r\n\t\t\t\t\t\tthisLetterAngle=((this.letters.item(i).width+space)/this.radius)/(Math.PI/180);\r\n\t\t\t\t\t\tcurAngle=multiplier*((multiplier*curAngle)+lastLetterAngle);\r\n\t\t\t\t\t\tangleRadians=curAngle*(Math.PI/180);\r\n\t\t\t\t\t\tlastLetterAngle=thisLetterAngle;\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).setAngle(curAngle);\r\n\t\t\t\t\t\tthis.letters.item(i).set('top', multiplier*-1*(Math.cos(angleRadians)*this.radius));\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', multiplier*(Math.sin(angleRadians)*this.radius));\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\r\n\t\t\t\t\t}else if(this.effect==='arc'){//arc\r\n\t\t\t\t\t\tcurAngle=multiplier*((multiplier*curAngle)+fixedLetterAngle);\r\n\t\t\t\t\t\tangleRadians=curAngle*(Math.PI/180);\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).set('top', multiplier*-1*(Math.cos(angleRadians)*this.radius));\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', multiplier*(Math.sin(angleRadians)*this.radius));\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\t\t\t\t\t}else if(this.effect==='STRAIGHT'){//STRAIGHT\r\n\t\t\t\t\t\t//var newfont=(i*5)+15;\r\n\t\t\t\t\t\t//this.letters.item(i).set('fontSize',(newfont));\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', (width));\r\n\t\t\t\t\t\tthis.letters.item(i).set('top', (0));\r\n\t\t\t\t\t\tthis.letters.item(i).setAngle(0);\r\n\t\t\t\t\t\twidth+=this.letters.item(i).get('width');\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set({\r\n\t\t\t\t\t\t\tborderColor: 'red',\r\n\t\t\t\t\t\t\tcornerColor: 'green',\r\n\t\t\t\t\t\t\tcornerSize: 6,\r\n\t\t\t\t\t\t\ttransparentCorners: false\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\t\t\t\t\t}else if(this.effect==='smallToLarge'){//smallToLarge\r\n\t\t\t\t\t\tvar small=parseInt(this.smallFont);\r\n\t\t\t\t\t\tvar large=parseInt(this.largeFont);\r\n\t\t\t\t\t\t//var small = 20;\r\n\t\t\t\t\t\t//var large = 75;\r\n\t\t\t\t\t\tvar difference=large-small;\r\n\t\t\t\t\t\tvar center=Math.ceil(this.text.length/2);\r\n\t\t\t\t\t\tvar step=difference/(this.text.length);\r\n\t\t\t\t\t\tvar newfont=small+(i*step);\r\n\r\n\t\t\t\t\t\t//var newfont=(i*this.smallFont)+15;\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).set('fontSize', (newfont));\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', (width));\r\n\t\t\t\t\t\twidth+=this.letters.item(i).get('width');\r\n\t\t\t\t\t\t//this.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\t/*this.letters.item(i).set({\r\n\t\t\t\t\t\t borderColor: 'red',\r\n\t\t\t\t\t\t cornerColor: 'green',\r\n\t\t\t\t\t\t cornerSize: 6,\r\n\t\t\t\t\t\t transparentCorners: false\r\n\t\t\t\t\t\t });*/\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\t\t\t\t\t\tthis.letters.item(i).set('top', -1*this.letters.item(i).get('fontSize')+i);\r\n\t\t\t\t\t\t//this.letters.width=width;\r\n\t\t\t\t\t\t//this.letters.height=this.letters.item(i).get('height');\r\n\r\n\t\t\t\t\t}else if(this.effect==='largeToSmallTop'){//largeToSmallTop\r\n\t\t\t\t\t\tvar small=parseInt(this.largeFont);\r\n\t\t\t\t\t\tvar large=parseInt(this.smallFont);\r\n\t\t\t\t\t\t//var small = 20;\r\n\t\t\t\t\t\t//var large = 75;\r\n\t\t\t\t\t\tvar difference=large-small;\r\n\t\t\t\t\t\tvar center=Math.ceil(this.text.length/2);\r\n\t\t\t\t\t\tvar step=difference/(this.text.length);\r\n\t\t\t\t\t\tvar newfont=small+(i*step);\r\n\t\t\t\t\t\t//var newfont=((this.text.length-i)*this.smallFont)+12;\r\n\t\t\t\t\t\tthis.letters.item(i).set('fontSize', (newfont));\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', (width));\r\n\t\t\t\t\t\twidth+=this.letters.item(i).get('width');\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set({\r\n\t\t\t\t\t\t\tborderColor: 'red',\r\n\t\t\t\t\t\t\tcornerColor: 'green',\r\n\t\t\t\t\t\t\tcornerSize: 6,\r\n\t\t\t\t\t\t\ttransparentCorners: false\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\t\t\t\t\t\tthis.letters.item(i).top=-1*this.letters.item(i).get('fontSize')+(i/this.text.length);\r\n\r\n\t\t\t\t\t}else if(this.effect==='largeToSmallBottom'){\r\n\t\t\t\t\t\tvar small=parseInt(this.largeFont);\r\n\t\t\t\t\t\tvar large=parseInt(this.smallFont);\r\n\t\t\t\t\t\t//var small = 20;\r\n\t\t\t\t\t\t//var large = 75;\r\n\t\t\t\t\t\tvar difference=large-small;\r\n\t\t\t\t\t\tvar center=Math.ceil(this.text.length/2);\r\n\t\t\t\t\t\tvar step=difference/(this.text.length);\r\n\t\t\t\t\t\tvar newfont=small+(i*step);\r\n\t\t\t\t\t\t//var newfont=((this.text.length-i)*this.smallFont)+12;\r\n\t\t\t\t\t\tthis.letters.item(i).set('fontSize', (newfont));\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', (width));\r\n\t\t\t\t\t\twidth+=this.letters.item(i).get('width');\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set({\r\n\t\t\t\t\t\t\tborderColor: 'red',\r\n\t\t\t\t\t\t\tcornerColor: 'green',\r\n\t\t\t\t\t\t\tcornerSize: 6,\r\n\t\t\t\t\t\t\ttransparentCorners: false\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\t\t\t\t\t\t//this.letters.item(i).top =-1* this.letters.item(i).get('fontSize')+newfont-((this.text.length-i))-((this.text.length-i));\r\n\t\t\t\t\t\tthis.letters.item(i).top=-1*this.letters.item(i).get('fontSize')-i;\r\n\r\n\t\t\t\t\t}else if(this.effect==='bulge'){//bulge\r\n\t\t\t\t\t\tvar small=parseInt(this.smallFont);\r\n\t\t\t\t\t\tvar large=parseInt(this.largeFont);\r\n\t\t\t\t\t\t//var small = 20;\r\n\t\t\t\t\t\t//var large = 75;\r\n\t\t\t\t\t\tvar difference=large-small;\r\n\t\t\t\t\t\tvar center=Math.ceil(this.text.length/2);\r\n\t\t\t\t\t\tvar step=difference/(this.text.length-center);\r\n\t\t\t\t\t\tif(i<center)\r\n\t\t\t\t\t\t\tvar newfont=small+(i*step);\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tvar newfont=large-((i-center+1)*step);\r\n\t\t\t\t\t\tthis.letters.item(i).set('fontSize', (newfont));\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).set('left', (width));\r\n\t\t\t\t\t\twidth+=this.letters.item(i).get('width');\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\r\n\t\t\t\t\t\tthis.letters.item(i).set('top', -1*this.letters.item(i).get('height')/2);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar scaleX=this.letters.get('scaleX');\r\n\t\t\t\tvar scaleY=this.letters.get('scaleY');\r\n\t\t\t\tvar angle=this.letters.get('angle');\r\n\r\n\t\t\t\tthis.letters.set('scaleX', 1);\r\n\t\t\t\tthis.letters.set('scaleY', 1);\r\n\t\t\t\tthis.letters.set('angle', 0);\r\n\r\n\t\t\t\t// Update group coords\r\n\t\t\t\tthis.letters._calcBounds();\r\n\t\t\t\tthis.letters._updateObjectsCoords();\r\n\t\t\t\tthis.letters.saveCoords();\r\n\t\t\t\t// this.letters.render(ctx);\r\n\r\n\t\t\t\tthis.letters.set('scaleX', scaleX);\r\n\t\t\t\tthis.letters.set('scaleY', scaleY);\r\n\t\t\t\tthis.letters.set('angle', angle);\r\n\r\n\t\t\t\tthis.width=this.letters.width;\r\n\t\t\t\tthis.height=this.letters.height;\r\n\t\t\t\tthis.letters.left=-(this.letters.width/2);\r\n\t\t\t\tthis.letters.top=-(this.letters.height/2);\r\n//\t\t\t\tconsole.log('End rendering')\r\n\t\t\t}\r\n\t\t},\r\n\t\t_renderOld: function (ctx){\r\n\t\t\tif(this.letters){\r\n\t\t\t\tvar curAngle=0,\r\n\t\t\t\t\t\tangleRadians=0,\r\n\t\t\t\t\t\talign=0;\r\n\t\t\t\t// Text align\r\n\t\t\t\tvar rev=0;\r\n\t\t\t\tif(this.reverse){\r\n\t\t\t\t\trev=0.5;\r\n\t\t\t\t}\r\n\t\t\t\tif(this.get('textAlign')==='center'||this.get('textAlign')==='justify'){\r\n\t\t\t\t\talign=(this.spacing/2)*(this.text.length-rev);\t// Remove '-1' after this.text.length for proper angle rendering\r\n\t\t\t\t}else if(this.get('textAlign')==='right'){\r\n\t\t\t\t\talign=(this.spacing)*(this.text.length-rev);\t// Remove '-1' after this.text.length for proper angle rendering\r\n\t\t\t\t}\r\n\t\t\t\tvar multiplier=this.reverse?1:-1;\r\n\t\t\t\tfor(var i=0, len=this.text.length; i<len; i++){\r\n\t\t\t\t\t// Find coords of each letters (radians : angle*(Math.PI / 180)\r\n\t\t\t\t\tcurAngle=multiplier*(-i*parseInt(this.spacing, 10)+align);\r\n\t\t\t\t\tangleRadians=curAngle*(Math.PI/180);\r\n\r\n\t\t\t\t\tfor(var key in this.delegatedProperties){\r\n\t\t\t\t\t\tthis.letters.item(i).set(key, this.get(key));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.letters.item(i).set('top', (multiplier-Math.cos(angleRadians)*this.radius));\r\n\t\t\t\t\tthis.letters.item(i).set('left', (multiplier+Math.sin(angleRadians)*this.radius));\r\n\t\t\t\t\tthis.letters.item(i).setAngle(curAngle);\r\n\t\t\t\t\tthis.letters.item(i).set('padding', 0);\r\n\t\t\t\t\tthis.letters.item(i).set('selectable', false);\r\n\t\t\t\t}\r\n\t\t\t\t// Update group coords\r\n\t\t\t\tthis.letters._calcBounds();\r\n\t\t\t\tif(this.reverse){\r\n\t\t\t\t\tthis.letters.top=this.letters.top-this.height*2.5;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.letters.top=0;\r\n\t\t\t\t}\r\n\t\t\t\tthis.letters.left=this.letters.left-this.width/2; // Change here, for proper group display\r\n\t\t\t\t//this.letters._updateObjectsCoords();\t\t\t\t\t// Commented off this line for group misplacement\r\n\t\t\t\tthis.letters.saveCoords();\r\n//\t\t\t\tthis.letters.render(ctx);\r\n\t\t\t\tthis.width=this.letters.width;\r\n\t\t\t\tthis.height=this.letters.height;\r\n\t\t\t\tthis.letters.left=-(this.letters.width/2);\r\n\t\t\t\tthis.letters.top=-(this.letters.height/2);\r\n\t\t\t}\r\n\t\t},\r\n\t\trender: function (ctx, noTransform){\r\n\t\t\t// do not render if object is not visible\r\n\t\t\tif(!this.visible)\r\n\t\t\t\treturn;\r\n\t\t\tif(!this.letters)\r\n\t\t\t\treturn;\r\n\r\n\t\t\tctx.save();\r\n\t\t\tthis.transform(ctx);\r\n\r\n\t\t\tvar groupScaleFactor=Math.max(this.scaleX, this.scaleY);\r\n\r\n\t\t\tthis.clipTo&&fabric.util.clipContext(this, ctx);\r\n\r\n\t\t\t//The array is now sorted in order of highest first, so start from end.\r\n\t\t\tfor(var i=0, len=this.letters.size(); i<len; i++){\r\n\t\t\t\tvar object=this.letters.item(i),\r\n\t\t\t\t\t\toriginalScaleFactor=object.borderScaleFactor,\r\n\t\t\t\t\t\toriginalHasRotatingPoint=object.hasRotatingPoint;\r\n\r\n\t\t\t\t// do not render if object is not visible\r\n\t\t\t\tif(!object.visible)\r\n\t\t\t\t\tcontinue;\r\n\r\n//\t\t\t\tobject.borderScaleFactor=groupScaleFactor;\r\n//\t\t\t\tobject.hasRotatingPoint=false;\r\n\r\n\t\t\t\tobject.render(ctx);\r\n\r\n//\t\t\t\tobject.borderScaleFactor=originalScaleFactor;\r\n//\t\t\t\tobject.hasRotatingPoint=originalHasRotatingPoint;\r\n\t\t\t}\r\n\t\t\tthis.clipTo&&ctx.restore();\r\n\r\n\t\t\t//Those lines causes double borders.. not sure why\r\n//\t\t\tif(!noTransform&&this.active){\r\n//\t\t\t\tthis.drawBorders(ctx);\r\n//\t\t\t\tthis.drawControls(ctx);\r\n//\t\t\t}\r\n\t\t\tctx.restore();\r\n\t\t\tthis.setCoords();\r\n\t\t},\r\n\t\t/**\r\n\t\t * @private\r\n\t\t */\r\n\t\t_set: function (key, value){\r\n\t\t\tthis.callSuper('_set', key, value);\r\n\t\t\tif(this.letters){\r\n\t\t\t\tthis.letters.set(key, value);\r\n\t\t\t\t//Properties are delegated with the object is rendered\r\n//\t\t\t\tif (key in this.delegatedProperties) {\r\n//\t\t\t\t\tvar i = this.letters.size();\r\n//\t\t\t\t\twhile (i--) {\r\n//\t\t\t\t\t\tthis.letters.item(i).set(key, value);\r\n//\t\t\t\t\t}\r\n//\t\t\t\t}\r\n\t\t\t\tif(key in this._dimensionAffectingProps){\r\n\t\t\t\t\tthis._initDimensions();\r\n\t\t\t\t\tthis.setCoords();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\ttoObject: function (propertiesToInclude){\r\n\t\t\tvar object=extend(this.callSuper('toObject', propertiesToInclude), {\r\n\t\t\t\tradius: this.radius,\r\n\t\t\t\tspacing: this.spacing,\r\n\t\t\t\treverse: this.reverse,\r\n\t\t\t\teffect: this.effect,\r\n\t\t\t\trange: this.range,\r\n\t\t\t\tsmallFont: this.smallFont,\r\n\t\t\t\tlargeFont: this.largeFont\r\n\t\t\t\t\t\t//\t\t\t\tletters: this.letters\t//No need to pass this, the letters are recreated on the fly every time when initiated\r\n\t\t\t});\r\n\t\t\tif(!this.includeDefaultValues){\r\n\t\t\t\tthis._removeDefaultValues(object);\r\n\t\t\t}\r\n\t\t\treturn object;\r\n\t\t},\r\n\t\t/**\r\n\t\t * Returns string represenation of a group\r\n\t\t * @return {String}\r\n\t\t */\r\n\t\ttoString: function (){\r\n\t\t\treturn '#<fabric.CurvedText ('+this.complexity()+'): { \"text\": \"'+this.text+'\", \"fontFamily\": \"'+this.fontFamily+'\", \"radius\": \"'+this.radius+'\", \"spacing\": \"'+this.spacing+'\", \"reverse\": \"'+this.reverse+'\" }>';\r\n\t\t},\r\n\t\t/* _TO_SVG_START_ */\r\n\t\t/**\r\n\t\t * Returns svg representation of an instance\r\n\t\t * @param {Function} [reviver] Method for further parsing of svg representation.\r\n\t\t * @return {String} svg representation of an instance\r\n\t\t */\r\n\t\ttoSVG: function (reviver){\r\n\t\t\tvar markup=[\r\n\t\t\t\t'<g ',\r\n\t\t\t\t'transform=\"', this.getSvgTransform(),\r\n\t\t\t\t'\">'\r\n\t\t\t];\r\n\t\t\tif(this.letters){\r\n\t\t\t\tfor(var i=0, len=this.letters.size(); i<len; i++){\r\n\t\t\t\t\tmarkup.push(this.letters.item(i).toSVG(reviver));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tmarkup.push('</g>');\r\n\t\t\treturn reviver?reviver(markup.join('')):markup.join('');\r\n\t\t}\r\n\t\t/* _TO_SVG_END_ */\r\n\t});\r\n\r\n\t/**\r\n\t * Returns {@link fabric.CurvedText} instance from an object representation\r\n\t * @static\r\n\t * @memberOf fabric.CurvedText\r\n\t * @param {Object} object Object to create a group from\r\n\t * @param {Object} [options] Options object\r\n\t * @return {fabric.CurvedText} An instance of fabric.CurvedText\r\n\t */\r\n\tfabric.CurvedText.fromObject=function (object){\r\n\t\treturn new fabric.CurvedText(object.text, clone(object));\r\n\t};\r\n\r\n\tfabric.util.createAccessors(fabric.CurvedText);\r\n\r\n\t/**\r\n\t * Indicates that instances of this type are async\r\n\t * @static\r\n\t * @memberOf fabric.CurvedText\r\n\t * @type Boolean\r\n\t * @default\r\n\t */\r\n\tfabric.CurvedText.async=false;\r\n\r\n})(typeof exports!=='undefined'?exports:this);\r\n","Milople_Personalizedcool/js/customiseControls.js":"/*\r\n * fabric.js Controls Extension\r\n * for fabric.js current build\r\n * Simon Kunz 09.02.2016 for pixolith\r\n * Licensed under the MIT license.\r\n */\r\n\r\n'use strict';\r\n(function(window) {\r\n    var fabric = window.fabric || ( window.fabric = {} ),\r\n        minExtCompat = '1.6.0',\r\n        isVML = function() {\r\n            return typeof G_vmlCanvasManager !== 'undefined';\r\n        },\r\n        degreesToRadians = fabric.util.degreesToRadians,\r\n        cursorOffset = {\r\n            mt: 0, // n\r\n            tr: 1, // ne\r\n            mr: 2, // e\r\n            br: 3, // se\r\n            mb: 4, // s\r\n            bl: 5, // sw\r\n            ml: 6, // w\r\n            tl: 7, // nw\r\n        };\r\n\r\n    if (minExtCompat.localeCompare(window.fabric.version) > -1) {\r\n        console.warn('this extension might not be fully compatible with your version ' +\r\n            'of fabric.js (' + window.fabric.version + ').' +\r\n            'Consider using the latest compatible build of fabric.js (> ' + minExtCompat + ')'\r\n        );\r\n    }\r\n\r\n    fabric.util.object.extend(fabric.Object.prototype, {\r\n\r\n        /**\r\n         * When true, image icons are loaded via the drawImage method\r\n         * @type Boolean\r\n         * @default false\r\n         */\r\n\r\n        useCustomIcons: false,\r\n\r\n        /**\r\n         * Sets a background-color for drawImage operations with transparency\r\n         * @type string\r\n         * @default transparent\r\n         */\r\n\r\n        cornerBackgroundColor: 'transparent',\r\n\r\n        /**\r\n         * Sets the shape of the background for drawImage operations with transparency\r\n         * @type string\r\n         * @default rect\r\n         */\r\n\r\n        cornerShape: '',\r\n\r\n        /**\r\n         * Inner Padding between Shape Background and drawn Image\r\n         * @type int\r\n         * @default rect\r\n         */\r\n\r\n        cornerPadding: 0,\r\n\r\n        /**\r\n         * Set a custom corner icon\r\n         * @param {Object} obj settings and icon url.\r\n         * @param callback function\r\n         */\r\n\r\n        customiseCornerIcons: function(obj, callback) {\r\n            var setting,\r\n                cornerConfig;\r\n\r\n            for (setting in obj) {\r\n                if (obj.hasOwnProperty(setting)) {\r\n\r\n                    cornerConfig = {};\r\n\r\n                    if (obj[setting].cornerShape !== undefined) {\r\n                        this.cornerShape = obj[setting].cornerShape;\r\n                    }\r\n\r\n                    if (obj[setting].cornerBackgroundColor !== undefined) {\r\n                        this.cornerBackgroundColor = obj[setting].cornerBackgroundColor;\r\n                    }\r\n\r\n                    if (obj[setting].borderColor !== undefined) {\r\n                        this.borderColor = obj[setting].borderColor;\r\n                    }\r\n\r\n                    if (obj[setting].cornerSize !== undefined) {\r\n                        this.cornerSize = obj[setting].cornerSize;\r\n                    }\r\n\r\n                    if (obj[setting].cornerPadding !== undefined) {\r\n                        this.cornerPadding = obj[setting].cornerPadding;\r\n                    }\r\n\r\n                    if (obj[setting].icon !== undefined || Object.keys(obj)[0] === 'settings') {\r\n                        this.useCustomIcons = true;\r\n\r\n                        if (obj[setting].settings !== undefined) {\r\n                            cornerConfig.settings = obj[setting].settings;\r\n                        }\r\n\r\n                        if (obj[setting].icon !== undefined) {\r\n                            cornerConfig.icon = obj[setting].icon;\r\n\r\n                            this.loadIcon(setting, cornerConfig, function() {\r\n                                if (callback && typeof( callback ) === 'function') {\r\n                                    callback();\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * loads the icon image as an image src.\r\n         * @param {Object} corner to load an icon.\r\n         * @param cornerConfig as object containing icon url and corner specific settings\r\n         * @param callback function.\r\n         */\r\n\r\n        loadIcon: function(corner, cornerConfig, callback) {\r\n            var self = this,\r\n                icon = new Image();\r\n\r\n            icon.onload = function() {\r\n                self[corner + 'Icon'] = this;\r\n\r\n                if (cornerConfig.settings) {\r\n                    self[corner + 'Settings'] = cornerConfig.settings;\r\n                }\r\n\r\n                if (callback && typeof( callback ) === 'function') {\r\n                    callback();\r\n                }\r\n            };\r\n\r\n            icon.onerror = function() {\r\n                fabric.warn(this.src + ' icon is not an image');\r\n            };\r\n\r\n            if (cornerConfig.icon.match(/^http[s]?:\\/\\//) || cornerConfig.icon.substring(0, 2) === '//') {\r\n                icon.crossOrigin = 'Anonymous';\r\n            }\r\n\r\n            icon.src = cornerConfig.icon;\r\n        },\r\n\r\n        /**\r\n         * copy of the setter method for our american friends.\r\n         * @param {Object} obj containing corner icon urls and settings.\r\n         */\r\n\r\n        customizeCornerIcons: function(obj) {\r\n            this.customiseCornerIcons(obj);\r\n        },\r\n\r\n        /**\r\n         * Draws corners of an object's bounding box.\r\n         * Requires public properties: width, height\r\n         * Requires public options: cornerSize, padding\r\n         * @param {CanvasRenderingContext2D} ctx Context to draw on\r\n         * @return {fabric.Object} thisArg\r\n         * @chainable\r\n         */\r\n\r\n        drawControls: function(ctx) {\r\n\r\n            if (!this.hasControls) {\r\n                return this;\r\n            }\r\n\r\n            var wh = this._calculateCurrentDimensions(),\r\n                width = wh.x,\r\n                height = wh.y,\r\n                scaleOffset = this.cornerSize,\r\n                left = -(width + scaleOffset) / 2,\r\n                top = -(height + scaleOffset) / 2,\r\n                methodName;\r\n\r\n            if (!this.useCustomIcons) {\r\n                ctx.lineWidth = 1;\r\n                ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;\r\n                ctx.strokeStyle = ctx.fillStyle = this.cornerColor;\r\n\r\n                if (!this.transparentCorners) {\r\n                    ctx.strokeStyle = this.cornerStrokeColor;\r\n                }\r\n\r\n                methodName = this.transparentCorners ? 'stroke' : 'fill';\r\n            } else {\r\n                methodName = 'drawImage';\r\n            }\r\n\r\n            ctx.save();\r\n            //this._setLineDash(ctx, this.cornerDashArray, null);\r\n\r\n            // top-left\r\n            this._drawControl('tl', ctx, methodName,\r\n                left,\r\n                top,\r\n                this.tlIcon,\r\n                this.tlSettings\r\n            );\r\n\r\n            // top-right\r\n            this._drawControl('tr', ctx, methodName,\r\n                left + width,\r\n                top,\r\n                this.trIcon,\r\n                this.trSettings\r\n            );\r\n\r\n            // bottom-left\r\n            this._drawControl('bl', ctx, methodName,\r\n                left,\r\n                top + height,\r\n                this.blIcon,\r\n                this.blSettings\r\n            );\r\n\r\n            // bottom-right\r\n            this._drawControl('br', ctx, methodName,\r\n                left + width,\r\n                top + height,\r\n                this.brIcon,\r\n                this.brSettings\r\n            );\r\n\r\n            if (!this.get('lockUniScaling')) {\r\n\r\n                // middle-top\r\n                this._drawControl('mt', ctx, methodName,\r\n                    left + width / 2,\r\n                    top,\r\n                    this.mtIcon,\r\n                    this.mtSettings\r\n                );\r\n\r\n                // middle-bottom\r\n                this._drawControl('mb', ctx, methodName,\r\n                    left + width / 2,\r\n                    top + height,\r\n                    this.mbIcon,\r\n                    this.mbSettings\r\n                );\r\n\r\n                // middle-right\r\n                this._drawControl('mr', ctx, methodName,\r\n                    left + width,\r\n                    top + height / 2,\r\n                    this.mrIcon,\r\n                    this.mrSettings\r\n                );\r\n\r\n                // middle-left\r\n                this._drawControl('ml', ctx, methodName,\r\n                    left,\r\n                    top + height / 2,\r\n                    this.mlIcon,\r\n                    this.mlSettings\r\n                );\r\n            }\r\n\r\n            // middle-top-rotate\r\n            if (this.hasRotatingPoint) {\r\n                this._drawControl('mtr', ctx, methodName,\r\n                    left + width / 2,\r\n                    top - this.rotatingPointOffset,\r\n                    this.mtrIcon,\r\n                    this.mtrSettings\r\n                );\r\n            }\r\n\r\n            ctx.restore();\r\n\r\n            return this;\r\n        },\r\n\r\n        /** Draw controls either with background-shape and color (transparency) or plain image (modified core method)\r\n         * @private\r\n         * {string} icon url of the control\r\n         */\r\n\r\n        _drawControl: function(control, ctx, methodName, left, top, icon, settings) {\r\n            if (!this.isControlVisible(control)) {\r\n                return;\r\n            }\r\n\r\n            var size = this.cornerSize,\r\n                cornerStroke = this.cornerStrokeColor || 'transparent',\r\n                cornerBG = this.cornerBackgroundColor || 'black',\r\n                cornerShape = this.cornerShape || 'rect',\r\n                cornerPadding = this.cornerPadding || 10;\r\n\r\n            if (settings) {\r\n                if (settings.cornerSize) {\r\n                    // Set the size, and also recalc left and top\r\n                    left = left + size / 2 - settings.cornerSize / 2;\r\n                    top = top + size / 2 - settings.cornerSize / 2;\r\n                    size = settings.cornerSize;\r\n                }\r\n                cornerShape = settings.cornerShape || cornerShape;\r\n                cornerBG = settings.cornerBackgroundColor || cornerBG;\r\n                cornerPadding = settings.cornerPadding || cornerPadding;\r\n            }\r\n\r\n            if (this.useCustomIcons) {\r\n                if (cornerShape) {\r\n                    ctx.globalAlpha = 1;\r\n                    ctx.fillStyle = cornerBG;\r\n                    ctx.lineWidth = 1;\r\n                    ctx.strokeStyle = cornerStroke;\r\n                    switch (cornerShape) {\r\n                        case 'rect':\r\n                            ctx.fillRect(left, top, size, size);\r\n\r\n                            if (cornerStroke) {\r\n                                ctx.strokeRect(left, top, size, size);\r\n                            }\r\n\r\n                            break;\r\n                        case 'circle':\r\n                            ctx.beginPath();\r\n                            ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI);\r\n                            ctx.fill();\r\n\r\n                            if (cornerStroke) {\r\n                                ctx.stroke();\r\n                            }\r\n\r\n                            ctx.closePath();\r\n                            break;\r\n                    }\r\n\r\n                    if (icon !== undefined) {\r\n                        ctx[methodName](\r\n                            icon,\r\n                            left + cornerPadding / 2,\r\n                            top + cornerPadding / 2,\r\n                            size - cornerPadding,\r\n                            size - cornerPadding\r\n                        );\r\n                    }\r\n\r\n                } else {\r\n                    if (icon !== undefined) {\r\n                        ctx[methodName](\r\n                            icon,\r\n                            left,\r\n                            top,\r\n                            size,\r\n                            size\r\n                        );\r\n                    }\r\n                }\r\n            } else {\r\n                isVML() || this.transparentCorners || ctx.clearRect(left, top, size, size);\r\n                ctx[methodName + 'Rect'](left, top, size, size);\r\n                if (!this.transparentCorners && cornerStroke) {\r\n                    ctx.strokeRect(left, top, size, size);\r\n                }\r\n            }\r\n\r\n        },\r\n    });\r\n\r\n    fabric.util.object.extend(fabric.Canvas.prototype, {\r\n        /**\r\n         * When true, actions can be overwritten\r\n         * @type Boolean\r\n         * @default false\r\n         */\r\n\r\n        overwriteActions: false,\r\n\r\n        /**\r\n         * When true, cursors are fixed\r\n         * @type Boolean\r\n         * @default false\r\n         */\r\n\r\n        fixedCursors: false,\r\n\r\n        /**\r\n         * setter Method for actions and cursors.\r\n         * @param {Object} obj containing corner action and cursor url/type.\r\n         */\r\n\r\n        customiseControls: function(obj) {\r\n            var setting;\r\n\r\n            for (setting in obj) {\r\n                if (obj.hasOwnProperty(setting)) {\r\n                    if (obj[setting].action !== undefined) {\r\n                        this.overwriteActions = true;\r\n                        this.setCustomAction(setting, obj[setting].action);\r\n                    }\r\n\r\n                    if (obj[setting].cursor !== undefined) {\r\n                        this.fixedCursors = true;\r\n                        this.setCustomCursor(setting, obj[setting].cursor);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * loads the icon image as an image src.\r\n         * @param {Object} corner to load an icon.\r\n         * @param action as a string.\r\n         */\r\n\r\n        setCustomAction: function(corner, action) {\r\n            this[corner + 'Action'] = action;\r\n        },\r\n\r\n        /**\r\n         * loads the icon image as an image src.\r\n         * @param {Object} corner to load an icon.\r\n         * @param cursorUrl as a string.\r\n         */\r\n\r\n        setCustomCursor: function(corner, cursorUrl) {\r\n            this[corner + 'cursorIcon'] = cursorUrl;\r\n        },\r\n\r\n        /**\r\n         * copy of the setter method for our american friends.\r\n         * @param {Object} obj containing corner action and cursor url/type.\r\n         */\r\n\r\n        customizeControls: function(obj) {\r\n            this.customiseControls(obj);\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n\r\n        _getActionFromCorner: function(target, corner, e) {\r\n            if (!corner) {\r\n                return 'drag';\r\n            }\r\n\r\n            if (corner) {\r\n                if (this[corner + 'Action'] && this.overwriteActions) {\r\n                    switch (corner) {\r\n                        case 'mtr':\r\n                            return this[corner + 'Action'] || 'rotate';\r\n                        case 'ml':\r\n                        case 'mr':\r\n                            if (e[this.altActionKey]) {\r\n                                return e[this.altActionKey] ? 'skewY' : 'scaleX';\r\n                            }\r\n                            return this[corner + 'Action'];\r\n                        case 'mt':\r\n                        case 'mb':\r\n                            if (e[this.altActionKey]) {\r\n                                return e[this.altActionKey] ? 'skewY' : 'scaleY';\r\n                            }\r\n                            return this[corner + 'Action'];\r\n                        default:\r\n                            return this[corner + 'Action'] || 'scale';\r\n                    }\r\n                } else {\r\n                    switch (corner) {\r\n                        case 'mtr':\r\n                            return 'rotate';\r\n                        case 'ml':\r\n                        case 'mr':\r\n                            return e[this.altActionKey] ? 'skewY' : 'scaleX';\r\n                        case 'mt':\r\n                        case 'mb':\r\n                            return e[this.altActionKey] ? 'skewX' : 'scaleY';\r\n                        default:\r\n                            return 'scale';\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         * @param {Event} e Event object\r\n         * @param {fabric.Object} target\r\n         */\r\n        _setupCurrentTransform: function(e, target) {\r\n            if (!target) {\r\n                return;\r\n            }\r\n\r\n            var pointer = this.getPointer(e),\r\n                corner = target._findTargetCorner(this.getPointer(e, true)),\r\n                action = this._getActionFromCorner(target, corner, e),\r\n                origin = this._getOriginFromCorner(target, corner);\r\n\r\n            if (typeof action === 'function') {\r\n                action.call(this, e, target);\r\n\r\n                // as of fabric 1.7.11 object cache will try to slice the action to check for scale so we need to convert this to a string\r\n                action = 'void';\r\n            }\r\n\r\n            this._currentTransform = {\r\n                target: target,\r\n                action: action,\r\n                corner: corner,\r\n                scaleX: target.scaleX,\r\n                scaleY: target.scaleY,\r\n                skewX: target.skewX,\r\n                skewY: target.skewY,\r\n                offsetX: pointer.x - target.left,\r\n                offsetY: pointer.y - target.top,\r\n                originX: origin.x,\r\n                originY: origin.y,\r\n                ex: pointer.x,\r\n                ey: pointer.y,\r\n                lastX: pointer.x,\r\n                lastY: pointer.y,\r\n                left: target.left,\r\n                top: target.top,\r\n                theta: degreesToRadians(target.angle),\r\n                width: target.width * target.scaleX,\r\n                mouseXSign: 1,\r\n                mouseYSign: 1,\r\n                shiftKey: e.shiftKey,\r\n                altKey: e[this.centeredKey],\r\n            };\r\n\r\n            this._currentTransform.original = {\r\n                left: target.left,\r\n                top: target.top,\r\n                scaleX: target.scaleX,\r\n                scaleY: target.scaleY,\r\n                skewX: target.skewX,\r\n                skewY: target.skewY,\r\n                originX: origin.x,\r\n                originY: origin.y,\r\n            };\r\n\r\n            if (action === 'remove') {\r\n                this._removeAction(e, target);\r\n            }\r\n\r\n            if (action === 'moveUp') {\r\n                this._moveLayerUpAction(e, target);\r\n            }\r\n\r\n            if (action === 'moveDown') {\r\n                this._moveLayerDownAction(e, target);\r\n            }\r\n\r\n            if (typeof action === 'object') {\r\n                if (Object.keys(action)[0] === 'rotateByDegrees') {\r\n                    this._rotateByDegrees(e, target, action.rotateByDegrees);\r\n                }\r\n            }\r\n\r\n            this._resetCurrentTransform();\r\n        },\r\n\r\n        /**\r\n         * Custom remove object action\r\n         * @private\r\n         * @param {Event} e Event object\r\n         * @param {fabric.Object} target\r\n         */\r\n\r\n        _removeAction: function(e, target) {\r\n            var _this = this;\r\n            if (this.getActiveGroup() && this.getActiveGroup() !== 'undefined') {\r\n                this.getActiveGroup().forEachObject(function(o) {\r\n                    o.off();\r\n                    o.remove();\r\n                });\r\n                this.discardActiveGroup();\r\n\r\n                // as of fabric 1.6.3 necessary for reasons..\r\n                setTimeout(function() {\r\n                    _this.deactivateAll();\r\n                }, 0);\r\n\r\n            } else {\r\n                target.off();\r\n                target.remove();\r\n\r\n                setTimeout(function() {\r\n                    _this.deactivateAll();\r\n                }, 0);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Custom move up object action\r\n         * @private\r\n         * @param {Event} e Event object\r\n         * @param {fabric.Object} target\r\n         */\r\n\r\n        _moveLayerUpAction: function(e, target) {\r\n            if (this.getActiveGroup() && this.getActiveGroup() !== 'undefined') {\r\n                this.getActiveGroup().forEachObject(function(o) {\r\n                    o.bringForward();\r\n                });\r\n            } else {\r\n                target.bringForward();\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Custom move down object action\r\n         * @private\r\n         * @param {Event} e Event object\r\n         * @param {fabric.Object} target\r\n         */\r\n\r\n        _moveLayerDownAction: function(e, target) {\r\n            if (this.getActiveGroup() && this.getActiveGroup() !== 'undefined') {\r\n                this.getActiveGroup().forEachObject(function(o) {\r\n                    o.sendBackwards();\r\n                });\r\n            } else {\r\n                target.sendBackwards();\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Custom move down object action\r\n         * @private\r\n         * @param {Event} e Event object\r\n         * @param {fabric.Object} target\r\n         * @param {Integer} value of rotation\r\n         */\r\n\r\n        _rotateByDegrees: function(e, target, value) {\r\n            var angle = parseInt(target.getAngle()) + value,\r\n                needsOriginRestore = false;\r\n\r\n            if (( target.originX !== 'center' || target.originY !== 'center' ) && target.centeredRotation) {\r\n                this._setOriginToCenter(target);\r\n                needsOriginRestore = true;\r\n            }\r\n\r\n            angle = angle > 360 ? angle - 360 : angle;\r\n\r\n            if (this.getActiveGroup() && this.getActiveGroup() !== 'undefined') {\r\n                this.getActiveGroup().forEachObject(function(obj) {\r\n                    obj\r\n                        .setAngle(angle)\r\n                        .setCoords();\r\n                });\r\n            } else {\r\n                target\r\n                    .setAngle(angle)\r\n                    .setCoords();\r\n            }\r\n\r\n            if (needsOriginRestore) {\r\n                this._setCenterToOrigin(target);\r\n            }\r\n\r\n            this.renderAll();\r\n        },\r\n\r\n        /**\r\n         * Sets either the standard behaviour cursors or if fixedCursors is true, tries to set a custom cursor\r\n         * either by using an icon or a build-in cursor. Cursor icon extensions are matched with a regular expression.\r\n         * @private\r\n         * {string} corner name\r\n         * {target} event handler of the hovered corner\r\n         */\r\n        _setCornerCursor: function(corner, target, e) {\r\n            var iconUrlPattern = /\\.(?:jpe?g|png|gif|jpg|jpeg|svg)$/;\r\n\r\n            if (this.fixedCursors && this[corner + 'cursorIcon']) {\r\n                if (this[corner + 'cursorIcon'].match(iconUrlPattern)) {\r\n                    this.setCursor('url(' + this[corner + 'cursorIcon'] + '), auto');\r\n                } else {\r\n                    if (this[corner + 'cursorIcon'] === 'resize') {\r\n                        this.setCursor(this._getRotatedCornerCursor(corner, target, e));\r\n                    } else {\r\n                        this.setCursor(this[corner + 'cursorIcon']);\r\n                    }\r\n                }\r\n            } else {\r\n                if (corner in cursorOffset) {\r\n                    this.setCursor(this._getRotatedCornerCursor(corner, target, e));\r\n                } else if (corner === 'mtr' && target.hasRotatingPoint) {\r\n                    this.setCursor(this.rotationCursor);\r\n                } else {\r\n                    this.setCursor(this.defaultCursor);\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        },\r\n    });\r\n\r\n    if (typeof exports !== 'undefined') {\r\n        module.exports = this;\r\n    }\r\n\r\n})(window);\r\n","Milople_Personalizedcool/js/jcrop.js":"/**\r\n * jquery.Jcrop.min.js v0.9.12 (build:20130202)\r\n * jQuery Image Cropping Plugin - released under MIT License\r\n * Copyright (c) 2008-2013 Tapmodo Interactive LLC\r\n * https://github.com/tapmodo/Jcrop\r\n */\r\nrequire([\"jquery\"], function (jQuery) {\r\n(function(a){a.Jcrop=function(b,c){function i(a){return Math.round(a)+\"px\"}function j(a){return d.baseClass+\"-\"+a}function k(){return a.fx.step.hasOwnProperty(\"backgroundColor\")}function l(b){var c=a(b).offset();return[c.left,c.top]}function m(a){return[a.pageX-e[0],a.pageY-e[1]]}function n(b){typeof b!=\"object\"&&(b={}),d=a.extend(d,b),a.each([\"onChange\",\"onSelect\",\"onRelease\",\"onDblClick\"],function(a,b){typeof d[b]!=\"function\"&&(d[b]=function(){})})}function o(a,b,c){e=l(D),bc.setCursor(a===\"move\"?a:a+\"-resize\");if(a===\"move\")return bc.activateHandlers(q(b),v,c);var d=_.getFixed(),f=r(a),g=_.getCorner(r(f));_.setPressed(_.getCorner(f)),_.setCurrent(g),bc.activateHandlers(p(a,d),v,c)}function p(a,b){return function(c){if(!d.aspectRatio)switch(a){case\"e\":c[1]=b.y2;break;case\"w\":c[1]=b.y2;break;case\"n\":c[0]=b.x2;break;case\"s\":c[0]=b.x2}else switch(a){case\"e\":c[1]=b.y+1;break;case\"w\":c[1]=b.y+1;break;case\"n\":c[0]=b.x+1;break;case\"s\":c[0]=b.x+1}_.setCurrent(c),bb.update()}}function q(a){var b=a;return bd.watchKeys\r\n(),function(a){_.moveOffset([a[0]-b[0],a[1]-b[1]]),b=a,bb.update()}}function r(a){switch(a){case\"n\":return\"sw\";case\"s\":return\"nw\";case\"e\":return\"nw\";case\"w\":return\"ne\";case\"ne\":return\"sw\";case\"nw\":return\"se\";case\"se\":return\"nw\";case\"sw\":return\"ne\"}}function s(a){return function(b){return d.disabled?!1:a===\"move\"&&!d.allowMove?!1:(e=l(D),W=!0,o(a,m(b)),b.stopPropagation(),b.preventDefault(),!1)}}function t(a,b,c){var d=a.width(),e=a.height();d>b&&b>0&&(d=b,e=b/a.width()*a.height()),e>c&&c>0&&(e=c,d=c/a.height()*a.width()),T=a.width()/d,U=a.height()/e,a.width(d).height(e)}function u(a){return{x:a.x*T,y:a.y*U,x2:a.x2*T,y2:a.y2*U,w:a.w*T,h:a.h*U}}function v(a){var b=_.getFixed();b.w>d.minSelect[0]&&b.h>d.minSelect[1]?(bb.enableHandles(),bb.done()):bb.release(),bc.setCursor(d.allowSelect?\"crosshair\":\"default\")}function w(a){if(d.disabled)return!1;if(!d.allowSelect)return!1;W=!0,e=l(D),bb.disableHandles(),bc.setCursor(\"crosshair\");var b=m(a);return _.setPressed(b),bb.update(),bc.activateHandlers(x,v,a.type.substring\r\n(0,5)===\"touch\"),bd.watchKeys(),a.stopPropagation(),a.preventDefault(),!1}function x(a){_.setCurrent(a),bb.update()}function y(){var b=a(\"<div></div>\").addClass(j(\"tracker\"));return g&&b.css({opacity:0,backgroundColor:\"white\"}),b}function be(a){G.removeClass().addClass(j(\"holder\")).addClass(a)}function bf(a,b){function t(){window.setTimeout(u,l)}var c=a[0]/T,e=a[1]/U,f=a[2]/T,g=a[3]/U;if(X)return;var h=_.flipCoords(c,e,f,g),i=_.getFixed(),j=[i.x,i.y,i.x2,i.y2],k=j,l=d.animationDelay,m=h[0]-j[0],n=h[1]-j[1],o=h[2]-j[2],p=h[3]-j[3],q=0,r=d.swingSpeed;c=k[0],e=k[1],f=k[2],g=k[3],bb.animMode(!0);var s,u=function(){return function(){q+=(100-q)/r,k[0]=Math.round(c+q/100*m),k[1]=Math.round(e+q/100*n),k[2]=Math.round(f+q/100*o),k[3]=Math.round(g+q/100*p),q>=99.8&&(q=100),q<100?(bh(k),t()):(bb.done(),bb.animMode(!1),typeof b==\"function\"&&b.call(bs))}}();t()}function bg(a){bh([a[0]/T,a[1]/U,a[2]/T,a[3]/U]),d.onSelect.call(bs,u(_.getFixed())),bb.enableHandles()}function bh(a){_.setPressed([a[0],a[1]]),_.setCurrent([a[2],\r\na[3]]),bb.update()}function bi(){return u(_.getFixed())}function bj(){return _.getFixed()}function bk(a){n(a),br()}function bl(){d.disabled=!0,bb.disableHandles(),bb.setCursor(\"default\"),bc.setCursor(\"default\")}function bm(){d.disabled=!1,br()}function bn(){bb.done(),bc.activateHandlers(null,null)}function bo(){G.remove(),A.show(),A.css(\"visibility\",\"visible\"),a(b).removeData(\"Jcrop\")}function bp(a,b){bb.release(),bl();var c=new Image;c.onload=function(){var e=c.width,f=c.height,g=d.boxWidth,h=d.boxHeight;D.width(e).height(f),D.attr(\"src\",a),H.attr(\"src\",a),t(D,g,h),E=D.width(),F=D.height(),H.width(E).height(F),M.width(E+L*2).height(F+L*2),G.width(E).height(F),ba.resize(E,F),bm(),typeof b==\"function\"&&b.call(bs)},c.src=a}function bq(a,b,c){var e=b||d.bgColor;d.bgFade&&k()&&d.fadeTime&&!c?a.animate({backgroundColor:e},{queue:!1,duration:d.fadeTime}):a.css(\"backgroundColor\",e)}function br(a){d.allowResize?a?bb.enableOnly():bb.enableHandles():bb.disableHandles(),bc.setCursor(d.allowSelect?\"crosshair\":\"default\"),bb\r\n.setCursor(d.allowMove?\"move\":\"default\"),d.hasOwnProperty(\"trueSize\")&&(T=d.trueSize[0]/E,U=d.trueSize[1]/F),d.hasOwnProperty(\"setSelect\")&&(bg(d.setSelect),bb.done(),delete d.setSelect),ba.refresh(),d.bgColor!=N&&(bq(d.shade?ba.getShades():G,d.shade?d.shadeColor||d.bgColor:d.bgColor),N=d.bgColor),O!=d.bgOpacity&&(O=d.bgOpacity,d.shade?ba.refresh():bb.setBgOpacity(O)),P=d.maxSize[0]||0,Q=d.maxSize[1]||0,R=d.minSize[0]||0,S=d.minSize[1]||0,d.hasOwnProperty(\"outerImage\")&&(D.attr(\"src\",d.outerImage),delete d.outerImage),bb.refresh()}var d=a.extend({},a.Jcrop.defaults),e,f=navigator.userAgent.toLowerCase(),g=/msie/.test(f),h=/msie [1-6]\\./.test(f);typeof b!=\"object\"&&(b=a(b)[0]),typeof c!=\"object\"&&(c={}),n(c);var z={border:\"none\",visibility:\"visible\",margin:0,padding:0,position:\"absolute\",top:0,left:0},A=a(b),B=!0;if(b.tagName==\"IMG\"){if(A[0].width!=0&&A[0].height!=0)A.width(A[0].width),A.height(A[0].height);else{var C=new Image;C.src=A[0].src,A.width(C.width),A.height(C.height)}var D=A.clone().removeAttr(\"id\").\r\ncss(z).show();D.width(A.width()),D.height(A.height()),A.after(D).hide()}else D=A.css(z).show(),B=!1,d.shade===null&&(d.shade=!0);t(D,d.boxWidth,d.boxHeight);var E=D.width(),F=D.height(),G=a(\"<div />\").width(E).height(F).addClass(j(\"holder\")).css({position:\"relative\",backgroundColor:d.bgColor}).insertAfter(A).append(D);d.addClass&&G.addClass(d.addClass);var H=a(\"<div />\"),I=a(\"<div />\").width(\"100%\").height(\"100%\").css({zIndex:310,position:\"absolute\",overflow:\"hidden\"}),J=a(\"<div />\").width(\"100%\").height(\"100%\").css(\"zIndex\",320),K=a(\"<div />\").css({position:\"absolute\",zIndex:600}).dblclick(function(){var a=_.getFixed();d.onDblClick.call(bs,a)}).insertBefore(D).append(I,J);B&&(H=a(\"<img />\").attr(\"src\",D.attr(\"src\")).css(z).width(E).height(F),I.append(H)),h&&K.css({overflowY:\"hidden\"});var L=d.boundary,M=y().width(E+L*2).height(F+L*2).css({position:\"absolute\",top:i(-L),left:i(-L),zIndex:290}).mousedown(w),N=d.bgColor,O=d.bgOpacity,P,Q,R,S,T,U,V=!0,W,X,Y;e=l(D);var Z=function(){function a(){var a={},b=[\"touchstart\"\r\n,\"touchmove\",\"touchend\"],c=document.createElement(\"div\"),d;try{for(d=0;d<b.length;d++){var e=b[d];e=\"on\"+e;var f=e in c;f||(c.setAttribute(e,\"return;\"),f=typeof c[e]==\"function\"),a[b[d]]=f}return a.touchstart&&a.touchend&&a.touchmove}catch(g){return!1}}function b(){return d.touchSupport===!0||d.touchSupport===!1?d.touchSupport:a()}return{createDragger:function(a){return function(b){return d.disabled?!1:a===\"move\"&&!d.allowMove?!1:(e=l(D),W=!0,o(a,m(Z.cfilter(b)),!0),b.stopPropagation(),b.preventDefault(),!1)}},newSelection:function(a){return w(Z.cfilter(a))},cfilter:function(a){return a.pageX=a.originalEvent.changedTouches[0].pageX,a.pageY=a.originalEvent.changedTouches[0].pageY,a},isSupported:a,support:b()}}(),_=function(){function h(d){d=n(d),c=a=d[0],e=b=d[1]}function i(a){a=n(a),f=a[0]-c,g=a[1]-e,c=a[0],e=a[1]}function j(){return[f,g]}function k(d){var f=d[0],g=d[1];0>a+f&&(f-=f+a),0>b+g&&(g-=g+b),F<e+g&&(g+=F-(e+g)),E<c+f&&(f+=E-(c+f)),a+=f,c+=f,b+=g,e+=g}function l(a){var b=m();switch(a){case\"ne\":return[\r\nb.x2,b.y];case\"nw\":return[b.x,b.y];case\"se\":return[b.x2,b.y2];case\"sw\":return[b.x,b.y2]}}function m(){if(!d.aspectRatio)return p();var f=d.aspectRatio,g=d.minSize[0]/T,h=d.maxSize[0]/T,i=d.maxSize[1]/U,j=c-a,k=e-b,l=Math.abs(j),m=Math.abs(k),n=l/m,r,s,t,u;return h===0&&(h=E*10),i===0&&(i=F*10),n<f?(s=e,t=m*f,r=j<0?a-t:t+a,r<0?(r=0,u=Math.abs((r-a)/f),s=k<0?b-u:u+b):r>E&&(r=E,u=Math.abs((r-a)/f),s=k<0?b-u:u+b)):(r=c,u=l/f,s=k<0?b-u:b+u,s<0?(s=0,t=Math.abs((s-b)*f),r=j<0?a-t:t+a):s>F&&(s=F,t=Math.abs(s-b)*f,r=j<0?a-t:t+a)),r>a?(r-a<g?r=a+g:r-a>h&&(r=a+h),s>b?s=b+(r-a)/f:s=b-(r-a)/f):r<a&&(a-r<g?r=a-g:a-r>h&&(r=a-h),s>b?s=b+(a-r)/f:s=b-(a-r)/f),r<0?(a-=r,r=0):r>E&&(a-=r-E,r=E),s<0?(b-=s,s=0):s>F&&(b-=s-F,s=F),q(o(a,b,r,s))}function n(a){return a[0]<0&&(a[0]=0),a[1]<0&&(a[1]=0),a[0]>E&&(a[0]=E),a[1]>F&&(a[1]=F),[Math.round(a[0]),Math.round(a[1])]}function o(a,b,c,d){var e=a,f=c,g=b,h=d;return c<a&&(e=c,f=a),d<b&&(g=d,h=b),[e,g,f,h]}function p(){var d=c-a,f=e-b,g;return P&&Math.abs(d)>P&&(c=d>0?a+P:a-P),Q&&Math.abs\r\n(f)>Q&&(e=f>0?b+Q:b-Q),S/U&&Math.abs(f)<S/U&&(e=f>0?b+S/U:b-S/U),R/T&&Math.abs(d)<R/T&&(c=d>0?a+R/T:a-R/T),a<0&&(c-=a,a-=a),b<0&&(e-=b,b-=b),c<0&&(a-=c,c-=c),e<0&&(b-=e,e-=e),c>E&&(g=c-E,a-=g,c-=g),e>F&&(g=e-F,b-=g,e-=g),a>E&&(g=a-F,e-=g,b-=g),b>F&&(g=b-F,e-=g,b-=g),q(o(a,b,c,e))}function q(a){return{x:a[0],y:a[1],x2:a[2],y2:a[3],w:a[2]-a[0],h:a[3]-a[1]}}var a=0,b=0,c=0,e=0,f,g;return{flipCoords:o,setPressed:h,setCurrent:i,getOffset:j,moveOffset:k,getCorner:l,getFixed:m}}(),ba=function(){function f(a,b){e.left.css({height:i(b)}),e.right.css({height:i(b)})}function g(){return h(_.getFixed())}function h(a){e.top.css({left:i(a.x),width:i(a.w),height:i(a.y)}),e.bottom.css({top:i(a.y2),left:i(a.x),width:i(a.w),height:i(F-a.y2)}),e.right.css({left:i(a.x2),width:i(E-a.x2)}),e.left.css({width:i(a.x)})}function j(){return a(\"<div />\").css({position:\"absolute\",backgroundColor:d.shadeColor||d.bgColor}).appendTo(c)}function k(){b||(b=!0,c.insertBefore(D),g(),bb.setBgOpacity(1,0,1),H.hide(),l(d.shadeColor||d.bgColor,1),bb.\r\nisAwake()?n(d.bgOpacity,1):n(1,1))}function l(a,b){bq(p(),a,b)}function m(){b&&(c.remove(),H.show(),b=!1,bb.isAwake()?bb.setBgOpacity(d.bgOpacity,1,1):(bb.setBgOpacity(1,1,1),bb.disableHandles()),bq(G,0,1))}function n(a,e){b&&(d.bgFade&&!e?c.animate({opacity:1-a},{queue:!1,duration:d.fadeTime}):c.css({opacity:1-a}))}function o(){d.shade?k():m(),bb.isAwake()&&n(d.bgOpacity)}function p(){return c.children()}var b=!1,c=a(\"<div />\").css({position:\"absolute\",zIndex:240,opacity:0}),e={top:j(),left:j().height(F),right:j().height(F),bottom:j()};return{update:g,updateRaw:h,getShades:p,setBgColor:l,enable:k,disable:m,resize:f,refresh:o,opacity:n}}(),bb=function(){function k(b){var c=a(\"<div />\").css({position:\"absolute\",opacity:d.borderOpacity}).addClass(j(b));return I.append(c),c}function l(b,c){var d=a(\"<div />\").mousedown(s(b)).css({cursor:b+\"-resize\",position:\"absolute\",zIndex:c}).addClass(\"ord-\"+b);return Z.support&&d.bind(\"touchstart.jcrop\",Z.createDragger(b)),J.append(d),d}function m(a){var b=d.handleSize,e=l(a,c++\r\n).css({opacity:d.handleOpacity}).addClass(j(\"handle\"));return b&&e.width(b).height(b),e}function n(a){return l(a,c++).addClass(\"jcrop-dragbar\")}function o(a){var b;for(b=0;b<a.length;b++)g[a[b]]=n(a[b])}function p(a){var b,c;for(c=0;c<a.length;c++){switch(a[c]){case\"n\":b=\"hline\";break;case\"s\":b=\"hline bottom\";break;case\"e\":b=\"vline right\";break;case\"w\":b=\"vline\"}e[a[c]]=k(b)}}function q(a){var b;for(b=0;b<a.length;b++)f[a[b]]=m(a[b])}function r(a,b){d.shade||H.css({top:i(-b),left:i(-a)}),K.css({top:i(b),left:i(a)})}function t(a,b){K.width(Math.round(a)).height(Math.round(b))}function v(){var a=_.getFixed();_.setPressed([a.x,a.y]),_.setCurrent([a.x2,a.y2]),w()}function w(a){if(b)return x(a)}function x(a){var c=_.getFixed();t(c.w,c.h),r(c.x,c.y),d.shade&&ba.updateRaw(c),b||A(),a?d.onSelect.call(bs,u(c)):d.onChange.call(bs,u(c))}function z(a,c,e){if(!b&&!c)return;d.bgFade&&!e?D.animate({opacity:a},{queue:!1,duration:d.fadeTime}):D.css(\"opacity\",a)}function A(){K.show(),d.shade?ba.opacity(O):z(O,!0),b=!0}function B\r\n(){F(),K.hide(),d.shade?ba.opacity(1):z(1),b=!1,d.onRelease.call(bs)}function C(){h&&J.show()}function E(){h=!0;if(d.allowResize)return J.show(),!0}function F(){h=!1,J.hide()}function G(a){a?(X=!0,F()):(X=!1,E())}function L(){G(!1),v()}var b,c=370,e={},f={},g={},h=!1;d.dragEdges&&a.isArray(d.createDragbars)&&o(d.createDragbars),a.isArray(d.createHandles)&&q(d.createHandles),d.drawBorders&&a.isArray(d.createBorders)&&p(d.createBorders),a(document).bind(\"touchstart.jcrop-ios\",function(b){a(b.currentTarget).hasClass(\"jcrop-tracker\")&&b.stopPropagation()});var M=y().mousedown(s(\"move\")).css({cursor:\"move\",position:\"absolute\",zIndex:360});return Z.support&&M.bind(\"touchstart.jcrop\",Z.createDragger(\"move\")),I.append(M),F(),{updateVisible:w,update:x,release:B,refresh:v,isAwake:function(){return b},setCursor:function(a){M.css(\"cursor\",a)},enableHandles:E,enableOnly:function(){h=!0},showHandles:C,disableHandles:F,animMode:G,setBgOpacity:z,done:L}}(),bc=function(){function f(b){M.css({zIndex:450}),b?a(document).bind(\"touchmove.jcrop\"\r\n,k).bind(\"touchend.jcrop\",l):e&&a(document).bind(\"mousemove.jcrop\",h).bind(\"mouseup.jcrop\",i)}function g(){M.css({zIndex:290}),a(document).unbind(\".jcrop\")}function h(a){return b(m(a)),!1}function i(a){return a.preventDefault(),a.stopPropagation(),W&&(W=!1,c(m(a)),bb.isAwake()&&d.onSelect.call(bs,u(_.getFixed())),g(),b=function(){},c=function(){}),!1}function j(a,d,e){return W=!0,b=a,c=d,f(e),!1}function k(a){return b(m(Z.cfilter(a))),!1}function l(a){return i(Z.cfilter(a))}function n(a){M.css(\"cursor\",a)}var b=function(){},c=function(){},e=d.trackDocument;return e||M.mousemove(h).mouseup(i).mouseout(i),D.before(M),{activateHandlers:j,setCursor:n}}(),bd=function(){function e(){d.keySupport&&(b.show(),b.focus())}function f(a){b.hide()}function g(a,b,c){d.allowMove&&(_.moveOffset([b,c]),bb.updateVisible(!0)),a.preventDefault(),a.stopPropagation()}function i(a){if(a.ctrlKey||a.metaKey)return!0;Y=a.shiftKey?!0:!1;var b=Y?10:1;switch(a.keyCode){case 37:g(a,-b,0);break;case 39:g(a,b,0);break;case 38:g(a,0,-b);break;\r\ncase 40:g(a,0,b);break;case 27:d.allowSelect&&bb.release();break;case 9:return!0}return!1}var b=a('<input type=\"radio\" />').css({position:\"fixed\",left:\"-120px\",width:\"12px\"}).addClass(\"jcrop-keymgr\"),c=a(\"<div />\").css({position:\"absolute\",overflow:\"hidden\"}).append(b);return d.keySupport&&(b.keydown(i).blur(f),h||!d.fixedSupport?(b.css({position:\"absolute\",left:\"-20px\"}),c.append(b).insertBefore(D)):b.insertBefore(D)),{watchKeys:e}}();Z.support&&M.bind(\"touchstart.jcrop\",Z.newSelection),J.hide(),br(!0);var bs={setImage:bp,animateTo:bf,setSelect:bg,setOptions:bk,tellSelect:bi,tellScaled:bj,setClass:be,disable:bl,enable:bm,cancel:bn,release:bb.release,destroy:bo,focus:bd.watchKeys,getBounds:function(){return[E*T,F*U]},getWidgetSize:function(){return[E,F]},getScaleFactor:function(){return[T,U]},getOptions:function(){return d},ui:{holder:G,selection:K}};return g&&G.bind(\"selectstart\",function(){return!1}),A.data(\"Jcrop\",bs),bs},a.fn.Jcrop=function(b,c){var d;return this.each(function(){if(a(this).data(\"Jcrop\")){if(\r\nb===\"api\")return a(this).data(\"Jcrop\");a(this).data(\"Jcrop\").setOptions(b)}else this.tagName==\"IMG\"?a.Jcrop.Loader(this,function(){a(this).css({display:\"block\",visibility:\"hidden\"}),d=a.Jcrop(this,b),a.isFunction(c)&&c.call(d)}):(a(this).css({display:\"block\",visibility:\"hidden\"}),d=a.Jcrop(this,b),a.isFunction(c)&&c.call(d))}),this},a.Jcrop.Loader=function(b,c,d){function g(){f.complete?(e.unbind(\".jcloader\"),a.isFunction(c)&&c.call(f)):window.setTimeout(g,50)}var e=a(b),f=e[0];e.bind(\"load.jcloader\",g).bind(\"error.jcloader\",function(b){e.unbind(\".jcloader\"),a.isFunction(d)&&d.call(f)}),f.complete&&a.isFunction(c)&&(e.unbind(\".jcloader\"),c.call(f))},a.Jcrop.defaults={allowSelect:!0,allowMove:!0,allowResize:!0,trackDocument:!0,baseClass:\"jcrop\",addClass:null,bgColor:\"black\",bgOpacity:.6,bgFade:!1,borderOpacity:.4,handleOpacity:.5,handleSize:null,aspectRatio:0,keySupport:!0,createHandles:[\"n\",\"s\",\"e\",\"w\",\"nw\",\"ne\",\"se\",\"sw\"],createDragbars:[\"n\",\"s\",\"e\",\"w\"],createBorders:[\"n\",\"s\",\"e\",\"w\"],drawBorders:!0,dragEdges\r\n:!0,fixedSupport:!0,touchSupport:null,shade:null,boxWidth:0,boxHeight:0,boundary:2,fadeTime:400,animationDelay:20,swingSpeed:3,minSelect:[0,0],maxSize:[0,0],minSize:[0,0],onChange:function(){},onSelect:function(){},onDblClick:function(){},onRelease:function(){}}})(jQuery);\r\n});","Milople_Personalizedcool/js/simplecrop.js":"require([\"jquery\"], function (jQuery) {\r\n(function ($) {\r\n\r\n    $.fn.simpleCropper = function (onComplete) {\r\n\r\n        var image_dimension_x = 600;\r\n        var image_dimension_y = 600;\r\n        var scaled_width = 0;\r\n        var scaled_height = 0;\r\n        var x1 = 0;\r\n        var y1 = 0;\r\n        var x2 = 0;\r\n        var y2 = 0;\r\n        var current_image = null;\r\n        var image_filename = null;\r\n        var aspX = 1;\r\n        var aspY = 1;\r\n        var file_display_area = null;\r\n        var ias = null;\r\n        var original_data = null;\r\n        var jcrop_api;\r\n        var bottom_html = \"<input type='file' id='fileInput' name='files[]'/ accept='image/*'><canvas id='myCanvas' style='display:none;'></canvas><div id='modal'></div><div id='preview'><div class='buttons'><div class='cancel'></div><div class='ok'></div></div></div>\";\r\n        $('body').append(bottom_html);\r\n\r\n        //add click to element\r\n        this.click(function () {\r\n            aspX = $(this).attr('data-width');\r\n            aspY = $(this).attr('data-width');\r\n            aspTop=$(this).attr('data-top');\r\n            aspLeft=$(this).attr('data-left');\r\n            file_display_area = $('#result-image');\r\n            $('#fileInput').click();\r\n        });\r\n\r\n        $(document).ready(function () {\r\n            //capture selected filename\r\n            $('#fileInput').change(function (click) {\r\n                imageUpload($('#preview').get(0));\r\n                // Reset input value\r\n                $(this).val(\"\");\r\n            });\r\n\r\n            //ok listener\r\n            $('.ok').click(function () {\r\n                preview();\r\n                $('#preview').delay(100).hide();\r\n                $('#modal').hide();\r\n                jcrop_api.destroy();\r\n                reset();\r\n            });\r\n\r\n            //cancel listener\r\n            $('.cancel').click(function (event) {\r\n                $('#preview').delay(100).hide();\r\n                $('#modal').hide();\r\n                jcrop_api.destroy();\r\n                reset();\r\n            });\r\n        });\r\n\r\n        function reset() {\r\n            scaled_width = 0;\r\n            scaled_height = 0;\r\n            x1 = 0;\r\n            y1 = 0;\r\n            x2 = 0;\r\n            y2 = 0;\r\n            current_image = null;\r\n            image_filename = null;\r\n            original_data = null;\r\n            aspX = 1;\r\n            aspY = 1;\r\n            file_display_area = null;\r\n        }\r\n\r\n        function imageUpload(dropbox) {\r\n            var file = $(\"#fileInput\").get(0).files[0];\r\n\r\n            var imageType = /image.*/;\r\n\r\n            if (file.type.match(imageType)) {\r\n                var reader = new FileReader();\r\n                image_filename = file.name;\r\n\r\n                reader.onload = function (e) {\r\n                    // Clear the current image.\r\n                    $('#photo').remove();\r\n\r\n                    original_data = reader.result;\r\n\r\n                    // Create a new image with image crop functionality\r\n                    current_image = new Image();\r\n                    current_image.src = reader.result;\r\n                    current_image.id = \"photo\";\r\n                    current_image.style['maxWidth'] = image_dimension_x + 'px';\r\n                    current_image.style['maxHeight'] = image_dimension_y + 'px';\r\n                    current_image.onload = function () {\r\n                        // Calculate scaled image dimensions\r\n                        if (current_image.width > image_dimension_x || current_image.height > image_dimension_y) {\r\n                            if (current_image.width > current_image.height) {\r\n                                scaled_width = image_dimension_x;\r\n                                scaled_height = image_dimension_x * current_image.height / current_image.width;\r\n                            }\r\n                            if (current_image.width < current_image.height) {\r\n                                scaled_height = image_dimension_y;\r\n                                scaled_width = image_dimension_y * current_image.width / current_image.height;\r\n                            }\r\n                            if (current_image.width == current_image.height) {\r\n                                scaled_width = image_dimension_x;\r\n                                scaled_height = image_dimension_y;\r\n                            }\r\n                        }\r\n                        else {\r\n                            scaled_width = current_image.width;\r\n                            scaled_height = current_image.height;\r\n                        }\r\n\r\n                        // set the image size to the scaled proportions which is required for at least IE11\r\n                        current_image.style['width'] = scaled_width + 'px';\r\n                        current_image.style['height'] = scaled_height + 'px';\r\n\r\n                        // Position the modal div to the center of the screen\r\n                        $('#modal').css('display', 'block');\r\n                        var window_width = $(window).width() / 2 - scaled_width / 2 + \"px\";\r\n                        var window_height = $(window).height() / 2 - scaled_height / 2 + \"px\";\r\n\r\n                        // Show image in modal view\r\n                        $(\"#preview\").css(\"top\", window_height);\r\n                        $(\"#preview\").css(\"left\", window_width);\r\n                        $('#preview').show(500);\r\n\r\n\r\n                        // Calculate selection rect\r\n                        var selection_width = 0;\r\n                        var selection_height = 0;\r\n\r\n                        var max_x = Math.floor(scaled_height * aspX / aspY);\r\n                        var max_y = Math.floor(scaled_width * aspY / aspX);\r\n\r\n\r\n                        if (max_x > scaled_width) {\r\n                            selection_width = scaled_width;\r\n                            selection_height = max_y;\r\n                        }\r\n                        else {\r\n                            selection_width = max_x;\r\n                            selection_height = scaled_height;\r\n                        }\r\n\r\n                        ias = $(this).Jcrop({\r\n                            onSelect: showCoords,\r\n                            onChange: showCoords,\r\n                            bgColor: '#747474',\r\n                            bgOpacity: .4,\r\n                            aspectRatio: aspX / aspY,\r\n                            setSelect: [0, 0, selection_width, selection_height]\r\n                        }, function () {\r\n                            jcrop_api = this;\r\n                        });\r\n                    }\r\n\r\n                    // Add image to dropbox element\r\n                    dropbox.appendChild(current_image);\r\n                }\r\n\r\n                reader.readAsDataURL(file);\r\n            } else {\r\n                dropbox.innerHTML = \"File not supported!\";\r\n            }\r\n        }\r\n\r\n        function showCoords(c) {\r\n            x1 = c.x;\r\n            y1 = c.y;\r\n            x2 = c.x2;\r\n            y2 = c.y2;\r\n        }\r\n\r\n        function preview() {\r\n            // Set canvas\r\n            var canvas = document.getElementById('myCanvas');\r\n            var context = canvas.getContext('2d');\r\n\r\n            // Delete previous image on canvas\r\n            context.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n            // Set selection width and height\r\n            var sw = x2 - x1;\r\n            var sh = y2 - y1;\r\n\r\n\r\n            // Set image original width and height\r\n            var imgWidth = current_image.naturalWidth;\r\n            var imgHeight = current_image.naturalHeight;\r\n\r\n            // Set selection koeficient\r\n            var kw = imgWidth / $(\"#preview\").width();\r\n            var kh = imgHeight / $(\"#preview\").height();\r\n\r\n            // Set canvas width and height and draw selection on it\r\n            canvas.width = aspX;\r\n            canvas.height = aspY;\r\n            context.drawImage(current_image, (x1 * kw), (y1 * kh), (sw * kw), (sh * kh), 0, 0, aspX, aspY);\r\n\r\n            // Convert canvas image to normal img\r\n            var dataUrl = canvas.toDataURL();\r\n            var imageFoo = document.createElement('img');\r\n            imageFoo.id='template-id';\r\n            imageFoo.src = dataUrl;\r\n            var flagForImageCheck=false;\r\n            var activeObject;\r\n            // Append it to the body element\r\n            $('#preview').delay(100).hide();\r\n            $('#modal').hide();\r\n            file_display_area.html('');\r\n            file_display_area.append(imageFoo);  \r\n            file_display_area.append('<a class=\"delete\" ></a>');\r\n            window.canvas.forEachObject(function(cavasObjects){\r\n                if(cavasObjects.name=='template')\r\n                {\r\n                    flagForImageCheck=true;\r\n                    activeObject=cavasObjects;    \r\n                }\r\n            });\r\n                if(flagForImageCheck){\r\n                    activeObject.remove();\r\n                    fabric.Image.fromURL(dataUrl, function(img) {\r\n                        var center = window.canvas.getCenter();\r\n                        img.left = aspLeft;\r\n                        img.top = aspTop;\r\n                        img.originY='center';\r\n                        img.originX='center';\r\n                        img.name=\"template\";\r\n                        img.lockMovementX= true;\r\n                        img.lockMovementY= true;\r\n                        img.lockScalingX= true;\r\n                        img.lockScalingY= true;\r\n                        img.lockUniScaling= true;\r\n                        img.lockRotation= true;\r\n                        img.hasControls= false;\r\n                        img.hasBorders= false;\r\n                        img.selectable= false;\r\n                        window.canvas.add(img);\r\n                        img.bringToFront();\r\n                        window.canvas.renderAll();\r\n                        img.setCoords();\r\n                    });\r\n                }else{\r\n                    fabric.Image.fromURL(dataUrl, function(img) {\r\n                        var center = window.canvas.getCenter();\r\n                        img.left = aspLeft;\r\n                        img.top = aspTop;\r\n                        img.lockMovementX= true;\r\n                        img.lockMovementY= true;\r\n                        img.lockScalingX= true;\r\n                        img.lockScalingY= true;\r\n                        img.lockUniScaling= true;\r\n                        img.lockRotation= true;\r\n                        img.hasControls= false;\r\n                        img.hasBorders= false;\r\n                        img.selectable= false;\r\n                        img.originY='center';\r\n                        img.originX='center';\r\n                        img.name=\"template\";\r\n                        window.canvas.add(img);\r\n                        img.bringToFront();\r\n                        window.canvas.renderAll();\r\n                        img.setCoords();\r\n                    });\r\n                }\r\n            if (onComplete) onComplete(\r\n                {                    \r\n                    \"original\": { \"filename\": image_filename, \"base64\": original_data, \"width\": current_image.width, \"height\": current_image.height },\r\n                    \"crop\": { \"x\": (x1 * kw), \"y\": (y1 * kh), \"width\": (sw * kw), \"height\": (sh * kh) }\r\n                }\r\n               );\r\n        }\r\n\r\n        $(window).resize(function () {\r\n            // Position the modal div to the center of the screen\r\n            var window_width = $(window).width() / 2 - scaled_width / 2 + \"px\";\r\n            var window_height = $(window).height() / 2 - scaled_height / 2 + \"px\";\r\n\r\n            // Show image in modal view\r\n            $(\"#preview\").css(\"top\", window_height);\r\n            $(\"#preview\").css(\"left\", window_width);\r\n        });\r\n        $('#result-image').on('click', '.delete', function() {\r\n            \r\n                window.canvas.forEachObject(function(cavasObjects){\r\n                if(cavasObjects.name=='template'){\r\n                 $('#template-id').remove();\r\n                  cavasObjects.remove();\r\n                  window.canvas.renderAll.bind(window.canvas);\r\n                 }\r\n                 window.canvas.renderAll.bind(window.canvas);\r\n            });\r\n        });\r\n        \r\n    }\r\n}(jQuery));\r\n});\r\n","Milople_Personalizedcool/js/responsiveslides.js":"/*! http://responsiveslides.com v1.54 by @viljamis */\r\n require([\"jquery\"], function (jQuery) {\r\n(function(c,I,B){c.fn.responsiveSlides=function(l){var a=c.extend({auto:!0,speed:500,timeout:4E3,pager:!1,nav:!1,random:!1,pause:!1,pauseControls:!0,prevText:\"Previous\",nextText:\"Next\",maxwidth:\"\",navContainer:\"\",manualControls:\"\",namespace:\"rslides\",before:c.noop,after:c.noop},l);return this.each(function(){B++;var f=c(this),s,r,t,m,p,q,n=0,e=f.children(),C=e.size(),h=parseFloat(a.speed),D=parseFloat(a.timeout),u=parseFloat(a.maxwidth),g=a.namespace,d=g+B,E=g+\"_nav \"+d+\"_nav\",v=g+\"_here\",j=d+\"_on\",\r\nw=d+\"_s\",k=c(\"<ul class='\"+g+\"_tabs \"+d+\"_tabs' />\"),x={\"float\":\"left\",position:\"relative\",opacity:1,zIndex:2},y={\"float\":\"none\",position:\"absolute\",opacity:0,zIndex:1},F=function(){var b=(document.body||document.documentElement).style,a=\"transition\";if(\"string\"===typeof b[a])return!0;s=[\"Moz\",\"Webkit\",\"Khtml\",\"O\",\"ms\"];var a=a.charAt(0).toUpperCase()+a.substr(1),c;for(c=0;c<s.length;c++)if(\"string\"===typeof b[s[c]+a])return!0;return!1}(),z=function(b){a.before(b);F?(e.removeClass(j).css(y).eq(b).addClass(j).css(x),\r\nn=b,setTimeout(function(){a.after(b)},h)):e.stop().fadeOut(h,function(){c(this).removeClass(j).css(y).css(\"opacity\",1)}).eq(b).fadeIn(h,function(){c(this).addClass(j).css(x);a.after(b);n=b})};a.random&&(e.sort(function(){return Math.round(Math.random())-0.5}),f.empty().append(e));e.each(function(a){this.id=w+a});f.addClass(g+\" \"+d);l&&l.maxwidth&&f.css(\"max-width\",u);e.hide().css(y).eq(0).addClass(j).css(x).show();F&&e.show().css({\"-webkit-transition\":\"opacity \"+h+\"ms ease-in-out\",\"-moz-transition\":\"opacity \"+\r\nh+\"ms ease-in-out\",\"-o-transition\":\"opacity \"+h+\"ms ease-in-out\",transition:\"opacity \"+h+\"ms ease-in-out\"});if(1<e.size()){if(D<h+100)return;if(a.pager&&!a.manualControls){var A=[];e.each(function(a){a+=1;A+=\"<li><a href='#' class='\"+w+a+\"'>\"+a+\"</a></li>\"});k.append(A);l.navContainer?c(a.navContainer).append(k):f.after(k)}a.manualControls&&(k=c(a.manualControls),k.addClass(g+\"_tabs \"+d+\"_tabs\"));(a.pager||a.manualControls)&&k.find(\"li\").each(function(a){c(this).addClass(w+(a+1))});if(a.pager||a.manualControls)q=\r\nk.find(\"a\"),r=function(a){q.closest(\"li\").removeClass(v).eq(a).addClass(v)};a.auto&&(t=function(){p=setInterval(function(){e.stop(!0,!0);var b=n+1<C?n+1:0;(a.pager||a.manualControls)&&r(b);z(b)},D)},t());m=function(){a.auto&&(clearInterval(p),t())};a.pause&&f.hover(function(){clearInterval(p)},function(){m()});if(a.pager||a.manualControls)q.bind(\"click\",function(b){b.preventDefault();a.pauseControls||m();b=q.index(this);n===b||c(\".\"+j).queue(\"fx\").length||(r(b),z(b))}).eq(0).closest(\"li\").addClass(v),\r\na.pauseControls&&q.hover(function(){clearInterval(p)},function(){m()});if(a.nav){g=\"<a href='#' class='\"+E+\" prev'>\"+a.prevText+\"</a><a href='#' class='\"+E+\" next'>\"+a.nextText+\"</a>\";l.navContainer?c(a.navContainer).append(g):f.after(g);var d=c(\".\"+d+\"_nav\"),G=d.filter(\".prev\");d.bind(\"click\",function(b){b.preventDefault();b=c(\".\"+j);if(!b.queue(\"fx\").length){var d=e.index(b);b=d-1;d=d+1<C?n+1:0;z(c(this)[0]===G[0]?b:d);if(a.pager||a.manualControls)r(c(this)[0]===G[0]?b:d);a.pauseControls||m()}}); \r\na.pauseControls&&d.hover(function(){clearInterval(p)},function(){m()})}}if(\"undefined\"===typeof document.body.style.maxWidth&&l.maxwidth){var H=function(){f.css(\"width\",\"100%\");f.width()>u&&f.css(\"width\",u)};H();c(I).bind(\"resize\",function(){H()})}})}})(jQuery,this,0); });\r\n","Milople_Personalizedcool/js/personalized.js":"/**\n *\n * Do not edit or add to this file if you wish to upgrade the module to newer\n * versions in the future. If you wish to customize the module for your\n * needs please contact us to https://www.milople.com/contact-us.html\n *\n * @category    Ecommerce\n * @package     Milople_Personlized\n * @copyright   Copyright (c) 2016 Milople Technologies Pvt. Ltd. All Rights Reserved.\n * @url         https://www.milople.com/magento2-extensions/personalized-products-m2.html\n *\n **/\nvar side_counter = 0;\nvar flag_for_text_baground;\nvar canvas_objects_aspect_ratio = 1;\nvar test_variable = 45667;\nvar height_for_restricted = 0;\nvar width_for_resticted = 0;\nvar name_number_counter = 1;\nvar global_canvas_width = 0;\nvar global_canvas_height = 0;\nvar state; // current unsaved state\nvar undo = []; // past states\nvar redo = [];  // reverted states\nwindow.canvasObjects = new Array(); //javascript array\nrequire([\"jquery\", \"Magento_Catalog/js/price-utils\"], function (jQuery, priceUtils) {\n\tvar jQuery = jQuery.noConflict();\n\tdecideWhichBlockToShow = function () {\n\t\tvar isMobile = window.matchMedia(\"only screen and (max-width: 760px)\");\n\t\tif (isMobile.matches) {\n\t\t\tif (!jQuery('#add_text_button').hasClass(\"tab-view\")) {\n\t\t\t\tjQuery('.update-text').hide();\n\t\t\t\tjQuery('#add_text_button').hide();\n\t\t\t\tjQuery('.text_effect_buttons').hide();\n\t\t\t\tjQuery('.font_style_popup').hide();\n\t\t\t}\n\t\t} else {\n\t\t\tjQuery('#format_text').hide();\n\t\t}\n\t}\n\tsave = function () {\n          // clear the redo stack\n\t\t\t\t  redo = [];\n          jQuery('#redo').prop('disabled', true);\n\t\t\t\t\tjQuery('#redoImage').prop('disabled', true);\n\t\t\t\t\tjQuery('#redoClipart').prop('disabled', true);\n          // initial call won't have a state\n          if (state) {\n            undo.push(state);\n            jQuery('#undo').prop('disabled', false);\n\t\t\t\t\t\tjQuery('#undoImage').prop('disabled', false);\n\t\t\t\t\t\tjQuery('#undoClipart').prop('disabled', false);\n          }\n          state = JSON.stringify(canvas);\n  }\n\tfunction checkCanvas () {\n\n\t\tif(typeof canvas == 'undefined'){\n\t\t\tsetTimeout(checkCanvas, 50);\n\t\t } else {\n\t\t save();\n\t\t}\n\t}\n\tjQuery(document).ready(function () {\n\t\t\n\t\tdecideWhichBlockToShow();\n\t\tcheckCanvas();\n\t\tjQuery(\"#imageDiv\").click(function () {\n\t\t\tresetDefault();\n\t\t});\n\t\tif(jQuery(\".font_color\").length){\n            var color = new Piklor(\".color-picker\", [\n              \"#ff0000\"\n            , \"#ff6666\"\n            , \"#00ff80\"\n            , \"#0080ff\"\n            , \"#99ccff\"\n            , \"#000000\"\n            , \"#666666\"\n            , \"#ffff00\"\n            , \"#1abc9c\"\n            , \"#2ecc71\"\n            , \"#3498db\"\n            , \"#9b59b6\"\n            , \"#34495e\"\n            , \"#f1c40f\"\n            , \"#e67e22\"\n            , \"#e74c3c\"\n            , \"#ecf0f1\"\n            , \"#95a5a6\"\n            ], {\n                open: \".font_color\",\n\t\t\t\t\t\t\t  closeOnBlur: true\n            }) ;\n\t\t\t      \n            color.colorChosen(function (col) {\n                canvas.getActiveObject().setFill(col);\n                canvas.renderAll();\n            }); \n        }\n      \n        if(jQuery(\".background_color\").length){\n          var backgroundcolor = new Piklor(\".backgroundcolor-picker\", [\n              \"#ff0000\"\n            , \"#ff6666\"\n            , \"#00ff80\"\n            , \"#0080ff\"\n            , \"#99ccff\"\n            , \"#000000\"\n            , \"#666666\"\n            , \"#ffff00\"\n            , \"#1abc9c\"\n            , \"#2ecc71\"\n            , \"#3498db\"\n            , \"#9b59b6\"\n            , \"#34495e\"\n            , \"#f1c40f\"\n            , \"#e67e22\"\n            , \"#e74c3c\"\n            , \"#ecf0f1\"\n            , \"#95a5a6\"\n          ], {\n              open: \".background_color\",\n\t\t\t\t\t\t\tcloseOnBlur: true\n          }) ;\n          backgroundcolor.colorChosen(function (col) {\n              canvas.getActiveObject().setBackgroundColor(col);\n              canvas.renderAll();\n          });\n        }\n\t\tjQuery(\".designAreasDiv\").click(function () {\n\t\t\tvar isMobile = window.matchMedia(\"only screen and (max-width: 760px)\");\n\t\t\tif (isMobile.matches && canvas.getActiveObject() == null) {\n\t\t\t\tresetDefault();\n\t\t\t}\n\t\t});\n\t});\n\n\tresetDefault = function () {\n\t\tjQuery(\"#content-upload\").hide();\n\t\tjQuery(\"#content-clipart\").hide();\n\t\tjQuery(\"#content-text\").hide();\n\t\tjQuery(\"#content-template\").hide();\n\t\tjQuery(\"#content-name-number\").hide();\n\t\tjQuery(\".label_in_popup\").css(\"display\", \"inline-block\");\n\t\tcanvas.deactivateAll().renderAll();\n\t\tjQuery(\".small-content-text\").css({\n\t\t\t\"display\": \"none\"\n\t\t});\n\t\tjQuery(\".small_border_label\").css({\n\t\t\t\"display\": \"block\"\n\t\t});\n\t\tjQuery(\".dir_pad\").css({\n\t\t\t\"display\": \"none\"\n\t\t});\n\t\tjQuery(\".personalized-container\").css({\n\t\t\t\"display\": \"block\"\n\t\t});\n\t\tjQuery(\".small-directional-pad\").css({\n\t\t\t\"display\": \"none\"\n\t\t});\n\t\tjQuery(\"#content-template\").css({\n\t\t\t\"display\": \"none\"\n\t\t});\n\t\tjQuery('.personalizer_popup').css({\n\t\t\t\"bottom\": \"0\"\n\t\t});\n\t\tjQuery(\".text_content\").css({\n\t\t\t\"display\": \"block\"\n\t\t});\n\t\tvar isMobile = window.matchMedia(\"only screen and (max-width: 760px)\");\n\t\tif (isMobile.matches) {\n\t\t\tjQuery('.text_effect_buttons').hide();\n\t\t\tjQuery('.font_style_popup').hide();\n\t\t}\n\t\tif (jQuery('#format_text').length) document.getElementById(\"format_text\").disabled = true;\n\t\tjQuery('#add_text').val('');\n\t\tjQuery('button.circle').hide();\n\t\tjQuery('label').removeClass('active');\n\t\tjQuery('.update-text').hide();\n\t\tif (jQuery('#add_text_button').hasClass(\"tab-view\")) {\n\t\t\tjQuery('#add_text_button').show();\n\t\t}\n\t}\n\t// Tab click on popup\n\tjQuery(document).on('click', '.label_in_popup', function () {\n\t\tvar isMobile = window.matchMedia(\"only screen and (max-width: 760px)\");\n\t\tactiveBorderColor = jQuery(this).attr('data-border');\n\t\tif (isMobile.matches) {\n\t\t\t// Display in popup\n\t\t\tif (jQuery(this).attr('id') == 'tab-name-number') {\n\t\t\t\tjQuery('.personalizer_popup').css({\n\t\t\t\t\t\"bottom\": \"25%\"\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tjQuery('.personalizer_popup').css({\n\t\t\t\t\t\"bottom\": \"0\"\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (jQuery('#' + jQuery(this).attr('data-section')).css('display') == 'none') {\n\t\t\t\tif (jQuery(this).attr('id') == 'tab-name-number') {\n\t\t\t\t\tjQuery('section').slideUp();\n\t\t\t\t} else {\n\t\t\t\t\tjQuery('section').slideUp();\n\t\t\t\t\tjQuery('button.circle').show();\n\t\t\t\t\tjQuery('button.circle').css({\n\t\t\t\t\t\t'border-color': activeBorderColor\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tjQuery('.small_border_label').find('.label_in_popup').hide();\n\t\t\t\tjQuery('label').removeClass('active');\n\t\t\t}\n\t\t\tjQuery(this).toggleClass(\"active\");\n\t\t\tjQuery('#' + jQuery(this).attr('data-section')).slideToggle();\n\t\t\treturn;\n\t\t}\n\t\tif (jQuery('#' + jQuery(this).attr('data-section')).css('display') == 'none') {\n\t\t\tjQuery('section').slideUp();\n\t\t\tjQuery('label').removeClass('active');\n\t\t}\n\t\tjQuery(this).toggleClass(\"active\");\n\t\tjQuery('#' + jQuery(this).attr('data-section')).slideToggle();\n\t})\n\tjQuery(document).on('keypress keydown keyup change', '#add_name', function () {\n\t\tvar firstname = jQuery(\"input[name^='milople_name']\");\n\t\tvar f_name = document.getElementById('add_name');\n\t\tif (!firstname[0].value) {\n\t\t\tf_name.style.borderColor = \"red\";\n\t\t} else {\n\t\t\tf_name.style.borderColor = \"green\";\n\t\t}\n\t\taddname();\n\t});\n\tjQuery(document).on('keypress keydown keyup change', '#add_numb', function () {\n\t\tvar firstnumber = jQuery(\"input[name^='milople_number']\");\n\t\tvar f_numb = document.getElementById('add_numb');\n\t\tif (!firstnumber[0].value) {\n\t\t\tf_numb.style.borderColor = \"red\";\n\t\t} else {\n\t\t\tf_numb.style.borderColor = \"green\";\n\t\t}\n\t\taddnumber();\n\t});\n\t//function for adding name and number field dynamcally\n\tjQuery('#nameAndNumbertable').on('click', '.remove_row', function () {\n\t\tjQuery(this).closest('tr').remove();\n\t\tname_number_counter--;\n\t\tif (name_number_counter == 0) {\n\t\t\tcanvas.getObjects().forEach(function (obj) {\n\t\t\t\tif (obj.id == 'nameObject') {\n\t\t\t\t\ttextObj = obj;\n\t\t\t\t\tcanvas.remove(textObj);\n\t\t\t\t\tcanvas.renderAll();\n\t\t\t\t\tsave();\n\t\t\t\t}\n\t\t\t});\n\t\t\tcanvas.getObjects().forEach(function (obj) {\n\t\t\t\tif (obj.id == 'numberObject') {\n\t\t\t\t\ttextObj = obj;\n\t\t\t\t\tcanvas.remove(textObj);\n\t\t\t\t\tcanvas.renderAll();\n\t\t\t\t\tsave();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\tjQuery('p span.addone').click(function () {\n\t\tif (name_number_counter == 0) {\n\t\t\tjQuery('#nameAndNumbertable').append('<tr><td><input type=\"text\" id=\"add_name\" name=\"milople_name[]\"/></td><td><input id=\"add_numb\" type=\"text\" name=\"milople_number[]\"/><td><input type=\"text\" name=\"milople_size[]\"/></td><td><span data-icon=\"Q\" class=\"remove_row round\"></span></td></tr>')\n\t\t} else {\n\t\t\tjQuery('#nameAndNumbertable').append('<tr><td><input type=\"text\" name=\"milople_name[]\"/></td><td><input type=\"text\" name=\"milople_number[]\"/><td><input type=\"text\" name=\"milople_size[]\"/></td><td><span data-icon=\"Q\" class=\"remove_row round\"></span></td></tr>')\n\t\t}\n\t\tname_number_counter++;\n\t});\n\tjQuery('p span.close-name').click(function () {\n\t\tjQuery('.personalizer_popup').css({\n\t\t\t\"bottom\": \"0\"\n\t\t});\n\t\tresetDefault();\n\t});\n\tjQuery(\"#font_style_effect\").click(function () {\n\t\tjQuery(\".text_effect_buttons\").css(\"display\", \"none\");\n\t\tjQuery(\".font_style_popup\").css(\"display\", \"block\");\n\t});\n\tjQuery('#font_color').click(function () {\n\t\tflag_for_text_baground = 0;\n\t});\n\tjQuery('#font_bg_color').click(function () {\n\t\tflag_for_text_baground = 1;\n\t});\n\t//thumb click\n\tjQuery(\".product-thumbs a\").on('click', function () {\n\t\tvar target = jQuery(this).attr('data-main-canvas-id');\n\t\tjQuery(\"#drawingArea-\" + target).show().siblings(\"div.designAreasDiv\").hide();\n\t\tif (jQuery(\"#image-template-\" + target).length > 0) {\n\t\t\tjQuery(\"#image-template-\" + target).show().siblings(\"div.imageTemplate\").hide();\n\t\t\tjQuery(\"label#tab-template\").show();\n\t\t\tjQuery(\"#content-template \").hide();\n\t\t} else {\n\t\t\tjQuery(\"#tab1\").prop(\"checked\", true);\n\t\t\tjQuery(\"label#tab-template\").hide();\n\t\t\tjQuery(\"#content-template \").hide();\n\t\t}\n\t\tcanvas = canvasObjects[target];\n\t\tcanvas.off({\n\t\t\t'object:moving': onSelected,\n\t\t\t'object:selected': onSelected,\n\t\t\t'object:modified': onModified,\n\t\t\t'selection:created': onSelected,\n\t\t\t'selection:cleared': onDeSelected\n\t\t});\n\t\tcanvas.on({\n\t\t\t'object:moving': onSelected,\n\t\t\t'object:selected': onSelected,\n\t\t\t'object:modified': onModified,\n\t\t\t'selection:created': onSelected,\n\t\t\t'selection:cleared': onDeSelected\n\t\t});\n\t\tif (jQuery('#imageDiv').length) {\n\t\t\tjQuery('#imageDiv').attr(\"src\", jQuery(this).attr(\"data-main-image-src\"));\n\t\t} else {\n\t\t\tcanvas.setBackgroundImage(jQuery(this).attr(\"data-main-image-src\"), canvas.renderAll.bind(canvas));\n\t\t}\n\t\tvar isMobile = window.matchMedia(\"only screen and (max-width: 760px)\");\n\t\tif (isMobile.matches) {\n\t\t\tjQuery('#add_text_button').hide();\n\t\t} else {\n\t\t\tchange_add_update_buttons('', 'inline-block', 'none', 'silver');\n\t\t}\n\t});\n\t//Set the radius ,spacing and effect for text object\n\tjQuery('#radius, #spacing, #effect').change(function () {\n\t\tif (canvas.getActiveObject()) {\n\t\t\tif (jQuery(this).attr('id') == 'effect') {\n\t\t\t\tif (canvas.getActiveObject().type == 'text' && jQuery(this).val() != 'STRAIGHT') {\n\t\t\t\t\tconvert_text_object('curvedText');\n\t\t\t\t} else if (canvas.getActiveObject().type == 'curvedText' && jQuery(this).val() == 'STRAIGHT') {\n\t\t\t\t\tconvert_text_object('text');\n\t\t\t\t}\n\t\t\t}\n\t\t\tcanvas.getActiveObject().set(jQuery(this).attr('id'), jQuery(this).val());\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t\tif (jQuery(this).attr('id') == 'effect') {\n\t\t\tif (jQuery(this).val() == 'curved' || jQuery(this).val() == 'arc') {\n\t\t\t\tjQuery('.radius-effect, .spacing-effect, .reverse-effect').css('display', 'block');\n\t\t\t} else {\n\t\t\t\tjQuery('.radius-effect, .spacing-effect, .reverse-effect').css('display', 'none');\n\t\t\t}\n\t\t\tif (jQuery(this).val() == 'STRAIGHT') {\n\t\t\t\tjQuery('#font_inc').css('display', 'inline-block');\n\t\t\t\tjQuery('#font_dec').css('display', 'inline-block');\n\t\t\t} else {\n\t\t\t\tjQuery('#font_inc').css('display', 'none');\n\t\t\t\tjQuery('#font_dec').css('display', 'none');\n\t\t\t}\n\t\t}\n\t});\n\t//Reserve active object\n\tjQuery('#reverse').click(function () {\n\t\tif (canvas.getActiveObject()) {\n\t\t\tcanvas.getActiveObject().set('reverse', jQuery(this).is(':checked'));\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t});\n\t// Adding text on image\n\taddtext = function (mobile) {\n\t\tvar textVar = document.getElementById('add_text');\n\t\tvar imageObjects = parseInt(document.getElementById('iObject').value);\n\t\tvar textObjects = parseInt(document.getElementById('tObject').value);\n\t\ttextObjects++;\n\t\tchangePrice(textObjects, imageObjects);\n\t\tvar textFont = jQuery(\"#font_selection option:selected\").val();\n\t\tif (textFont == '') {\n\t\t\ttextFont = 'Calibri';\n\t\t}\n\t\tif (textVar.value) {\n\t\t\tvar center = canvas.getCenter();\n\t\t\tvar textObj = new fabric.Text(textVar.value, {\n\t\t\t\tfontSize: 18,\n\t\t\t\ttextAlign: \"left\",\n\t\t\t\toriginX: 'center',\n\t\t\t\toriginY: 'center',\n\t\t\t\tfontFamily: textFont,\n\t\t\t\ttop: center.top,\n\t\t\t\tleft: center.left,\n\t\t\t});\n\t\t\tif (mobile == undefined) {\n\t\t\t\ttextVar.value = \"\";\n\t\t\t}\n\t\t\tcanvas.add(textObj);\n\t\t\tcanvas.setActiveObject(textObj);\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t\tif (jQuery('#effect').val() == 'curved' || jQuery('#effect').val() == 'arc') {\n\t\t\t\tconvert_text_object('curvedText');\n\t\t\t}\n\t\t\tchange_add_update_buttons(textVar.value, 'none', 'inline-block', 'silver');\n\t\t} else {\n\t\t\ttextVar.style.borderColor = \"red\";\n\t\t}\n\t}\n\t//Add Name function\n\taddname = function () {\n\t\tvar mode = \"insert\";\n\t\ttextObj = '';\n\t\tif (jQuery('#format_text').length) document.getElementById(\"format_text\").disabled = false;\n\t\tvar textVar = document.getElementById('add_name');\n\t\tvar imageObjects = parseInt(document.getElementById('iObject').value);\n\t\tvar textObjects = parseInt(document.getElementById('tObject').value);\n\t\tcanvas.getObjects().forEach(function (obj) {\n\t\t\tif (obj.id == 'nameObject') {\n\t\t\t\tmode = \"update\";\n\t\t\t\ttextObj = obj;\n\t\t\t}\n\t\t})\n\t\tchangePrice(textObjects, imageObjects);\n\t\tif (mode == 'insert') {\n\t\t\tif (textVar.value) {\n\t\t\t\tvar center = canvas.getCenter();\n\t\t\t\tvar textFont = jQuery(\"#font_selection option:selected\").val();\n\t\t\t\tif (textFont == '') {\n\t\t\t\t\ttextFont = 'Calibri';\n\t\t\t\t}\n\t\t\t\tvar textObj = new fabric.Text(textVar.value, {\n\t\t\t\t\tfontSize: 24,\n\t\t\t\t\ttextAlign: \"left\",\n\t\t\t\t\toriginX: 'center',\n\t\t\t\t\toriginY: 'center',\n\t\t\t\t\tfontFamily: textFont,\n\t\t\t\t\ttop: 50,\n\t\t\t\t\tleft: center.left,\n\t\t\t\t});\n\t\t\t\ttextObj.id = 'nameObject';\n\t\t\t\tcanvas.add(textObj);\n\t\t\t\tcanvas.setActiveObject(textObj);\n\t\t\t\tcanvas.renderAll();\n\t\t\t\tif (jQuery('#effect').val() == 'curved' || jQuery('#effect').val() == 'arc') {\n\t\t\t\t\tconvert_text_object('curvedText');\n\t\t\t\t}\n\t\t\t\tchange_add_update_buttons(textVar.value, 'none', 'inline-block', 'silver');\n\t\t\t\ttextVar.style.borderColor = \"green\";\n\t\t\t} else {\n\t\t\t\ttextVar.style.borderColor = \"red\";\n\t\t\t}\n\t\t} else { // update\n\t\t\tif (textVar.value != '') {\n\t\t\t\ttextObj.setText(textVar.value);\n\t\t\t\tcanvas.setActiveObject(textObj);\n\t\t\t\tcanvas.renderAll();\n\t\t\t} else {\n\t\t\t\tcanvas.remove(textObj);\n\t\t\t\tcanvas.renderAll();\n\t\t\t\tsave();\n\t\t\t}\n\t\t}\n\t}\n\t//Add Number function\n\taddnumber = function () {\n\t\tvar mode = \"insert\";\n\t\ttextObj = '';\n\t\tif (jQuery('#format_text').length) document.getElementById(\"format_text\").disabled = false;\n\t\tvar textVar = document.getElementById('add_numb');\n\t\tvar imageObjects = parseInt(document.getElementById('iObject').value);\n\t\tvar textObjects = parseInt(document.getElementById('tObject').value);\n\t\tcanvas.getObjects().forEach(function (obj) {\n\t\t\tif (obj.id == 'numberObject') {\n\t\t\t\tmode = \"update\";\n\t\t\t\ttextObj = obj;\n\t\t\t}\n\t\t})\n\t\tchangePrice(textObjects, imageObjects);\n\t\tif (mode == 'insert') {\n\t\t\tif (textVar.value) {\n\t\t\t\tvar center = canvas.getCenter();\n\t\t\t\tvar textObj = new fabric.Text(textVar.value, {\n\t\t\t\t\tfontSize: 24,\n\t\t\t\t\ttextAlign: \"left\",\n\t\t\t\t\toriginX: 'center',\n\t\t\t\t\toriginY: 'center',\n\t\t\t\t\tfontFamily: jQuery(\"#font_selection option:selected\").val(),\n\t\t\t\t\ttop: 80,\n\t\t\t\t\tleft: center.left,\n\t\t\t\t});\n\t\t\t\t//textVar.value = \"\";\n\t\t\t\ttextObj.id = 'numberObject';\n\t\t\t\tcanvas.add(textObj);\n\t\t\t\tcanvas.setActiveObject(textObj);\n\t\t\t\tcanvas.renderAll();\n\t\t\t\tsave();\n\t\t\t\tif (jQuery('#effect').val() == 'curved' || jQuery('#effect').val() == 'arc') {\n\t\t\t\t\tconvert_text_object('curvedText');\n\t\t\t\t}\n\t\t\t\tchange_add_update_buttons(textVar.value, 'none', 'inline-block', 'silver');\n\t\t\t\ttextVar.style.borderColor = \"green\";\n\t\t\t} else {\n\t\t\t\ttextVar.style.borderColor = \"red\";\n\t\t\t}\n\t\t} else {\n\t\t\tif (textVar.value != '') {\n\t\t\t\ttextObj.setText(textVar.value);\n\t\t\t\tcanvas.setActiveObject(textObj);\n\t\t\t\tcanvas.renderAll();\n\t\t\t} else {\n\t\t\t\tcanvas.remove(textObj);\n\t\t\t\tcanvas.renderAll();\n\t\t\t\tsave();\n\t\t\t}\n\t\t}\n\t}\n\t//Covert the normal text object to curved text object\n\tconvert_text_object = function (to_object_type) {\n\t\tvar props = {};\n\t\tvar obj = canvas.getActiveObject();\n\t\tif (obj) {\n\t\t\tprops = obj.toObject();\n\t\t\tdelete props['type'];\n\t\t\tprops['textAlign'] = obj.getTextAlign();\n\t\t\tprops['originX'] = obj.getOriginX();\n\t\t\tprops['originY'] = obj.getOriginY();\n\t\t\tprops['fontFamily'] = obj.getFontFamily();\n\t\t\tprops['fill'] = obj.getFill();\n\t\t\tprops['backgroundColor'] = obj.getBackgroundColor();\n\t\t\tprops['top'] = obj.getTop();\n\t\t\tprops['left'] = obj.getLeft();\n\t\t\tprops['objectType'] = obj.objectType;\n\t\t\tif (obj.type == 'curvedText' && to_object_type == 'text') {\n\t\t\t\tvar convertedText = new fabric.Text(obj.getText(), props);\n\t\t\t} else if (obj.type == 'text' && to_object_type == 'curvedText') {\n\t\t\t\tprops['effect'] = jQuery('#effect').val();\n\t\t\t\tprops['radius'] = jQuery('#radius').val();\n\t\t\t\tprops['spacing'] = jQuery('#spacing').val();\n\t\t\t\tprops['reverse'] = jQuery('#reverse').is(':checked');\n\t\t\t\tvar convertedText = new fabric.CurvedText(obj.getText(), props);\n\t\t\t}\n\t\t\tcanvas.remove(obj);\n\t\t\tcanvas.add(convertedText).renderAll();\n\t\t\tsave();\n\t\t\tcanvas.setActiveObject(canvas.item(canvas.getObjects().length - 1));\n\t\t}\n\t}\n\t// Removing image on product image\n\tremoveImageFromServer = function (imageId) {\n\t\tvar baseUrl = jQuery(\"#baseURL\").val();\n\t\tjQuery.ajax({\n\t\t\ttype: 'POST',\n\t\t\turl: baseUrl + 'personalizedcool/index/deleteraw',\n\t\t\tdata: {\n\t\t\t\t'imageId': imageId\n\t\t\t},\n\t\t\tdataType: 'text',\n\t\t\tshowLoader: true,\n\t\t\tsuccess: function (result) {\n\t\t\t\tvar rawImageValue = jQuery(\"#raw_images\").val();\n\t\t\t\trawImageid = result;\n\t\t\t\tif (rawImageValue == imageId) {\n\t\t\t\t\trawImageValue = 0;\n\t\t\t\t} else {\n\t\t\t\t\tvar rawImageArray = rawImageValue.split(\",\");\n\t\t\t\t\tvar index = rawImageArray.indexOf(imageId);\n\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\trawImageArray.splice(index, 1);\n\t\t\t\t\t\trawImageArray.toString();\n\t\t\t\t\t\trawImageValue = rawImageArray;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tjQuery(\"#raw_images\").val(rawImageValue);\n\t\t\t},\n\t\t\terror: function (xhr, status) {}\n\t\t});\n\t}\n\t// Adding image on product image\n\thandleImage = function (e) {\n\t\tvar reader = new FileReader();\n\t\tvar baseUrl = jQuery(\"#baseURL\").val();\n\t\tvar file = this.files[0];\n\t\tvar fd = new FormData();\n\t\tfd.append(\"afile\", file);\n\t\tisRawEnabled = parseInt(document.getElementById('is_raw').value);\n\t\tvar rawImageid;\n\t\tjQuery.ajax({\n\t\t\ttype: 'POST',\n\t\t\turl: baseUrl + 'personalizedcool/index/saveraw',\n\t\t\tdata: fd,\n\t\t\tdataType: 'text',\n\t\t\tcache: false,\n\t\t\tshowLoader: true,\n\t\t\tcontentType: false,\n\t\t\tprocessData: false,\n\t\t\tbeforeSend: function (xhr, opts) {\n\t\t\t\tif (isRawEnabled == 0) //just an example\n\t\t\t\t{\n\t\t\t\t\timageUpload(reader, e, 0);\n\t\t\t\t\txhr.abort();\n\t\t\t\t}\n\t\t\t},\n\t\t\tsuccess: function (result) {\n\t\t\t\trawImageid = result;\n\t\t\t\tvar rawImageValue = jQuery(\"#raw_images\").val();\n\t\t\t\tif (rawImageValue == 0) {\n\t\t\t\t\trawImageValue = result;\n\t\t\t\t} else {\n\t\t\t\t\trawImageValue = rawImageValue + ',' + result;\n\t\t\t\t}\n\t\t\t\tjQuery(\"#raw_images\").val(rawImageValue);\n\t\t\t\timageUpload(reader, e, rawImageid);\n\t\t\t} //success\n\t\t}); //ajax call\n\t}\n\t// Upload image event handler\n\tvar imageLoader = document.getElementById('uploadimage');\n\tif (typeof (imageLoader) != 'undefined' && imageLoader != null) {\n\t\timageLoader.addEventListener('change', handleImage, false);\n\t}\n\t//Upload the image to server based on the setting at backend.\n\tfunction imageUpload(reader, e, rawImageid) {\n\t\tvar textObjects = parseInt(document.getElementById('tObject').value);\n\t\tvar imageObjects = parseInt(document.getElementById('iObject').value);\n\t\timageObjects++;\n\t\tchangePrice(textObjects, imageObjects);\n\t\tvar center = canvas.getCenter();\n\t\treader.onload = function (event) {\n\t\t\tvar img = new Image();\n\t\t\timg.onload = function () {\n\t\t\t\tvar imgInstance = new fabric.Image(img, {\n\t\t\t\t\tscaleX: 0.5,\n\t\t\t\t\tscaleY: 0.5,\n\t\t\t\t\toriginX: 'center',\n\t\t\t\t\toriginY: 'center',\n\t\t\t\t\ttop: center.top,\n\t\t\t\t\tleft: center.left,\n\t\t\t\t\tobjectType: 'image'\n\t\t\t\t});\n\t\t\t\timgInstance.RawImageId = rawImageid;\n\t\t\t\tisFitEnable = parseInt(document.getElementById('image_fit').value);\n\t\t\t\tif (isFitEnable == 1) {\n\t\t\t\t\timgInstance.set({\n\t\t\t\t\t\ttop: canvas.height / 2,\n\t\t\t\t\t\tleft: canvas.width / 2,\n\t\t\t\t\t\tscaleY: (canvas.height / imgInstance.height) - 0.03,\n\t\t\t\t\t\tscaleX: (canvas.width / imgInstance.width) - 0.03\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcanvas.add(imgInstance);\n\t\t\t\tcanvas.setActiveObject(canvas.item(canvas.getObjects().length - 1));\n\t\t\t\tcanvas.renderAll();\n\t\t\t\tsave();\n\t\t\t}\n\t\t\timg.src = event.target.result;\n\t\t}\n\t\treader.readAsDataURL(e.target.files[0]);\n\t}\n\t// Apply bold effect to text object\n\tjQuery(\"#text-bold\").click(function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject && activeObject.type == 'text') {\n\t\t\tactiveObject.fontWeight = (activeObject.fontWeight == 'bold' ? '' : 'bold');\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t});\n\t// Apply Italic effect to text object\n\tjQuery(\"#text-italic\").click(function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject && activeObject.type === 'text') {\n\t\t\tactiveObject.fontStyle = (activeObject.fontStyle == 'italic' ? '' : 'italic');\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t});\n\t// Apply strike effect to text object\n\tjQuery(\"#text-strike\").click(function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject && activeObject.type === 'text') {\n\t\t\tactiveObject.textDecoration = (activeObject.textDecoration == 'line-through' ? '' : 'line-through');\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t});\n\t// Apply underline effect to text object\n\tjQuery(\"#text-underline\").click(function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject && activeObject.type === 'text') {\n\t\t\tactiveObject.textDecoration = (activeObject.textDecoration == 'underline' ? '' : 'underline');\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t});\n\t// Apply align left to text object\n\tjQuery(\"#text-left\").click(function () {\n\t\tcanvas.getActiveObject().setLeft(0);\n\t\tcanvas.getActiveObject().setCoords();\n\t\tcanvas.renderAll();\n\t\tsave();\n\t});\n\t// Apply align center to text object\n\tjQuery(\"#text-center\").click(function () {\n\t\tcanvas.getActiveObject().setLeft(parseInt((canvas.width - canvas.getActiveObject().width) / 2));\n\t\tcanvas.getActiveObject().setCoords();\n\t\tcanvas.renderAll();\n\t\tsave();\n\t});\n\t// Apply align right to text object\n\tjQuery(\"#text-right\").click(function () {\n\t\tcanvas.getActiveObject().setLeft(parseInt(canvas.getWidth() - canvas.getActiveObject().getWidth()));\n\t\tcanvas.getActiveObject().setCoords();\n\t\tcanvas.renderAll();\n\t\tsave();\n\t});\n\t// Apply font family to text object on change event of font family dropdown\n\tjQuery(\"#font-family\").change(function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject && activeObject.type === 'text') {\n\t\t\tactiveObject.fontFamily = this.value;\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t});\n\t// Increase the font size of text\n\tjQuery(\"#font_inc\").on('click', function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject && activeObject.type === 'text') {\n\t\t\tfontSize = activeObject.getFontSize();\n\t\t\tfontSize = parseInt(fontSize);\n\t\t\tfontSize += 2;\n\t\t\tif (fontSize > 10) {\n\t\t\t\tactiveObject.setFontSize(fontSize);\n\t\t\t}\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t});\n\t// DeIncrease the font size of text\n\tjQuery(\"#font_dec\").on('click', function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject && activeObject.type === 'text') {\n\t\t\tfontSize = activeObject.getFontSize();\n\t\t\tfontSize = parseInt(fontSize);\n\t\t\tfontSize -= 2;\n\t\t\tif (fontSize > 10) {\n\t\t\t\tactiveObject.setFontSize(fontSize);\n\t\t\t}\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t});\n\tupdateFontColor = function (picker) {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject && (activeObject.type === 'text' || activeObject.type === 'curvedText')) {\n\t\t\tvar hex = document.getElementById('valueInput').value;\n\t\t\tjQuery('span#font_preview').css(\"border-color\", \"#\" + hex);\n\t\t\tactiveObject.setFill(picker.toHEXString());\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t}\n\tupdateBackround = function (picker) {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject && (activeObject.type === 'text' || activeObject.type === 'curvedText')) {\n\t\t\tvar hex = document.getElementById('valueSpan').value;\n\t\t\tjQuery('#font_bg_color').css(\"background-color\", \"#\" + hex);\n\t\t\tactiveObject.setBackgroundColor(picker.toHEXString());\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t}\n\t// Handling the delete key event for deleting object\n\twindow.onkeydown = function (e) {\n\t\tswitch (e.keyCode) {\n\t\tcase 46: // delete\n\t\t\tvar activeObject = canvas.getActiveObject();\n\t\t\tif (activeObject && activeObject.type === 'text') {\n\t\t\t\tvar textObjects = parseInt(document.getElementById('tObject').value);\n\t\t\t\tvar imageObjects = parseInt(document.getElementById('iObject').value);\n\t\t\t\ttextObjects--;\n\t\t\t\tchangePrice(textObjects, imageObjects);\n\t\t\t} else if (activeObject) {\n\t\t\t\tisRawEnabled = parseInt(document.getElementById('is_raw').value);\n\t\t\t\tvar rawImageValue = jQuery(\"#raw_images\").val();\n\t\t\t\tif (activeObject.get('type') != \"text\" && isRawEnabled == 1 && rawImageValue != 0) {\n\t\t\t\t\tremoveImageFromServer(activeObject.RawImageId);\n\t\t\t\t}\n\t\t\t\tvar textObjects = parseInt(document.getElementById('tObject').value);\n\t\t\t\tvar imageObjects = parseInt(document.getElementById('iObject').value);\n\t\t\t\timageObjects--;\n\t\t\t\tchangePrice(textObjects, imageObjects);\n\t\t\t}\n\t\t\tcanvas.remove(activeObject);\n\t\t\tbreak;\n\t\t}\n\t\tif (jQuery('#format_text').length) document.getElementById(\"format_text\").disabled = true;\n\t\tjQuery(\".small_border_label\").css({\n\t\t\t\"display\": \"block\"\n\t\t});\n\t\tjQuery(\"#small-edit-element\").css({\n\t\t\t\"display\": \"none\"\n\t\t});\n\t}\n\tjQuery('select#font_selection').on('change', function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject && (activeObject.type === 'text' || activeObject.type === 'curvedText')) {\n\t\t\tactiveObject.setFontFamily(this.value);\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t});\n\n\tfunction changePrice(textObjects = 0, imageObjects = 0) {\n\t\tvar pricePerText = 0;\n\t\tvar pricePerImage = 0;\n\t\tvar textVar = document.getElementById('add_text');\n\t\tif (textVar) {\n\t\t\tpricePerText = textVar.getAttribute('data-price-per-text');\n\t\t\t//alert(\"pricePerText = \" + pricePerText);\n\t\t}\n\t\telse {\n\t\t\tpricePerText = 0;\n\t\t}\n\n\t\tvar imageUploader = document.getElementById('uploadimage');\n\t\t//alert(imageUploader);\n\t\tif (imageUploader) {\n\t\t\tpricePerImage = imageUploader.getAttribute('data-price-per-image');\n\t\t\t//alert(\"pricePerImage = \" + pricePerImage);\n\t\t} else {\n\t\t\tpricePerImage = 0;\n\t\t}\n\t\tdocument.getElementById('tObject').value = textObjects;\n\t\tdocument.getElementById('iObject').value = imageObjects;\n\t\tvar productPrice = parseFloat(jQuery('span.special-price > span.price-final_price > span.price-wrapper').attr('data-price-amount'));\n\t\tvar finalPrice = productPrice + (pricePerText * textObjects) + (pricePerImage * imageObjects);\n\t\tformatedPrice = priceUtils.formatPrice(parseFloat(finalPrice));\n\t\tjQuery('span.special-price > span.price-final_price > span.price-wrapper > span.price').text(formatedPrice);\n\t}\n\n\tmoveCenter = function () {\n\t\tvar obj = canvas.getActiveObject();\n\t\tobj.center();\n\t\tobj.setCoords();\n\t\tcanvas.renderAll();\n\t\tsave();\n\t}\n\tmoveLeft = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject) {\n\t\t\toldLeft = parseInt(activeObject.getLeft(), 10);\n\t\t\toldLeft -= 10;\n\t\t\tactiveObject.setLeft(oldLeft).setCoords();\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t}\n\tmoveRight = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject) {\n\t\t\toldRight = parseInt(activeObject.getLeft(), 10);\n\t\t\toldRight += 10;\n\t\t\tactiveObject.setLeft(oldRight).setCoords();\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t}\n\tmoveTop = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject) {\n\t\t\toldTop = parseInt(activeObject.getTop(), 10);\n\t\t\toldTop -= 10;\n\t\t\tactiveObject.setTop(oldTop).setCoords();\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t}\n\tmoveTopLeft = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject) {\n\t\t\toldTop = parseInt(activeObject.getTop(), 10);\n\t\t\toldTop -= 10;\n\t\t\toldLeft = parseInt(activeObject.getLeft(), 10);\n\t\t\toldLeft -= 10;\n\t\t\tactiveObject.setLeft(oldLeft).setCoords();\n\t\t\tactiveObject.setTop(oldTop).setCoords();\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t}\n\tmoveTopRight = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject) {\n\t\t\toldTop = parseInt(activeObject.getTop(), 10);\n\t\t\toldTop -= 10;\n\t\t\toldRight = parseInt(activeObject.getLeft(), 10);\n\t\t\toldRight += 10;\n\t\t\tactiveObject.setLeft(oldRight).setCoords();\n\t\t\tactiveObject.setTop(oldTop).setCoords();\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t}\n\tmoveBottomLeft = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject) {\n\t\t\toldBottom = parseInt(activeObject.getTop(), 10);\n\t\t\toldBottom += 10;\n\t\t\toldLeft = parseInt(activeObject.getLeft(), 10);\n\t\t\toldLeft -= 10;\n\t\t\tactiveObject.setTop(oldBottom).setCoords();\n\t\t\tactiveObject.setLeft(oldLeft).setCoords();\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t}\n\tmoveBottomRight = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject) {\n\t\t\toldBottom = parseInt(activeObject.getTop(), 10);\n\t\t\toldBottom += 10;\n\t\t\toldLeft = parseInt(activeObject.getLeft(), 10);\n\t\t\toldLeft += 10;\n\t\t\tactiveObject.setTop(oldBottom).setCoords();\n\t\t\tactiveObject.setLeft(oldLeft).setCoords();\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t}\n\tmoveBottom = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject) {\n\t\t\toldBottom = parseInt(activeObject.getTop(), 10);\n\t\t\toldBottom += 10;\n\t\t\tactiveObject.setTop(oldBottom).setCoords();\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t}\n\trotateClock = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject) {\n\t\t\toldAngle = parseInt(activeObject.getAngle(), 10);\n\t\t\toldAngle += 10;\n\t\t\tactiveObject.setAngle(oldAngle).setCoords();\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t}\n\trotateAntiClock = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject) {\n\t\t\toldAngle = parseInt(activeObject.getAngle(), 10);\n\t\t\toldAngle -= 10;\n\t\t\tactiveObject.setAngle(oldAngle).setCoords();\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}\n\t}\n\tjQuery('#undo').click(function() {\n            replay(undo, redo, '#redo', this);\n   });\n  jQuery('#redo').click(function() {\n            replay(redo, undo, '#undo', this);\n\n  });\n  jQuery('#undoImage').click(function() {\n            replay(undo, redo, '#redoImage', this);\n\t\t\t\t\t\tvar textObjects = parseInt(document.getElementById('tObject').value);\n            var imageObjects = parseInt(document.getElementById('iObject').value);\n            textObjects--;\n            changePrice(textObjects, imageObjects);\n  });\n  jQuery('#redoImage').click(function() {\n            replay(redo, undo, '#undoImage', this);\n\t\t\t\t\t\tvar textObjects = parseInt(document.getElementById('tObject').value);\n            var imageObjects = parseInt(document.getElementById('iObject').value);\n            textObjects++;\n            changePrice(textObjects, imageObjects);\n  });\n\tjQuery('#undoClipart').click(function() {\n            replay(undo, redo, '#redoClipart', this);\n   });\n  jQuery('#redoClipart').click(function() {\n            replay(redo, undo, '#undoClipart', this);\n  });\n\n\tfunction replay(playStack, saveStack, buttonsOn, buttonsOff) {\n         \tsaveStack.push(state);\n          state = playStack.pop();\n          var on = jQuery(buttonsOn);\n          var off = jQuery(buttonsOff);\n          // turn both buttons off for the moment to prevent rapid clicking\n          on.prop('disabled', true);\n          off.prop('disabled', true);\n          canvas.clear();\n\t\t\t\t\tcanvas.loadFromJSON(state, function() {\n\t\t\t\t\t\t\t //alert(state);\n\t\t\t\t\t\t\t canvas.renderAll();\n\t\t\t\t\t     // now turn the buttons back on if applicable\n\t\t\t\t\t     on.prop('disabled', false);\n\t\t\t\t\t     if (playStack.length) {\n\t\t\t\t\t         off.prop('disabled', false);\n\t\t\t\t\t     }\n\t\t\t\t\t});\n\t\t\t\t\tvar textObjects=0;\n\t\t\t\t\tvar imageObjects=0;\n\t\t\t\t\tvar counterz = (state.match(/image/g) || []).length;\n\t\t\t\t\t//alert(counterz);\n\t\t\t\t\tif(counterz>0){\n\t\t\t\t\t\timageObjects++;\n\t\t\t\t\t}\n\t\t\t\t\tcanvas.getObjects().forEach(function (obj) {\n\t\t\t\t\tif(obj.type=='text'){\n\t\t\t\t\t\t\ttextObjects++;\n\t\t\t\t\t\t}\n \t\t\t\t\t})\n          changePrice(textObjects, (counterz/2));\n  }\n\tdeleteObject = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject.id != 'nameObject' && activeObject.id != 'numberObject') {\n\t\t\tif (activeObject && activeObject.type === 'text') {\n\t\t\t\tvar textObjects = parseInt(document.getElementById('tObject').value);\n\t\t\t\tvar imageObjects = parseInt(document.getElementById('iObject').value);\n\t\t\t\ttextObjects--;\n\t\t\t\tchangePrice(textObjects, imageObjects);\n\t\t\t}\n\t\t\telse if (activeObject) {\n\t\t\t\tisRawEnabled = parseInt(document.getElementById('is_raw').value);\n\t\t\t\tif (activeObject.get('type') != \"text\" && isRawEnabled == 1) {\n\t\t\t\t\tremoveImageFromServer(activeObject.RawImageId);\n\t\t\t\t}\n\t\t\t\tvar textObjects = parseInt(document.getElementById('tObject').value);\n\t\t\t\tvar imageObjects = parseInt(document.getElementById('iObject').value);\n\t\t\t\timageObjects--;\n\t\t\t\tchangePrice(textObjects, imageObjects);\n\t\t\t}\n\t\t}\n\t\tif (activeObject.id == 'nameObject' || activeObject.id == 'numberObject') {\n\t\t\tjQuery('#add_name').val('');\n\t\t\tjQuery('#add_numb').val('');\n\t\t\tjQuery('#add_size').val('');\n\t\t}\n\t\tcanvas.remove(activeObject);\n\t\tif (jQuery('#format_text').length) document.getElementById(\"format_text\").disabled = true;\n\t\tresetDefault();\n\t}\n\tjQuery(document).on('click', '.clipart-image', function () {\n\t\tvar textObjects = parseInt(document.getElementById('tObject').value);\n\t\tvar imageObjects = parseInt(document.getElementById('iObject').value);\n\t\timageObjects++;\n\t\tchangePrice(textObjects, imageObjects);\n\t\tvar imageName = jQuery(this).attr(\"src\")\n\t\tfabric.Image.fromURL(imageName, function (img) {\n\t\t\tvar center = canvas.getCenter();\n\t\t\tvar oImg = img.set({\n\t\t\t\ttop: center.top,\n\t\t\t\tleft: center.left,\n\t\t\t\toriginX: 'center',\n\t\t\t\toriginY: 'center'\n\t\t\t}).scale(0.6);\n\t\t\tisFitEnable = parseInt(document.getElementById('image_fit').value);\n\t\t\tif (isFitEnable == 1) {\n\t\t\t\toImg.set({\n\t\t\t\t\ttop: canvas.height / 2,\n\t\t\t\t\tleft: canvas.width / 2,\n\t\t\t\t\tscaleY: (canvas.height / oImg.height) - 0.03,\n\t\t\t\t\tscaleX: (canvas.width / oImg.width) - 0.03\n\t\t\t\t});\n\t\t\t}\n\t\t\tcanvas.add(oImg);\n\t\t\tcanvas.renderAll();\n\t\t\tsave();\n\t\t}, {\n\t\t\tcrossOrigin: 'anonymous'\n\t\t});\n\t});\n\tfilterClipart = function () {\n\t\tvar clipart = document.getElementById('clipart_categories');\n\t\tvar baseURL = document.getElementById('baseURL').value;\n\t\tvalue = clipart.options[clipart.selectedIndex].value\n\t\tif (jQuery('clipart-images-loader')) {\n\t\t\tvar clip_process_loader = jQuery('#clipart-images-loader');\n\t\t\tjQuery('#clipart-images-loader').css(\"display\", \"block\");\n\t\t\tjQuery('#clipart_images_container').html(jQuery('#clipart-images-loader').html());\n\t\t}\n\t\tjQuery.ajax({\n\t\t\turl: baseURL + 'personalizedcool/index/clipart/',\n\t\t\tdata: {\n\t\t\t\tclipart_cat_id: value\n\t\t\t},\n\t\t\ttype: 'POST',\n\t\t\tbeforeSend: function () {},\n\t\t\tsuccess: function (result) {\n\t\t\t\tjQuery('#clipart_images_container').html(result.image);\n\t\t\t\tclip_process_loader.css(\"display\", \"none\");\n\t\t\t\tjQuery('#clipart_images_container').append(clip_process_loader);\n\t\t\t}\n\t\t});\n\t} //  Clip Art\n\tvar clipart = document.getElementById('clipart_categories');\n\tif (typeof (clipart) != 'undefined' && clipart != null) {\n\t\tclipart.addEventListener('change', filterClipart, false);\n\t}\n\tbringToFront = function () {\n\t\tvar activeObject = canvas.getActiveObject(),\n\t\t\tactiveGroup = canvas.getActiveGroup();\n\t\tif (activeObject) {\n\t\t\tactiveObject.bringToFront();\n\t\t} else if (activeGroup) {\n\t\t\tvar objectsInGroup = activeGroup.getObjects();\n\t\t\tcanvas.discardActiveGroup();\n\t\t\tobjectsInGroup.forEach(function (object) {\n\t\t\t\tobject.bringToFront();\n\t\t\t});\n\t\t}\n\t};\n\tcloneObject = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (activeObject) {\n\t\t\tvar imageObjects = parseInt(document.getElementById('iObject').value);\n\t\t\tvar textObjects = parseInt(document.getElementById('tObject').value);\n\t\t\tobject = fabric.util.object.clone(activeObject);\n\t\t\tobject.set(\"top\", object.top + 5);\n\t\t\tobject.set(\"left\", object.left + 5);\n\t\t\tcanvas.add(object);\n\t\t\tif (activeObject.get('type') == 'curvedText' || activeObject.get('type') == 'text') {\n\t\t\t\ttextObjects++;\n\t\t\t\tchangePrice(textObjects, imageObjects);\n\t\t\t} else {\n\t\t\t\timageObjects++;\n\t\t\t\tchangePrice(textObjects, imageObjects);\n\t\t\t}\n\t\t}\n\t};\n\tsendToBack = function () {\n\t\tvar activeObject = canvas.getActiveObject(),\n\t\t\tactiveGroup = canvas.getActiveGroup();\n\t\tif (activeObject) {\n\t\t\tactiveObject.sendToBack();\n\t\t} else if (activeGroup) {\n\t\t\tvar objectsInGroup = activeGroup.getObjects();\n\t\t\tcanvas.discardActiveGroup();\n\t\t\tobjectsInGroup.forEach(function (object) {\n\t\t\t\tobject.sendToBack();\n\t\t\t});\n\t\t}\n\t\tcanvas.renderAll();\n\t\tsave();\n\t};\n\tflipHorizontal = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (!activeObject) {\n\t\t\treturn;\n\t\t}\n\t\tvar flip = false;\n\t\tvar originalFlipX = activeObject.flipX;\n\t\tvar originalFlipY = activeObject.flipY;\n\t\tif (activeObject.flipX == false) {\n\t\t\tflip = true;\n\t\t} else {\n\t\t\tflip = false;\n\t\t}\n\t\tactiveObject.set('flipX', flip);\n\t\tcanvas.renderAll();\n\t\tsave();\n\t};\n\tflipVertical = function () {\n\t\tvar activeObject = canvas.getActiveObject();\n\t\tif (!activeObject) {\n\t\t\treturn;\n\t\t}\n\t\tvar flip = false;\n\t\tvar originalFlipX = activeObject.flipX;\n\t\tvar originalFlipY = activeObject.flipY;\n\t\tif (activeObject.flipY == false) {\n\t\t\tflip = true;\n\t\t} else {\n\t\t\tflip = false;\n\t\t}\n\t\tactiveObject.set('flipY', flip);\n\t\tcanvas.renderAll();\n\t\tsave();\n\t};\n\t// Template Settings\n\tjQuery.event.special.inputchange = {\n\t\tsetup: function () {\n\t\t\tvar self = this,\n\t\t\t\tval;\n\t\t\tjQuery.data(this, 'timer', window.setInterval(function () {\n\t\t\t\tval = self.value;\n\t\t\t\tif (jQuery.data(self, 'cache') != val) {\n\t\t\t\t\tjQuery.data(self, 'cache', val);\n\t\t\t\t\tjQuery(self).trigger('inputchange');\n\t\t\t\t}\n\t\t\t}, 20));\n\t\t},\n\t\tteardown: function () {\n\t\t\twindow.clearInterval(jQuery.data(this, 'timer'));\n\t\t},\n\t\tadd: function () {\n\t\t\tjQuery.data(this, 'cache', this.value);\n\t\t}\n\t};\n\t//Event for template on product page.\n\tjQuery(document).on('blur', 'input.template-text', function () {\n\t\tvar id = jQuery(this).attr('id');\n\t\tvar characterId = jQuery(\"#\" + id).attr('data-id');\n\t\tjQuery('#character-left' + characterId).removeClass('data-validation');\n\t\tjQuery('#' + id).removeClass('data-validation-textbox');\n\t});\n\t//Event for template on product page.\n\tjQuery(document).on('keypress keyup change blur', 'input.template-text', function () {\n\t\tvar mode = \"insert\";\n\t\tvar textObj;\n\t\tvar id = this.id;\n\t\tvar max = jQuery(\"#\" + id).attr('data-char');\n\t\tvar characterId = jQuery(\"#\" + id).attr('data-id');\n\t\tvar len = (this.value).length;\n\t\tvar char = max - len;\n\t\tvar family = jQuery(\"#\" + id).attr('data-family');\n\t\tvar size = jQuery(\"#\" + id).attr('data-size');\n\t\tvar top = jQuery(\"#\" + id).attr('data-top');\n\t\tvar left = jQuery(\"#\" + id).attr('data-left');\n\t\tvar angle = jQuery(\"#\" + id).attr('data-angle');\n\t\tvar effect = jQuery(\"#\" + id).attr('data-effect');\n\t\tvar radius = jQuery(\"#\" + id).attr('data-radius');\n\t\tvar spacing = jQuery(\"#\" + id).attr('data-spacing');\n\t\tif (len < max) {\n\t\t\tjQuery('#character-left' + characterId).text('(' + char + ' characters left)');\n\t\t\tjQuery('#character-left' + characterId).removeClass('data-validation');\n\t\t\tjQuery('#' + id).removeClass('data-validation-textbox');\n\t\t} else {\n\t\t\tjQuery('#character-left' + characterId).html('(' + char + ' characters left)');\n\t\t\tjQuery('#character-left' + characterId).addClass('data-validation');\n\t\t\tjQuery('#' + id).addClass('data-validation-textbox');\n\t\t}\n\t\tcanvas.getObjects().forEach(function (obj) {\n\t\t\tif (obj.id == id) {\n\t\t\t\tmode = \"update\";\n\t\t\t\ttextObj = obj;\n\t\t\t}\n\t\t})\n\t\tif (mode == \"insert\" && this.value != '') {\n\t\t\ttextObj = new fabric.Text(this.value, {\n\t\t\t\tfontSize: size,\n\t\t\t\ttextAlign: \"left\",\n\t\t\t\toriginX: 'center',\n\t\t\t\toriginY: 'center',\n\t\t\t\tfontFamily: family,\n\t\t\t\ttop: top,\n\t\t\t\tleft: left,\n\t\t\t\tangle: angle,\n\t\t\t\tlockMovementX: true,\n\t\t\t\tlockMovementY: true,\n\t\t\t\tlockScalingX: true,\n\t\t\t\tlockScalingY: true,\n\t\t\t\tlockUniScaling: true,\n\t\t\t\tlockRotation: true,\n\t\t\t\thasControls: false,\n\t\t\t\thasBorders: false\n\t\t\t});\n\t\t\tif (effect != 'STRAIGHT') {\n\t\t\t\tvar props = {};\n\t\t\t\tto_object_type = effect;\n\t\t\t\tvar obj = textObj;\n\t\t\t\tif (obj) {\n\t\t\t\t\tprops = obj.toObject();\n\t\t\t\t\tdelete props['type'];\n\t\t\t\t\tprops['textAlign'] = obj.getTextAlign();\n\t\t\t\t\tprops['originX'] = obj.getOriginX();\n\t\t\t\t\tprops['originY'] = obj.getOriginY();\n\t\t\t\t\tprops['fontFamily'] = obj.getFontFamily();\n\t\t\t\t\tprops['fill'] = obj.getFill();\n\t\t\t\t\tprops['backgroundColor'] = obj.getBackgroundColor();\n\t\t\t\t\tprops['top'] = obj.getTop();\n\t\t\t\t\tprops['left'] = obj.getLeft();\n\t\t\t\t\tprops['objectType'] = obj.objectType;\n\t\t\t\t\tprops['lockMovementX'] = obj.lockMovementX;\n\t\t\t\t\tprops['lockMovementY'] = obj.lockMovementY;\n\t\t\t\t\tprops['lockScalingX'] = obj.lockScalingX;\n\t\t\t\t\tprops['lockScalingY'] = obj.lockScalingY;\n\t\t\t\t\tprops['lockRotation'] = obj.lockRotation;\n\t\t\t\t\tprops['hasControls'] = obj.hasControls;\n\t\t\t\t\tprops['hasBorders'] = obj.hasBorders;\n\t\t\t\t\tif (obj.type == 'curvedText' && to_object_type == 'text') {\n\t\t\t\t\t\tvar convertedText = new fabric.Text(obj.getText(), props);\n\t\t\t\t\t} else if (obj.type == 'text' && to_object_type == 'curved') {\n\t\t\t\t\t\tprops['effect'] = effect;\n\t\t\t\t\t\tprops['radius'] = radius;\n\t\t\t\t\t\tprops['spacing'] = spacing;\n\t\t\t\t\t\tvar convertedText = new fabric.CurvedText(obj.getText(), props);\n\t\t\t\t\t}\n\t\t\t\t\tcanvas.add(convertedText).renderAll();\n\t\t\t\t\tconvertedText.id = id;\n\t\t\t\t\tcanvas.setActiveObject(canvas.item(canvas.getObjects().length - 1));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttextObj.id = id;\n\t\t\t\tcanvas.add(textObj);\n\t\t\t}\n\t\t} else if (mode == 'update') {\n\t\t\tif (this.value == '') {\n\t\t\t\tcanvas.remove(textObj);\n\t\t\t} else {\n\t\t\t\ttextObj.setText(this.value);\n\t\t\t}\n\t\t}\n\t\tcanvas.renderAll();\n\t});\n\tonSelected = function (e) {\n\t\tproper_object_selected = true;\n\t\tvar isMobile = window.matchMedia(\"only screen and (max-width: 760px)\");\n\t\tif (e.target.get('type') == 'curvedText' || e.target.get('type') == 'text') {\n\t\t\tif (isMobile.matches) {\n\t\t\t\tif (jQuery('#format_text').length) document.getElementById(\"format_text\").disabled = false;\n\t\t\t\tchange_add_update_buttons(e.target.get('text'), 'none', 'none', 'silver');\n\t\t\t} else {\n\t\t\t\t// Added this condition due to control\n\t\t\t\tif (canvas.getActiveObject() != null) {\n\t\t\t\t\tselect_text_styles();\n\t\t\t\t\tchange_add_update_buttons(e.target.get('text'), 'none', 'inline-block', 'silver');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isMobile.matches && canvas.getActiveObject() != null) {\n\t\t\tjQuery(\"#small-edit-element\").css({\n\t\t\t\t\"display\": \"block\"\n\t\t\t});\n\t\t}\n\t\tif ((!jQuery('#add_text_button').hasClass(\"tab-view\"))) {\n\t\t\tif (jQuery('#format_text').length) document.getElementById(\"format_text\").disabled = false;\n\t\t}\n\t}\n\t//On selection of object set value to text effect options.\n\tselect_text_styles = function () {\n\t\tif (jQuery('#text-bold').length) {\n\t\t\tif (canvas.getActiveObject().getFontWeight() == 'bold') {\n\t\t\t\tdocument.getElementById('text-bold').style.background = '#e6e4df';\n\t\t\t} else {\n\t\t\t\tdocument.getElementById('text-bold').style.background = '#fff';\n\t\t\t}\n\t\t\tif (canvas.getActiveObject().getFontStyle() == 'italic') {\n\t\t\t\tdocument.getElementById('text-italic').style.background = '#e6e4df';\n\t\t\t} else {\n\t\t\t\tdocument.getElementById('text-italic').style.background = '#fff';\n\t\t\t}\n\t\t\tif (canvas.getActiveObject().getTextDecoration() == 'underline') {\n\t\t\t\tdocument.getElementById('text-underline').style.background = '#e6e4df';\n\t\t\t} else {\n\t\t\t\tdocument.getElementById('text-underline').style.background = '#fff';\n\t\t\t}\n\t\t\tjQuery('#font_bg_color').css('background-color', canvas.getActiveObject().getBackgroundColor());\n\t\t\tjQuery('#font_selection').val(canvas.getActiveObject().getFontFamily());\n\t\t\tif (canvas.getActiveObject().type == 'curvedText') {\n\t\t\t\tjQuery('#effect').val(canvas.getActiveObject().getEffect());\n\t\t\t\tif (canvas.getActiveObject().getEffect() == 'curved' || canvas.getActiveObject().getEffect() == 'arc') {\n\t\t\t\t\tjQuery('.radius-effect, .spacing-effect, .reverse-effect').css('display', 'block');\n\t\t\t\t\tjQuery('#radius').val(canvas.getActiveObject().getRadius());\n\t\t\t\t\tjQuery('#spacing').val(canvas.getActiveObject().getSpacing());\n\t\t\t\t\tjQuery('#reverse').prop('checked', canvas.getActiveObject().getReverse());\n\t\t\t\t} else {\n\t\t\t\t\tjQuery('.radius-effect, .spacing-effect, .reverse-effect').css('display', 'none');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjQuery('#effect').val('STRAIGHT');\n\t\t\t\tjQuery('.radius-effect, .spacing-effect, .reverse-effect').css('display', 'none');\n\t\t\t}\n\t\t}\n\t}\n\t//Reset button and text effect style\n\tonDeSelected = function () {\n\t\tvar isMobile = window.matchMedia(\"only screen and (max-width: 760px)\");\n\t\tif (!isMobile.matches) {\n\t\t\tchange_add_update_buttons('', 'none', 'inline-block', 'silver');\n\t\t\tdeselect_text_styles();\n\t\t}\n\t\telse {\n\t\t\tchange_add_update_buttons('', 'none', 'inline-block', 'silver');\n\t\t\tdeselect_text_styles();\n\t\t}\n\t}\n\t//set value on modification of object\n\tonModified = function (e) {\n\t\tsave();\n\t\tif (e.target.get('type') == 'curvedText' || e.target.get('type') == 'text') {\n\t\t\te.target.setFontSize(parseFloat(e.target.fontSize * e.target.scaleX).toFixed(2));\n\t\t\te.target.setScaleX(1);\n\t\t\te.target.setScaleY(1);\n\t\t\te.target.setCoords();\n\t\t\tcanvas.renderAll();\n\t\t}\n\t}\n\n\t// Update the text object text\n\tupdatetext = function () {\n\t\tif (jQuery('#add_text').val()) {\n\t\t\tif (canvas.getActiveObject().type == 'curvedText' || canvas.getActiveObject().type == 'text') {\n\t\t\t\tcanvas.getActiveObject().setText(jQuery('#add_text').val());\n\t\t\t\tcanvas.renderAll();\n\t\t\t\tsave();\n\t\t\t\tjQuery('#add_text').css('border-color', 'silver');\n\t\t\t}\n\t\t} else {\n\t\t\tjQuery('#add_text').css('border-color', 'red');\n\t\t}\n\t}\n\t//Update the name\n\tupdatename = function () {\n\t\tif (jQuery('#add_name').val()) {\n\t\t\tif (canvas.getActiveObject().type == 'curvedText' || canvas.getActiveObject().type == 'text') {\n\t\t\t\tcanvas.getActiveObject().setText(jQuery('#add_name').val());\n\t\t\t\tcanvas.renderAll();\n\t\t\t\tsave();\n\t\t\t\tjQuery('#add_name').css('border-color', 'silver');\n\t\t\t}\n\t\t} else {\n\t\t\tjQuery('#add_name').css('border-color', 'red');\n\t\t}\n\t}\n\t// Change button text from add to update\n\tchange_add_update_buttons = function (text_value, add_button_display, update_button_display, border_color) {\n\t\tjQuery('#add_text').val(text_value);\n\t\tjQuery('#add_text_button').css('display', add_button_display);\n\t\tjQuery('.update-text').css('display', update_button_display);\n\t\tjQuery('#add_text').css('border-color', border_color);\n\t}\n\t// Reset Text effect\n\tdeselect_text_styles = function () {\n\t\tif (jQuery('#text-bold').length) {\n\t\t\tdocument.getElementById('text-bold').style.background = '#fff';\n\t\t\tdocument.getElementById('text-italic').style.background = '#fff';\n\t\t\tdocument.getElementById('text-underline').style.background = '#fff';\n\t\t\tjQuery('#font_bg_color').css('background-color', '');\n\t\t\tjQuery('#font_selection option:first').attr('selected', 'selected');\n\t\t\tjQuery('#effect').val('STRAIGHT');\n\t\t\tjQuery('.radius-effect, .spacing-effect, .reverse-effect').css('display', 'none');\n\t\t}\n\t\t// Hide the small-edit-element\n\t\tjQuery(\"#small-edit-element\").css({\n\t\t\t\"display\": \"none\"\n\t\t});\n\t}\n\tvar modal = document.getElementById('myModal');\n\t// When the user clicks anywhere outside of the modal, close it\n\twindow.onclick = function(event) {\n\t\t\tif (event.target == modal) {\n\t\t\t\t\tmodal.style.display = \"none\";\n\t\t\t\t\t//jQuery(\".color-picker\").hide();\n\t\t\t}\n\t\t\t\n\t}\n\t\n\t  jQuery('#upper-canvas').mousedown(function() {\n        if(jQuery('.update-text').css('display')=='inline-block') {\n\t\t\t\tjQuery('.update-text').css('display', 'inline-block !important');\n\t\t\t\tjQuery('#add_text_button').css('display', 'none !important');\n\t\t\t\tconsole.log('g');\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjQuery('.update-text').css('display', 'none !important');\n\t\t\t\tjQuery('#add_text_button').css('display', 'inline-block !important');\n\t\t\t\tconsole.log('s');\n\t\t\t}\n    });\n\t\n// Load all the option of simple product on selection of swatch on configurabl product page.\n\tjQuery(\"div.swatch-opt\").on(\"click\", \"div.swatch-option\", function () {\n\t\tsetTimeout(function () {\n\t\t\tattributeConfig = {};\n\t\t\tvar hasArea = document.getElementById('hasArea').value;\n\t\t\tif (hasArea == '') {\n\t\t\t\tjQuery('div.swatch-attribute').find('.selected').each(function () {\n\t\t\t\t\tvar $selectedGrand = jQuery(this).parent().parent();\n\t\t\t\t\tattributeConfig[$selectedGrand.attr('attribute-code')] = $selectedGrand.attr('option-selected');\n\t\t\t\t});\n\t\t\t}\n\t\t\tvar numItems = jQuery('.swatch-attribute').length;\n\t\t\tif (numItems == Object.keys(attributeConfig).length) {\n\t\t\t\tjQuery('#list_personalizer').show();\n\t\t\t\tjQuery('#enquire_now_btn').show();\n\t\t\t\tvar baseUrl = jQuery(\"#baseURL\").val();\n\t\t\t\tproductId = document.getElementsByName('product')[0].value;\n\t\t\t\tattributeCallData = {\n\t\t\t\t\t'product_id': productId,\n\t\t\t\t\t'attributes': attributeConfig,\n\t\t\t\t\t'additional': ''\n\t\t\t\t};\n\t\t\t\tjQuery.ajax({\n\t\t\t\t\ttype: 'POST',\n\t\t\t\t\turl: baseUrl + 'personalizedcool/index/load/',\n\t\t\t\t\tdata: attributeCallData,\n\t\t\t\t\tshowLoader: true,\n\t\t\t\t\tsuccess: function (result) {\n\t\t\t\t\t\tjQuery('#personalized_it_btn').show();\n\t\t\t\t\t\tif (result.noarea != '') {\n\t\t\t\t\t\t\tcanvas.clear();\n\t\t\t\t\t\t\tcanvas.deactivateAll().renderAll();\n\t\t\t\t\t\t\tjQuery('#imageDiv').attr('src', result.base);\n\t\t\t\t\t\t\tjQuery('#config_id').val(result.id);\n\t\t\t\t\t\t\tjQuery('#container').remove();\n\t\t\t\t\t\t\tjQuery('#no-area').html('');\n\t\t\t\t\t\t\tjQuery('#product-zoom-container').remove();\n\t\t\t\t\t\t\tjQuery('div.gallery-placeholder').append(result.area);\n\t\t\t\t\t\t\twindow.canvasObjects[result.id] = new fabric.Canvas('imageCanvas-' + result.id);\n\t\t\t\t\t\t\tcanvas = window.canvasObjects[result.id];\n\t\t\t\t\t\t\tcanvas.on({\n\t\t\t\t\t\t\t\t'object:moving': onSelected,\n\t\t\t\t\t\t\t\t'object:selected': onSelected,\n\t\t\t\t\t\t\t\t'object:modified': onModified,\n\t\t\t\t\t\t\t\t'selection:created': onSelected,\n\t\t\t\t\t\t\t\t'selection:cleared': onDeSelected\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjQuery('#no-area').html('');\n\t\t\t\t\t\t\tconfigurableId = jQuery('#config_id').val();\n\t\t\t\t\t\t\tjQuery('#drawingArea-' + configurableId).remove();\n\t\t\t\t\t\t\tjQuery('#product-zoom-container-' + configurableId).remove();\n\t\t\t\t\t\t\tjQuery('#no-area').append(result.area);\n\t\t\t\t\t\t\tjQuery('#imageDiv').attr('src', result.base);\n\t\t\t\t\t\t\tcanvas = new fabric.Canvas('imageCanvas');\n\t\t\t\t\t\t\tcanvas.setHeight(global_canvas_height);\n\t\t\t\t\t\t\tcanvas.setWidth(global_canvas_width);\n\t\t\t\t\t\t\tcanvas.renderAll();\n\t\t\t\t\t\t\tcanvas.on({\n\t\t\t\t\t\t\t\t'object:moving': onSelected,\n\t\t\t\t\t\t\t\t'object:selected': onSelected,\n\t\t\t\t\t\t\t\t'object:modified': onModified,\n\t\t\t\t\t\t\t\t'selection:created': onSelected,\n\t\t\t\t\t\t\t\t'selection:cleared': onDeSelected\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (result.html != '') {\n\t\t\t\t\t\t\tjQuery('<input id=\"template\" class=\"personalized_tab_radio\" name=\"tabs\" type=\"radio\"><label id=\"tab-template\" for=\"template\">Template</label>').insertAfter(\"#tab-clip\");\n\t\t\t\t\t\t\tjQuery('<section id=\"content-template\"> </section>').insertAfter('#content-clipart');\n\t\t\t\t\t\t\tjQuery('#content-template').html(result.html);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjQuery('#template').remove();\n\t\t\t\t\t\t\tjQuery('#tab-template').remove();\n\t\t\t\t\t\t\tjQuery('#content-template').remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, 500); // How long do you want the delay to be (in milliseconds)?\n\t}); //Swatch click event\n\t// No Area add to cart process\n\tnoArea = function (widget, form, baseUrl) {\n\t\tindex = 0;\n\t\tvar imgUrl = document.getElementById(\"imageDiv\").src;\n\t\tif (window.canvasObjects.length == 0) {\n\t\t\tvar zcanvas = jQuery('#product-zoom-canvas');\n\t\t\tzcanvas.innerHTML = '';\n\t\t\tvar imagearray = [];\n\t\t\tjQuery(\"#product-zoom-container\").empty();\n\t\t\tjQuery('#product-zoom-container').append(zcanvas);\n\t\t\tvar zoomCanvas = new fabric.Canvas('product-zoom-canvas');\n\t\t\tzoomCanvas.setHeight(canvas.getHeight());\n\t\t\tzoomCanvas.setWidth(canvas.getWidth());\n\t\t\tzoomCanvas.setBackgroundImage(imgUrl, zoomCanvas.renderAll.bind(zoomCanvas));\n\t\t\tcanvas.deactivateAll();\n\t\t\tvar originalImage = canvas.toDataURL();\n\t\t\tfabric.Image.fromURL(originalImage, function (oImg) {\n\t\t\t\tzoomCanvas.add(oImg.set({\n\t\t\t\t\tleft: 0,\n\t\t\t\t\ttop: 0\n\t\t\t\t}));\n\t\t\t\tzoomCanvas.renderAll();\n\t\t\t\tzoomCanvas.calcOffset();\n\t\t\t\timagearray.push(zoomCanvas.toDataURL(\"image/png\"));\n\t\t\t\tif (canvas.getObjects().length >= 1) {\n\t\t\t\t\timagearray.push(originalImage);\n\t\t\t\t}\n\t\t\t\t// Get the img object.\n\t\t\t\tjQuery.ajax({\n\t\t\t\t\ttype: 'POST',\n\t\t\t\t\turl: baseUrl,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\t'imagedata[]': imagearray\n\t\t\t\t\t},\n\t\t\t\t\tbeforeSend: function () {\n\t\t\t\t\t\tjQuery('#product-addtocart-button').find('span').text(\"Adding...\");\n\t\t\t\t\t\tjQuery('#product-addtocart-button').addClass('disabled');\n\t\t\t\t\t},\n\t\t\t\t\tsuccess: function (result) {\n\t\t\t\t\t\tvar imageElement = document.getElementById(\"image_html\"); // Get the img object.\n\t\t\t\t\t\timageElement.value = result;\n\t\t\t\t\t\twidget.catalogAddToCart('submitForm', jQuery(form));\n\t\t\t\t\t}\n\t\t\t\t}); //Ajax Call\n\t\t\t}); // Image Generation\n\t\t} else {\n\t\t\tid = jQuery(\"#config_id\").val();\n\t\t\tvar zcanvas = jQuery('#product-zoom-canvas-' + id);\n\t\t\tzcanvas.innerHTML = '';\n\t\t\tvar imagearray = [];\n\t\t\tjQuery(\"#product-zoom-container-\" + id).empty();\n\t\t\tjQuery('#product-zoom-container-' + id).append(zcanvas);\n\t\t\tvar zoomCanvas = new fabric.Canvas('product-zoom-canvas-' + id);\n\t\t\tzoomCanvas.setBackgroundImage(imgUrl, zoomCanvas.renderAll.bind(zoomCanvas));\n\t\t\tcanvas.deactivateAll();\n\t\t\tvar originalImage = canvas.toDataURL();\n\t\t\tfabric.Image.fromURL(window.canvasObjects[id].toDataURL(), function (oImg) {\n\t\t\t\tzoomCanvas.add(oImg.set({\n\t\t\t\t\tleft: parseInt(document.getElementById(\"drawingArea-\" + id).style.left),\n\t\t\t\t\ttop: parseInt(document.getElementById(\"drawingArea-\" + id).style.top)\n\t\t\t\t}));\n\t\t\t\tzoomCanvas.renderAll();\n\t\t\t\tzoomCanvas.calcOffset();\n\t\t\t\timagearray.push(zoomCanvas.toDataURL(\"image/png\"));\n\t\t\t\t// Get the img object.\n\t\t\t\tjQuery.ajax({\n\t\t\t\t\ttype: 'POST',\n\t\t\t\t\turl: baseUrl,\n\t\t\t\t\tdata: {\n\t\t\t\t\t\t'imagedata[]': imagearray\n\t\t\t\t\t},\n\t\t\t\t\tbeforeSend: function () {\n\t\t\t\t\t\tjQuery('#product-addtocart-button').find('span').text(\"Adding...\");\n\t\t\t\t\t\tjQuery('#product-addtocart-button').addClass('disabled');\n\t\t\t\t\t},\n\t\t\t\t\tsuccess: function (result) {\n\t\t\t\t\t\tvar imageElement = document.getElementById(\"image_html\"); // Get the img object.\n\t\t\t\t\t\timageElement.value = result;\n\t\t\t\t\t\twidget.catalogAddToCart('submitForm', jQuery(form));\n\t\t\t\t\t}\n\t\t\t\t}); //Ajax Call\n\t\t\t}); // Image Generation\n\t\t}\n\t} //End No Area Add to cart\n\tjQuery(document).on('keyup', 'input#add_text', function () {\n\t\tvar isMobile = window.matchMedia(\"only screen and (max-width: 760px)\");\n\t\tif (isMobile.matches) {\n\t\t\tif (jQuery('#format_text').length) document.getElementById(\"format_text\").disabled = false;\n\t\t\tif (jQuery('input#add_text').val() != '') {\n\t\t\t\tif (canvas.getActiveObject()) {\n\t\t\t\t\tupdatetext();\n\t\t\t\t} else {\n\t\t\t\t\taddtext(true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdeleteObject();\n\t\t\t}\n\t\t\tif (!jQuery('#add_text_button').hasClass(\"tab-view\")) {\n\t\t\t\tjQuery('.update-text').hide();\n\t\t\t\tjQuery('#add_text_button').hide();\n\t\t\t}\n\t\t}\n\t}); // Event for text type for popup - app only\n\tjQuery(document).on('click', 'button.circle', function (e) {\n\t\tif (jQuery('section#content-text').css('display') == 'block') {\n\t\t\tif (jQuery('.text_effect_buttons').css('display') == 'block') {\n\t\t\t\tjQuery('.text_content').show();\n\t\t\t\tjQuery('.text_effect_buttons').hide();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (jQuery('.font_style_popup').css('display') == 'block') {\n\t\t\t\tjQuery('.text_effect_buttons').show();\n\t\t\t\tjQuery('.font_style_popup').hide();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (jQuery('.text_content').css('display') == 'block') {\n\t\t\t\tresetDefault();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tresetDefault();\n\t});\n(function() {\n    var image1 = document.createElement('img'),\n        image2 = document.createElement('img'),\n        image3 = document.createElement('img'),\n        canvas,\n        width = 1000,\n        height = 500,\n        randomColor = function randomColor() {\n            var letters = '0123456789ABCDEF';\n            var color = '#';\n            for (var i = 0; i < 6; i++) {\n                color += letters[Math.floor(Math.random() * 16)];\n            }\n            return color;\n        };\n\n    fabric.Object.prototype.setControlsVisibility( {\n        ml: false,\n        mr: false,\n        mb: false,\n        mt: false,\n        mtr: false,\n\t\ttl: false,\n\t\tbr: false,\n\t\tbl: false,\n\t   } );\n\n    fabric.Canvas.prototype.customiseControls({\n        tl: {\n            action: 'rotate',\n            cursor: 'crosshair',\n        },\n\t\t\t tr: {\n            action: function(e, target) {\n\t\t\t\t\t\t\tdeleteObject();\n\t\t\t\t\t\t},\n            cursor: 'pointer',\n        },\n        br: {\n            action: 'scale',\n        },\n\t\t\t\tbl:{\n      \t\t\t cursor: 'pointer',\n\t\t\t\t\t\t action: function( e, target ) {\n\t\t\t\t\t\t\t cloneObject();\n       \t\t\t }\n   \t\t  },\n    });\n    // basic settings\n\t\tif (window.source_rotate_icon !== undefined) {\n\t\t\tfabric.Object.prototype.customiseCornerIcons({\n\t\t\t\t\tsettings: {\n\t\t\t\t\t\t\tborderColor: '#f95e2e',\n\t\t\t\t\t\t\tborderType : 'dotted',\n\t\t\t\t\t\t\tcornerSize: 25,\n\t\t\t\t\t\t\tcornerShape: 'circle',\n\t\t\t\t\t\t\tcornerBackgroundColor: '#FFC300',\n\t\t\t\t\t},\n\t\t\t\t\ttl: {\n\t\t\t\t\t\t\ticon: source_rotate_icon,\n\t\t\t\t\t},\n\t\t\t\t\ttr: {\n\t\t\t\t\t\t\ticon: source_delete_icon,\n\t\t\t\t\t},\n\t\t\t\t\tbr: {\n\t\t\t\t\t\t\ticon: source_resize_icon,\n\t\t\t\t\t},\n\t\t\t\t\tbl: {\n\t\t\t\t\t\t\ticon: source_duplicate_icon,\n\t\t\t\t\t}\n\t\t\t}, function() {\n\t\t\t\t\t//canvas.renderAll();\n\t\t\t});\n\t\t}\t\n })();\n}); // Required\n","Emizentech_Banner/js/jquery.bannerslider.js":"sh(document).ready(function() {\r\n\tsh.fn.extend({\r\n\t\tbannerslider: function(options) {\r\n\r\n\t\t\t//default values for plugin options\r\n\t\t\tvar defaults = {\r\n\t\t\t\tinterval: 5000,\r\n\t\t\t\tduration: 500,\r\n\t\t\t\tlineheight: 1,\r\n\t\t\t\theight: 'auto', //reserved\r\n\t\t\t\thoverpause: false,\r\n\t\t\t\tpager: true,\r\n\t\t\t\tnav: true, //reserved\r\n\t\t\t\tkeynav: true\r\n\t\t\t}\r\n\t\t\tvar options =  sh.extend(defaults, options);\r\n \r\n\t\t\treturn this.each(function() {\r\n\t\t\t\tvar o = options;\r\n\t\t\t\tvar obj = sh(this);\r\n\r\n\t\t\t\t//store the slide and pager li\r\n\t\t\t\tvar slides = sh('.slides li', obj);\r\n\t\t\t\tvar pager = sh('.pager li', obj);\r\n\r\n\t\t\t\t//set initial current and next slide index values\r\n\t\t\t\tvar current = 0;\r\n\t\t\t\tvar next = current+1;\r\n\r\n\t\t\t\t//get height and width of initial slide image and calculate size ratio\r\n\t\t\t\tvar imgHeight = slides.eq(current).find('img').height();\r\n\t\t\t\tvar imgWidth = slides.eq(current).find('img').width();\r\n\t\t\t\tvar imgRatio = imgWidth/imgHeight;\r\n\r\n\t\t\t\t//define vars for setsize function\r\n\t\t\t\tvar sliderWidth = 0;\r\n\t\t\t\tvar cropHeight = 0;\r\n\r\n\t\t\t\t//hide all slides, fade in the first, add active class to first slide\r\n\t\t\t\tslides.hide().eq(current).fadeIn(o.duration).addClass('active');\r\n\t\t\t\t\r\n\r\n\t\t\t\t//build pager if it doesn't already exist and if enabled\r\n\t\t\t\tif(pager.length) {\r\n\t\t\t\t\tpager.eq(current).addClass('active');\r\n\t\t\t\t} else if(o.pager){\r\n\t\t\t\t\tobj.append('<ul class=\"pager\"></ul>');\r\n\t\t\t\t\tslides.each(function(index) {\r\n\t\t\t\t\t\tsh('.pager', obj).append('<li><a href=\"#\"><span>'+index+'</span></a></li>')\r\n\t\t\t\t\t});\r\n\t\t\t\t\tpager = sh('.pager li', obj);\r\n\t\t\t\t\tpager.eq(current).addClass('active');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//rotate to selected slide on pager click\r\n\t\t\t\tif(pager){\r\n\t\t\t\t\tsh('a', pager).click(function() {\r\n\t\t\t\t\t\t//stop the timer\r\n\t\t\t\t\t\tclearTimeout(obj.play);\r\n\t\t\t\t\t\t//set the slide index based on pager index\r\n\t\t\t\t\t\tnext = sh(this).parent().index();\r\n\t\t\t\t\t\t//rotate the slides\r\n\t\t\t\t\t\trotate();\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//primary function to change slides\r\n\t\t\t\tvar rotate = function(){\r\n\t\t\t\t\t//fade out current slide and remove active class,\r\n\t\t\t\t\t//fade in next slide and add active class\r\n\t\t\t\t\tslides.eq(current).fadeOut(o.duration).removeClass('active')\r\n\t\t\t\t\t\t.end().eq(next).fadeIn(o.duration).addClass('active').queue(function(){\r\n\t\t\t\t\t\t\t//add rotateTimer function to end of animation queue\r\n\t\t\t\t\t\t\t//this prevents animation buildup caused by requestAnimationFrame\r\n\t\t\t\t\t\t\t//rotateTimer starts a timer for the next rotate\r\n\t\t\t\t\t\t\trotateTimer();\r\n\t\t\t\t\t\t\tsh(this).dequeue()\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t//update pager to reflect slide change\r\n\t\t\t\t\tif(pager){\r\n\t\t\t\t\t\tpager.eq(current).removeClass('active')\r\n\t\t\t\t\t\t\t.end().eq(next).addClass('active');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//update current and next vars to reflect slide change\r\n\t\t\t\t\t//set next as first slide if current is the last\r\n\t\t\t\t\tcurrent = next;\r\n\t\t\t\t\tnext = current >= slides.length-1 ? 0 : current+1;\r\n\t\t\t\t};\r\n\t\t\t\t//create a timer to control slide rotation interval\r\n\t\t\t\tvar rotateTimer = function(){\r\n\t\t\t\t\tobj.play = setTimeout(function(){\r\n\t\t\t\t\t\t//trigger slide rotate function at end of timer\r\n\t\t\t\t\t\trotate();\r\n\t\t\t\t\t}, o.interval);\r\n\t\t\t\t};\r\n\t\t\t\t//start the timer for the first time\r\n\t\t\t\trotateTimer();\r\n\r\n\t\t\t\t//pause the slider on hover\r\n\t\t\t\t//disabled by default due to bug\r\n\t\t\t\tif(o.hoverpause){\r\n\t\t\t\t\tslides.hover(function(){\r\n\t\t\t\t\t\t//stop the timer in mousein\r\n\t\t\t\t\t\tclearTimeout(obj.play);\r\n\t\t\t\t\t}, function(){\r\n\t\t\t\t\t\t//start the timer on mouseout\r\n\t\t\t\t\t\trotateTimer();\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//calculate and set height based on image width/height ratio and specified line height\r\n\t\t\t\tvar setsize = function(){\r\n\t\t\t\t\tsliderWidth = sh('.slides', obj).width();\r\n\t\t\t\t\tcropHeight = Math.floor(((sliderWidth/imgRatio)/o.lineheight))*o.lineheight;\r\n\r\n\t\t\t\t\tsh('.slides', obj).css({height: cropHeight});\r\n\t\t\t\t};\r\n\t\t\t\tsetsize();\r\n\r\n\t\t\t\t//bind setsize function to window resize event\r\n\t\t\t\tsh(window).resize(function(){\r\n\t\t\t\t\tsetsize();\r\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t\r\n\r\n\t\t\t\t//Add keyboard navigation\n\r\n\t\t\t\tif(o.keynav){\r\n\t\t\t\t\tsh(document).keyup(function(e){\n\r\n\t\t\t\t\t\tswitch (e.which) {\n\r\n\t\t\t\t\t\t\tcase 39: case 32: //right arrow & space\n\r\n\t\t\t\t\t\t\t\tclearTimeout(obj.play);\n\r\n\t\t\t\t\t\t\t\trotate();\n\r\n\t\t\t\t\t\t\t\tbreak;\n\r\n\r\n\t\t\t\t\t\t\tcase 37: // left arrow\r\n\t\t\t\t\t\t\t\tclearTimeout(obj.play);\r\n\t\t\t\t\t\t\t\tnext = current - 1;\r\n\t\t\t\t\t\t\t\trotate();\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\n\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n\r\n});\r\n","Emizentech_Banner/js/jquery-1.7.2.min.js":"/*! sh v1.7.2 sh.com | sh.org/license */\r\nif(!window.sh) {\r\n(function(a,b){function cy(a){return f.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}function cu(a){if(!cj[a]){var b=c.body,d=f(\"<\"+a+\">\").appendTo(b),e=d.css(\"display\");d.remove();if(e===\"none\"||e===\"\"){ck||(ck=c.createElement(\"iframe\"),ck.frameBorder=ck.width=ck.height=0),b.appendChild(ck);if(!cl||!ck.createElement)cl=(ck.contentWindow||ck.contentDocument).document,cl.write((f.support.boxModel?\"<!doctype html>\":\"\")+\"<html><body>\"),cl.close();d=cl.createElement(a),cl.body.appendChild(d),e=f.css(d,\"display\"),b.removeChild(ck)}cj[a]=e}return cj[a]}function ct(a,b){var c={};f.each(cp.concat.apply([],cp.slice(0,b)),function(){c[this]=a});return c}function cs(){cq=b}function cr(){setTimeout(cs,0);return cq=f.now()}function ci(){try{return new a.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(b){}}function ch(){try{return new a.XMLHttpRequest}catch(b){}}function cb(a,c){a.dataFilter&&(c=a.dataFilter(c,a.dataType));var d=a.dataTypes,e={},g,h,i=d.length,j,k=d[0],l,m,n,o,p;for(g=1;g<i;g++){if(g===1)for(h in a.converters)typeof h==\"string\"&&(e[h.toLowerCase()]=a.converters[h]);l=k,k=d[g];if(k===\"*\")k=l;else if(l!==\"*\"&&l!==k){m=l+\" \"+k,n=e[m]||e[\"* \"+k];if(!n){p=b;for(o in e){j=o.split(\" \");if(j[0]===l||j[0]===\"*\"){p=e[j[1]+\" \"+k];if(p){o=e[o],o===!0?n=p:p===!0&&(n=o);break}}}}!n&&!p&&f.error(\"No conversion from \"+m.replace(\" \",\" to \")),n!==!0&&(c=n?n(c):p(o(c)))}}return c}function ca(a,c,d){var e=a.contents,f=a.dataTypes,g=a.responseFields,h,i,j,k;for(i in g)i in d&&(c[g[i]]=d[i]);while(f[0]===\"*\")f.shift(),h===b&&(h=a.mimeType||c.getResponseHeader(\"content-type\"));if(h)for(i in e)if(e[i]&&e[i].test(h)){f.unshift(i);break}if(f[0]in d)j=f[0];else{for(i in d){if(!f[0]||a.converters[i+\" \"+f[0]]){j=i;break}k||(k=i)}j=j||k}if(j){j!==f[0]&&f.unshift(j);return d[j]}}function b_(a,b,c,d){if(f.isArray(b))f.each(b,function(b,e){c||bD.test(a)?d(a,e):b_(a+\"[\"+(typeof e==\"object\"?b:\"\")+\"]\",e,c,d)});else if(!c&&f.type(b)===\"object\")for(var e in b)b_(a+\"[\"+e+\"]\",b[e],c,d);else d(a,b)}function b$(a,c){var d,e,g=f.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((g[d]?a:e||(e={}))[d]=c[d]);e&&f.extend(!0,a,e)}function bZ(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h=a[f],i=0,j=h?h.length:0,k=a===bS,l;for(;i<j&&(k||!l);i++)l=h[i](c,d,e),typeof l==\"string\"&&(!k||g[l]?l=b:(c.dataTypes.unshift(l),l=bZ(a,c,d,e,l,g)));(k||!l)&&!g[\"*\"]&&(l=bZ(a,c,d,e,\"*\",g));return l}function bY(a){return function(b,c){typeof b!=\"string\"&&(c=b,b=\"*\");if(f.isFunction(c)){var d=b.toLowerCase().split(bO),e=0,g=d.length,h,i,j;for(;e<g;e++)h=d[e],j=/^\\+/.test(h),j&&(h=h.substr(1)||\"*\"),i=a[h]=a[h]||[],i[j?\"unshift\":\"push\"](c)}}}function bB(a,b,c){var d=b===\"width\"?a.offsetWidth:a.offsetHeight,e=b===\"width\"?1:0,g=4;if(d>0){if(c!==\"border\")for(;e<g;e+=2)c||(d-=parseFloat(f.css(a,\"padding\"+bx[e]))||0),c===\"margin\"?d+=parseFloat(f.css(a,c+bx[e]))||0:d-=parseFloat(f.css(a,\"border\"+bx[e]+\"Width\"))||0;return d+\"px\"}d=by(a,b);if(d<0||d==null)d=a.style[b];if(bt.test(d))return d;d=parseFloat(d)||0;if(c)for(;e<g;e+=2)d+=parseFloat(f.css(a,\"padding\"+bx[e]))||0,c!==\"padding\"&&(d+=parseFloat(f.css(a,\"border\"+bx[e]+\"Width\"))||0),c===\"margin\"&&(d+=parseFloat(f.css(a,c+bx[e]))||0);return d+\"px\"}function bo(a){var b=c.createElement(\"div\");bh.appendChild(b),b.innerHTML=a.outerHTML;return b.firstChild}function bn(a){var b=(a.nodeName||\"\").toLowerCase();b===\"input\"?bm(a):b!==\"script\"&&typeof a.getElementsByTagName!=\"undefined\"&&f.grep(a.getElementsByTagName(\"input\"),bm)}function bm(a){if(a.type===\"checkbox\"||a.type===\"radio\")a.defaultChecked=a.checked}function bl(a){return typeof a.getElementsByTagName!=\"undefined\"?a.getElementsByTagName(\"*\"):typeof a.querySelectorAll!=\"undefined\"?a.querySelectorAll(\"*\"):[]}function bk(a,b){var c;b.nodeType===1&&(b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase(),c===\"object\"?b.outerHTML=a.outerHTML:c!==\"input\"||a.type!==\"checkbox\"&&a.type!==\"radio\"?c===\"option\"?b.selected=a.defaultSelected:c===\"input\"||c===\"textarea\"?b.defaultValue=a.defaultValue:c===\"script\"&&b.text!==a.text&&(b.text=a.text):(a.checked&&(b.defaultChecked=b.checked=a.checked),b.value!==a.value&&(b.value=a.value)),b.removeAttribute(f.expando),b.removeAttribute(\"_submit_attached\"),b.removeAttribute(\"_change_attached\"))}function bj(a,b){if(b.nodeType===1&&!!f.hasData(a)){var c,d,e,g=f._data(a),h=f._data(b,g),i=g.events;if(i){delete h.handle,h.events={};for(c in i)for(d=0,e=i[c].length;d<e;d++)f.event.add(b,c,i[c][d])}h.data&&(h.data=f.extend({},h.data))}}function bi(a,b){return f.nodeName(a,\"table\")?a.getElementsByTagName(\"tbody\")[0]||a.appendChild(a.ownerDocument.createElement(\"tbody\")):a}function U(a){var b=V.split(\"|\"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function T(a,b,c){b=b||0;if(f.isFunction(b))return f.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return f.grep(a,function(a,d){return a===b===c});if(typeof b==\"string\"){var d=f.grep(a,function(a){return a.nodeType===1});if(O.test(b))return f.filter(b,d,!c);b=f.filter(b,d)}return f.grep(a,function(a,d){return f.inArray(a,b)>=0===c})}function S(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function K(){return!0}function J(){return!1}function n(a,b,c){var d=b+\"defer\",e=b+\"queue\",g=b+\"mark\",h=f._data(a,d);h&&(c===\"queue\"||!f._data(a,e))&&(c===\"mark\"||!f._data(a,g))&&setTimeout(function(){!f._data(a,e)&&!f._data(a,g)&&(f.removeData(a,d,!0),h.fire())},0)}function m(a){for(var b in a){if(b===\"data\"&&f.isEmptyObject(a[b]))continue;if(b!==\"toJSON\")return!1}return!0}function l(a,c,d){if(d===b&&a.nodeType===1){var e=\"data-\"+c.replace(k,\"-$1\").toLowerCase();d=a.getAttribute(e);if(typeof d==\"string\"){try{d=d===\"true\"?!0:d===\"false\"?!1:d===\"null\"?null:f.isNumeric(d)?+d:j.test(d)?f.parseJSON(d):d}catch(g){}f.data(a,c,d)}else d=b}return d}function h(a){var b=g[a]={},c,d;a=a.split(/\\s+/);for(c=0,d=a.length;c<d;c++)b[a[c]]=!0;return b}var c=a.document,d=a.navigator,e=a.location,f=function(){function J(){if(!e.isReady){try{c.documentElement.doScroll(\"left\")}catch(a){setTimeout(J,1);return}e.ready()}}var e=function(a,b){return new e.fn.init(a,b,h)},f=a.sh,g=a.$,h,i=/^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w\\-]*)$)/,j=/\\S/,k=/^\\s+/,l=/\\s+$/,m=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/,n=/^[\\],:{}\\s]*$/,o=/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,p=/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,q=/(?:^|:|,)(?:\\s*\\[)+/g,r=/(webkit)[ \\/]([\\w.]+)/,s=/(opera)(?:.*version)?[ \\/]([\\w.]+)/,t=/(msie) ([\\w.]+)/,u=/(mozilla)(?:.*? rv:([\\w.]+))?/,v=/-([a-z]|[0-9])/ig,w=/^-ms-/,x=function(a,b){return(b+\"\").toUpperCase()},y=d.userAgent,z,A,B,C=Object.prototype.toString,D=Object.prototype.hasOwnProperty,E=Array.prototype.push,F=Array.prototype.slice,G=String.prototype.trim,H=Array.prototype.indexOf,I={};e.fn=e.prototype={constructor:e,init:function(a,d,f){var g,h,j,k;if(!a)return this;if(a.nodeType){this.context=this[0]=a,this.length=1;return this}if(a===\"body\"&&!d&&c.body){this.context=c,this[0]=c.body,this.selector=a,this.length=1;return this}if(typeof a==\"string\"){a.charAt(0)!==\"<\"||a.charAt(a.length-1)!==\">\"||a.length<3?g=i.exec(a):g=[null,a,null];if(g&&(g[1]||!d)){if(g[1]){d=d instanceof e?d[0]:d,k=d?d.ownerDocument||d:c,j=m.exec(a),j?e.isPlainObject(d)?(a=[c.createElement(j[1])],e.fn.attr.call(a,d,!0)):a=[k.createElement(j[1])]:(j=e.buildFragment([g[1]],[k]),a=(j.cacheable?e.clone(j.fragment):j.fragment).childNodes);return e.merge(this,a)}h=c.getElementById(g[2]);if(h&&h.parentNode){if(h.id!==g[2])return f.find(a);this.length=1,this[0]=h}this.context=c,this.selector=a;return this}return!d||d.sh?(d||f).find(a):this.constructor(d).find(a)}if(e.isFunction(a))return f.ready(a);a.selector!==b&&(this.selector=a.selector,this.context=a.context);return e.makeArray(a,this)},selector:\"\",sh:\"1.7.2\",length:0,size:function(){return this.length},toArray:function(){return F.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=this.constructor();e.isArray(a)?E.apply(d,a):e.merge(d,a),d.prevObject=this,d.context=this.context,b===\"find\"?d.selector=this.selector+(this.selector?\" \":\"\")+c:b&&(d.selector=this.selector+\".\"+b+\"(\"+c+\")\");return d},each:function(a,b){return e.each(this,a,b)},ready:function(a){e.bindReady(),A.add(a);return this},eq:function(a){a=+a;return a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(F.apply(this,arguments),\"slice\",F.call(arguments).join(\",\"))},map:function(a){return this.pushStack(e.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:E,sort:[].sort,splice:[].splice},e.fn.init.prototype=e.fn,e.extend=e.fn.extend=function(){var a,c,d,f,g,h,i=arguments[0]||{},j=1,k=arguments.length,l=!1;typeof i==\"boolean\"&&(l=i,i=arguments[1]||{},j=2),typeof i!=\"object\"&&!e.isFunction(i)&&(i={}),k===j&&(i=this,--j);for(;j<k;j++)if((a=arguments[j])!=null)for(c in a){d=i[c],f=a[c];if(i===f)continue;l&&f&&(e.isPlainObject(f)||(g=e.isArray(f)))?(g?(g=!1,h=d&&e.isArray(d)?d:[]):h=d&&e.isPlainObject(d)?d:{},i[c]=e.extend(l,h,f)):f!==b&&(i[c]=f)}return i},e.extend({noConflict:function(b){a.$===e&&(a.$=g),b&&a.sh===e&&(a.sh=f);return e},isReady:!1,readyWait:1,holdReady:function(a){a?e.readyWait++:e.ready(!0)},ready:function(a){if(a===!0&&!--e.readyWait||a!==!0&&!e.isReady){if(!c.body)return setTimeout(e.ready,1);e.isReady=!0;if(a!==!0&&--e.readyWait>0)return;A.fireWith(c,[e]),e.fn.trigger&&e(c).trigger(\"ready\").off(\"ready\")}},bindReady:function(){if(!A){A=e.Callbacks(\"once memory\");if(c.readyState===\"complete\")return setTimeout(e.ready,1);if(c.addEventListener)c.addEventListener(\"DOMContentLoaded\",B,!1),a.addEventListener(\"load\",e.ready,!1);else if(c.attachEvent){c.attachEvent(\"onreadystatechange\",B),a.attachEvent(\"onload\",e.ready);var b=!1;try{b=a.frameElement==null}catch(d){}c.documentElement.doScroll&&b&&J()}}},isFunction:function(a){return e.type(a)===\"function\"},isArray:Array.isArray||function(a){return e.type(a)===\"array\"},isWindow:function(a){return a!=null&&a==a.window},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):I[C.call(a)]||\"object\"},isPlainObject:function(a){if(!a||e.type(a)!==\"object\"||a.nodeType||e.isWindow(a))return!1;try{if(a.constructor&&!D.call(a,\"constructor\")&&!D.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(c){return!1}var d;for(d in a);return d===b||D.call(a,d)},isEmptyObject:function(a){for(var b in a)return!1;return!0},error:function(a){throw new Error(a)},parseJSON:function(b){if(typeof b!=\"string\"||!b)return null;b=e.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(n.test(b.replace(o,\"@\").replace(p,\"]\").replace(q,\"\")))return(new Function(\"return \"+b))();e.error(\"Invalid JSON: \"+b)},parseXML:function(c){if(typeof c!=\"string\"||!c)return null;var d,f;try{a.DOMParser?(f=new DOMParser,d=f.parseFromString(c,\"text/xml\")):(d=new ActiveXObject(\"Microsoft.XMLDOM\"),d.async=\"false\",d.loadXML(c))}catch(g){d=b}(!d||!d.documentElement||d.getElementsByTagName(\"parsererror\").length)&&e.error(\"Invalid XML: \"+c);return d},noop:function(){},globalEval:function(b){b&&j.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(w,\"ms-\").replace(v,x)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var f,g=0,h=a.length,i=h===b||e.isFunction(a);if(d){if(i){for(f in a)if(c.apply(a[f],d)===!1)break}else for(;g<h;)if(c.apply(a[g++],d)===!1)break}else if(i){for(f in a)if(c.call(a[f],f,a[f])===!1)break}else for(;g<h;)if(c.call(a[g],g,a[g++])===!1)break;return a},trim:G?function(a){return a==null?\"\":G.call(a)}:function(a){return a==null?\"\":(a+\"\").replace(k,\"\").replace(l,\"\")},makeArray:function(a,b){var c=b||[];if(a!=null){var d=e.type(a);a.length==null||d===\"string\"||d===\"function\"||d===\"regexp\"||e.isWindow(a)?E.call(c,a):e.merge(c,a)}return c},inArray:function(a,b,c){var d;if(b){if(H)return H.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=a.length,e=0;if(typeof c.length==\"number\")for(var f=c.length;e<f;e++)a[d++]=c[e];else while(c[e]!==b)a[d++]=c[e++];a.length=d;return a},grep:function(a,b,c){var d=[],e;c=!!c;for(var f=0,g=a.length;f<g;f++)e=!!b(a[f],f),c!==e&&d.push(a[f]);return d},map:function(a,c,d){var f,g,h=[],i=0,j=a.length,k=a instanceof e||j!==b&&typeof j==\"number\"&&(j>0&&a[0]&&a[j-1]||j===0||e.isArray(a));if(k)for(;i<j;i++)f=c(a[i],i,d),f!=null&&(h[h.length]=f);else for(g in a)f=c(a[g],g,d),f!=null&&(h[h.length]=f);return h.concat.apply([],h)},guid:1,proxy:function(a,c){if(typeof c==\"string\"){var d=a[c];c=a,a=d}if(!e.isFunction(a))return b;var f=F.call(arguments,2),g=function(){return a.apply(c,f.concat(F.call(arguments)))};g.guid=a.guid=a.guid||g.guid||e.guid++;return g},access:function(a,c,d,f,g,h,i){var j,k=d==null,l=0,m=a.length;if(d&&typeof d==\"object\"){for(l in d)e.access(a,c,l,d[l],1,h,f);g=1}else if(f!==b){j=i===b&&e.isFunction(f),k&&(j?(j=c,c=function(a,b,c){return j.call(e(a),c)}):(c.call(a,f),c=null));if(c)for(;l<m;l++)c(a[l],d,j?f.call(a[l],l,c(a[l],d)):f,i);g=1}return g?a:k?c.call(a):m?c(a[0],d):h},now:function(){return(new Date).getTime()},uaMatch:function(a){a=a.toLowerCase();var b=r.exec(a)||s.exec(a)||t.exec(a)||a.indexOf(\"compatible\")<0&&u.exec(a)||[];return{browser:b[1]||\"\",version:b[2]||\"0\"}},sub:function(){function a(b,c){return new a.fn.init(b,c)}e.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function(d,f){f&&f instanceof e&&!(f instanceof a)&&(f=a(f));return e.fn.init.call(this,d,f,b)},a.fn.init.prototype=a.fn;var b=a(c);return a},browser:{}}),e.each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"),function(a,b){I[\"[object \"+b+\"]\"]=b.toLowerCase()}),z=e.uaMatch(y),z.browser&&(e.browser[z.browser]=!0,e.browser.version=z.version),e.browser.webkit&&(e.browser.safari=!0),j.test(\"\u00a0\")&&(k=/^[\\s\\xA0]+/,l=/[\\s\\xA0]+$/),h=e(c),c.addEventListener?B=function(){c.removeEventListener(\"DOMContentLoaded\",B,!1),e.ready()}:c.attachEvent&&(B=function(){c.readyState===\"complete\"&&(c.detachEvent(\"onreadystatechange\",B),e.ready())});return e}(),g={};f.Callbacks=function(a){a=a?g[a]||h(a):{};var c=[],d=[],e,i,j,k,l,m,n=function(b){var d,e,g,h,i;for(d=0,e=b.length;d<e;d++)g=b[d],h=f.type(g),h===\"array\"?n(g):h===\"function\"&&(!a.unique||!p.has(g))&&c.push(g)},o=function(b,f){f=f||[],e=!a.memory||[b,f],i=!0,j=!0,m=k||0,k=0,l=c.length;for(;c&&m<l;m++)if(c[m].apply(b,f)===!1&&a.stopOnFalse){e=!0;break}j=!1,c&&(a.once?e===!0?p.disable():c=[]:d&&d.length&&(e=d.shift(),p.fireWith(e[0],e[1])))},p={add:function(){if(c){var a=c.length;n(arguments),j?l=c.length:e&&e!==!0&&(k=a,o(e[0],e[1]))}return this},remove:function(){if(c){var b=arguments,d=0,e=b.length;for(;d<e;d++)for(var f=0;f<c.length;f++)if(b[d]===c[f]){j&&f<=l&&(l--,f<=m&&m--),c.splice(f--,1);if(a.unique)break}}return this},has:function(a){if(c){var b=0,d=c.length;for(;b<d;b++)if(a===c[b])return!0}return!1},empty:function(){c=[];return this},disable:function(){c=d=e=b;return this},disabled:function(){return!c},lock:function(){d=b,(!e||e===!0)&&p.disable();return this},locked:function(){return!d},fireWith:function(b,c){d&&(j?a.once||d.push([b,c]):(!a.once||!e)&&o(b,c));return this},fire:function(){p.fireWith(this,arguments);return this},fired:function(){return!!i}};return p};var i=[].slice;f.extend({Deferred:function(a){var b=f.Callbacks(\"once memory\"),c=f.Callbacks(\"once memory\"),d=f.Callbacks(\"memory\"),e=\"pending\",g={resolve:b,reject:c,notify:d},h={done:b.add,fail:c.add,progress:d.add,state:function(){return e},isResolved:b.fired,isRejected:c.fired,then:function(a,b,c){i.done(a).fail(b).progress(c);return this},always:function(){i.done.apply(i,arguments).fail.apply(i,arguments);return this},pipe:function(a,b,c){return f.Deferred(function(d){f.each({done:[a,\"resolve\"],fail:[b,\"reject\"],progress:[c,\"notify\"]},function(a,b){var c=b[0],e=b[1],g;f.isFunction(c)?i[a](function(){g=c.apply(this,arguments),g&&f.isFunction(g.promise)?g.promise().then(d.resolve,d.reject,d.notify):d[e+\"With\"](this===i?d:this,[g])}):i[a](d[e])})}).promise()},promise:function(a){if(a==null)a=h;else for(var b in h)a[b]=h[b];return a}},i=h.promise({}),j;for(j in g)i[j]=g[j].fire,i[j+\"With\"]=g[j].fireWith;i.done(function(){e=\"resolved\"},c.disable,d.lock).fail(function(){e=\"rejected\"},b.disable,d.lock),a&&a.call(i,i);return i},when:function(a){function m(a){return function(b){e[a]=arguments.length>1?i.call(arguments,0):b,j.notifyWith(k,e)}}function l(a){return function(c){b[a]=arguments.length>1?i.call(arguments,0):c,--g||j.resolveWith(j,b)}}var b=i.call(arguments,0),c=0,d=b.length,e=Array(d),g=d,h=d,j=d<=1&&a&&f.isFunction(a.promise)?a:f.Deferred(),k=j.promise();if(d>1){for(;c<d;c++)b[c]&&b[c].promise&&f.isFunction(b[c].promise)?b[c].promise().then(l(c),j.reject,m(c)):--g;g||j.resolveWith(j,b)}else j!==a&&j.resolveWith(j,d?[a]:[]);return k}}),f.support=function(){var b,d,e,g,h,i,j,k,l,m,n,o,p=c.createElement(\"div\"),q=c.documentElement;p.setAttribute(\"className\",\"t\"),p.innerHTML=\"   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>\",d=p.getElementsByTagName(\"*\"),e=p.getElementsByTagName(\"a\")[0];if(!d||!d.length||!e)return{};g=c.createElement(\"select\"),h=g.appendChild(c.createElement(\"option\")),i=p.getElementsByTagName(\"input\")[0],b={leadingWhitespace:p.firstChild.nodeType===3,tbody:!p.getElementsByTagName(\"tbody\").length,htmlSerialize:!!p.getElementsByTagName(\"link\").length,style:/top/.test(e.getAttribute(\"style\")),hrefNormalized:e.getAttribute(\"href\")===\"/a\",opacity:/^0.55/.test(e.style.opacity),cssFloat:!!e.style.cssFloat,checkOn:i.value===\"on\",optSelected:h.selected,getSetAttribute:p.className!==\"t\",enctype:!!c.createElement(\"form\").enctype,html5Clone:c.createElement(\"nav\").cloneNode(!0).outerHTML!==\"<:nav></:nav>\",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,pixelMargin:!0},f.boxModel=b.boxModel=c.compatMode===\"CSS1Compat\",i.checked=!0,b.noCloneChecked=i.cloneNode(!0).checked,g.disabled=!0,b.optDisabled=!h.disabled;try{delete p.test}catch(r){b.deleteExpando=!1}!p.addEventListener&&p.attachEvent&&p.fireEvent&&(p.attachEvent(\"onclick\",function(){b.noCloneEvent=!1}),p.cloneNode(!0).fireEvent(\"onclick\")),i=c.createElement(\"input\"),i.value=\"t\",i.setAttribute(\"type\",\"radio\"),b.radioValue=i.value===\"t\",i.setAttribute(\"checked\",\"checked\"),i.setAttribute(\"name\",\"t\"),p.appendChild(i),j=c.createDocumentFragment(),j.appendChild(p.lastChild),b.checkClone=j.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=i.checked,j.removeChild(i),j.appendChild(p);if(p.attachEvent)for(n in{submit:1,change:1,focusin:1})m=\"on\"+n,o=m in p,o||(p.setAttribute(m,\"return;\"),o=typeof p[m]==\"function\"),b[n+\"Bubbles\"]=o;j.removeChild(p),j=g=h=p=i=null,f(function(){var d,e,g,h,i,j,l,m,n,q,r,s,t,u=c.getElementsByTagName(\"body\")[0];!u||(m=1,t=\"padding:0;margin:0;border:\",r=\"position:absolute;top:0;left:0;width:1px;height:1px;\",s=t+\"0;visibility:hidden;\",n=\"style='\"+r+t+\"5px solid #000;\",q=\"<div \"+n+\"display:block;'><div style='\"+t+\"0;display:block;overflow:hidden;'></div></div>\"+\"<table \"+n+\"' cellpadding='0' cellspacing='0'>\"+\"<tr><td></td></tr></table>\",d=c.createElement(\"div\"),d.style.cssText=s+\"width:0;height:0;position:static;top:0;margin-top:\"+m+\"px\",u.insertBefore(d,u.firstChild),p=c.createElement(\"div\"),d.appendChild(p),p.innerHTML=\"<table><tr><td style='\"+t+\"0;display:none'></td><td>t</td></tr></table>\",k=p.getElementsByTagName(\"td\"),o=k[0].offsetHeight===0,k[0].style.display=\"\",k[1].style.display=\"none\",b.reliableHiddenOffsets=o&&k[0].offsetHeight===0,a.getComputedStyle&&(p.innerHTML=\"\",l=c.createElement(\"div\"),l.style.width=\"0\",l.style.marginRight=\"0\",p.style.width=\"2px\",p.appendChild(l),b.reliableMarginRight=(parseInt((a.getComputedStyle(l,null)||{marginRight:0}).marginRight,10)||0)===0),typeof p.style.zoom!=\"undefined\"&&(p.innerHTML=\"\",p.style.width=p.style.padding=\"1px\",p.style.border=0,p.style.overflow=\"hidden\",p.style.display=\"inline\",p.style.zoom=1,b.inlineBlockNeedsLayout=p.offsetWidth===3,p.style.display=\"block\",p.style.overflow=\"visible\",p.innerHTML=\"<div style='width:5px;'></div>\",b.shrinkWrapBlocks=p.offsetWidth!==3),p.style.cssText=r+s,p.innerHTML=q,e=p.firstChild,g=e.firstChild,i=e.nextSibling.firstChild.firstChild,j={doesNotAddBorder:g.offsetTop!==5,doesAddBorderForTableAndCells:i.offsetTop===5},g.style.position=\"fixed\",g.style.top=\"20px\",j.fixedPosition=g.offsetTop===20||g.offsetTop===15,g.style.position=g.style.top=\"\",e.style.overflow=\"hidden\",e.style.position=\"relative\",j.subtractsBorderForOverflowNotVisible=g.offsetTop===-5,j.doesNotIncludeMarginInBodyOffset=u.offsetTop!==m,a.getComputedStyle&&(p.style.marginTop=\"1%\",b.pixelMargin=(a.getComputedStyle(p,null)||{marginTop:0}).marginTop!==\"1%\"),typeof d.style.zoom!=\"undefined\"&&(d.style.zoom=1),u.removeChild(d),l=p=d=null,f.extend(b,j))});return b}();var j=/^(?:\\{.*\\}|\\[.*\\])$/,k=/([A-Z])/g;f.extend({cache:{},uuid:0,expando:\"sh\"+(f.fn.sh+Math.random()).replace(/\\D/g,\"\"),noData:{embed:!0,object:\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\",applet:!0},hasData:function(a){a=a.nodeType?f.cache[a[f.expando]]:a[f.expando];return!!a&&!m(a)},data:function(a,c,d,e){if(!!f.acceptData(a)){var g,h,i,j=f.expando,k=typeof c==\"string\",l=a.nodeType,m=l?f.cache:a,n=l?a[j]:a[j]&&j,o=c===\"events\";if((!n||!m[n]||!o&&!e&&!m[n].data)&&k&&d===b)return;n||(l?a[j]=n=++f.uuid:n=j),m[n]||(m[n]={},l||(m[n].toJSON=f.noop));if(typeof c==\"object\"||typeof c==\"function\")e?m[n]=f.extend(m[n],c):m[n].data=f.extend(m[n].data,c);g=h=m[n],e||(h.data||(h.data={}),h=h.data),d!==b&&(h[f.camelCase(c)]=d);if(o&&!h[c])return g.events;k?(i=h[c],i==null&&(i=h[f.camelCase(c)])):i=h;return i}},removeData:function(a,b,c){if(!!f.acceptData(a)){var d,e,g,h=f.expando,i=a.nodeType,j=i?f.cache:a,k=i?a[h]:h;if(!j[k])return;if(b){d=c?j[k]:j[k].data;if(d){f.isArray(b)||(b in d?b=[b]:(b=f.camelCase(b),b in d?b=[b]:b=b.split(\" \")));for(e=0,g=b.length;e<g;e++)delete d[b[e]];if(!(c?m:f.isEmptyObject)(d))return}}if(!c){delete j[k].data;if(!m(j[k]))return}f.support.deleteExpando||!j.setInterval?delete j[k]:j[k]=null,i&&(f.support.deleteExpando?delete a[h]:a.removeAttribute?a.removeAttribute(h):a[h]=null)}},_data:function(a,b,c){return f.data(a,b,c,!0)},acceptData:function(a){if(a.nodeName){var b=f.noData[a.nodeName.toLowerCase()];if(b)return b!==!0&&a.getAttribute(\"classid\")===b}return!0}}),f.fn.extend({data:function(a,c){var d,e,g,h,i,j=this[0],k=0,m=null;if(a===b){if(this.length){m=f.data(j);if(j.nodeType===1&&!f._data(j,\"parsedAttrs\")){g=j.attributes;for(i=g.length;k<i;k++)h=g[k].name,h.indexOf(\"data-\")===0&&(h=f.camelCase(h.substring(5)),l(j,h,m[h]));f._data(j,\"parsedAttrs\",!0)}}return m}if(typeof a==\"object\")return this.each(function(){f.data(this,a)});d=a.split(\".\",2),d[1]=d[1]?\".\"+d[1]:\"\",e=d[1]+\"!\";return f.access(this,function(c){if(c===b){m=this.triggerHandler(\"getData\"+e,[d[0]]),m===b&&j&&(m=f.data(j,a),m=l(j,a,m));return m===b&&d[1]?this.data(d[0]):m}d[1]=c,this.each(function(){var b=f(this);b.triggerHandler(\"setData\"+e,d),f.data(this,a,c),b.triggerHandler(\"changeData\"+e,d)})},null,c,arguments.length>1,null,!1)},removeData:function(a){return this.each(function(){f.removeData(this,a)})}}),f.extend({_mark:function(a,b){a&&(b=(b||\"fx\")+\"mark\",f._data(a,b,(f._data(a,b)||0)+1))},_unmark:function(a,b,c){a!==!0&&(c=b,b=a,a=!1);if(b){c=c||\"fx\";var d=c+\"mark\",e=a?0:(f._data(b,d)||1)-1;e?f._data(b,d,e):(f.removeData(b,d,!0),n(b,c,\"mark\"))}},queue:function(a,b,c){var d;if(a){b=(b||\"fx\")+\"queue\",d=f._data(a,b),c&&(!d||f.isArray(c)?d=f._data(a,b,f.makeArray(c)):d.push(c));return d||[]}},dequeue:function(a,b){b=b||\"fx\";var c=f.queue(a,b),d=c.shift(),e={};d===\"inprogress\"&&(d=c.shift()),d&&(b===\"fx\"&&c.unshift(\"inprogress\"),f._data(a,b+\".run\",e),d.call(a,function(){f.dequeue(a,b)},e)),c.length||(f.removeData(a,b+\"queue \"+b+\".run\",!0),n(a,b,\"queue\"))}}),f.fn.extend({queue:function(a,c){var d=2;typeof a!=\"string\"&&(c=a,a=\"fx\",d--);if(arguments.length<d)return f.queue(this[0],a);return c===b?this:this.each(function(){var b=f.queue(this,a,c);a===\"fx\"&&b[0]!==\"inprogress\"&&f.dequeue(this,a)})},dequeue:function(a){return this.each(function(){f.dequeue(this,a)})},delay:function(a,b){a=f.fx?f.fx.speeds[a]||a:a,b=b||\"fx\";return this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||\"fx\",[])},promise:function(a,c){function m(){--h||d.resolveWith(e,[e])}typeof a!=\"string\"&&(c=a,a=b),a=a||\"fx\";var d=f.Deferred(),e=this,g=e.length,h=1,i=a+\"defer\",j=a+\"queue\",k=a+\"mark\",l;while(g--)if(l=f.data(e[g],i,b,!0)||(f.data(e[g],j,b,!0)||f.data(e[g],k,b,!0))&&f.data(e[g],i,f.Callbacks(\"once memory\"),!0))h++,l.add(m);m();return d.promise(c)}});var o=/[\\n\\t\\r]/g,p=/\\s+/,q=/\\r/g,r=/^(?:button|input)$/i,s=/^(?:button|input|object|select|textarea)$/i,t=/^a(?:rea)?$/i,u=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,v=f.support.getSetAttribute,w,x,y;f.fn.extend({attr:function(a,b){return f.access(this,f.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){f.removeAttr(this,a)})},prop:function(a,b){return f.access(this,f.prop,a,b,arguments.length>1)},removeProp:function(a){a=f.propFix[a]||a;return this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,g,h,i;if(f.isFunction(a))return this.each(function(b){f(this).addClass(a.call(this,b,this.className))});if(a&&typeof a==\"string\"){b=a.split(p);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{g=\" \"+e.className+\" \";for(h=0,i=b.length;h<i;h++)~g.indexOf(\" \"+b[h]+\" \")||(g+=b[h]+\" \");e.className=f.trim(g)}}}return this},removeClass:function(a){var c,d,e,g,h,i,j;if(f.isFunction(a))return this.each(function(b){f(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a==\"string\"||a===b){c=(a||\"\").split(p);for(d=0,e=this.length;d<e;d++){g=this[d];if(g.nodeType===1&&g.className)if(a){h=(\" \"+g.className+\" \").replace(o,\" \");for(i=0,j=c.length;i<j;i++)h=h.replace(\" \"+c[i]+\" \",\" \");g.className=f.trim(h)}else g.className=\"\"}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b==\"boolean\";if(f.isFunction(a))return this.each(function(c){f(this).toggleClass(a.call(this,c,this.className,b),b)});return this.each(function(){if(c===\"string\"){var e,g=0,h=f(this),i=b,j=a.split(p);while(e=j[g++])i=d?i:!h.hasClass(e),h[i?\"addClass\":\"removeClass\"](e)}else if(c===\"undefined\"||c===\"boolean\")this.className&&f._data(this,\"__className__\",this.className),this.className=this.className||a===!1?\"\":f._data(this,\"__className__\")||\"\"})},hasClass:function(a){var b=\" \"+a+\" \",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(\" \"+this[c].className+\" \").replace(o,\" \").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,g=this[0];{if(!!arguments.length){e=f.isFunction(a);return this.each(function(d){var g=f(this),h;if(this.nodeType===1){e?h=a.call(this,d,g.val()):h=a,h==null?h=\"\":typeof h==\"number\"?h+=\"\":f.isArray(h)&&(h=f.map(h,function(a){return a==null?\"\":a+\"\"})),c=f.valHooks[this.type]||f.valHooks[this.nodeName.toLowerCase()];if(!c||!(\"set\"in c)||c.set(this,h,\"value\")===b)this.value=h}})}if(g){c=f.valHooks[g.type]||f.valHooks[g.nodeName.toLowerCase()];if(c&&\"get\"in c&&(d=c.get(g,\"value\"))!==b)return d;d=g.value;return typeof d==\"string\"?d.replace(q,\"\"):d==null?\"\":d}}}}),f.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,g=a.selectedIndex,h=[],i=a.options,j=a.type===\"select-one\";if(g<0)return null;c=j?g:0,d=j?g+1:i.length;for(;c<d;c++){e=i[c];if(e.selected&&(f.support.optDisabled?!e.disabled:e.getAttribute(\"disabled\")===null)&&(!e.parentNode.disabled||!f.nodeName(e.parentNode,\"optgroup\"))){b=f(e).val();if(j)return b;h.push(b)}}if(j&&!h.length&&i.length)return f(i[g]).val();return h},set:function(a,b){var c=f.makeArray(b);f(a).find(\"option\").each(function(){this.selected=f.inArray(f(this).val(),c)>=0}),c.length||(a.selectedIndex=-1);return c}}},attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(a,c,d,e){var g,h,i,j=a.nodeType;if(!!a&&j!==3&&j!==8&&j!==2){if(e&&c in f.attrFn)return f(a)[c](d);if(typeof a.getAttribute==\"undefined\")return f.prop(a,c,d);i=j!==1||!f.isXMLDoc(a),i&&(c=c.toLowerCase(),h=f.attrHooks[c]||(u.test(c)?x:w));if(d!==b){if(d===null){f.removeAttr(a,c);return}if(h&&\"set\"in h&&i&&(g=h.set(a,d,c))!==b)return g;a.setAttribute(c,\"\"+d);return d}if(h&&\"get\"in h&&i&&(g=h.get(a,c))!==null)return g;g=a.getAttribute(c);return g===null?b:g}},removeAttr:function(a,b){var c,d,e,g,h,i=0;if(b&&a.nodeType===1){d=b.toLowerCase().split(p),g=d.length;for(;i<g;i++)e=d[i],e&&(c=f.propFix[e]||e,h=u.test(e),h||f.attr(a,e,\"\"),a.removeAttribute(v?e:c),h&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(r.test(a.nodeName)&&a.parentNode)f.error(\"type property can't be changed\");else if(!f.support.radioValue&&b===\"radio\"&&f.nodeName(a,\"input\")){var c=a.value;a.setAttribute(\"type\",b),c&&(a.value=c);return b}}},value:{get:function(a,b){if(w&&f.nodeName(a,\"button\"))return w.get(a,b);return b in a?a.value:null},set:function(a,b,c){if(w&&f.nodeName(a,\"button\"))return w.set(a,b,c);a.value=b}}},propFix:{tabindex:\"tabIndex\",readonly:\"readOnly\",\"for\":\"htmlFor\",\"class\":\"className\",maxlength:\"maxLength\",cellspacing:\"cellSpacing\",cellpadding:\"cellPadding\",rowspan:\"rowSpan\",colspan:\"colSpan\",usemap:\"useMap\",frameborder:\"frameBorder\",contenteditable:\"contentEditable\"},prop:function(a,c,d){var e,g,h,i=a.nodeType;if(!!a&&i!==3&&i!==8&&i!==2){h=i!==1||!f.isXMLDoc(a),h&&(c=f.propFix[c]||c,g=f.propHooks[c]);return d!==b?g&&\"set\"in g&&(e=g.set(a,d,c))!==b?e:a[c]=d:g&&\"get\"in g&&(e=g.get(a,c))!==null?e:a[c]}},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode(\"tabindex\");return c&&c.specified?parseInt(c.value,10):s.test(a.nodeName)||t.test(a.nodeName)&&a.href?0:b}}}}),f.attrHooks.tabindex=f.propHooks.tabIndex,x={get:function(a,c){var d,e=f.prop(a,c);return e===!0||typeof e!=\"boolean\"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;b===!1?f.removeAttr(a,c):(d=f.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase()));return c}},v||(y={name:!0,id:!0,coords:!0},w=f.valHooks.button={get:function(a,c){var d;d=a.getAttributeNode(c);return d&&(y[c]?d.nodeValue!==\"\":d.specified)?d.nodeValue:b},set:function(a,b,d){var e=a.getAttributeNode(d);e||(e=c.createAttribute(d),a.setAttributeNode(e));return e.nodeValue=b+\"\"}},f.attrHooks.tabindex.set=w.set,f.each([\"width\",\"height\"],function(a,b){f.attrHooks[b]=f.extend(f.attrHooks[b],{set:function(a,c){if(c===\"\"){a.setAttribute(b,\"auto\");return c}}})}),f.attrHooks.contenteditable={get:w.get,set:function(a,b,c){b===\"\"&&(b=\"false\"),w.set(a,b,c)}}),f.support.hrefNormalized||f.each([\"href\",\"src\",\"width\",\"height\"],function(a,c){f.attrHooks[c]=f.extend(f.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),f.support.style||(f.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=\"\"+b}}),f.support.optSelected||(f.propHooks.selected=f.extend(f.propHooks.selected,{get:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex);return null}})),f.support.enctype||(f.propFix.enctype=\"encoding\"),f.support.checkOn||f.each([\"radio\",\"checkbox\"],function(){f.valHooks[this]={get:function(a){return a.getAttribute(\"value\")===null?\"on\":a.value}}}),f.each([\"radio\",\"checkbox\"],function(){f.valHooks[this]=f.extend(f.valHooks[this],{set:function(a,b){if(f.isArray(b))return a.checked=f.inArray(f(a).val(),b)>=0}})});var z=/^(?:textarea|input|select)$/i,A=/^([^\\.]*)?(?:\\.(.+))?$/,B=/(?:^|\\s)hover(\\.\\S+)?\\b/,C=/^key/,D=/^(?:mouse|contextmenu)|click/,E=/^(?:focusinfocus|focusoutblur)$/,F=/^(\\w*)(?:#([\\w\\-]+))?(?:\\.([\\w\\-]+))?$/,G=function(\r\na){var b=F.exec(a);b&&(b[1]=(b[1]||\"\").toLowerCase(),b[3]=b[3]&&new RegExp(\"(?:^|\\\\s)\"+b[3]+\"(?:\\\\s|$)\"));return b},H=function(a,b){var c=a.attributes||{};return(!b[1]||a.nodeName.toLowerCase()===b[1])&&(!b[2]||(c.id||{}).value===b[2])&&(!b[3]||b[3].test((c[\"class\"]||{}).value))},I=function(a){return f.event.special.hover?a:a.replace(B,\"mouseenter$1 mouseleave$1\")};f.event={add:function(a,c,d,e,g){var h,i,j,k,l,m,n,o,p,q,r,s;if(!(a.nodeType===3||a.nodeType===8||!c||!d||!(h=f._data(a)))){d.handler&&(p=d,d=p.handler,g=p.selector),d.guid||(d.guid=f.guid++),j=h.events,j||(h.events=j={}),i=h.handle,i||(h.handle=i=function(a){return typeof f!=\"undefined\"&&(!a||f.event.triggered!==a.type)?f.event.dispatch.apply(i.elem,arguments):b},i.elem=a),c=f.trim(I(c)).split(\" \");for(k=0;k<c.length;k++){l=A.exec(c[k])||[],m=l[1],n=(l[2]||\"\").split(\".\").sort(),s=f.event.special[m]||{},m=(g?s.delegateType:s.bindType)||m,s=f.event.special[m]||{},o=f.extend({type:m,origType:l[1],data:e,handler:d,guid:d.guid,selector:g,quick:g&&G(g),namespace:n.join(\".\")},p),r=j[m];if(!r){r=j[m]=[],r.delegateCount=0;if(!s.setup||s.setup.call(a,e,n,i)===!1)a.addEventListener?a.addEventListener(m,i,!1):a.attachEvent&&a.attachEvent(\"on\"+m,i)}s.add&&(s.add.call(a,o),o.handler.guid||(o.handler.guid=d.guid)),g?r.splice(r.delegateCount++,0,o):r.push(o),f.event.global[m]=!0}a=null}},global:{},remove:function(a,b,c,d,e){var g=f.hasData(a)&&f._data(a),h,i,j,k,l,m,n,o,p,q,r,s;if(!!g&&!!(o=g.events)){b=f.trim(I(b||\"\")).split(\" \");for(h=0;h<b.length;h++){i=A.exec(b[h])||[],j=k=i[1],l=i[2];if(!j){for(j in o)f.event.remove(a,j+b[h],c,d,!0);continue}p=f.event.special[j]||{},j=(d?p.delegateType:p.bindType)||j,r=o[j]||[],m=r.length,l=l?new RegExp(\"(^|\\\\.)\"+l.split(\".\").sort().join(\"\\\\.(?:.*\\\\.)?\")+\"(\\\\.|$)\"):null;for(n=0;n<r.length;n++)s=r[n],(e||k===s.origType)&&(!c||c.guid===s.guid)&&(!l||l.test(s.namespace))&&(!d||d===s.selector||d===\"**\"&&s.selector)&&(r.splice(n--,1),s.selector&&r.delegateCount--,p.remove&&p.remove.call(a,s));r.length===0&&m!==r.length&&((!p.teardown||p.teardown.call(a,l)===!1)&&f.removeEvent(a,j,g.handle),delete o[j])}f.isEmptyObject(o)&&(q=g.handle,q&&(q.elem=null),f.removeData(a,[\"events\",\"handle\"],!0))}},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,e,g){if(!e||e.nodeType!==3&&e.nodeType!==8){var h=c.type||c,i=[],j,k,l,m,n,o,p,q,r,s;if(E.test(h+f.event.triggered))return;h.indexOf(\"!\")>=0&&(h=h.slice(0,-1),k=!0),h.indexOf(\".\")>=0&&(i=h.split(\".\"),h=i.shift(),i.sort());if((!e||f.event.customEvent[h])&&!f.event.global[h])return;c=typeof c==\"object\"?c[f.expando]?c:new f.Event(h,c):new f.Event(h),c.type=h,c.isTrigger=!0,c.exclusive=k,c.namespace=i.join(\".\"),c.namespace_re=c.namespace?new RegExp(\"(^|\\\\.)\"+i.join(\"\\\\.(?:.*\\\\.)?\")+\"(\\\\.|$)\"):null,o=h.indexOf(\":\")<0?\"on\"+h:\"\";if(!e){j=f.cache;for(l in j)j[l].events&&j[l].events[h]&&f.event.trigger(c,d,j[l].handle.elem,!0);return}c.result=b,c.target||(c.target=e),d=d!=null?f.makeArray(d):[],d.unshift(c),p=f.event.special[h]||{};if(p.trigger&&p.trigger.apply(e,d)===!1)return;r=[[e,p.bindType||h]];if(!g&&!p.noBubble&&!f.isWindow(e)){s=p.delegateType||h,m=E.test(s+h)?e:e.parentNode,n=null;for(;m;m=m.parentNode)r.push([m,s]),n=m;n&&n===e.ownerDocument&&r.push([n.defaultView||n.parentWindow||a,s])}for(l=0;l<r.length&&!c.isPropagationStopped();l++)m=r[l][0],c.type=r[l][1],q=(f._data(m,\"events\")||{})[c.type]&&f._data(m,\"handle\"),q&&q.apply(m,d),q=o&&m[o],q&&f.acceptData(m)&&q.apply(m,d)===!1&&c.preventDefault();c.type=h,!g&&!c.isDefaultPrevented()&&(!p._default||p._default.apply(e.ownerDocument,d)===!1)&&(h!==\"click\"||!f.nodeName(e,\"a\"))&&f.acceptData(e)&&o&&e[h]&&(h!==\"focus\"&&h!==\"blur\"||c.target.offsetWidth!==0)&&!f.isWindow(e)&&(n=e[o],n&&(e[o]=null),f.event.triggered=h,e[h](),f.event.triggered=b,n&&(e[o]=n));return c.result}},dispatch:function(c){c=f.event.fix(c||a.event);var d=(f._data(this,\"events\")||{})[c.type]||[],e=d.delegateCount,g=[].slice.call(arguments,0),h=!c.exclusive&&!c.namespace,i=f.event.special[c.type]||{},j=[],k,l,m,n,o,p,q,r,s,t,u;g[0]=c,c.delegateTarget=this;if(!i.preDispatch||i.preDispatch.call(this,c)!==!1){if(e&&(!c.button||c.type!==\"click\")){n=f(this),n.context=this.ownerDocument||this;for(m=c.target;m!=this;m=m.parentNode||this)if(m.disabled!==!0){p={},r=[],n[0]=m;for(k=0;k<e;k++)s=d[k],t=s.selector,p[t]===b&&(p[t]=s.quick?H(m,s.quick):n.is(t)),p[t]&&r.push(s);r.length&&j.push({elem:m,matches:r})}}d.length>e&&j.push({elem:this,matches:d.slice(e)});for(k=0;k<j.length&&!c.isPropagationStopped();k++){q=j[k],c.currentTarget=q.elem;for(l=0;l<q.matches.length&&!c.isImmediatePropagationStopped();l++){s=q.matches[l];if(h||!c.namespace&&!s.namespace||c.namespace_re&&c.namespace_re.test(s.namespace))c.data=s.data,c.handleObj=s,o=((f.event.special[s.origType]||{}).handle||s.handler).apply(q.elem,g),o!==b&&(c.result=o,o===!1&&(c.preventDefault(),c.stopPropagation()))}}i.postDispatch&&i.postDispatch.call(this,c);return c.result}},props:\"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),fixHooks:{},keyHooks:{props:\"char charCode key keyCode\".split(\" \"),filter:function(a,b){a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode);return a}},mouseHooks:{props:\"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),filter:function(a,d){var e,f,g,h=d.button,i=d.fromElement;a.pageX==null&&d.clientX!=null&&(e=a.target.ownerDocument||c,f=e.documentElement,g=e.body,a.pageX=d.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=d.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?d.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0);return a}},fix:function(a){if(a[f.expando])return a;var d,e,g=a,h=f.event.fixHooks[a.type]||{},i=h.props?this.props.concat(h.props):this.props;a=f.Event(g);for(d=i.length;d;)e=i[--d],a[e]=g[e];a.target||(a.target=g.srcElement||c),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey===b&&(a.metaKey=a.ctrlKey);return h.filter?h.filter(a,g):a},special:{ready:{setup:f.bindReady},load:{noBubble:!0},focus:{delegateType:\"focusin\"},blur:{delegateType:\"focusout\"},beforeunload:{setup:function(a,b,c){f.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=f.extend(new f.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?f.event.trigger(e,null,b):f.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},f.event.handle=f.event.dispatch,f.removeEvent=c.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){a.detachEvent&&a.detachEvent(\"on\"+b,c)},f.Event=function(a,b){if(!(this instanceof f.Event))return new f.Event(a,b);a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?K:J):this.type=a,b&&f.extend(this,b),this.timeStamp=a&&a.timeStamp||f.now(),this[f.expando]=!0},f.Event.prototype={preventDefault:function(){this.isDefaultPrevented=K;var a=this.originalEvent;!a||(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=K;var a=this.originalEvent;!a||(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=K,this.stopPropagation()},isDefaultPrevented:J,isPropagationStopped:J,isImmediatePropagationStopped:J},f.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\"},function(a,b){f.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c=this,d=a.relatedTarget,e=a.handleObj,g=e.selector,h;if(!d||d!==c&&!f.contains(c,d))a.type=e.origType,h=e.handler.apply(this,arguments),a.type=b;return h}}}),f.support.submitBubbles||(f.event.special.submit={setup:function(){if(f.nodeName(this,\"form\"))return!1;f.event.add(this,\"click._submit keypress._submit\",function(a){var c=a.target,d=f.nodeName(c,\"input\")||f.nodeName(c,\"button\")?c.form:b;d&&!d._submit_attached&&(f.event.add(d,\"submit._submit\",function(a){a._submit_bubble=!0}),d._submit_attached=!0)})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&f.event.simulate(\"submit\",this.parentNode,a,!0))},teardown:function(){if(f.nodeName(this,\"form\"))return!1;f.event.remove(this,\"._submit\")}}),f.support.changeBubbles||(f.event.special.change={setup:function(){if(z.test(this.nodeName)){if(this.type===\"checkbox\"||this.type===\"radio\")f.event.add(this,\"propertychange._change\",function(a){a.originalEvent.propertyName===\"checked\"&&(this._just_changed=!0)}),f.event.add(this,\"click._change\",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1,f.event.simulate(\"change\",this,a,!0))});return!1}f.event.add(this,\"beforeactivate._change\",function(a){var b=a.target;z.test(b.nodeName)&&!b._change_attached&&(f.event.add(b,\"change._change\",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&f.event.simulate(\"change\",this.parentNode,a,!0)}),b._change_attached=!0)})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!==\"radio\"&&b.type!==\"checkbox\")return a.handleObj.handler.apply(this,arguments)},teardown:function(){f.event.remove(this,\"._change\");return z.test(this.nodeName)}}),f.support.focusinBubbles||f.each({focus:\"focusin\",blur:\"focusout\"},function(a,b){var d=0,e=function(a){f.event.simulate(b,a.target,f.event.fix(a),!0)};f.event.special[b]={setup:function(){d++===0&&c.addEventListener(a,e,!0)},teardown:function(){--d===0&&c.removeEventListener(a,e,!0)}}}),f.fn.extend({on:function(a,c,d,e,g){var h,i;if(typeof a==\"object\"){typeof c!=\"string\"&&(d=d||c,c=b);for(i in a)this.on(i,c,d,a[i],g);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c==\"string\"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=J;else if(!e)return this;g===1&&(h=e,e=function(a){f().off(a);return h.apply(this,arguments)},e.guid=h.guid||(h.guid=f.guid++));return this.each(function(){f.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,c,d){if(a&&a.preventDefault&&a.handleObj){var e=a.handleObj;f(a.delegateTarget).off(e.namespace?e.origType+\".\"+e.namespace:e.origType,e.selector,e.handler);return this}if(typeof a==\"object\"){for(var g in a)this.off(g,c,a[g]);return this}if(c===!1||typeof c==\"function\")d=c,c=b;d===!1&&(d=J);return this.each(function(){f.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){f(this.context).on(a,this.selector,b,c);return this},die:function(a,b){f(this.context).off(a,this.selector||\"**\",b);return this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,\"**\"):this.off(b,a,c)},trigger:function(a,b){return this.each(function(){f.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return f.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||f.guid++,d=0,e=function(c){var e=(f._data(this,\"lastToggle\"+a.guid)||0)%d;f._data(this,\"lastToggle\"+a.guid,e+1),c.preventDefault();return b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),f.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"),function(a,b){f.fn[b]=function(a,c){c==null&&(c=a,a=null);return arguments.length>0?this.on(b,null,a,c):this.trigger(b)},f.attrFn&&(f.attrFn[b]=!0),C.test(b)&&(f.event.fixHooks[b]=f.event.keyHooks),D.test(b)&&(f.event.fixHooks[b]=f.event.mouseHooks)}),function(){function x(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}if(j.nodeType===1){g||(j[d]=c,j.sizset=h);if(typeof b!=\"string\"){if(j===b){k=!0;break}}else if(m.filter(b,[j]).length>0){k=j;break}}j=j[a]}e[h]=k}}}function w(a,b,c,e,f,g){for(var h=0,i=e.length;h<i;h++){var j=e[h];if(j){var k=!1;j=j[a];while(j){if(j[d]===c){k=e[j.sizset];break}j.nodeType===1&&!g&&(j[d]=c,j.sizset=h);if(j.nodeName.toLowerCase()===b){k=j;break}j=j[a]}e[h]=k}}}var a=/((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|['\"][^'\"]*['\"]|[^\\[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,d=\"sizcache\"+(Math.random()+\"\").replace(\".\",\"\"),e=0,g=Object.prototype.toString,h=!1,i=!0,j=/\\\\/g,k=/\\r\\n/g,l=/\\W/;[0,0].sort(function(){i=!1;return 0});var m=function(b,d,e,f){e=e||[],d=d||c;var h=d;if(d.nodeType!==1&&d.nodeType!==9)return[];if(!b||typeof b!=\"string\")return e;var i,j,k,l,n,q,r,t,u=!0,v=m.isXML(d),w=[],x=b;do{a.exec(\"\"),i=a.exec(x);if(i){x=i[3],w.push(i[1]);if(i[2]){l=i[3];break}}}while(i);if(w.length>1&&p.exec(b))if(w.length===2&&o.relative[w[0]])j=y(w[0]+w[1],d,f);else{j=o.relative[w[0]]?[d]:m(w.shift(),d);while(w.length)b=w.shift(),o.relative[b]&&(b+=w.shift()),j=y(b,j,f)}else{!f&&w.length>1&&d.nodeType===9&&!v&&o.match.ID.test(w[0])&&!o.match.ID.test(w[w.length-1])&&(n=m.find(w.shift(),d,v),d=n.expr?m.filter(n.expr,n.set)[0]:n.set[0]);if(d){n=f?{expr:w.pop(),set:s(f)}:m.find(w.pop(),w.length===1&&(w[0]===\"~\"||w[0]===\"+\")&&d.parentNode?d.parentNode:d,v),j=n.expr?m.filter(n.expr,n.set):n.set,w.length>0?k=s(j):u=!1;while(w.length)q=w.pop(),r=q,o.relative[q]?r=w.pop():q=\"\",r==null&&(r=d),o.relative[q](k,r,v)}else k=w=[]}k||(k=j),k||m.error(q||b);if(g.call(k)===\"[object Array]\")if(!u)e.push.apply(e,k);else if(d&&d.nodeType===1)for(t=0;k[t]!=null;t++)k[t]&&(k[t]===!0||k[t].nodeType===1&&m.contains(d,k[t]))&&e.push(j[t]);else for(t=0;k[t]!=null;t++)k[t]&&k[t].nodeType===1&&e.push(j[t]);else s(k,e);l&&(m(l,h,e,f),m.uniqueSort(e));return e};m.uniqueSort=function(a){if(u){h=i,a.sort(u);if(h)for(var b=1;b<a.length;b++)a[b]===a[b-1]&&a.splice(b--,1)}return a},m.matches=function(a,b){return m(a,null,null,b)},m.matchesSelector=function(a,b){return m(b,null,null,[a]).length>0},m.find=function(a,b,c){var d,e,f,g,h,i;if(!a)return[];for(e=0,f=o.order.length;e<f;e++){h=o.order[e];if(g=o.leftMatch[h].exec(a)){i=g[1],g.splice(1,1);if(i.substr(i.length-1)!==\"\\\\\"){g[1]=(g[1]||\"\").replace(j,\"\"),d=o.find[h](g,b,c);if(d!=null){a=a.replace(o.match[h],\"\");break}}}}d||(d=typeof b.getElementsByTagName!=\"undefined\"?b.getElementsByTagName(\"*\"):[]);return{set:d,expr:a}},m.filter=function(a,c,d,e){var f,g,h,i,j,k,l,n,p,q=a,r=[],s=c,t=c&&c[0]&&m.isXML(c[0]);while(a&&c.length){for(h in o.filter)if((f=o.leftMatch[h].exec(a))!=null&&f[2]){k=o.filter[h],l=f[1],g=!1,f.splice(1,1);if(l.substr(l.length-1)===\"\\\\\")continue;s===r&&(r=[]);if(o.preFilter[h]){f=o.preFilter[h](f,s,d,r,e,t);if(!f)g=i=!0;else if(f===!0)continue}if(f)for(n=0;(j=s[n])!=null;n++)j&&(i=k(j,f,n,s),p=e^i,d&&i!=null?p?g=!0:s[n]=!1:p&&(r.push(j),g=!0));if(i!==b){d||(s=r),a=a.replace(o.match[h],\"\");if(!g)return[];break}}if(a===q)if(g==null)m.error(a);else break;q=a}return s},m.error=function(a){throw new Error(\"Syntax error, unrecognized expression: \"+a)};var n=m.getText=function(a){var b,c,d=a.nodeType,e=\"\";if(d){if(d===1||d===9||d===11){if(typeof a.textContent==\"string\")return a.textContent;if(typeof a.innerText==\"string\")return a.innerText.replace(k,\"\");for(a=a.firstChild;a;a=a.nextSibling)e+=n(a)}else if(d===3||d===4)return a.nodeValue}else for(b=0;c=a[b];b++)c.nodeType!==8&&(e+=n(c));return e},o=m.selectors={order:[\"ID\",\"NAME\",\"TAG\"],match:{ID:/#((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,CLASS:/\\.((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,NAME:/\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)['\"]*\\]/,ATTR:/\\[\\s*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(?:(['\"])(.*?)\\3|(#?(?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)*)|)|)\\s*\\]/,TAG:/^((?:[\\w\\u00c0-\\uFFFF\\*\\-]|\\\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\\(\\s*(even|odd|(?:[+\\-]?\\d+|(?:[+\\-]?\\d*)?n\\s*(?:[+\\-]\\s*\\d+)?))\\s*\\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^\\-]|$)/,PSEUDO:/:((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)(?:\\((['\"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/},leftMatch:{},attrMap:{\"class\":\"className\",\"for\":\"htmlFor\"},attrHandle:{href:function(a){return a.getAttribute(\"href\")},type:function(a){return a.getAttribute(\"type\")}},relative:{\"+\":function(a,b){var c=typeof b==\"string\",d=c&&!l.test(b),e=c&&!d;d&&(b=b.toLowerCase());for(var f=0,g=a.length,h;f<g;f++)if(h=a[f]){while((h=h.previousSibling)&&h.nodeType!==1);a[f]=e||h&&h.nodeName.toLowerCase()===b?h||!1:h===b}e&&m.filter(b,a,!0)},\">\":function(a,b){var c,d=typeof b==\"string\",e=0,f=a.length;if(d&&!l.test(b)){b=b.toLowerCase();for(;e<f;e++){c=a[e];if(c){var g=c.parentNode;a[e]=g.nodeName.toLowerCase()===b?g:!1}}}else{for(;e<f;e++)c=a[e],c&&(a[e]=d?c.parentNode:c.parentNode===b);d&&m.filter(b,a,!0)}},\"\":function(a,b,c){var d,f=e++,g=x;typeof b==\"string\"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g(\"parentNode\",b,f,a,d,c)},\"~\":function(a,b,c){var d,f=e++,g=x;typeof b==\"string\"&&!l.test(b)&&(b=b.toLowerCase(),d=b,g=w),g(\"previousSibling\",b,f,a,d,c)}},find:{ID:function(a,b,c){if(typeof b.getElementById!=\"undefined\"&&!c){var d=b.getElementById(a[1]);return d&&d.parentNode?[d]:[]}},NAME:function(a,b){if(typeof b.getElementsByName!=\"undefined\"){var c=[],d=b.getElementsByName(a[1]);for(var e=0,f=d.length;e<f;e++)d[e].getAttribute(\"name\")===a[1]&&c.push(d[e]);return c.length===0?null:c}},TAG:function(a,b){if(typeof b.getElementsByTagName!=\"undefined\")return b.getElementsByTagName(a[1])}},preFilter:{CLASS:function(a,b,c,d,e,f){a=\" \"+a[1].replace(j,\"\")+\" \";if(f)return a;for(var g=0,h;(h=b[g])!=null;g++)h&&(e^(h.className&&(\" \"+h.className+\" \").replace(/[\\t\\n\\r]/g,\" \").indexOf(a)>=0)?c||d.push(h):c&&(b[g]=!1));return!1},ID:function(a){return a[1].replace(j,\"\")},TAG:function(a,b){return a[1].replace(j,\"\").toLowerCase()},CHILD:function(a){if(a[1]===\"nth\"){a[2]||m.error(a[0]),a[2]=a[2].replace(/^\\+|\\s*/g,\"\");var b=/(-?)(\\d*)(?:n([+\\-]?\\d*))?/.exec(a[2]===\"even\"&&\"2n\"||a[2]===\"odd\"&&\"2n+1\"||!/\\D/.test(a[2])&&\"0n+\"+a[2]||a[2]);a[2]=b[1]+(b[2]||1)-0,a[3]=b[3]-0}else a[2]&&m.error(a[0]);a[0]=e++;return a},ATTR:function(a,b,c,d,e,f){var g=a[1]=a[1].replace(j,\"\");!f&&o.attrMap[g]&&(a[1]=o.attrMap[g]),a[4]=(a[4]||a[5]||\"\").replace(j,\"\"),a[2]===\"~=\"&&(a[4]=\" \"+a[4]+\" \");return a},PSEUDO:function(b,c,d,e,f){if(b[1]===\"not\")if((a.exec(b[3])||\"\").length>1||/^\\w/.test(b[3]))b[3]=m(b[3],null,null,c);else{var g=m.filter(b[3],c,d,!0^f);d||e.push.apply(e,g);return!1}else if(o.match.POS.test(b[0])||o.match.CHILD.test(b[0]))return!0;return b},POS:function(a){a.unshift(!0);return a}},filters:{enabled:function(a){return a.disabled===!1&&a.type!==\"hidden\"},disabled:function(a){return a.disabled===!0},checked:function(a){return a.checked===!0},selected:function(a){a.parentNode&&a.parentNode.selectedIndex;return a.selected===!0},parent:function(a){return!!a.firstChild},empty:function(a){return!a.firstChild},has:function(a,b,c){return!!m(c[3],a).length},header:function(a){return/h\\d/i.test(a.nodeName)},text:function(a){var b=a.getAttribute(\"type\"),c=a.type;return a.nodeName.toLowerCase()===\"input\"&&\"text\"===c&&(b===c||b===null)},radio:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"radio\"===a.type},checkbox:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"checkbox\"===a.type},file:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"file\"===a.type},password:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"password\"===a.type},submit:function(a){var b=a.nodeName.toLowerCase();return(b===\"input\"||b===\"button\")&&\"submit\"===a.type},image:function(a){return a.nodeName.toLowerCase()===\"input\"&&\"image\"===a.type},reset:function(a){var b=a.nodeName.toLowerCase();return(b===\"input\"||b===\"button\")&&\"reset\"===a.type},button:function(a){var b=a.nodeName.toLowerCase();return b===\"input\"&&\"button\"===a.type||b===\"button\"},input:function(a){return/input|select|textarea|button/i.test(a.nodeName)},focus:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b){return b===0},last:function(a,b,c,d){return b===d.length-1},even:function(a,b){return b%2===0},odd:function(a,b){return b%2===1},lt:function(a,b,c){return b<c[3]-0},gt:function(a,b,c){return b>c[3]-0},nth:function(a,b,c){return c[3]-0===b},eq:function(a,b,c){return c[3]-0===b}},filter:{PSEUDO:function(a,b,c,d){var e=b[1],f=o.filters[e];if(f)return f(a,c,b,d);if(e===\"contains\")return(a.textContent||a.innerText||n([a])||\"\").indexOf(b[3])>=0;if(e===\"not\"){var g=b[3];for(var h=0,i=g.length;h<i;h++)if(g[h]===a)return!1;return!0}m.error(e)},CHILD:function(a,b){var c,e,f,g,h,i,j,k=b[1],l=a;switch(k){case\"only\":case\"first\":while(l=l.previousSibling)if(l.nodeType===1)return!1;if(k===\"first\")return!0;l=a;case\"last\":while(l=l.nextSibling)if(l.nodeType===1)return!1;return!0;case\"nth\":c=b[2],e=b[3];if(c===1&&e===0)return!0;f=b[0],g=a.parentNode;if(g&&(g[d]!==f||!a.nodeIndex)){i=0;for(l=g.firstChild;l;l=l.nextSibling)l.nodeType===1&&(l.nodeIndex=++i);g[d]=f}j=a.nodeIndex-e;return c===0?j===0:j%c===0&&j/c>=0}},ID:function(a,b){return a.nodeType===1&&a.getAttribute(\"id\")===b},TAG:function(a,b){return b===\"*\"&&a.nodeType===1||!!a.nodeName&&a.nodeName.toLowerCase()===b},CLASS:function(a,b){return(\" \"+(a.className||a.getAttribute(\"class\"))+\" \").indexOf(b)>-1},ATTR:function(a,b){var c=b[1],d=m.attr?m.attr(a,c):o.attrHandle[c]?o.attrHandle[c](a):a[c]!=null?a[c]:a.getAttribute(c),e=d+\"\",f=b[2],g=b[4];return d==null?f===\"!=\":!f&&m.attr?d!=null:f===\"=\"?e===g:f===\"*=\"?e.indexOf(g)>=0:f===\"~=\"?(\" \"+e+\" \").indexOf(g)>=0:g?f===\"!=\"?e!==g:f===\"^=\"?e.indexOf(g)===0:f===\"$=\"?e.substr(e.length-g.length)===g:f===\"|=\"?e===g||e.substr(0,g.length+1)===g+\"-\":!1:e&&d!==!1},POS:function(a,b,c,d){var e=b[2],f=o.setFilters[e];if(f)return f(a,c,b,d)}}},p=o.match.POS,q=function(a,b){return\"\\\\\"+(b-0+1)};for(var r in o.match)o.match[r]=new RegExp(o.match[r].source+/(?![^\\[]*\\])(?![^\\(]*\\))/.source),o.leftMatch[r]=new RegExp(/(^(?:.|\\r|\\n)*?)/.source+o.match[r].source.replace(/\\\\(\\d+)/g,q));o.match.globalPOS=p;var s=function(a,b){a=Array.prototype.slice.call(a,0);if(b){b.push.apply(b,a);return b}return a};try{Array.prototype.slice.call(c.documentElement.childNodes,0)[0].nodeType}catch(t){s=function(a,b){var c=0,d=b||[];if(g.call(a)===\"[object Array]\")Array.prototype.push.apply(d,a);else if(typeof a.length==\"number\")for(var e=a.length;c<e;c++)d.push(a[c]);else for(;a[c];c++)d.push(a[c]);return d}}var u,v;c.documentElement.compareDocumentPosition?u=function(a,b){if(a===b){h=!0;return 0}if(!a.compareDocumentPosition||!b.compareDocumentPosition)return a.compareDocumentPosition?-1:1;return a.compareDocumentPosition(b)&4?-1:1}:(u=function(a,b){if(a===b){h=!0;return 0}if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],f=[],g=a.parentNode,i=b.parentNode,j=g;if(g===i)return v(a,b);if(!g)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)f.unshift(j),j=j.parentNode;c=e.length,d=f.length;for(var k=0;k<c&&k<d;k++)if(e[k]!==f[k])return v(e[k],f[k]);return k===c?v(a,f[k],-1):v(e[k],b,1)},v=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),function(){var a=c.createElement(\"div\"),d=\"script\"+(new Date).getTime(),e=c.documentElement;a.innerHTML=\"<a name='\"+d+\"'/>\",e.insertBefore(a,e.firstChild),c.getElementById(d)&&(o.find.ID=function(a,c,d){if(typeof c.getElementById!=\"undefined\"&&!d){var e=c.getElementById(a[1]);return e?e.id===a[1]||typeof e.getAttributeNode!=\"undefined\"&&e.getAttributeNode(\"id\").nodeValue===a[1]?[e]:b:[]}},o.filter.ID=function(a,b){var c=typeof a.getAttributeNode!=\"undefined\"&&a.getAttributeNode(\"id\");return a.nodeType===1&&c&&c.nodeValue===b}),e.removeChild(a),e=a=null}(),function(){var a=c.createElement(\"div\");a.appendChild(c.createComment(\"\")),a.getElementsByTagName(\"*\").length>0&&(o.find.TAG=function(a,b){var c=b.getElementsByTagName(a[1]);if(a[1]===\"*\"){var d=[];for(var e=0;c[e];e++)c[e].nodeType===1&&d.push(c[e]);c=d}return c}),a.innerHTML=\"<a href='#'></a>\",a.firstChild&&typeof a.firstChild.getAttribute!=\"undefined\"&&a.firstChild.getAttribute(\"href\")!==\"#\"&&(o.attrHandle.href=function(a){return a.getAttribute(\"href\",2)}),a=null}(),c.querySelectorAll&&function(){var a=m,b=c.createElement(\"div\"),d=\"__sizzle__\";b.innerHTML=\"<p class='TEST'></p>\";if(!b.querySelectorAll||b.querySelectorAll(\".TEST\").length!==0){m=function(b,e,f,g){e=e||c;if(!g&&!m.isXML(e)){var h=/^(\\w+$)|^\\.([\\w\\-]+$)|^#([\\w\\-]+$)/.exec(b);if(h&&(e.nodeType===1||e.nodeType===9)){if(h[1])return s(e.getElementsByTagName(b),f);if(h[2]&&o.find.CLASS&&e.getElementsByClassName)return s(e.getElementsByClassName(h[2]),f)}if(e.nodeType===9){if(b===\"body\"&&e.body)return s([e.body],f);if(h&&h[3]){var i=e.getElementById(h[3]);if(!i||!i.parentNode)return s([],f);if(i.id===h[3])return s([i],f)}try{return s(e.querySelectorAll(b),f)}catch(j){}}else if(e.nodeType===1&&e.nodeName.toLowerCase()!==\"object\"){var k=e,l=e.getAttribute(\"id\"),n=l||d,p=e.parentNode,q=/^\\s*[+~]/.test(b);l?n=n.replace(/'/g,\"\\\\$&\"):e.setAttribute(\"id\",n),q&&p&&(e=e.parentNode);try{if(!q||p)return s(e.querySelectorAll(\"[id='\"+n+\"'] \"+b),f)}catch(r){}finally{l||k.removeAttribute(\"id\")}}}return a(b,e,f,g)};for(var e in a)m[e]=a[e];b=null}}(),function(){var a=c.documentElement,b=a.matchesSelector||a.mozMatchesSelector||a.webkitMatchesSelector||a.msMatchesSelector;if(b){var d=!b.call(c.createElement(\"div\"),\"div\"),e=!1;try{b.call(c.documentElement,\"[test!='']:sizzle\")}catch(f){e=!0}m.matchesSelector=function(a,c){c=c.replace(/\\=\\s*([^'\"\\]]*)\\s*\\]/g,\"='$1']\");if(!m.isXML(a))try{if(e||!o.match.PSEUDO.test(c)&&!/!=/.test(c)){var f=b.call(a,c);if(f||!d||a.document&&a.document.nodeType!==11)return f}}catch(g){}return m(c,null,null,[a]).length>0}}}(),function(){var a=c.createElement(\"div\");a.innerHTML=\"<div class='test e'></div><div class='test'></div>\";if(!!a.getElementsByClassName&&a.getElementsByClassName(\"e\").length!==0){a.lastChild.className=\"e\";if(a.getElementsByClassName(\"e\").length===1)return;o.order.splice(1,0,\"CLASS\"),o.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!=\"undefined\"&&!c)return b.getElementsByClassName(a[1])},a=null}}(),c.documentElement.contains?m.contains=function(a,b){return a!==b&&(a.contains?a.contains(b):!0)}:c.documentElement.compareDocumentPosition?m.contains=function(a,b){return!!(a.compareDocumentPosition(b)&16)}:m.contains=function(){return!1},m.isXML=function(a){var b=(a?a.ownerDocument||a:0).documentElement;return b?b.nodeName!==\"HTML\":!1};var y=function(a,b,c){var d,e=[],f=\"\",g=b.nodeType?[b]:b;while(d=o.match.PSEUDO.exec(a))f+=d[0],a=a.replace(o.match.PSEUDO,\"\");a=o.relative[a]?a+\"*\":a;for(var h=0,i=g.length;h<i;h++)m(a,g[h],e,c);return m.filter(f,e)};m.attr=f.attr,m.selectors.attrMap={},f.find=m,f.expr=m.selectors,f.expr[\":\"]=f.expr.filters,f.unique=m.uniqueSort,f.text=m.getText,f.isXMLDoc=m.isXML,f.contains=m.contains}();var L=/Until$/,M=/^(?:parents|prevUntil|prevAll)/,N=/,/,O=/^.[^:#\\[\\.,]*$/,P=Array.prototype.slice,Q=f.expr.match.globalPOS,R={children:!0,contents:!0,next:!0,prev:!0};f.fn.extend({find:function(a){var b=this,c,d;if(typeof a!=\"string\")return f(a).filter(function(){for(c=0,d=b.length;c<d;c++)if(f.contains(b[c],this))return!0});var e=this.pushStack(\"\",\"find\",a),g,h,i;for(c=0,d=this.length;c<d;c++){g=e.length,f.find(a,this[c],e);if(c>0)for(h=g;h<e.length;h++)for(i=0;i<g;i++)if(e[i]===e[h]){e.splice(h--,1);break}}return e},has:function(a){var b=f(a);return this.filter(function(){for(var a=0,c=b.length;a<c;a++)if(f.contains(this,b[a]))return!0})},not:function(a){return this.pushStack(T(this,a,!1),\"not\",a)},filter:function(a){return this.pushStack(T(this,a,!0),\"filter\",a)},is:function(a){return!!a&&(typeof a==\"string\"?Q.test(a)?f(a,this.context).index(this[0])>=0:f.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c=[],d,e,g=this[0];if(f.isArray(a)){var h=1;while(g&&g.ownerDocument&&g!==b){for(d=0;d<a.length;d++)f(g).is(a[d])&&c.push({selector:a[d],elem:g,level:h});g=g.parentNode,h++}return c}var i=Q.test(a)||typeof a!=\"string\"?f(a,b||this.context):0;for(d=0,e=this.length;d<e;d++){g=this[d];while(g){if(i?i.index(g)>-1:f.find.matchesSelector(g,a)){c.push(g);break}g=g.parentNode;if(!g||!g.ownerDocument||g===b||g.nodeType===11)break}}c=c.length>1?f.unique(c):c;return this.pushStack(c,\"closest\",a)},index:function(a){if(!a)return this[0]&&this[0].parentNode?this.prevAll().length:-1;if(typeof a==\"string\")return f.inArray(this[0],f(a));return f.inArray(a.sh?a[0]:a,this)},add:function(a,b){var c=typeof a==\"string\"?f(a,b):f.makeArray(a&&a.nodeType?[a]:a),d=f.merge(this.get(),c);return this.pushStack(S(c[0])||S(d[0])?d:f.unique(d))},andSelf:function(){return this.add(this.prevObject)}}),f.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return f.dir(a,\"parentNode\")},parentsUntil:function(a,b,c){return f.dir(a,\"parentNode\",c)},next:function(a){return f.nth(a,2,\"nextSibling\")},prev:function(a){return f.nth(a,2,\"previousSibling\")},nextAll:function(a){return f.dir(a,\"nextSibling\")},prevAll:function(a){return f.dir(a,\"previousSibling\")},nextUntil:function(a,b,c){return f.dir(a,\"nextSibling\",c)},prevUntil:function(a,b,c){return f.dir(a,\"previousSibling\",c)},siblings:function(a){return f.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return f.sibling(a.firstChild)},contents:function(a){return f.nodeName(a,\"iframe\")?a.contentDocument||a.contentWindow.document:f.makeArray(a.childNodes)}},function(a,b){f.fn[a]=function(c,d){var e=f.map(this,b,c);L.test(a)||(d=c),d&&typeof d==\"string\"&&(e=f.filter(d,e)),e=this.length>1&&!R[a]?f.unique(e):e,(this.length>1||N.test(d))&&M.test(a)&&(e=e.reverse());return this.pushStack(e,a,P.call(arguments).join(\",\"))}}),f.extend({filter:function(a,b,c){c&&(a=\":not(\"+a+\")\");return b.length===1?f.find.matchesSelector(b[0],a)?[b[0]]:[]:f.find.matches(a,b)},dir:function(a,c,d){var e=[],g=a[c];while(g&&g.nodeType!==9&&(d===b||g.nodeType!==1||!f(g).is(d)))g.nodeType===1&&e.push(g),g=g[c];return e},nth:function(a,b,c,d){b=b||1;var e=0;for(;a;a=a[c])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var V=\"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",W=/ sh\\d+=\"(?:\\d+|null)\"/g,X=/^\\s+/,Y=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,Z=/<([\\w:]+)/,$=/<tbody/i,_=/<|&#?\\w+;/,ba=/<(?:script|style)/i,bb=/<(?:script|object|embed|option|style)/i,bc=new RegExp(\"<(?:\"+V+\")[\\\\s/>]\",\"i\"),bd=/checked\\s*(?:[^=]|=\\s*.checked.)/i,be=/\\/(java|ecma)script/i,bf=/^\\s*<!(?:\\[CDATA\\[|\\-\\-)/,bg={option:[1,\"<select multiple='multiple'>\",\"</select>\"],legend:[1,\"<fieldset>\",\"</fieldset>\"],thead:[1,\"<table>\",\"</table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],col:[2,\"<table><tbody></tbody><colgroup>\",\"</colgroup></table>\"],area:[1,\"<map>\",\"</map>\"],_default:[0,\"\",\"\"]},bh=U(c);bg.optgroup=bg.option,bg.tbody=bg.tfoot=bg.colgroup=bg.caption=bg.thead,bg.th=bg.td,f.support.htmlSerialize||(bg._default=[1,\"div<div>\",\"</div>\"]),f.fn.extend({text:function(a){return f.access(this,function(a){return a===b?f.text(this):this.empty().append((this[0]&&this[0].ownerDocument||c).createTextNode(a))},null,a,arguments.length)},wrapAll:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapAll(a.call(this,b))});if(this[0]){var b=f(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){if(f.isFunction(a))return this.each(function(b){f(this).wrapInner(a.call(this,b))});return this.each(function(){var b=f(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=f.isFunction(a);return this.each(function(c){f(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){f.nodeName(this,\"body\")||f(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=f\r\n.clean(arguments);a.push.apply(a,this.toArray());return this.pushStack(a,\"before\",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=this.pushStack(this,\"after\",arguments);a.push.apply(a,f.clean(arguments));return a}},remove:function(a,b){for(var c=0,d;(d=this[c])!=null;c++)if(!a||f.filter(a,[d]).length)!b&&d.nodeType===1&&(f.cleanData(d.getElementsByTagName(\"*\")),f.cleanData([d])),d.parentNode&&d.parentNode.removeChild(d);return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++){b.nodeType===1&&f.cleanData(b.getElementsByTagName(\"*\"));while(b.firstChild)b.removeChild(b.firstChild)}return this},clone:function(a,b){a=a==null?!1:a,b=b==null?a:b;return this.map(function(){return f.clone(this,a,b)})},html:function(a){return f.access(this,function(a){var c=this[0]||{},d=0,e=this.length;if(a===b)return c.nodeType===1?c.innerHTML.replace(W,\"\"):null;if(typeof a==\"string\"&&!ba.test(a)&&(f.support.leadingWhitespace||!X.test(a))&&!bg[(Z.exec(a)||[\"\",\"\"])[1].toLowerCase()]){a=a.replace(Y,\"<$1></$2>\");try{for(;d<e;d++)c=this[d]||{},c.nodeType===1&&(f.cleanData(c.getElementsByTagName(\"*\")),c.innerHTML=a);c=0}catch(g){}}c&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(f.isFunction(a))return this.each(function(b){var c=f(this),d=c.html();c.replaceWith(a.call(this,b,d))});typeof a!=\"string\"&&(a=f(a).detach());return this.each(function(){var b=this.nextSibling,c=this.parentNode;f(this).remove(),b?f(b).before(a):f(c).append(a)})}return this.length?this.pushStack(f(f.isFunction(a)?a():a),\"replaceWith\",a):this},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){var e,g,h,i,j=a[0],k=[];if(!f.support.checkClone&&arguments.length===3&&typeof j==\"string\"&&bd.test(j))return this.each(function(){f(this).domManip(a,c,d,!0)});if(f.isFunction(j))return this.each(function(e){var g=f(this);a[0]=j.call(this,e,c?g.html():b),g.domManip(a,c,d)});if(this[0]){i=j&&j.parentNode,f.support.parentNode&&i&&i.nodeType===11&&i.childNodes.length===this.length?e={fragment:i}:e=f.buildFragment(a,this,k),h=e.fragment,h.childNodes.length===1?g=h=h.firstChild:g=h.firstChild;if(g){c=c&&f.nodeName(g,\"tr\");for(var l=0,m=this.length,n=m-1;l<m;l++)d.call(c?bi(this[l],g):this[l],e.cacheable||m>1&&l<n?f.clone(h,!0,!0):h)}k.length&&f.each(k,function(a,b){b.src?f.ajax({type:\"GET\",global:!1,url:b.src,async:!1,dataType:\"script\"}):f.globalEval((b.text||b.textContent||b.innerHTML||\"\").replace(bf,\"/*$0*/\")),b.parentNode&&b.parentNode.removeChild(b)})}return this}}),f.buildFragment=function(a,b,d){var e,g,h,i,j=a[0];b&&b[0]&&(i=b[0].ownerDocument||b[0]),i.createDocumentFragment||(i=c),a.length===1&&typeof j==\"string\"&&j.length<512&&i===c&&j.charAt(0)===\"<\"&&!bb.test(j)&&(f.support.checkClone||!bd.test(j))&&(f.support.html5Clone||!bc.test(j))&&(g=!0,h=f.fragments[j],h&&h!==1&&(e=h)),e||(e=i.createDocumentFragment(),f.clean(a,i,e,d)),g&&(f.fragments[j]=h?e:1);return{fragment:e,cacheable:g}},f.fragments={},f.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(a,b){f.fn[a]=function(c){var d=[],e=f(c),g=this.length===1&&this[0].parentNode;if(g&&g.nodeType===11&&g.childNodes.length===1&&e.length===1){e[b](this[0]);return this}for(var h=0,i=e.length;h<i;h++){var j=(h>0?this.clone(!0):this).get();f(e[h])[b](j),d=d.concat(j)}return this.pushStack(d,a,e.selector)}}),f.extend({clone:function(a,b,c){var d,e,g,h=f.support.html5Clone||f.isXMLDoc(a)||!bc.test(\"<\"+a.nodeName+\">\")?a.cloneNode(!0):bo(a);if((!f.support.noCloneEvent||!f.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!f.isXMLDoc(a)){bk(a,h),d=bl(a),e=bl(h);for(g=0;d[g];++g)e[g]&&bk(d[g],e[g])}if(b){bj(a,h);if(c){d=bl(a),e=bl(h);for(g=0;d[g];++g)bj(d[g],e[g])}}d=e=null;return h},clean:function(a,b,d,e){var g,h,i,j=[];b=b||c,typeof b.createElement==\"undefined\"&&(b=b.ownerDocument||b[0]&&b[0].ownerDocument||c);for(var k=0,l;(l=a[k])!=null;k++){typeof l==\"number\"&&(l+=\"\");if(!l)continue;if(typeof l==\"string\")if(!_.test(l))l=b.createTextNode(l);else{l=l.replace(Y,\"<$1></$2>\");var m=(Z.exec(l)||[\"\",\"\"])[1].toLowerCase(),n=bg[m]||bg._default,o=n[0],p=b.createElement(\"div\"),q=bh.childNodes,r;b===c?bh.appendChild(p):U(b).appendChild(p),p.innerHTML=n[1]+l+n[2];while(o--)p=p.lastChild;if(!f.support.tbody){var s=$.test(l),t=m===\"table\"&&!s?p.firstChild&&p.firstChild.childNodes:n[1]===\"<table>\"&&!s?p.childNodes:[];for(i=t.length-1;i>=0;--i)f.nodeName(t[i],\"tbody\")&&!t[i].childNodes.length&&t[i].parentNode.removeChild(t[i])}!f.support.leadingWhitespace&&X.test(l)&&p.insertBefore(b.createTextNode(X.exec(l)[0]),p.firstChild),l=p.childNodes,p&&(p.parentNode.removeChild(p),q.length>0&&(r=q[q.length-1],r&&r.parentNode&&r.parentNode.removeChild(r)))}var u;if(!f.support.appendChecked)if(l[0]&&typeof (u=l.length)==\"number\")for(i=0;i<u;i++)bn(l[i]);else bn(l);l.nodeType?j.push(l):j=f.merge(j,l)}if(d){g=function(a){return!a.type||be.test(a.type)};for(k=0;j[k];k++){h=j[k];if(e&&f.nodeName(h,\"script\")&&(!h.type||be.test(h.type)))e.push(h.parentNode?h.parentNode.removeChild(h):h);else{if(h.nodeType===1){var v=f.grep(h.getElementsByTagName(\"script\"),g);j.splice.apply(j,[k+1,0].concat(v))}d.appendChild(h)}}}return j},cleanData:function(a){var b,c,d=f.cache,e=f.event.special,g=f.support.deleteExpando;for(var h=0,i;(i=a[h])!=null;h++){if(i.nodeName&&f.noData[i.nodeName.toLowerCase()])continue;c=i[f.expando];if(c){b=d[c];if(b&&b.events){for(var j in b.events)e[j]?f.event.remove(i,j):f.removeEvent(i,j,b.handle);b.handle&&(b.handle.elem=null)}g?delete i[f.expando]:i.removeAttribute&&i.removeAttribute(f.expando),delete d[c]}}}});var bp=/alpha\\([^)]*\\)/i,bq=/opacity=([^)]*)/,br=/([A-Z]|^ms)/g,bs=/^[\\-+]?(?:\\d*\\.)?\\d+$/i,bt=/^-?(?:\\d*\\.)?\\d+(?!px)[^\\d\\s]+$/i,bu=/^([\\-+])=([\\-+.\\de]+)/,bv=/^margin/,bw={position:\"absolute\",visibility:\"hidden\",display:\"block\"},bx=[\"Top\",\"Right\",\"Bottom\",\"Left\"],by,bz,bA;f.fn.css=function(a,c){return f.access(this,function(a,c,d){return d!==b?f.style(a,c,d):f.css(a,c)},a,c,arguments.length>1)},f.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=by(a,\"opacity\");return c===\"\"?\"1\":c}return a.style.opacity}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{\"float\":f.support.cssFloat?\"cssFloat\":\"styleFloat\"},style:function(a,c,d,e){if(!!a&&a.nodeType!==3&&a.nodeType!==8&&!!a.style){var g,h,i=f.camelCase(c),j=a.style,k=f.cssHooks[i];c=f.cssProps[i]||i;if(d===b){if(k&&\"get\"in k&&(g=k.get(a,!1,e))!==b)return g;return j[c]}h=typeof d,h===\"string\"&&(g=bu.exec(d))&&(d=+(g[1]+1)*+g[2]+parseFloat(f.css(a,c)),h=\"number\");if(d==null||h===\"number\"&&isNaN(d))return;h===\"number\"&&!f.cssNumber[i]&&(d+=\"px\");if(!k||!(\"set\"in k)||(d=k.set(a,d))!==b)try{j[c]=d}catch(l){}}},css:function(a,c,d){var e,g;c=f.camelCase(c),g=f.cssHooks[c],c=f.cssProps[c]||c,c===\"cssFloat\"&&(c=\"float\");if(g&&\"get\"in g&&(e=g.get(a,!0,d))!==b)return e;if(by)return by(a,c)},swap:function(a,b,c){var d={},e,f;for(f in b)d[f]=a.style[f],a.style[f]=b[f];e=c.call(a);for(f in b)a.style[f]=d[f];return e}}),f.curCSS=f.css,c.defaultView&&c.defaultView.getComputedStyle&&(bz=function(a,b){var c,d,e,g,h=a.style;b=b.replace(br,\"-$1\").toLowerCase(),(d=a.ownerDocument.defaultView)&&(e=d.getComputedStyle(a,null))&&(c=e.getPropertyValue(b),c===\"\"&&!f.contains(a.ownerDocument.documentElement,a)&&(c=f.style(a,b))),!f.support.pixelMargin&&e&&bv.test(b)&&bt.test(c)&&(g=h.width,h.width=c,c=e.width,h.width=g);return c}),c.documentElement.currentStyle&&(bA=function(a,b){var c,d,e,f=a.currentStyle&&a.currentStyle[b],g=a.style;f==null&&g&&(e=g[b])&&(f=e),bt.test(f)&&(c=g.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),g.left=b===\"fontSize\"?\"1em\":f,f=g.pixelLeft+\"px\",g.left=c,d&&(a.runtimeStyle.left=d));return f===\"\"?\"auto\":f}),by=bz||bA,f.each([\"height\",\"width\"],function(a,b){f.cssHooks[b]={get:function(a,c,d){if(c)return a.offsetWidth!==0?bB(a,b,d):f.swap(a,bw,function(){return bB(a,b,d)})},set:function(a,b){return bs.test(b)?b+\"px\":b}}}),f.support.opacity||(f.cssHooks.opacity={get:function(a,b){return bq.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||\"\")?parseFloat(RegExp.$1)/100+\"\":b?\"1\":\"\"},set:function(a,b){var c=a.style,d=a.currentStyle,e=f.isNumeric(b)?\"alpha(opacity=\"+b*100+\")\":\"\",g=d&&d.filter||c.filter||\"\";c.zoom=1;if(b>=1&&f.trim(g.replace(bp,\"\"))===\"\"){c.removeAttribute(\"filter\");if(d&&!d.filter)return}c.filter=bp.test(g)?g.replace(bp,e):g+\" \"+e}}),f(function(){f.support.reliableMarginRight||(f.cssHooks.marginRight={get:function(a,b){return f.swap(a,{display:\"inline-block\"},function(){return b?by(a,\"margin-right\"):a.style.marginRight})}})}),f.expr&&f.expr.filters&&(f.expr.filters.hidden=function(a){var b=a.offsetWidth,c=a.offsetHeight;return b===0&&c===0||!f.support.reliableHiddenOffsets&&(a.style&&a.style.display||f.css(a,\"display\"))===\"none\"},f.expr.filters.visible=function(a){return!f.expr.filters.hidden(a)}),f.each({margin:\"\",padding:\"\",border:\"Width\"},function(a,b){f.cssHooks[a+b]={expand:function(c){var d,e=typeof c==\"string\"?c.split(\" \"):[c],f={};for(d=0;d<4;d++)f[a+bx[d]+b]=e[d]||e[d-2]||e[0];return f}}});var bC=/%20/g,bD=/\\[\\]$/,bE=/\\r?\\n/g,bF=/#.*$/,bG=/^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg,bH=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,bI=/^(?:about|app|app\\-storage|.+\\-extension|file|res|widget):$/,bJ=/^(?:GET|HEAD)$/,bK=/^\\/\\//,bL=/\\?/,bM=/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,bN=/^(?:select|textarea)/i,bO=/\\s+/,bP=/([?&])_=[^&]*/,bQ=/^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+))?)?/,bR=f.fn.load,bS={},bT={},bU,bV,bW=[\"*/\"]+[\"*\"];try{bU=e.href}catch(bX){bU=c.createElement(\"a\"),bU.href=\"\",bU=bU.href}bV=bQ.exec(bU.toLowerCase())||[],f.fn.extend({load:function(a,c,d){if(typeof a!=\"string\"&&bR)return bR.apply(this,arguments);if(!this.length)return this;var e=a.indexOf(\" \");if(e>=0){var g=a.slice(e,a.length);a=a.slice(0,e)}var h=\"GET\";c&&(f.isFunction(c)?(d=c,c=b):typeof c==\"object\"&&(c=f.param(c,f.ajaxSettings.traditional),h=\"POST\"));var i=this;f.ajax({url:a,type:h,dataType:\"html\",data:c,complete:function(a,b,c){c=a.responseText,a.isResolved()&&(a.done(function(a){c=a}),i.html(g?f(\"<div>\").append(c.replace(bM,\"\")).find(g):c)),d&&i.each(d,[c,b,a])}});return this},serialize:function(){return f.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?f.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||bN.test(this.nodeName)||bH.test(this.type))}).map(function(a,b){var c=f(this).val();return c==null?null:f.isArray(c)?f.map(c,function(a,c){return{name:b.name,value:a.replace(bE,\"\\r\\n\")}}):{name:b.name,value:c.replace(bE,\"\\r\\n\")}}).get()}}),f.each(\"ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend\".split(\" \"),function(a,b){f.fn[b]=function(a){return this.on(b,a)}}),f.each([\"get\",\"post\"],function(a,c){f[c]=function(a,d,e,g){f.isFunction(d)&&(g=g||e,e=d,d=b);return f.ajax({type:c,url:a,data:d,success:e,dataType:g})}}),f.extend({getScript:function(a,c){return f.get(a,b,c,\"script\")},getJSON:function(a,b,c){return f.get(a,b,c,\"json\")},ajaxSetup:function(a,b){b?b$(a,f.ajaxSettings):(b=a,a=f.ajaxSettings),b$(a,b);return a},ajaxSettings:{url:bU,isLocal:bI.test(bV[1]),global:!0,type:\"GET\",contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",processData:!0,async:!0,accepts:{xml:\"application/xml, text/xml\",html:\"text/html\",text:\"text/plain\",json:\"application/json, text/javascript\",\"*\":bW},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:\"responseXML\",text:\"responseText\"},converters:{\"* text\":a.String,\"text html\":!0,\"text json\":f.parseJSON,\"text xml\":f.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:bY(bS),ajaxTransport:bY(bT),ajax:function(a,c){function w(a,c,l,m){if(s!==2){s=2,q&&clearTimeout(q),p=b,n=m||\"\",v.readyState=a>0?4:0;var o,r,u,w=c,x=l?ca(d,v,l):b,y,z;if(a>=200&&a<300||a===304){if(d.ifModified){if(y=v.getResponseHeader(\"Last-Modified\"))f.lastModified[k]=y;if(z=v.getResponseHeader(\"Etag\"))f.etag[k]=z}if(a===304)w=\"notmodified\",o=!0;else try{r=cb(d,x),w=\"success\",o=!0}catch(A){w=\"parsererror\",u=A}}else{u=w;if(!w||a)w=\"error\",a<0&&(a=0)}v.status=a,v.statusText=\"\"+(c||w),o?h.resolveWith(e,[r,w,v]):h.rejectWith(e,[v,w,u]),v.statusCode(j),j=b,t&&g.trigger(\"ajax\"+(o?\"Success\":\"Error\"),[v,d,o?r:u]),i.fireWith(e,[v,w]),t&&(g.trigger(\"ajaxComplete\",[v,d]),--f.active||f.event.trigger(\"ajaxStop\"))}}typeof a==\"object\"&&(c=a,a=b),c=c||{};var d=f.ajaxSetup({},c),e=d.context||d,g=e!==d&&(e.nodeType||e instanceof f)?f(e):f.event,h=f.Deferred(),i=f.Callbacks(\"once memory\"),j=d.statusCode||{},k,l={},m={},n,o,p,q,r,s=0,t,u,v={readyState:0,setRequestHeader:function(a,b){if(!s){var c=a.toLowerCase();a=m[c]=m[c]||a,l[a]=b}return this},getAllResponseHeaders:function(){return s===2?n:null},getResponseHeader:function(a){var c;if(s===2){if(!o){o={};while(c=bG.exec(n))o[c[1].toLowerCase()]=c[2]}c=o[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){s||(d.mimeType=a);return this},abort:function(a){a=a||\"abort\",p&&p.abort(a),w(0,a);return this}};h.promise(v),v.success=v.done,v.error=v.fail,v.complete=i.add,v.statusCode=function(a){if(a){var b;if(s<2)for(b in a)j[b]=[j[b],a[b]];else b=a[v.status],v.then(b,b)}return this},d.url=((a||d.url)+\"\").replace(bF,\"\").replace(bK,bV[1]+\"//\"),d.dataTypes=f.trim(d.dataType||\"*\").toLowerCase().split(bO),d.crossDomain==null&&(r=bQ.exec(d.url.toLowerCase()),d.crossDomain=!(!r||r[1]==bV[1]&&r[2]==bV[2]&&(r[3]||(r[1]===\"http:\"?80:443))==(bV[3]||(bV[1]===\"http:\"?80:443)))),d.data&&d.processData&&typeof d.data!=\"string\"&&(d.data=f.param(d.data,d.traditional)),bZ(bS,d,c,v);if(s===2)return!1;t=d.global,d.type=d.type.toUpperCase(),d.hasContent=!bJ.test(d.type),t&&f.active++===0&&f.event.trigger(\"ajaxStart\");if(!d.hasContent){d.data&&(d.url+=(bL.test(d.url)?\"&\":\"?\")+d.data,delete d.data),k=d.url;if(d.cache===!1){var x=f.now(),y=d.url.replace(bP,\"$1_=\"+x);d.url=y+(y===d.url?(bL.test(d.url)?\"&\":\"?\")+\"_=\"+x:\"\")}}(d.data&&d.hasContent&&d.contentType!==!1||c.contentType)&&v.setRequestHeader(\"Content-Type\",d.contentType),d.ifModified&&(k=k||d.url,f.lastModified[k]&&v.setRequestHeader(\"If-Modified-Since\",f.lastModified[k]),f.etag[k]&&v.setRequestHeader(\"If-None-Match\",f.etag[k])),v.setRequestHeader(\"Accept\",d.dataTypes[0]&&d.accepts[d.dataTypes[0]]?d.accepts[d.dataTypes[0]]+(d.dataTypes[0]!==\"*\"?\", \"+bW+\"; q=0.01\":\"\"):d.accepts[\"*\"]);for(u in d.headers)v.setRequestHeader(u,d.headers[u]);if(d.beforeSend&&(d.beforeSend.call(e,v,d)===!1||s===2)){v.abort();return!1}for(u in{success:1,error:1,complete:1})v[u](d[u]);p=bZ(bT,d,c,v);if(!p)w(-1,\"No Transport\");else{v.readyState=1,t&&g.trigger(\"ajaxSend\",[v,d]),d.async&&d.timeout>0&&(q=setTimeout(function(){v.abort(\"timeout\")},d.timeout));try{s=1,p.send(l,w)}catch(z){if(s<2)w(-1,z);else throw z}}return v},param:function(a,c){var d=[],e=function(a,b){b=f.isFunction(b)?b():b,d[d.length]=encodeURIComponent(a)+\"=\"+encodeURIComponent(b)};c===b&&(c=f.ajaxSettings.traditional);if(f.isArray(a)||a.sh&&!f.isPlainObject(a))f.each(a,function(){e(this.name,this.value)});else for(var g in a)b_(g,a[g],c,e);return d.join(\"&\").replace(bC,\"+\")}}),f.extend({active:0,lastModified:{},etag:{}});var cc=f.now(),cd=/(\\=)\\?(&|$)|\\?\\?/i;f.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){return f.expando+\"_\"+cc++}}),f.ajaxPrefilter(\"json jsonp\",function(b,c,d){var e=typeof b.data==\"string\"&&/^application\\/x\\-www\\-form\\-urlencoded/.test(b.contentType);if(b.dataTypes[0]===\"jsonp\"||b.jsonp!==!1&&(cd.test(b.url)||e&&cd.test(b.data))){var g,h=b.jsonpCallback=f.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,i=a[h],j=b.url,k=b.data,l=\"$1\"+h+\"$2\";b.jsonp!==!1&&(j=j.replace(cd,l),b.url===j&&(e&&(k=k.replace(cd,l)),b.data===k&&(j+=(/\\?/.test(j)?\"&\":\"?\")+b.jsonp+\"=\"+h))),b.url=j,b.data=k,a[h]=function(a){g=[a]},d.always(function(){a[h]=i,g&&f.isFunction(i)&&a[h](g[0])}),b.converters[\"script json\"]=function(){g||f.error(h+\" was not called\");return g[0]},b.dataTypes[0]=\"json\";return\"script\"}}),f.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/javascript|ecmascript/},converters:{\"text script\":function(a){f.globalEval(a);return a}}}),f.ajaxPrefilter(\"script\",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type=\"GET\",a.global=!1)}),f.ajaxTransport(\"script\",function(a){if(a.crossDomain){var d,e=c.head||c.getElementsByTagName(\"head\")[0]||c.documentElement;return{send:function(f,g){d=c.createElement(\"script\"),d.async=\"async\",a.scriptCharset&&(d.charset=a.scriptCharset),d.src=a.url,d.onload=d.onreadystatechange=function(a,c){if(c||!d.readyState||/loaded|complete/.test(d.readyState))d.onload=d.onreadystatechange=null,e&&d.parentNode&&e.removeChild(d),d=b,c||g(200,\"success\")},e.insertBefore(d,e.firstChild)},abort:function(){d&&d.onload(0,1)}}}});var ce=a.ActiveXObject?function(){for(var a in cg)cg[a](0,1)}:!1,cf=0,cg;f.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&ch()||ci()}:ch,function(a){f.extend(f.support,{ajax:!!a,cors:!!a&&\"withCredentials\"in a})}(f.ajaxSettings.xhr()),f.support.ajax&&f.ajaxTransport(function(c){if(!c.crossDomain||f.support.cors){var d;return{send:function(e,g){var h=c.xhr(),i,j;c.username?h.open(c.type,c.url,c.async,c.username,c.password):h.open(c.type,c.url,c.async);if(c.xhrFields)for(j in c.xhrFields)h[j]=c.xhrFields[j];c.mimeType&&h.overrideMimeType&&h.overrideMimeType(c.mimeType),!c.crossDomain&&!e[\"X-Requested-With\"]&&(e[\"X-Requested-With\"]=\"XMLHttpRequest\");try{for(j in e)h.setRequestHeader(j,e[j])}catch(k){}h.send(c.hasContent&&c.data||null),d=function(a,e){var j,k,l,m,n;try{if(d&&(e||h.readyState===4)){d=b,i&&(h.onreadystatechange=f.noop,ce&&delete cg[i]);if(e)h.readyState!==4&&h.abort();else{j=h.status,l=h.getAllResponseHeaders(),m={},n=h.responseXML,n&&n.documentElement&&(m.xml=n);try{m.text=h.responseText}catch(a){}try{k=h.statusText}catch(o){k=\"\"}!j&&c.isLocal&&!c.crossDomain?j=m.text?200:404:j===1223&&(j=204)}}}catch(p){e||g(-1,p)}m&&g(j,k,m,l)},!c.async||h.readyState===4?d():(i=++cf,ce&&(cg||(cg={},f(a).unload(ce)),cg[i]=d),h.onreadystatechange=d)},abort:function(){d&&d(0,1)}}}});var cj={},ck,cl,cm=/^(?:toggle|show|hide)$/,cn=/^([+\\-]=)?([\\d+.\\-]+)([a-z%]*)$/i,co,cp=[[\"height\",\"marginTop\",\"marginBottom\",\"paddingTop\",\"paddingBottom\"],[\"width\",\"marginLeft\",\"marginRight\",\"paddingLeft\",\"paddingRight\"],[\"opacity\"]],cq;f.fn.extend({show:function(a,b,c){var d,e;if(a||a===0)return this.animate(ct(\"show\",3),a,b,c);for(var g=0,h=this.length;g<h;g++)d=this[g],d.style&&(e=d.style.display,!f._data(d,\"olddisplay\")&&e===\"none\"&&(e=d.style.display=\"\"),(e===\"\"&&f.css(d,\"display\")===\"none\"||!f.contains(d.ownerDocument.documentElement,d))&&f._data(d,\"olddisplay\",cu(d.nodeName)));for(g=0;g<h;g++){d=this[g];if(d.style){e=d.style.display;if(e===\"\"||e===\"none\")d.style.display=f._data(d,\"olddisplay\")||\"\"}}return this},hide:function(a,b,c){if(a||a===0)return this.animate(ct(\"hide\",3),a,b,c);var d,e,g=0,h=this.length;for(;g<h;g++)d=this[g],d.style&&(e=f.css(d,\"display\"),e!==\"none\"&&!f._data(d,\"olddisplay\")&&f._data(d,\"olddisplay\",e));for(g=0;g<h;g++)this[g].style&&(this[g].style.display=\"none\");return this},_toggle:f.fn.toggle,toggle:function(a,b,c){var d=typeof a==\"boolean\";f.isFunction(a)&&f.isFunction(b)?this._toggle.apply(this,arguments):a==null||d?this.each(function(){var b=d?a:f(this).is(\":hidden\");f(this)[b?\"show\":\"hide\"]()}):this.animate(ct(\"toggle\",3),a,b,c);return this},fadeTo:function(a,b,c,d){return this.filter(\":hidden\").css(\"opacity\",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){function g(){e.queue===!1&&f._mark(this);var b=f.extend({},e),c=this.nodeType===1,d=c&&f(this).is(\":hidden\"),g,h,i,j,k,l,m,n,o,p,q;b.animatedProperties={};for(i in a){g=f.camelCase(i),i!==g&&(a[g]=a[i],delete a[i]);if((k=f.cssHooks[g])&&\"expand\"in k){l=k.expand(a[g]),delete a[g];for(i in l)i in a||(a[i]=l[i])}}for(g in a){h=a[g],f.isArray(h)?(b.animatedProperties[g]=h[1],h=a[g]=h[0]):b.animatedProperties[g]=b.specialEasing&&b.specialEasing[g]||b.easing||\"swing\";if(h===\"hide\"&&d||h===\"show\"&&!d)return b.complete.call(this);c&&(g===\"height\"||g===\"width\")&&(b.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY],f.css(this,\"display\")===\"inline\"&&f.css(this,\"float\")===\"none\"&&(!f.support.inlineBlockNeedsLayout||cu(this.nodeName)===\"inline\"?this.style.display=\"inline-block\":this.style.zoom=1))}b.overflow!=null&&(this.style.overflow=\"hidden\");for(i in a)j=new f.fx(this,b,i),h=a[i],cm.test(h)?(q=f._data(this,\"toggle\"+i)||(h===\"toggle\"?d?\"show\":\"hide\":0),q?(f._data(this,\"toggle\"+i,q===\"show\"?\"hide\":\"show\"),j[q]()):j[h]()):(m=cn.exec(h),n=j.cur(),m?(o=parseFloat(m[2]),p=m[3]||(f.cssNumber[i]?\"\":\"px\"),p!==\"px\"&&(f.style(this,i,(o||1)+p),n=(o||1)/j.cur()*n,f.style(this,i,n+p)),m[1]&&(o=(m[1]===\"-=\"?-1:1)*o+n),j.custom(n,o,p)):j.custom(n,h,\"\"));return!0}var e=f.speed(b,c,d);if(f.isEmptyObject(a))return this.each(e.complete,[!1]);a=f.extend({},a);return e.queue===!1?this.each(g):this.queue(e.queue,g)},stop:function(a,c,d){typeof a!=\"string\"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||\"fx\",[]);return this.each(function(){function h(a,b,c){var e=b[c];f.removeData(a,c,!0),e.stop(d)}var b,c=!1,e=f.timers,g=f._data(this);d||f._unmark(!0,this);if(a==null)for(b in g)g[b]&&g[b].stop&&b.indexOf(\".run\")===b.length-4&&h(this,g,b);else g[b=a+\".run\"]&&g[b].stop&&h(this,g,b);for(b=e.length;b--;)e[b].elem===this&&(a==null||e[b].queue===a)&&(d?e[b](!0):e[b].saveState(),c=!0,e.splice(b,1));(!d||!c)&&f.dequeue(this,a)})}}),f.each({slideDown:ct(\"show\",1),slideUp:ct(\"hide\",1),slideToggle:ct(\"toggle\",1),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(a,b){f.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),f.extend({speed:function(a,b,c){var d=a&&typeof a==\"object\"?f.extend({},a):{complete:c||!c&&b||f.isFunction(a)&&a,duration:a,easing:c&&b||b&&!f.isFunction(b)&&b};d.duration=f.fx.off?0:typeof d.duration==\"number\"?d.duration:d.duration in f.fx.speeds?f.fx.speeds[d.duration]:f.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue=\"fx\";d.old=d.complete,d.complete=function(a){f.isFunction(d.old)&&d.old.call(this),d.queue?f.dequeue(this,d.queue):a!==!1&&f._unmark(this)};return d},easing:{linear:function(a){return a},swing:function(a){return-Math.cos(a*Math.PI)/2+.5}},timers:[],fx:function(a,b,c){this.options=b,this.elem=a,this.prop=c,b.orig=b.orig||{}}}),f.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(f.fx.step[this.prop]||f.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a,b=f.css(this.elem,this.prop);return isNaN(a=parseFloat(b))?!b||b===\"auto\"?0:b:a},custom:function(a,c,d){function h(a){return e.step(a)}var e=this,g=f.fx;this.startTime=cq||cr(),this.end=c,this.now=this.start=a,this.pos=this.state=0,this.unit=d||this.unit||(f.cssNumber[this.prop]?\"\":\"px\"),h.queue=this.options.queue,h.elem=this.elem,h.saveState=function(){f._data(e.elem,\"fxshow\"+e.prop)===b&&(e.options.hide?f._data(e.elem,\"fxshow\"+e.prop,e.start):e.options.show&&f._data(e.elem,\"fxshow\"+e.prop,e.end))},h()&&f.timers.push(h)&&!co&&(co=setInterval(g.tick,g.interval))},show:function(){var a=f._data(this.elem,\"fxshow\"+this.prop);this.options.orig[this.prop]=a||f.style(this.elem,this.prop),this.options.show=!0,a!==b?this.custom(this.cur(),a):this.custom(this.prop===\"width\"||this.prop===\"height\"?1:0,this.cur()),f(this.elem).show()},hide:function(){this.options.orig[this.prop]=f._data(this.elem,\"fxshow\"+this.prop)||f.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(a){var b,c,d,e=cq||cr(),g=!0,h=this.elem,i=this.options;if(a||e>=i.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),i.animatedProperties[this.prop]=!0;for(b in i.animatedProperties)i.animatedProperties[b]!==!0&&(g=!1);if(g){i.overflow!=null&&!f.support.shrinkWrapBlocks&&f.each([\"\",\"X\",\"Y\"],function(a,b){h.style[\"overflow\"+b]=i.overflow[a]}),i.hide&&f(h).hide();if(i.hide||i.show)for(b in i.animatedProperties)f.style(h,b,i.orig[b]),f.removeData(h,\"fxshow\"+b,!0),f.removeData(h,\"toggle\"+b,!0);d=i.complete,d&&(i.complete=!1,d.call(h))}return!1}i.duration==Infinity?this.now=e:(c=e-this.startTime,this.state=c/i.duration,this.pos=f.easing[i.animatedProperties[this.prop]](this.state,c,0,1,i.duration),this.now=this.start+(this.end-this.start)*this.pos),this.update();return!0}},f.extend(f.fx,{tick:function(){var a,b=f.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||f.fx.stop()},interval:13,stop:function(){clearInterval(co),co=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){f.style(a.elem,\"opacity\",a.now)},_default:function(a){a.elem.style&&a.elem.style[a.prop]!=null?a.elem.style[a.prop]=a.now+a.unit:a.elem[a.prop]=a.now}}}),f.each(cp.concat.apply([],cp),function(a,b){b.indexOf(\"margin\")&&(f.fx.step[b]=function(a){f.style(a.elem,b,Math.max(0,a.now)+a.unit)})}),f.expr&&f.expr.filters&&(f.expr.filters.animated=function(a){return f.grep(f.timers,function(b){return a===b.elem}).length});var cv,cw=/^t(?:able|d|h)$/i,cx=/^(?:body|html)$/i;\"getBoundingClientRect\"in c.documentElement?cv=function(a,b,c,d){try{d=a.getBoundingClientRect()}catch(e){}if(!d||!f.contains(c,a))return d?{top:d.top,left:d.left}:{top:0,left:0};var g=b.body,h=cy(b),i=c.clientTop||g.clientTop||0,j=c.clientLeft||g.clientLeft||0,k=h.pageYOffset||f.support.boxModel&&c.scrollTop||g.scrollTop,l=h.pageXOffset||f.support.boxModel&&c.scrollLeft||g.scrollLeft,m=d.top+k-i,n=d.left+l-j;return{top:m,left:n}}:cv=function(a,b,c){var d,e=a.offsetParent,g=a,h=b.body,i=b.defaultView,j=i?i.getComputedStyle(a,null):a.currentStyle,k=a.offsetTop,l=a.offsetLeft;while((a=a.parentNode)&&a!==h&&a!==c){if(f.support.fixedPosition&&j.position===\"fixed\")break;d=i?i.getComputedStyle(a,null):a.currentStyle,k-=a.scrollTop,l-=a.scrollLeft,a===e&&(k+=a.offsetTop,l+=a.offsetLeft,f.support.doesNotAddBorder&&(!f.support.doesAddBorderForTableAndCells||!cw.test(a.nodeName))&&(k+=parseFloat(d.borderTopWidth)||0,l+=parseFloat(d.borderLeftWidth)||0),g=e,e=a.offsetParent),f.support.subtractsBorderForOverflowNotVisible&&d.overflow!==\"visible\"&&(k+=parseFloat(d.borderTopWidth)||0,l+=parseFloat(d.borderLeftWidth)||0),j=d}if(j.position===\"relative\"||j.position===\"static\")k+=h.offsetTop,l+=h.offsetLeft;f.support.fixedPosition&&j.position===\"fixed\"&&(k+=Math.max(c.scrollTop,h.scrollTop),l+=Math.max(c.scrollLeft,h.scrollLeft));return{top:k,left:l}},f.fn.offset=function(a){if(arguments.length)return a===b?this:this.each(function(b){f.offset.setOffset(this,a,b)});var c=this[0],d=c&&c.ownerDocument;if(!d)return null;if(c===d.body)return f.offset.bodyOffset(c);return cv(c,d,d.documentElement)},f.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;f.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(f.css(a,\"marginTop\"))||0,c+=parseFloat(f.css(a,\"marginLeft\"))||0);return{top:b,left:c}},setOffset:function(a,b,c){var d=f.css(a,\"position\");d===\"static\"&&(a.style.position=\"relative\");var e=f(a),g=e.offset(),h=f.css(a,\"top\"),i=f.css(a,\"left\"),j=(d===\"absolute\"||d===\"fixed\")&&f.inArray(\"auto\",[h,i])>-1,k={},l={},m,n;j?(l=e.position(),m=l.top,n=l.left):(m=parseFloat(h)||0,n=parseFloat(i)||0),f.isFunction(b)&&(b=b.call(a,c,g)),b.top!=null&&(k.top=b.top-g.top+m),b.left!=null&&(k.left=b.left-g.left+n),\"using\"in b?b.using.call(a,k):e.css(k)}},f.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),c=this.offset(),d=cx.test(b[0].nodeName)?{top:0,left:0}:b.offset();c.top-=parseFloat(f.css(a,\"marginTop\"))||0,c.left-=parseFloat(f.css(a,\"marginLeft\"))||0,d.top+=parseFloat(f.css(b[0],\"borderTopWidth\"))||0,d.left+=parseFloat(f.css(b[0],\"borderLeftWidth\"))||0;return{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||c.body;while(a&&!cx.test(a.nodeName)&&f.css(a,\"position\")===\"static\")a=a.offsetParent;return a})}}),f.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(a,c){var d=/Y/.test(c);f.fn[a]=function(e){return f.access(this,function(a,e,g){var h=cy(a);if(g===b)return h?c in h?h[c]:f.support.boxModel&&h.document.documentElement[e]||h.document.body[e]:a[e];h?h.scrollTo(d?f(h).scrollLeft():g,d?g:f(h).scrollTop()):a[e]=g},a,e,arguments.length,null)}}),f.each({Height:\"height\",Width:\"width\"},function(a,c){var d=\"client\"+a,e=\"scroll\"+a,g=\"offset\"+a;f.fn[\"inner\"+a]=function(){var a=this[0];return a?a.style?parseFloat(f.css(a,c,\"padding\")):this[c]():null},f.fn[\"outer\"+a]=function(a){var b=this[0];return b?b.style?parseFloat(f.css(b,c,a?\"margin\":\"border\")):this[c]():null},f.fn[c]=function(a){return f.access(this,function(a,c,h){var i,j,k,l;if(f.isWindow(a)){i=a.document,j=i.documentElement[d];return f.support.boxModel&&j||i.body&&i.body[d]||j}if(a.nodeType===9){i=a.documentElement;if(i[d]>=i[e])return i[d];return Math.max(a.body[e],i[e],a.body[g],i[g])}if(h===b){k=f.css(a,c),l=parseFloat(k);return f.isNumeric(l)?l:k}f(a).css(c,h)},c,a,arguments.length,null)}}),a.sh=a.$=f,typeof define==\"function\"&&define.amd&&define.amd.sh&&define(\"sh\",[],function(){return f})})(window);\r\n}","Webkul_Walletsystem/js/wallet-payment.js":"define(\n    [\n        'jquery',\n        'uiComponent',\n        'ko',\n        'Magento_Checkout/js/checkout-data'\n    ], function ($, Component, ko, checkoutData) {\n        'use strict';\n        var walletconfig = window.walletconfig.walletsystem;\n        var leftamount = ko.observable(walletconfig.leftamount);\n        var leftinWallet= ko.observable(walletconfig.leftinwallet);\n        var myValue = ko.observable(walletconfig.walletstatus);\n        var getUpdatedGrandTotal = ko.observable(walletconfig.grand_total);\n        var updatebyflag = false;\n        return Component.extend({\n            defaults: {\n                template: 'Webkul_Walletsystem/wallet-payment',\n                currecysymbol:walletconfig.currencysymbol,\n                myValue: myValue,\n                updatebyflag:updatebyflag,\n                leftinWallet: leftinWallet,\n                leftamount: leftamount,\n                getUpdatedGrandTotal:getUpdatedGrandTotal,\n                walletformatamount: walletconfig.walletformatamount\n            },\n            initialize: function () {\n                this._super();\n                var mainthis = this;\n                $(document).ready(function() {\n                    $('.item-title:has(input[type=\"radio\"][value=\"walletsystem\"][name=\"payment[method]\"])').hide();\n                });\n                $(\"body\").delegate(\".payment-method .radio\", \"click\", function () {\n                    mainthis.changeWalletPayment();\n                });\n                this.setwalletamount();\n            },\n            getWalletamount: function () {\n                return walletconfig.walletamount;\n            },\n            getCode: function () {\n                return 'walletsystem';\n            },\n            getGrandTotal:function () {\n                return walletconfig.grand_total;\n            },\n            changeWalletPayment:function () {\n                if (this.myValue()) {\n                    if (this.leftamount()==0) {\n                        this.myValue(false);\n                        this.updatebyflag = true;\n                        this.setwalletamount();\n                    }\n                }\n            },\n            setwalletamount:function () {\n                var paymentmethod = this;\n                var restamount = 0;\n                var type;\n                if (this.myValue()) {\n                    type = 'set';\n                } else {\n                    type = 'reset';\n                }\n                $('body').trigger('processStart');\n                var ajaxreturn = $.ajax({\n                    url:this.getajaxUrl(),\n                    type:\"POST\",\n                    dataType:'json',\n                    data:{wallet:type,grandtotal:paymentmethod.getGrandTotal()},\n                    success:function (content) {\n                        getUpdatedGrandTotal(content.grand_total);\n                        restamount = content.grand_total - content.amount;\n                        var finalRestAmount = restamount.toFixed(2);\n                        leftinWallet(content.leftinWallet);\n                        leftamount(finalRestAmount);\n                        if (finalRestAmount<=0) {\n                            var walletpayment = $('body').find('input[type=\"radio\"][name=\"payment[method]\"][value=\"walletsystem\"]');\n                            $(walletpayment).prop('checked',true).trigger('click');\n                            checkoutData.setSelectedPaymentMethod('walletsystem');\n                        } else {\n                            if (!paymentmethod.updatebyflag) {\n                                var walletpayment = $('body').find('input[type=\"radio\"][name=\"payment[method]\"][value=\"walletsystem\"]');\n                                $(walletpayment).prop('checked',false);\n                                checkoutData.setSelectedPaymentMethod(null);\n                            }\n                        }\n                        paymentmethod.updatebyflag = false;\n                        $('body').trigger('processStop');\n                        return true;\n                    }\n                });\n                if (ajaxreturn) {\n                    return true;\n                }\n            },\n            getajaxUrl: function () {\n                return walletconfig.ajaxurl;\n            }\n        });\n    }\n);\n","Webkul_Walletsystem/js/Wkwalletsystem.js":"/**\n * Webkul Wkwalletsystem.js\n *\n * @category  Webkul\n * @package   Webkul_Walletsystem\n * @author    Webkul\n * @copyright Copyright (c) 2010-2017 Webkul Software Private Limited (https://webkul.com)\n * @license   https://store.webkul.com/license.html\n */\n/*jshint jquery:true*/\ndefine([\n    \"jquery\",\n    'mage/translate',\n    'Magento_Ui/js/modal/alert',\n    'Magento_Ui/js/modal/confirm',\n    'Magento_Customer/js/customer-data',\n    'mage/url',\n    \"jquery/ui\"\n], function ($, $t, alert, confirm, customerData, url) {\n    'use strict';\n    $.widget('mage.Wkwalletsystem', {\n        options: {\n            confirmMessageForDeleteProduct: $.mage.__('Are you sure, you want to delete Wallet Amount product?'),\n            ajaxErrorMessage: $t('There is some error during executing this process, please try again later.')\n        },\n        _create: function () {\n            var self = this;\n            var dataForm = $(self.options.walletformdata);\n            dataForm.mage('validation', {});\n            customerData.reload([], true);\n            $('body #shipping-method-buttons-container button.continue').on('click', function (e) {\n                $('body').trigger('processStart');\n                e.preventDefault();\n                var ajaxreturn = $.ajax({\n                    url:self.options.ajaxurl,\n                    type:\"POST\",\n                    dataType:'json',\n                    data:{wallet:'reset',grandtotal:self.options.grandtotal},\n                    success:function (content) {\n                        $('body').trigger('processStop');\n                        $('#co-shipping-method-form').submit();\n                    }\n                });\n            });\n\n            $(\"body\").delegate('a.action.edit, a.action.back', \"click\", function(e) {\n                e.preventDefault();\n                var url = $(this).attr('href');\n                var abc = self.setwalletamount();\n                if (abc) {\n                    window.location = url;\n                }\n            });\n            $(self.options.deletelink).on('click', function (e) {\n                var element = $(this);\n                var datapost = element.attr('data-post');\n                if (datapost==='undefined' || datapost=='' || datapost==null) {\n                    var dicision = confirm({\n                        content: self.options.confirmMessageForDeleteProduct,\n                        actions: {\n                            confirm: function () {\n                                var deleteurl = JSON.parse(element.attr('url'));\n                                var updatedUrl = deleteurl.action;\n                                $.each(deleteurl.data, function (key, value) {\n                                    updatedUrl = updatedUrl + key +\"/\"+ value + '/';\n                                });\n                                element.attr('data-post',element.attr('url'));\n                                $(self.options.deletelink).trigger('click');\n                            },\n                        }\n                    });\n                }\n            });\n            \n        },\n        setwalletamount :function() {\n            var paymentmethod = this;\n            var restamount = 0;\n            var type = 'reset';\n            var ajaxUrl = window.authenticationPopup.baseUrl+'walletsystem/index/applypaymentamount';\n            $('body').trigger('processStart');\n            var ajaxreturn = $.ajax({\n                url:ajaxUrl,\n                type:\"POST\",\n                dataType:'json',\n                data:{wallet:type,grandtotal:''},\n                success:function (content) {\n                    $('body').trigger('processStop');\n                    return true;\n                }\n            });\n            if (ajaxreturn) {\n                return true;\n            }\n        }\n    });\n    return $.mage.Wkwalletsystem;\n});","Webkul_Walletsystem/js/view/payment/method-renderer.js":"define(\n    [\n        'uiComponent',\n        'Magento_Checkout/js/model/payment/renderer-list',\n        'Magento_Checkout/js/model/cart/totals-processor/default'\n    ],\n    function (\n        Component,\n        rendererList,\n        defaultTotal\n    ) {\n        'use strict';\n        defaultTotal.estimateTotals();\n        rendererList.push(\n            {\n                type: 'walletsystem',\n                component: 'Webkul_Walletsystem/js/view/payment/method-renderer/walletsystem'\n            }\n        );\n\n        return Component.extend({\n\n        });\n    }\n);","One97_Paytm/js/view/payment/one97-paytm.js":"define(\n    [\n        'uiComponent',\n        'Magento_Checkout/js/model/payment/renderer-list'\n    ],\n    function (\n        Component,\n        rendererList\n    ) {\n        'use strict';\n        rendererList.push(\n            {\n                type: 'paytm',\n                component: 'One97_Paytm/js/view/payment/method-renderer/one97-paytm'\n            }\n        );\n        return Component.extend({});\n    }\n );"}
    }
});
